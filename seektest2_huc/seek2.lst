#[1]   seek2.s
   10                     
   11           0001                      .ifdef HUC
#[3]   huc.inc
   12                                      .include "huc.inc"      ; HUC
    1                     ;
    2                     ; Hu-C internal include file
    3                     ;
    4                     
    5                     
    6                     ; variables
    7                     ; ----
    8                     
    9           2000                 .zp
   10  --:2000            __sp
   11  --:2000            __stack    .ds 2
   12  --:2002            __arg_idx  .ds 1
   13  --:2003            __temp     .ds 8
   14  --:200B            __ptr      .ds 2
   15  --:200D            __fbank    .ds 1
   16  --:200E            __fptr     .ds 2
   17  --:2010            __expr     .ds 2
   18                     
   19                     
   20                     ; macros
   21                     ; ----
   22                     
   23                             .macro __farptr
   24                              ldy    #bank(\1)
   25                              sty    \2
   26                              ldy    #low(\1)
   27                              sty    \3
   28                              ldy    #high(\1)
   29                              sty    \3+1
   30                             .endm
   31                     
   32                             .macro __farptr_i
   33                              sax
   34                              add    #low(\1)
   35                             .if (\# = 3)
   36                              sta    <\3
   37                             .else
   38                              sta    <__fptr
   39                             .endif
   40                              sax
   41                              adc    #high(\1) & $1F
   42                             .if (\# = 3)
   43                              sta    <\3+1
   44                             .else
   45                              tax
   46                             .endif
   47                              rol    A
   48                              rol    A
   49                              rol    A
   50                              rol    A
   51                              and    #$F
   52                              add    #bank(\1)
   53                             .if (\# = 3)
   54                              sta    <\2
   55                             .endif
   56                             .endm
   57                     
   58                             .macro __farptr_get
   59                              stx    <\1
   60                              ldy    #2
   61                              lda    [__ptr],Y
   62                              sta    <\2
   63                              iny
   64                              lda    [__ptr],Y
   65                              sta    <\2+1
   66                             .endm
   67                     
   68                             .macro __fgetb
   69                              tam    #3
   70                              txa
   71                              and    #$1F
   72                              ora    #$60
   73                              sta    <__fptr+1
   74                              lda    [__fptr]
   75                              tax
   76                              cla
   77                             .endm
   78                     
   79                     __ldb   .macro
   80                             .if (\# = 2)
   81                              clx
   82                              lda    \1
   83                              clc
   84                              adc    #low(\2)
   85                              sax
   86                              adc    #high(\2)
   87                             .else
   88                              ldx    \1
   89                            __extw
   90                             .endif
   91                             .endm
   92                     
   93                     __ldbp  .macro
   94                              lda    [\1]
   95                              tax
   96                            __extw
   97                             .endm
   98                     
   99                     __stbps .macro
  100                            __stw    <__temp
  101                            __ldwp    __stack
  102                            __stw    <__ptr
  103                            __ldw    <__temp
  104                              sax
  105                              sta    [__ptr]
  106                              sax
  107                            __addmi  2,__stack
  108                             .endm
  109                     
  110                     __ldw   .macro
  111                             .if (\# = 2)
  112                              lda    \1
  113                              clc
  114                              adc    #low(\2)
  115                              tax
  116                              lda    \1+1
  117                              adc    #high(\2)
  118                             .else
  119                              ldx    \1
  120                              lda    \1+1
  121                             .endif
  122                             .endm
  123                     
  124                     __ldwp  .macro
  125                              lda    [\1]
  126                              tax
  127                              ldy    #1
  128                              lda    [\1],Y
  129                             .endm
  130                     
  131                     __ldwi  .macro
  132                              ldx    #low(\1)
  133                              lda    #high(\1)
  134                             .endm
  135                     
  136                     __stw   .macro
  137                              stx    \1
  138                              sta    \1+1
  139                             .endm
  140                     
  141                     __stwp  .macro
  142                              sax
  143                              sta    [\1]
  144                              sax
  145                              ldy    #1
  146                              sta    [\1],Y
  147                             .endm
  148                     
  149                     __stwps .macro
  150                            __stw    <__temp
  151                            __ldwp    __stack
  152                            __stw    <__ptr
  153                            __ldw    <__temp
  154                            __stwp    __ptr
  155                            __addmi  2,__stack
  156                             .endm
  157                     
  158                     __pushw .macro
  159                            __submi  2,__stack
  160                              sax
  161                              sta    [__stack]
  162                              sax
  163                              ldy    #1
  164                              sta    [__stack],Y
  165                             .endm
  166                     
  167                     __popw  .macro
  168                              lda    [__stack]
  169                              tax
  170                              ldy    #1
  171                              lda    [__stack],Y
  172                            __addmi  2,__stack
  173                             .endm
  174                     
  175                     __calls .macro
  176                              pha
  177                              ldy    #\1
  178                              lda    [__stack],Y
  179                              sta    <__ptr
  180                              incw   <__stack
  181                              lda    [__stack],Y
  182                              sta    <__ptr+1
  183                              incw   <__stack
  184                              pla
  185                              jsr    hook
  186                             .endm
  187                     
  188                     __swapw .macro
  189                              pha
  190                              ldy    #1
  191                              lda    [__stack],Y
  192                              sta    <__temp
  193                              lda    [__stack]
  194                              sax
  195                              sta    [__stack]
  196                              pla
  197                              sta    [__stack],Y
  198                              lda    <__temp
  199                             .endm
  200                     
  201                     
  202                     ; TODO : check if we need pha/pla or not
  203                     __tstw  .macro
  204                              ; pha
  205                              stx    <__temp
  206                              ora    <__temp
  207                              ; pla
  208                             .endm
  209                     
  210                     __lsrw  .macro
  211                             lsr     A
  212                             sax
  213                             ror     A
  214                             sax
  215                             .endm
  216                     
  217                     __aslw  .macro
  218                              sax
  219                              asl    A
  220                              sax
  221                              rol    A
  222                             .endm
  223                     
  224                     __aslws .macro
  225                              asl    [__stack]
  226                              ldy    #1
  227                              rol    [__stack],Y
  228                             .endm
  229                     
  230                     __asrw  .macro
  231                              cmp    #$80
  232                              ror    A
  233                              sax
  234                              ror    A
  235                              sax
  236                             .endm
  237                     
  238                     __extw  .macro
  239                     ;        txa    ; signed
  240                     ;        cla
  241                     ;        bpl    .x_\@
  242                     ;        dec    A
  243                     ;.x_\@:
  244                              cla    ; unsigned
  245                             .endm
  246                     
  247                     __comw  .macro
  248                              sax
  249                              eor    #$FF
  250                              sax
  251                              eor    #$FF
  252                             .endm
  253                     
  254                     __negw  .macro
  255                              sax
  256                              eor    #$FF
  257                              clc
  258                              adc    #1
  259                              sax
  260                              eor    #$FF
  261                              adc    #0
  262                             .endm
  263                     
  264                     __boolw .macro
  265                              stx    <__temp
  266                              ora    <__temp
  267                              clx
  268                              beq    .x\@
  269                              inx
  270                     .x\@     cla
  271                             .endm
  272                     
  273                     __notw  .macro
  274                              stx    <__temp
  275                              ora    <__temp
  276                              clx
  277                              bne    .x\@
  278                              inx
  279                     .x\@     cla
  280                             .endm
  281                     
  282                     __addw  .macro
  283                              clc
  284                              sax
  285                              adc    \1
  286                              sax
  287                              adc    \1+1
  288                             .endm   
  289                     
  290                     __addwi .macro
  291                              clc
  292                              sax
  293                              adc    #low(\1)
  294                              sax
  295                              adc    #high(\1)
  296                             .endm   
  297                     
  298                     __addmi .macro
  299                              pha
  300                              clc
  301                              lda    <\2
  302                              adc    #low(\1)
  303                              sta    <\2
  304                              lda    <\2+1
  305                              adc    #high(\1)
  306                              sta    <\2+1
  307                              pla
  308                             .endm   
  309                     
  310                     __subw  .macro
  311                              sec
  312                              sax
  313                              sbc    \1
  314                              sax
  315                              sbc    \1+1
  316                             .endm   
  317                     
  318                     __subwi .macro
  319                              sec
  320                              sax
  321                              sbc    #low(\1)
  322                              sax
  323                              sbc    #high(\1)
  324                             .endm   
  325                     
  326                     __submi .macro
  327                              pha
  328                              sec
  329                              lda    <\2
  330                              sbc    #low(\1)
  331                              sta    <\2
  332                              lda    <\2+1
  333                              sbc    #high(\1)
  334                              sta    <\2+1
  335                              pla
  336                             .endm   
  337                     
  338                     __addws .macro
  339                              sax
  340                              clc
  341                              adc    [__stack]
  342                              sax
  343                              ldy    #1
  344                              adc    [__stack],Y
  345                            __addmi 2, __stack
  346                             .endm
  347                     
  348                     __subws .macro
  349                             stx     <__temp
  350                             sta     <__temp+1
  351                             sec
  352                             lda     [__stack]
  353                             sbc     <__temp
  354                             tax
  355                             ldy     #1
  356                             lda     [__stack],Y
  357                             sbc     <__temp+1
  358                             __addmi 2, __stack
  359                             .endm
  360                     
  361                     __orws  .macro
  362                              sax
  363                              ora    [__stack]
  364                              sax
  365                              ldy    #1
  366                              ora    [__stack],Y
  367                            __addmi  2,__stack
  368                             .endm
  369                     
  370                     __orwi  .macro
  371                              sax
  372                              ora    #low(\1)
  373                              sax
  374                              ora    #high(\1)
  375                             .endm   
  376                     
  377                     __orw   .macro
  378                              sax
  379                              ora    \1
  380                              sax
  381                              ora    \1+1
  382                             .endm   
  383                     
  384                     __andws .macro
  385                              sax
  386                              and    [__stack]
  387                              sax
  388                              ldy    #1
  389                              and    [__stack],Y
  390                            __addmi  2,__stack
  391                             .endm
  392                     
  393                     __andwi .macro
  394                              sax
  395                              and    #low(\1)
  396                              sax
  397                              and    #high(\1)
  398                             .endm   
  399                     
  400                     __andw  .macro
  401                              sax
  402                              and    \1
  403                              sax
  404                              and    \1+1
  405                             .endm   
  406                     
  407                     __eorws .macro
  408                              sax
  409                              eor    [__stack]
  410                              sax
  411                              ldy    #1
  412                              eor    [__stack],Y
  413                            __addmi  2,__stack
  414                             .endm
  415                     
  416                     __lbra  .macro
  417                              jmp    \1
  418                             .endm
  419                     
  420                     __lbeq  .macro
  421                              bne    .x\@
  422                              jmp    \1
  423                     .x\@
  424                             .endm
  425                     
  426                     __lbne  .macro
  427                              beq    .x\@
  428                              jmp    \1
  429                     .x\@
  430                             .endm
  431                     
  432                     __call  .macro
  433                              call   \1
  434                             .endm
  435                     
  436                     _set_bgpal .macro
  437                              set_bgpal \1,\2,\3
  438                             .endm
  439                     
  440                     _set_sprpal .macro
  441                              set_sprpal \1,\2,\3
  442                             .endm
  443                     
  444                     _load_background .macro
  445                              vload $1000,\1,#$4000
  446                              vsync
  447                              set_bgpal #0, \2,#16
  448                              batcpy #$0, \3, \4, \5
  449                             .endm
  450                     
#[2]   startup.asm
#[3]   huc_opt.inc
   13                                      .include "huc_opt.inc"
    1                     ;
    2                     ; Hu-C internal include file
    3                     ;
    4                     
    5                     ; optimized macros
    6                     ; ----
    7                     
    8                     ; phw
    9                     ;
   10                             .macro __phw
   11                              ; #1 (bytes :  9, cycles : 16)
   12                              ; #2 (bytes : 16, cycles : 28)
   13                     
   14                             .if (\# = 2)
   15                              tay
   16                              lda    <__arg_idx
   17                              add    #\2
   18                              sta    <__arg_idx
   19                              say
   20                             .else
   21                              ldy    <__arg_idx
   22                             .endif
   23                     
   24                              sta    __arg-(\1),Y
   25                              txa
   26                              sta    __arg-(\1-1),Y
   27                             .endm
   28                     
   29                     ; phb
   30                     ;
   31                             .macro __phb
   32                              ; #1 (bytes :  6, cycles : 11)
   33                              ; #2 (bytes : 12, cycles : 21)
   34                     
   35                             .if (\# = 2)
   36                              lda    <__arg_idx
   37                              add    #\2
   38                              sta    <__arg_idx
   39                              tay
   40                             .else
   41                              ldy    <__arg_idx
   42                             .endif
   43                     
   44                              txa
   45                              sta    __arg-(\1),Y
   46                             .endm
   47                     
   48                     ; plw
   49                     ;
   50                             .macro __plw
   51                              ; (bytes : 9/12, cycles : 16/22)
   52                     
   53                              dey
   54                              lda    __arg,Y
   55                             .if (\#)
   56                              sta    \1
   57                             .else
   58                              tax
   59                             .endif
   60                              dey
   61                              lda    __arg,Y
   62                             .if (\#)
   63                              sta    \1+1
   64                             .endif
   65                             .endm
   66                     
   67                     ; plb
   68                     ;
   69                             .macro __plb
   70                              ; (bytes : 6/7, cycles : 11/12)
   71                     
   72                             .if (\# = 2)
   73                              dey
   74                              ldx    __arg,Y
   75                              stx    \1
   76                             .else
   77                              dey
   78                              lda    __arg,Y
   79                             .if (\#)
   80                              sta    \1
   81                             .endif
   82                             .endif
   83                             .endm
   84                     
   85                     ; lea_s
   86                     ;
   87                             .macro __lea_s
   88                              ; (bytes : 10, cycles : 16)
   89                     
   90                              lda    <__sp
   91                              clc
   92                              adc    #LOW(\1)
   93                              tax
   94                              lda    <__sp+1
   95                              adc    #HIGH(\1)
   96                             .endm
   97                     
   98                     ; pea_s
   99                     ;
  100                             .macro __pea_s
  101                              ; (bytes : 25, cycles : 44)
  102                     
  103                              lda    <__sp
  104                              sec
  105                              sbc    #2
  106                              bcs    .x_\@
  107                              dec    <__sp+1
  108                     .x_\@:   sta    <__sp
  109                              clc
  110                              adc    #LOW(\1+2)
  111                              sta    [__sp]
  112                              tax
  113                              lda    <__sp+1
  114                              adc    #HIGH(\1+2)
  115                              ldy    #1
  116                              sta    [__sp],Y
  117                             .endm
  118                     
  119                     ; ldb_s
  120                     ;
  121                             .macro __ldb_s
  122                             .if (\1 < 256)
  123                              ; short index (bytes :  9, cycles : 13/17)
  124                     
  125                              ldy    #\1
  126                              lda    [__sp],Y
  127                              tax
  128                              cla
  129                     ;        bpl    .x_\@   ; signed
  130                     ;        dec    A
  131                     ;.x_\@:
  132                             .else
  133                              ; long index  (bytes : 20, cycles : 37/41)
  134                     
  135                              addw   #\1,<__sp,<__ptr        ; 13,26
  136                              lda    [__ptr]
  137                              tax
  138                              cla
  139                     ;        bpl    .x_\@   ; signed
  140                     ;        dec    A
  141                     ;.x_\@:
  142                             .endif
  143                             .endm
  144                     
  145                     ; ldb_p
  146                     ;
  147                             .macro __ldb_p
  148                              ; (bytes : 11, cycles : 19/23)
  149                              stx    <__ptr
  150                              sta    <__ptr+1
  151                              lda    [__ptr]
  152                              tax
  153                              cla
  154                     ;        bpl    .x_\@   ; signed
  155                     ;        dec    A
  156                     ;.x_\@:
  157                             .endm
  158                     
  159                     ; ldw_s
  160                     ;
  161                             .macro __ldw_s
  162                             .if (\1 < 255)
  163                              ; short index (bytes :  7/8, cycles : 18/20)
  164                              .if (\1 = 0)
  165                               lda   [__sp]
  166                               tax
  167                               ldy   #1
  168                               lda   [__sp],Y
  169                              .else
  170                               ldy   #\1
  171                               lda   [__sp],Y
  172                               tax
  173                               iny
  174                               lda   [__sp],Y
  175                              .endif
  176                             .else
  177                              ; long index  (bytes : 20, cycles : 44)
  178                     
  179                              addw   #\1,<__sp,<__ptr        ; 13,26
  180                              lda    [__ptr]
  181                              tax
  182                              ldy    #1
  183                              lda    [__ptr],Y
  184                             .endif
  185                             .endm
  186                     
  187                     ; stbi_s
  188                     ;
  189                             .macro __stbi_s
  190                             .if (\2 < 256)
  191                              ; short index (bytes :  8/ 9, cycles : 15)
  192                     
  193                              lda    #LOW(\1)
  194                              ldy    #\2
  195                              sta    [__sp],Y
  196                              tax
  197                     ;        lda    #HIGH(\1)
  198                              cla
  199                             .else
  200                              ; long index  (bytes : 19/20, cycles : 39)
  201                     
  202                              addw   #\2,<__sp,<__ptr        ; 13,26
  203                              lda    #LOW(\1)
  204                              sta    [__ptr]
  205                              tax
  206                     ;        lda    #HIGH(\1)
  207                              cla
  208                             .endif
  209                             .endm
  210                     
  211                     ; stwi_s
  212                     ;
  213                             .macro __stwi_s
  214                             .if (\2 < 255)
  215                              ; short index (bytes : 12, cycles : 24)
  216                     
  217                              lda    #LOW(\1)
  218                              ldy    #\2
  219                              sta    [__sp],Y
  220                              tax
  221                              lda    #HIGH(\1)
  222                              iny
  223                              sta    [__sp],Y
  224                             .else
  225                              ; long index  (bytes : 24, cycles : 48)
  226                     
  227                              addw   #\2,<__sp,<__ptr        ; 13,26
  228                              lda    #LOW(\1)
  229                              sta    [__ptr]
  230                              tax
  231                              lda    #HIGH(\1)
  232                              ldy    #1
  233                              sta    [__ptr],Y
  234                             .endif
  235                             .endm
  236                     
  237                     ; stb_s
  238                     ;
  239                             .macro __stb_s
  240                             .if (\1 < 255)
  241                              ; short index (bytes :  6, cycles : 13)
  242                     
  243                              sax
  244                              ldy    #\1
  245                              sta    [__sp],Y
  246                              sax
  247                             .else
  248                              ; long index  (bytes : 18, cycles : 42)
  249                     
  250                              pha
  251                              addw   #\1,<__sp,<__ptr        ; 13,26
  252                              txa
  253                              sta    [__ptr]
  254                              pla
  255                             .endif
  256                             .endm
  257                     
  258                     ; stw_s
  259                     ;
  260                             .macro __stw_s
  261                             .if (\1 < 255)
  262                              ; short index (bytes :  9, cycles : 22)
  263                     
  264                              sax
  265                              ldy    #\1
  266                              sta    [__sp],Y
  267                              sax
  268                              iny
  269                              sta    [__sp],Y
  270                             .else
  271                              ; long index  (bytes : 22, cycles : 51)
  272                     
  273                              pha
  274                              addw   #\1,<__sp,<__ptr        ; 13,26
  275                              txa
  276                              sta    [__ptr]
  277                              pla
  278                              ldy    #1
  279                              sta    [__ptr],Y
  280                             .endif
  281                             .endm
  282                     
  283                     ; addw_s
  284                     ;
  285                             .macro __addw_s
  286                             .if (\1 < 255)
  287                              ; short index (bytes : 10, cycles : 24)
  288                     
  289                              ldy    #\1
  290                              clc
  291                              sax
  292                              adc    [__sp],Y
  293                              sax
  294                              iny
  295                              adc    [__sp],Y
  296                             .else
  297                              ; long index  (bytes : 24, cycles : 55)
  298                     
  299                              pha                            ;  1, 3
  300                              addw   #\1,<__sp,<__ptr        ; 13,26
  301                              pla                            ;  1, 4
  302                              clc
  303                              sax
  304                              adc    [__ptr]
  305                              sax
  306                              ldy    #1
  307                              adc    [__ptr],Y
  308                             .endif
  309                             .endm
  310                     
  311                     ; incw_s
  312                     ;
  313                             .macro __incw_s
  314                              ; (bytes : 16, cycles : 24/40)
  315                     
  316                              pha
  317                              ldy    #\1
  318                              txa
  319                              inc    A
  320                              sta    [__sp],Y
  321                              bne    .x_\@
  322                              iny
  323                              lda    [__sp],Y
  324                              inc    A
  325                              sta    [__sp],Y
  326                     .x_\@:
  327                              pla
  328                             .endm
  329                     
  330                     ; ldd_i
  331                     ;
  332                             .macro __ldd_i
  333                              stw    #(\1) & 0xFFFF,<\2
  334                              stw    #(\1) >> 16,<\3
  335                              ldx    #low(\2)
  336                              lda    #high(\2)
  337                             .endm
  338                     
  339                     ; ldd_b
  340                     ;
  341                             .macro __ldd_b
  342                              lda     \1
  343                              sta    <\2
  344                              stz    <\2+1
  345                              stwz   <\3
  346                              ldx    #low(\2)
  347                              lda    #high(\2)
  348                             .endm
  349                     
  350                     ; ldd_w
  351                     ;
  352                             .macro __ldd_w
  353                              stw     \1,<\2
  354                              stwz   <\3
  355                              ldx    #low(\2)
  356                              lda    #high(\2)
  357                             .endm
  358                     
  359                     ; ldd_s_b
  360                     ;
  361                             .macro __ldd_s_b
  362                            __ldb_s  \1
  363                              stx    <\2
  364                              sta    <\2+1
  365                              stwz   <\3
  366                              ldx    #low(\2)
  367                              lda    #high(\2)
  368                             .endm
  369                     
  370                     ; ldd_s_w
  371                     ;
  372                             .macro __ldd_s_w
  373                            __ldw_s  \1
  374                              stx    <\2
  375                              sta    <\2+1
  376                              stwz   <\3
  377                              ldx    #low(\2)
  378                              lda    #high(\2)
  379                             .endm
  380                     
#[2]   startup.asm
   14                                     .endif  ; HUC
   15                     
#[3]   standard.inc
   16                                     .include  "standard.inc" ; HUCARD
    1                     ;
    2                     ; STANDARD.INC  -  MagicKit standard include file
    3                     ;
#[4]   equ.inc
    4                             .include        "equ.inc"
    1                     ;
    2                     ; EQU.INC  -  MagicKit Standard Equates
    3                     ;
    4                     ;
    5                     
    6                     
    7                     ; --------
    8                     ; This block defines standard system variables
    9                     ; in zero-page.
   10                     ;
   11                     
   12           20F3      vdc_crl = $20F3 ; VDC control register   (copy of)
   13           20F4      vdc_crh = $20F4 ;
   14           20F5      irq_m   = $20F5 ; interrupt control mask (copy of)
   15           20F6      vdc_sr  = $20F6 ; VDC status register    (copy of)
   16           20F7      vdc_reg = $20F7 ; VDC register index     (copy of)
   17                     
   18                             ; old aliases (for compatibility only, don't use them)
   19                     
   20           0000              .ifndef HUC
   24                             .endif
   25                     
   26                     ; --------
   27                     ; This block defines standard parameter-passing
   28                     ; areas (in zero-page) for subroutines.
   29                     ;
   30                     
   31           20EC      _bp     = $20EC ; base pointer
   32           20EE      _si     = $20EE ; source address
   33           20F0      _di     = $20F0 ; destination address
   34           20F8      _ax     = $20F8
   35           20F8      _al     = $20F8
   36           20F9      _ah     = $20F9
   37           20FA      _bx     = $20FA
   38           20FA      _bl     = $20FA
   39           20FB      _bh     = $20FB
   40           20FC      _cx     = $20FC
   41           20FC      _cl     = $20FC
   42           20FD      _ch     = $20FD
   43           20FE      _dx     = $20FE
   44           20FE      _dl     = $20FE
   45           20FF      _dh     = $20FF
   46                     
   47                     
   48                     ; --------
   49                     ; This block defines names for standard
   50                     ; devices and equipment on the PC-Engine.
   51                     ; (they should be self-explanatory...)
   52                     ;
   53                     
   54                         ; ----
   55                         ; VDC (Video Display Controller)
   56                     
   57           0000      videoport    .equ $0000
   58                     
   59           0000      video_reg    .equ  videoport
   60           0000      video_reg_l  .equ  video_reg
   61           0001      video_reg_h  .equ  video_reg+1
   62                     
   63           0002      video_data   .equ  videoport+2
   64           0002      video_data_l .equ  video_data
   65           0003      video_data_h .equ  video_data+1
   66                     
   67                     
   68                         ; ----
   69                         ; VCE (Video Color Encoder)
   70                     
   71           0400      colorport    .equ $0400
   72           0400      color_ctrl   .equ  colorport
   73                     
   74           0402      color_reg    .equ  colorport+2
   75           0402      color_reg_l  .equ  color_reg
   76           0403      color_reg_h  .equ  color_reg+1
   77                     
   78           0404      color_data   .equ  colorport+4
   79           0404      color_data_l .equ  color_data
   80           0405      color_data_h .equ  color_data+1
   81                     
   82           0001                   .ifdef HUC
   83           0402      _color_reg   .equ  colorport+2
   84           0404      _color_data  .equ  colorport+4
   85                                  .endif
   86                     
   87                         ; ----
   88                         ; PSG (Programmable Sound Generator)
   89                     
   90           0800      psgport      .equ  $0800
   91           0800      psg_ch       .equ  psgport
   92           0801      psg_mainvol  .equ  psgport+1
   93           0802      psg_freqlo   .equ  psgport+2
   94           0803      psg_freqhi   .equ  psgport+3
   95           0804      psg_ctrl     .equ  psgport+4
   96           0805      psg_pan      .equ  psgport+5
   97           0806      psg_wavebuf  .equ  psgport+6
   98           0807      psg_noise    .equ  psgport+7
   99           0808      psg_lfofreq  .equ  psgport+8
  100           0809      psg_lfoctrl  .equ  psgport+9
  101                     
  102                     
  103                         ; ----
  104                         ; TIMER
  105                     
  106           0C00      timerport    .equ  $0C00
  107           0C00      timer_cnt    .equ  timerport
  108           0C01      timer_ctrl   .equ  timerport+1        
  109                     
  110                     
  111                         ; ----
  112                         ; I/O port
  113                     
  114           1000      joyport      .equ  $1000
  115                     
  116                     
  117                         ; ----
  118                         ; IRQ ports
  119                     
  120           1400      irqport      .equ  $1400
  121           1402      irq_disable  .equ  irqport+2
  122           1403      irq_status   .equ  irqport+3
  123                     
  124                         ; ----
  125                         ; CDROM/Expansion ports
  126                     
  127           1800      cd_port       .equ  $1800
  128                     
  129           1803      bram_lock    .equ  cd_port+3  ; a read access here will do it
  130           1807      bram_unlock  .equ  cd_port+7  ; actually, bit #$80 of this byte
  131                     
  132                         ; ----
  133                         ; Arcade Card ports
  134                     
  135           1A00      ac_port        .equ  $1A00
  136           1A00      ac_data1       .equ  ac_port
  137           1A01      ac_data1_alt   .equ  ac_port+1
  138           1A02      ac_base1_l     .equ  ac_port+2
  139           1A03      ac_base1_m     .equ  ac_port+3
  140           1A04      ac_base1_h     .equ  ac_port+4
  141           1A05      ac_offset1_l   .equ  ac_port+5
  142           1A06      ac_offset1_m   .equ  ac_port+6
  143           1A09      ac_cntrol1     .equ  ac_port+9
  144           1A0A      ac_addoffset1  .equ  ac_port+$0A
  145                     
  146           1AE0      ac_shftreg    .equ  $1AE0       ; actually, probably rotate register
  147           1AE0      ac_shftreg_0  .equ  ac_shftreg
  148           1AE1      ac_shftreg_1  .equ  ac_shftreg+1
  149           1AE2      ac_shftreg_2  .equ  ac_shftreg+2
  150           1AE3      ac_shftreg_3  .equ  ac_shftreg+3
  151           1AE4      ac_shft_bits  .equ  ac_shftreg+4        ; positive = shift left
  152                     
  153           1AFD      ac_identbase  .equ  $1AFD
  154           1AFD      ac_identver_l .equ  ac_identbase
  155           1AFE      ac_identver_h .equ  ac_identbase+1
  156           1AFF      ac_identflag  .equ  ac_identbase+2
  157                     
  158           0051      AC_IDENT      .equ  $51 ; if ac_identflag = AC_IDENT, then AC in use
  159                     
  160                     
  161                     ; --------
  162                     ; This block defines names for macro
  163                     ; argument types (\?x).
  164                     ;
  165                     
  166           0000      ARG_NONE        .equ 0
  167           0001      ARG_REG         .equ 1
  168           0002      ARG_IMMED       .equ 2
  169           0003      ARG_ABS         .equ 3
  170           0003      ARG_ABSOLUTE    .equ 3
  171           0004      ARG_INDIRECT    .equ 4
  172           0005      ARG_STRING      .equ 5
  173           0006      ARG_LABEL       .equ 6
  174                     
#[3]   standard.inc
#[4]   macro.inc
    5                             .include        "macro.inc"
    1                     ;
    2                     ; MACRO.INC  -  MagicKit standard MACRO definitions
    3                     ;
    4                     
    5                     map     .macro                  ; map a memory bank into
    6                              lda   #bank(\1)        ; addressable memory
    7                              tam   #page(\1)
    8                             .endm
    9                     
   10                     ;
   11                     ; MAPLIBFUNC - Re-map a library function into $A000-space if it's
   12                     ;              not in library bank #1
   13                     ;
   14                     maplibfunc      .macro
   15                              tay
   16                              tma  #page(\1)
   17                              pha
   18                              lda  #bank(\1)
   19                              tam  #page(\1)
   20                              tya
   21                              jsr  \1
   22                              tay
   23                              pla
   24                              tam  #page(\1)
   25                              tya
   26                             .endm
   27                     
   28                     
   29                     ;
   30                     ; STWZ - store a word-sized zero value at stated memory location
   31                     ;
   32                     stwz    .macro
   33                              stz    LOW_BYTE \1
   34                              stz    HIGH_BYTE \1
   35                             .endm
   36                     
   37                     ;
   38                     ; STW - store a word-sized value at stated memory location
   39                     ;
   40                     stw     .macro
   41                              lda    LOW_BYTE \1
   42                              sta    LOW_BYTE \2
   43                              lda    HIGH_BYTE \1
   44                              sta    HIGH_BYTE \2
   45                             .endm
   46                     
   47                     stb     .macro
   48                              lda    \1
   49                              sta    \2
   50                             .endm
   51                     
   52                     ;
   53                     ; ADDW - add word-sized value to value at stated memory location,
   54                     ;        storing result back into stated memory location (or into
   55                     ;        another destination memory location - third arg)
   56                     ;
   57                     addw    .macro
   58                             .if     (\# = 3)
   59                              ; 3-arg mode
   60                              ;
   61                              clc
   62                              lda    LOW_BYTE \2
   63                              adc    LOW_BYTE \1
   64                              sta    LOW_BYTE \3
   65                              lda    HIGH_BYTE \2
   66                              adc    HIGH_BYTE \1
   67                              sta    HIGH_BYTE \3
   68                             .else
   69                              ; 2-arg mode
   70                              ;
   71                              clc
   72                              lda    LOW_BYTE \2
   73                              adc    LOW_BYTE \1
   74                              sta    LOW_BYTE \2
   75                              lda    HIGH_BYTE \2
   76                              adc    HIGH_BYTE \1
   77                              sta    HIGH_BYTE \2
   78                             .endif
   79                             .endm
   80                     
   81                     ;
   82                     ; ADCW - add word-sized value plus carry to value at stated memory location,
   83                     ;        storing result back into stated memory location
   84                     ;
   85                     adcw    .macro
   86                              lda    LOW_BYTE \2
   87                              adc    LOW_BYTE \1
   88                              sta    LOW_BYTE \2
   89                              lda    HIGH_BYTE \2
   90                              adc    HIGH_BYTE \1
   91                              sta    HIGH_BYTE \2
   92                             .endm
   93                     
   94                     ;
   95                     ; SUBW - substract word-sized value from value at stated memory location,
   96                     ;        storing result back into stated memory location
   97                     ;
   98                     subw    .macro
   99                              sec
  100                              lda    LOW_BYTE \2
  101                              sbc    LOW_BYTE \1
  102                              sta    LOW_BYTE \2
  103                              lda    HIGH_BYTE \2
  104                              sbc    HIGH_BYTE \1
  105                              sta    HIGH_BYTE \2
  106                             .endm
  107                     
  108                     ;
  109                     ; SBCW - substract word-sized value plus carry from value at stated memory
  110                     ;        location, storing result back into stated memory location
  111                     ;
  112                     sbcw    .macro
  113                              lda    LOW_BYTE \2
  114                              sbc    LOW_BYTE \1
  115                              sta    LOW_BYTE \2
  116                              lda    HIGH_BYTE \2
  117                              sbc    HIGH_BYTE \1
  118                              sta    HIGH_BYTE \2
  119                             .endm
  120                     
  121                     cmpw    .macro
  122                              lda    HIGH_BYTE \2
  123                              cmp    HIGH_BYTE \1
  124                              bne    .x_\@
  125                              lda    LOW_BYTE \2
  126                              cmp    LOW_BYTE \1
  127                     .x_\@:
  128                             .endm
  129                     
  130                     tstw    .macro                  ; test if the word-sized 
  131                              lda   \1               ; value at stated memory
  132                              ora   \1+1             ; location is zero
  133                             .endm
  134                     
  135                     incw    .macro                  ; increment a word-sized
  136                              inc    \1              ; value at stated memory
  137                              bne    .x_\@           ; location
  138                              inc    \1+1
  139                     .x_\@:
  140                             .endm
  141                     
  142                     decw    .macro                  ; decrement a word-sized
  143                              sec                    ; value at stated memory
  144                              lda    \1              ; location
  145                              sbc    #1
  146                              sta    \1
  147                              lda    \1+1
  148                              sbc    #0
  149                              sta    \1+1
  150                             .endm
  151                     
  152                     rolw    .macro                  ; rotate word-sized value
  153                              rol    \1              ; (at stated memory location)
  154                              rol    \1+1
  155                             .endm
  156                     
  157                     aslw    .macro                  ; arithmetic shift-left
  158                              asl    \1              ; word-sized value (at stated
  159                              rol    \1+1            ; memory location)
  160                             .endm
  161                     
  162                     lsrw    .macro                  ; logical shift-right word-sized
  163                              lsr    \1+1            ; value (at stated memory
  164                              ror    \1              ; location)
  165                             .endm
  166                     
  167                     rorw    .macro                  ; rotate right word-sized value
  168                              ror    \1+1            ; (at stated memory location)
  169                              ror    \1
  170                             .endm
  171                     
  172                     negw    .macro                  ; negate word-sized value
  173                              cla                    ; (at stated memory location)
  174                              sub    \1              ; 2's complement
  175                              sta    \1
  176                              cla
  177                              sbc    \1+1
  178                              sta    \1+1
  179                             .endm
  180                     
  181                     neg     .macro                  ; negate byte-sized value
  182                              eor    #$FF            ; in register A
  183                              inc    A               ; 2's complement
  184                             .endm
  185                     
  186                     add     .macro                  ; add byte-sized value to
  187                             .if (\# = 2)            ; register A (handle carry
  188                              lda    \2              ; flag)
  189                              clc
  190                              adc    \1
  191                              sta    \2
  192                             .else
  193                              clc
  194                              adc    \1
  195                             .endif
  196                             .endm
  197                     
  198                     sub     .macro                  ; subtract byte-sized value
  199                             .if (\# = 2)            ; from register A (handle
  200                              lda    \2              ; carry flag)
  201                              sec
  202                              sbc    \1
  203                              sta    \2
  204                             .else
  205                              sec
  206                              sbc    \1
  207                             .endif
  208                             .endm
  209                     
  210                     blo     .macro                  ; branch if 'lower'
  211                              bcc    \1
  212                             .endm
  213                     
  214                     bhs     .macro                  ; branch if 'higher or same'
  215                              bcs    \1
  216                             .endm
  217                     
  218                     bhi     .macro                  ; branch if 'higher'
  219                              beq    .x_\@
  220                              bcs    \1
  221                     .x_\@:
  222                             .endm
  223                     
  224                     ;-------------------------------
  225                     
  226                     ;
  227                     ; Long branch MACROs
  228                     ;
  229                     
  230                     lbne    .macro
  231                              beq    .x_\@
  232                              jmp    \1
  233                     .x_\@
  234                             .endm
  235                     
  236                     lbeq    .macro
  237                              bne    .x_\@
  238                              jmp    \1
  239                     .x_\@
  240                             .endm
  241                     
  242                     lbpl    .macro
  243                              bmi    .x_\@
  244                              jmp    \1
  245                     .x_\@
  246                             .endm
  247                     
  248                     lbmi    .macro
  249                              bpl    .x_\@
  250                              jmp    \1
  251                     .x_\@
  252                             .endm
  253                     
  254                     lbcc    .macro
  255                              bcs    .x_\@
  256                              jmp    \1
  257                     .x_\@
  258                             .endm
  259                     
  260                     lbcs    .macro
  261                              bcc    .x_\@
  262                              jmp    \1
  263                     .x_\@
  264                             .endm
  265                     
  266                     lblo    .macro
  267                              bcs    .x_\@
  268                              jmp    \1
  269                     .x_\@
  270                             .endm
  271                     
  272                     lbhs    .macro
  273                              bcc    .x_\@
  274                              jmp    \1
  275                     .x_\@
  276                             .endm
  277                     
  278                     
  279                     ;-------------------------------
  280                     
  281                     ;
  282                     ; These MACROs are the same as the MACROs
  283                     ; without an underscore; the difference
  284                     ; is these MACROs preserve the state of
  285                     ; the registers they use (at the expense
  286                     ; of speed)
  287                     ;
  288                     
  289                     _stw    .macro
  290                              pha
  291                              stw    \1,\2
  292                              pla
  293                             .endm
  294                     
  295                     _addw   .macro
  296                              pha
  297                              addw   \1,\2
  298                              pla
  299                             .endm
  300                     
  301                     _adcw   .macro
  302                              pha
  303                              adcw   \1,\2
  304                              pla
  305                             .endm
  306                     
  307                     _subw   .macro
  308                              pha
  309                              subw   \1,\2
  310                              pla
  311                             .endm
  312                     
  313                     _sbcw   .macro
  314                              pha
  315                              sbcw   \1,\2
  316                              pla
  317                             .endm
  318                     
  319                     _cmpw   .macro
  320                              pha
  321                              cmpw   \1,\2
  322                              pla
  323                             .endm
  324                     
  325                     _tstw   .macro
  326                              pha
  327                              tstw   \1
  328                              pla
  329                             .endm
  330                     
  331                     _incw   .macro
  332                              incw   \1
  333                             .endm
  334                     
  335                     _decw   .macro
  336                              pha
  337                              decw   \1
  338                              pla
  339                             .endm
  340                     
#[3]   standard.inc
#[4]   func.inc
    6                             .include        "func.inc"
    1                     ;
    2                     ; FUNC.INC  -  MagicKit Standard Functions
    3                     ;
    4                     ;
    5                     
    6                     ; ----
    7                     ; BATVAL - create a value for the BAT map
    8                     ;
    9                     ; parameters:
   10                     ; \1 = palette (0-15)
   11                     ; \2 = VRAM address of tile
   12                     
   13                     BATVAL   .func  (\1<<12)|(\2>>4)
   14                     
   15                     
   16                     ; ----
   17                     ; CHAR - create a BAT value for a character defined
   18                     ;        using '.defchar' (uses default palette)
   19                     ;
   20                     ; parameters:
   21                     ; \1 = name of character
   22                     ;
   23                     CHAR     .func  (PAL(\1)<<12|VRAM(\1)>>4)
   24                     
   25                     ; ----
   26                     ; SPR_VRAM - return shifted value of sprite-pattern VRAM address
   27                     ;
   28                     ; parameters:
   29                     ; \1 = VRAM address of sprite
   30                     ;
   31                     SPR_VRAM .func  (VRAM(\1)>>5)
   32                     
#[3]   standard.inc
#[4]   library.inc
    7                             .include        "library.inc"
    1                     ;
    2                     ; LIBRARY.INC  -  MagicKit include-interface to LIBRARY.ASM
    3                     ;
    4                     
    5                     ;
    6                     ; These MACROs are just simple one-line setups to the
    7                     ; back-end library subroutines.  They simply setup
    8                     ; calling parameters, and call the subroutine
    9                     ;
   10                     
   11                     
   12                     ; set video memory read and write address:
   13                     ;
   14                     ; setvraddr(addr)
   15                     ; ----
   16                     ; addr,  new address in VRAM to read at
   17                     ;
   18                             .macro setvraddr
   19                              stw  #\1,<_di
   20                              jsr  set_read
   21                             .endm
   22                     
   23                     ; setvwaddr(addr)
   24                     ; ----
   25                     ; addr,  new address in VRAM to write at
   26                     ;
   27                             .macro setvwaddr
   28                              stw  #\1,<_di
   29                              jsr  set_write
   30                             .endm
   31                     
   32                     ; set_bgpal(index, data [, nb])
   33                     ; ----
   34                     ; index, sub-palette index (0-15)
   35                     ; data,  color data memory address
   36                     ; nb,    number of sub-palette to load (optional, one by default)
   37                     
   38                             .macro set_bgpal
   39                              lda   \1
   40                              sta   <_al
   41                             .if (\?2 = ARG_LABEL)
   42                              stb   #BANK(\2),<_bl
   43                             .else
   44                              stb   #$FE,<_bl
   45                             .endif
   46                              stw   #\2,<_si
   47                             .if \?3
   48                              lda   \3
   49                             .else
   50                              lda   #1
   51                             .endif
   52                              sta   <_cl
   53                              jsr   load_palette
   54                             .endm
   55                     
   56                     ; set_sprpal(index, data [, nb])
   57                     ; ----
   58                     ; index, sub-palette index (0-15)
   59                     ; data,  palette data memory address
   60                     ; nb,    number of sub-palette to update (optional, one by default)
   61                     
   62                             .macro set_sprpal
   63                              lda   \1
   64                              add   #16
   65                              sta   <_al
   66                             .if (\?2 = ARG_LABEL)
   67                              stb   #BANK(\2),<_bl
   68                             .else
   69                              stb   #$FE,<_bl
   70                             .endif
   71                              stw   #\2,<_si
   72                             .if \?3
   73                              lda   \3
   74                             .else
   75                              lda   #1
   76                             .endif
   77                              sta   <_cl
   78                              jsr   load_palette
   79                             .endm
   80                     
   81                     ; setcolor(index, r, g, b)
   82                     ; ----
   83                     ; index, color index
   84                     ; r,     red   (0-7)
   85                     ; g,     green (0-7)
   86                     ; b,     blue  (0-7)
   87                     
   88                             .macro setcolor
   89                              stw   \1,color_reg
   90                              stw   #(((\3) << 6) + ((\2) << 3) + (\4)),color_data
   91                             .endm
   92                     
   93                     ; vload([vram,] data, size)
   94                     ; ----
   95                     ; vram, VRAM base address
   96                     ; data, video data memory address
   97                     ; size, number of words to copy
   98                     
   99                             .macro vload
  100                             .if (\# = 3)
  101                              stw   #\1,<_di
  102                             .if (\?2 = ARG_LABEL)
  103                              stb   #BANK(\2),<_bl
  104                             .else
  105                              stb   #$FE,<_bl
  106                             .endif
  107                              stw   #\2,<_si
  108                              stw    \3,<_cx
  109                             .else
  110                              stw   #VRAM(\1),<_di
  111                              stb   #BANK(\1),<_bl
  112                              stw   #\1,<_si
  113                              stw   #\2,<_cx
  114                             .endif
  115                              jsr   load_vram
  116                             .endm
  117                     
  118                     ; batcpy(vram, bat, w, h)
  119                     ; ----
  120                     ; vram,   VRAM base address
  121                     ; bat,    BAT address in memory
  122                     ; w,      nb of column to copy
  123                     ; h,      nb of row
  124                     
  125                             .macro batcpy
  126                             .if (\# = 5)
  127                              .fail "batcpy syntax has changed, update your code!"
  128                             .endif
  129                              stw    \1,<_di
  130                             .if (\?2 = ARG_LABEL)
  131                              stb   #BANK(\2),<_bl
  132                             .else
  133                              stb   #$FE,<_bl
  134                             .endif
  135                              stw   #\2,<_si
  136                              lda   \3
  137                              sta   <_cl
  138                              lda   \4
  139                              sta   <_ch
  140                              jsr   load_bat
  141                             .endm
  142                     
  143                     ; setmap(map, tile, ctable, w ,h)
  144                     ; ----
  145                     ; map,    map base address
  146                     ; tile,   tile vram address
  147                     ; ctable, tile palette table address
  148                     ; w,      map width
  149                     ; h,      map height
  150                     
  151                             .macro setmap
  152                              stw   #BANK(\1),mapbank
  153                              stw   #\1,mapaddr
  154                              stw   #(\2)>>4,maptilebase
  155                              stw   #\3,mapctable
  156                              stb   #BANK(\3),mapctablebank
  157                              stw   \4,mapwidth
  158                              stw   \5,mapheight
  159                             .endm
  160                     
  161                     ; mapcpy(vram, x, y, w, h)
  162                     ; ----
  163                     ; vram, VRAM base address
  164                     ; x,    x start coordinate in the map
  165                     ; y,    y start coordinate
  166                     ; w,    nb of column to copy
  167                     ; h,    nb of row
  168                     
  169                             .macro mapcpy
  170                              stw   #\1,<_di
  171                              lda   \2
  172                              sta   <_cl
  173                              lda   \3
  174                              sta   <_ch
  175                              lda   \4
  176                              sta   <_dl
  177                              lda   \5
  178                              sta   <_dh
  179                              jsr   load_map
  180                             .endm
  181                     
  182                     ; fntcpy(vram, font, color, bg, nb)
  183                     ; ----
  184                     ; vram,  VRAM base address
  185                     ; font,  font address in memory
  186                     ; color, character color
  187                     ; bg,    bg color
  188                     ; nb,    nb of char. to copy
  189                     
  190                             .macro fntcpy   
  191                              stw   #\1,<_di
  192                              stb   #BANK(\2),<_bl
  193                              stw   #\2,<_si
  194                              lda   \3
  195                              sta   <_al
  196                              lda   \4
  197                              sta   <_ah
  198                              lda   \4
  199                              sta   <_cl
  200                              jsr   load_font
  201                             .endm
  202                     
  203                     ; scroll(num, x, y, top, bottom, cr)
  204                     ; ----
  205                     ; num,    scroll number (0-3)
  206                     ; x,      BAT x position
  207                     ; y,      BAT y position
  208                     ; top,    screen window top
  209                     ; bottom, screen window bottom
  210                     ; cr,     screen window display control (bg/sp)
  211                     
  212                             .macro scroll
  213                              lda   \1
  214                              tax
  215                              lda   LOW_BYTE  \2
  216                              sta   scroll_xl,X
  217                              lda   HIGH_BYTE \2
  218                              sta   scroll_xh,X
  219                              lda   LOW_BYTE  \3
  220                              sta   scroll_yl,X
  221                              lda   HIGH_BYTE \3
  222                              sta   scroll_yh,X
  223                              lda   \4
  224                              sta   scroll_top,X
  225                              lda   \5
  226                              sta   scroll_bottom,X
  227                              lda   \6
  228                              ora   #$01
  229                              sta   scroll_cr,X
  230                             .endm
  231                     
  232                     ; scroll_disable(num)
  233                     ; ----
  234                     ; num,    scroll number (0-3)
  235                     
  236                             .macro scroll_disable
  237                              lda   \1
  238                              tax
  239                              lda   scroll_cr,X
  240                              and   #$fe
  241                              sta   scroll_cr,X
  242                             .endm
  243                     
  244                     ; setxres (xres)
  245                     ; ----
  246                     ; xres,    horizontal display resolution
  247                     
  248                             .macro setxres
  249                              stw   #\1,<_ax
  250                              jsr   set_xres
  251                             .endm
  252                     
#[3]   standard.inc
#[4]   sprites.inc
    8                             .include        "sprites.inc"
    1                     ;
    2                     ; SPRITES.INC  -  MagicKit sprite MACRO definitions
    3                     ;
    4                     
    5                     
    6                     ; load_sprites(vram_addr, spr_bank, #nb_group)
    7                     ; ----
    8                     ; vram_addr, destination address in VRAM
    9                     ; spr_bank,  sprite bank address
   10                     ; nb_group,  number of 32x64 patterns to copy
   11                     
   12                             .macro load_sprites
   13                     
   14                             ; put the VRAM address in _di
   15                     
   16                              stw   #\1,<_di
   17                     
   18                             ; put the sprite bank address in _si/_bl
   19                     
   20                              stw   #\2,<_si
   21                              stb   #BANK(\2),<_bl
   22                     
   23                             ; get the number of patterns to copy, multiply it by $200 -
   24                             ; the size in words of a 32x64 pattern (remember that
   25                             ; 'load_vram' need a size in words), and put it in _cx
   26                     
   27                              lda   \3
   28                              asl   A
   29                              stz   <_cx
   30                              sta   <_cx+1
   31                     
   32                             ; call the 'load_vram' function
   33                     
   34                              jsr load_vram
   35                             .endm
   36                     
   37                     
   38                     ; spr_set(#sprite, satb)
   39                     ; ----
   40                     ; sprite, the sprite number (0-63)
   41                     ; satb,   the address of the SATB in RAM
   42                     
   43                             .macro spr_set
   44                     
   45                             ; multiply the sprite number by 8 (the size of a SATB entry)
   46                             ; and put the result in _si
   47                     
   48                              stz   <_si+1
   49                              lda   \1
   50                              asl   A
   51                              asl   A
   52                              asl   A
   53                              rol   <_si+1
   54                              sta   <_si
   55                     
   56                             ; add the satb address to _si
   57                     
   58                              addw  #\2,<_si
   59                             .endm
   60                     
   61                     
   62                     ; spr_x(#x [,offset])
   63                     ; ----
   64                     ; x, the new x coordinate
   65                     
   66                             .macro spr_x
   67                              ldy   #2
   68                              .if (\# = 2)
   69                               lda   LOW_BYTE \1
   70                               clc
   71                               adc   LOW_BYTE \2
   72                               sta   [_si],Y
   73                               lda   HIGH_BYTE \1
   74                               adc   HIGH_BYTE \2
   75                              .else
   76                               lda   LOW_BYTE \1
   77                               sta   [_si],Y
   78                               lda   HIGH_BYTE \1
   79                              .endif
   80                              iny
   81                              sta   [_si],Y
   82                             .endm
   83                     
   84                     
   85                     ; spr_y(#y [,offset])
   86                     ; ----
   87                     ; y, the new y coordinate
   88                     
   89                             .macro spr_y
   90                              .if (\# = 2)
   91                               lda   LOW_BYTE \1
   92                               clc
   93                               adc   LOW_BYTE \2
   94                               sta   [_si]
   95                               lda   HIGH_BYTE \1
   96                               adc   HIGH_BYTE \2
   97                              .else
   98                               lda   LOW_BYTE \1
   99                               sta   [_si]
  100                               lda   HIGH_BYTE \1
  101                              .endif
  102                              ldy   #1
  103                              sta   [_si],Y
  104                             .endm
  105                     
  106                     
  107                     ; spr_pattern(#addr)
  108                     ; ----
  109                     ; addr, address of the sprite pattern in VRAM
  110                     
  111                             .macro spr_pattern
  112                              ldy   #4
  113                              .if (\?1 = ARG_IMMED)
  114                               lda   #LOW((\1) >> 5)
  115                               sta   [_si],Y
  116                               lda   #HIGH((\1) >> 5)
  117                              .else
  118                               lda   \1
  119                               sta   [_si],Y
  120                               lda   \1+1
  121                              .endif
  122                              iny
  123                              sta   [_si],Y
  124                             .endm
  125                     
  126                     
  127                     ; spr_ctrl(#mask, #flag)
  128                     ; ----
  129                     ; mask, mask of the bits to change
  130                     ; flag, new bit value
  131                     
  132                             .macro spr_ctrl
  133                              ldy   #7
  134                              lda   \1
  135                              eor   #$FF
  136                              and   [_si],Y
  137                              ora   \2
  138                              sta   [_si],Y
  139                             .endm
  140                     
  141                     
  142                     ; spr_pri(#flag)
  143                     ; ----
  144                     ; flag, new priority (1 = in foreground, 0 = in background)
  145                     
  146                             .macro spr_pri
  147                              ldy   #6
  148                              lda   [_si],Y
  149                              and   #$7F
  150                              ldx   \1
  151                              beq   .x\@
  152                              ora   #$80
  153                     .x\@:
  154                              sta [_si],Y
  155                             .endm
  156                     
  157                     
  158                     ; spr_pal(#index)
  159                     ; ----
  160                     ; index, palette index (0-15)
  161                     
  162                             .macro spr_pal
  163                              ldy   #6
  164                              lda   [_si],Y
  165                              and   #$F0
  166                              ora   \1
  167                              sta   [_si],Y
  168                             .endm
  169                     
  170                     
  171                     ; init_satb(addr)
  172                     ; ----
  173                     ; addr, the address of the local RAM SATB
  174                     
  175                             .macro init_satb
  176                              stz \1
  177                              tii \1,\1+1,511
  178                             .endm
  179                     
  180                     
  181                     ; update_satb(satb[, addr] [,nb_sprite])
  182                     ; ----
  183                     ; satb,      the address of the local RAM SATB
  184                     ; addr,      the address where to copy the SATB in VRAM ($7F00 by default)
  185                     ; nb_sprite, number of sprite entry to copy (64 by default)
  186                     
  187                             .macro update_satb
  188                              stw   #\1,<_si
  189                              stb   #BANK(\1),<_bl
  190                              .if (\?2)
  191                               stw   #\2,<_di
  192                              .else
  193                               stw   #$7F00,<_di
  194                              .endif
  195                              .if (\?3)
  196                               stw   #(\3)*4,<_cx
  197                              .else
  198                               stw   #$100,<_cx
  199                              .endif
  200                              jsr   load_vram
  201                             .endm
  202                     
  203                     
  204                     ; ----
  205           0008      FLIP_X_MASK .equ $08
  206           0080      FLIP_Y_MASK .equ $80
  207           0088      FLIP_MASK   .equ $88
  208           0031      SIZE_MASK   .equ $31
  209                     
  210           0000      NO_FLIP    .equ 0
  211           0000      NO_FLIP_X  .equ 0
  212           0000      NO_FLIP_Y  .equ 0
  213           0008      FLIP_X     .equ $08
  214           0080      FLIP_Y     .equ $80
  215           0000      SIZE_16x16 .equ 0
  216           0010      SIZE_16x32 .equ $10
  217           0030      SIZE_16x64 .equ $30
  218           0001      SIZE_32x16 .equ $01
  219           0011      SIZE_32x32 .equ $11
  220           0031      SIZE_32x64 .equ $31
  221                     
#[3]   standard.inc
#[4]   vdc.inc
    9                             .include        "vdc.inc"
    1                     ;
    2                     ; VDC.INC  -  MagicKit PC-Engine video MACRO definitions
    3                     ;
    4                     
    5                     
    6                     ;
    7                     ; VREG - set up video register to be read/written
    8                     ;
    9                     
   10                             .macro vreg
   11                              lda    \1
   12                              sta    <vdc_reg
   13                              .if (\?1 = ARG_IMMED)
   14                               st0   \1
   15                              .else
   16                               sta   video_reg
   17                              .endif
   18                             .endm
   19                     
   20                     ;
   21                     ; SETVINC - set VRAM auto-increment step
   22                     ;
   23                     
   24                             .macro setvinc
   25                              vreg  #5
   26                              .if (\?1 = ARG_IMMED)
   27                               st2   \1
   28                              .else
   29                               lda   \1
   30                               sta   video_data_h
   31                              .endif
   32                             .endm
   33                     
   34                             ; standard increment step
   35                     
   36           0000      VADDR_INC_1   = %00_000
   37           0008      VADDR_INC_32  = %01_000
   38           0010      VADDR_INC_64  = %10_000
   39           0018      VADDR_INC_128 = %11_000
   40                     
   41                     ;
   42                     ; SETBGMAP - set the bgmap virtual size
   43                     ;
   44                     
   45                             .macro setbgmap
   46                              lda   \1
   47                              jsr   set_bat_size
   48                             .endm
   49                     
   50                             ; standard bgmap size
   51                     
   52           0000      BGMAP_SIZE_32x32  = %000
   53           0001      BGMAP_SIZE_64x32  = %001
   54           0003      BGMAP_SIZE_128x32 = %011
   55           0004      BGMAP_SIZE_32x64  = %100
   56           0005      BGMAP_SIZE_64x64  = %101
   57           0007      BGMAP_SIZE_128x64 = %111
   58                     
   59                     ;
   60                     ; These values represent a bit in the VCE which
   61                     ; does color-correction to fix leading/trailing
   62                     ; edges of images
   63                     ;
   64                     ; Default to XRES_SOFT
   65                     ;
   66           0004      XRES_SOFT       = 4
   67           0000      XRES_SHARP      = 0
#[3]   standard.inc
#[4]   startup.inc
   10                             .include        "startup.inc"
    1                     ;
    2                     ; STARTUP.INC  -  MagicKit startup code equates and macros
    3                     ;
    4                     
    5                     ; ----
    6                     ; this block defines names for joypad
    7                     ; direction and button bits
    8                     
    9           0001      JOY_I           = $01
   10           0002      JOY_II          = $02
   11           0004      JOY_SEL         = $04
   12           0008      JOY_RUN         = $08
   13           0010      JOY_UP          = $10
   14           0020      JOY_RIGHT       = $20
   15           0040      JOY_DOWN        = $40
   16           0080      JOY_LEFT        = $80
   17                     
   18           0050      JOY_TYPE6       = $50
   19           0001      JOY_III         = $01
   20           0002      JOY_IV          = $02
   21           0004      JOY_V           = $04
   22           0008      JOY_VI          = $08
   23                     
   24           0000      JOY_BITI        = $0
   25           0001      JOY_BITII       = $1
   26           0002      JOY_BITSEL      = $2
   27           0003      JOY_BITRUN      = $3
   28           0004      JOY_BITUP       = $4
   29           0005      JOY_BITRT       = $5
   30           0006      JOY_BITDN       = $6
   31           0007      JOY_BITLT       = $7
   32                     
   33           0000      JOY_BITIII      = $0
   34           0001      JOY_BITIV       = $1
   35           0002      JOY_BITV        = $2
   36           0003      JOY_BITVI       = $3
   37                     
   38                     ; ----
   39                     ; this block defines names for interrupt
   40                     ; vectors
   41                     ;
   42           0000      IRQ2            = 0
   43           0001      IRQ1            = 1
   44           0002      TIMER           = 2
   45           0003      NMI             = 3
   46           0004      VSYNC           = 4
   47           0005      HSYNC           = 5
   48           0006      SOFT_RESET      = 6
   49                     
   50                     
   51                     ; ----
   52                     ; setvec(num, addr)
   53                     ; ----
   54                     ; num,  vector number (see defines above)
   55                     ; addr, address of the new routine
   56                     ; ----
   57                     
   58                     setvec  .macro
   59                              lda  \1
   60                              ldx  #LOW(\2)
   61                              ldy  #HIGH(\2)
   62                              jsr  set_intvec
   63                             .endm
   64                     
   65                     ; ----
   66                     ; vec_on(num)
   67                     ; ----
   68                     ; num, vector to enable
   69                     ; ----
   70                     
   71                     vec_on  .macro
   72                             .if (\1 = 5)
   73                              smb  #6,<irq_m
   74                             .else
   75                              smb  \1,<irq_m
   76                             .endif
   77                             .endm
   78                     
   79                     ; ----
   80                     ; vec_off(num)
   81                     ; ----
   82                     ; num, vector to disable
   83                     ; ----
   84                     
   85                     vec_off .macro
   86                             .if (\1 = 5)
   87                              rmb  #6,<irq_m
   88                             .else
   89                              rmb  \1,<irq_m
   90                             .endif
   91                             .endm
   92                     
   93                     ; ----
   94                     ; vsync([nb])
   95                     ; ----
   96                     ; nb, number of frames to be sync'ed on
   97                     ; ----
   98                     
   99                     vsync   .macro
  100                             .if (\# = 0)
  101                              lda #1
  102                             .else
  103                              lda \1
  104                             .endif
  105                              jsr  wait_vsync
  106                             .endm
  107                     
  108                     
#[3]   standard.inc
   11                     
#[2]   startup.asm
   17                     
   18                     
   19                     ; ----
   20                     ; setup flexible boundaries for startup code
   21                     ; and user program's "main".
   22                     ;
   23           0000      START_BANK      .equ    0
   24           0000      LIB1_BANK       .equ    START_BANK
   25           0001      LIB2_BANK       .equ    START_BANK+1
   26           0001                     .ifdef HUC
   27           0001      FONT_BANK       .equ    START_BANK+1
   28                     
   29           0001                      .if  (CDROM)
   30           0002      CONST_BANK       .equ   START_BANK+2
   31           0003      DATA_BANK        .equ   START_BANK+3
   32                                     .else
   36                                     .endif
   37                     
   38                                    .else
   42                                    .endif   ; HUC
   43                     
   44                     
   45                     ; ----
   46                     ; if FONT_VADDR is not specified, then specify it
   47                     ; (VRAM address to load font into)
   48                     ;
   49           0000              .ifndef FONT_VADDR
   51                             .endif
   52                     
   53                     ; ----
   54                     ; system variables
   55                     ;
   56           2012                      .zp
   57  --:2012            zp_ptr1:        .ds 2
   58                     
   59                     
   60           2200                      .bss
   61                     
   62           0001              .if  (CDROM)    ; CDROM def's in system.inc
   63                     
#[3]   system.inc
   64                                     .include  "system.inc"
    1                     ;
    2                     ; SYSTEM.INC  -  CD-ROM System standard definitions
    3                     ;
    4                     ;
    5                     
    6                     
    7                     ; --------
    8                     ; This block defines types of supported CD-ROM
    9                     ;
   10                     
   11           0001      STANDARD_CD     = 1
   12           0002      SUPER_CD        = 2
   13                     
   14                     
   15                     ; --------
   16                     ; This block defines standard system variables
   17                     ; in RAM page.
   18                     ;
   19                     
   20           2200      usrvec          = $2200
   21           2200      usr_jmptbl      = $2200
   22           2200      irq2_jmp        = $2200 ;2
   23           2202      irq1_jmp        = $2202 ;2      formerly called irq_jmp
   24           2204      timer_jmp       = $2204 ;2      formerly called timer_jmp
   25           2206      nmi_jmp         = $2206 ;2
   26           2208      vsync_hook      = $2208 ;2      formerly called sync_jmp
   27           220A      hsync_hook      = $220A ;2      formerly called rcr_jmp
   28           220C      bg_x1           = $220C ;2      formerly called bgx1
   29           220E      bg_x2           = $220E ;2
   30           2210      bg_y1           = $2210 ;2
   31           2212      bg_y2           = $2212 ;2
   32           2214      satb_addr       = $2214 ;2      formerly called sat_adr
   33           2216      sprptr          = $2216 ;1
   34           2217      spryl           = $2217 ;1
   35           2218      spryh           = $2218 ;1
   36           2219      sprxl           = $2219 ;1
   37           221A      sprxh           = $221A ;1
   38           221B      sprnl           = $221B ;1
   39           221C      sprnh           = $221C ;1
   40           221D      spral           = $221D ;1
   41           221E      sprah           = $221E ;1
   42           221F      color_cmd       = $221F ;1
   43           2220      bgc_ptr         = $2220 ;2
   44           2222      bgc_len         = $2222 ;1
   45           2223      sprc_ptr        = $2223 ;2
   46           2225      sprc_len        = $2225 ;1
   47           2227      joyena          = $2227 ;1
   48           2228      joy             = $2228 ;5
   49           222D      joytrg          = $222D ;5
   50           2232      joyold          = $2232 ;5
   51           2241      irq_cnt         = $2241 ;1
   52           2242      vdc_mwr         = $2242 ;1      formerly called mwr_m
   53           2243      vdc_dcr         = $2243 ;1      formerly called dcr_m
   54           2249      rndseed         = $2249 ;1
   55           2249      rndl            = $2249 ;1
   56           224A      rndh            = $224A ;1
   57           224B      rndm            = $224B ;1
   58                     
   59                     
   60                     ; --------
   61                     ; This block defines CD-ROM BIOS routine
   62                     ; entry points.
   63                     ;
   64                     
   65           E000      cd_boot         = $E000
   66           E003      cd_reset        = $E003
   67           E006      cd_base         = $E006
   68           E009      cd_read         = $E009
   69           E00C      cd_seek         = $E00C
   70           E00F      cd_exec         = $E00F
   71           E012      cd_play         = $E012
   72           E015      cd_search       = $E015
   73           E018      cd_pause        = $E018
   74           E01B      cd_stat         = $E01B
   75           E01E      cd_subq         = $E01E
   76           E021      cd_dinfo        = $E021
   77           E024      cd_contnts      = $E024
   78           E027      cd_subrd        = $E027
   79           E02A      cd_pcmrd        = $E02A
   80           E02D      cd_fade         = $E02D
   81                     
   82           E030      ad_reset        = $E030
   83           E033      ad_trans        = $E033
   84           E036      ad_read         = $E036
   85           E039      ad_write        = $E039
   86           E03C      ad_play         = $E03C
   87           E03F      ad_cplay        = $E03F
   88           E042      ad_stop         = $E042
   89           E045      ad_stat         = $E045
   90                     
   91           E048      bm_format       = $E048
   92           E04B      bm_free         = $E04B
   93           E04E      bm_read         = $E04E
   94           E051      bm_write        = $E051
   95           E054      bm_delete       = $E054
   96           E057      bm_files        = $E057
   97                     
   98           E05A      ex_getver       = $E05A
   99           E05D      ex_setvec       = $E05D
  100           E060      ex_getfnt       = $E060
  101           E063      ex_joysns       = $E063
  102           E066      ex_joyrep       = $E066
  103           E069      ex_scrsiz       = $E069
  104           E06C      ex_dotmod       = $E06C
  105           E06F      ex_scrmod       = $E06F
  106           E072      ex_imode        = $E072
  107           E075      ex_vmode        = $E075
  108           E078      ex_hmode        = $E078
  109           E07B      ex_vsync        = $E07B
  110           E07E      ex_rcron        = $E07E
  111           E081      ex_rcroff       = $E081
  112           E084      ex_irqon        = $E084
  113           E087      ex_irqoff       = $E087
  114           E08A      ex_bgon         = $E08A
  115           E08D      ex_bgoff        = $E08D
  116           E090      ex_spron        = $E090
  117           E093      ex_sproff       = $E093
  118           E096      ex_dspon        = $E096
  119           E099      ex_dspoff       = $E099
  120           E09C      ex_dmamod       = $E09C
  121           E09F      ex_sprdma       = $E09F
  122           E0A2      ex_satclr       = $E0A2
  123           E0A5      ex_sprput       = $E0A5
  124           E0A8      ex_setrcr       = $E0A8
  125           E0AB      ex_setred       = $E0AB
  126           E0AE      ex_setwrt       = $E0AE
  127           E0B1      ex_setdma       = $E0B1
  128           E0B4      ex_binbcd       = $E0B4
  129           E0B7      ex_bcdbin       = $E0B7
  130           E0BA      ex_rnd          = $E0BA
  131           E0DE      ex_memopen      = $E0DE
  132           E0E4      ex_colorcmd     = $E0E4
  133                     
  134           E0BD      ma_mul8u        = $E0BD
  135           E0C0      ma_mul8s        = $E0C0
  136           E0C3      ma_mul16u       = $E0C3
  137           E0C6      ma_div16s       = $E0C6
  138           E0C9      ma_div16u       = $E0C9
  139           E0CC      ma_sqrt         = $E0CC
  140           E0CF      ma_sin          = $E0CF
  141           E0D2      ma_cos          = $E0D2
  142           E0D5      ma_atni         = $E0D5
  143                     
  144           E0D8      psg_bios        = $E0D8
  145           E0DB      grp_bios        = $E0DB
  146           E0E1      psg_driver      = $E0E1
  147                     
  148                     
  149                     ; --------
  150                     ; This block defines aliases for library routines
  151                     ; that have their equivalent in the CD-ROM BIOS.
  152                     ;
  153                     
  154           0001                      .if (CDROM)
  155           E0BD      mulu8           = ma_mul8u
  156           E0C3      mulu16          = ma_mul16u
  157           E05D      set_intvec      = ex_setvec
  158                                     .endif
  159                     
  160                     ; --------
  161                     ; This block defines PSG BIOS function
  162                     ; number.
  163                     ;
  164                     
  165           0000      PSG_ON          = 0
  166           0001      PSG_OFF         = 1
  167           0002      PSG_INIT        = 2
  168           0003      PSG_BANK        = 3
  169           0004      PSG_TRACK       = 4
  170           0005      PSG_WAVE        = 5
  171           0006      PSG_ENV         = 6
  172           0007      PSG_FM          = 7
  173           0008      PSG_PE          = 8
  174           0009      PSG_PC          = 9
  175           000A      PSG_TEMPO       = 10
  176           000B      PSG_PLAY        = 11
  177           000C      PSG_MSTAT       = 12
  178           000D      PSG_SSTAT       = 13
  179           000E      PSG_MSTOP       = 14
  180           000F      PSG_SSTOP       = 15
  181           0010      PSG_ASTOP       = 16
  182           0011      PSG_MVOFF       = 17
  183           0012      PSG_CONT        = 18
  184           0013      PSG_FDOUT       = 19
  185           0014      PSG_DCNT        = 20
  186                     
  187                     
  188                     ; --------
  189                     ; This block defines GRP BIOS function
  190                     ; number.
  191                     ;
  192                     
  193           0000      VI_GINIT        = 0
  194           0001      VI_CASHCLR      = 1
  195           0002      VI_STRTADR      = 2
  196           0003      VI_GETADRS      = 3
  197           0004      VI_CLS          = 4
  198           0005      VI_PSET         = 5
  199           0006      VI_POINT        = 6
  200           0007      VI_LINE         = 7
  201           0008      VI_BOX          = 8
  202           0009      VI_BOXF         = 9
  203           000A      VI_FLOOD        = 10
  204           000B      VI_PAINT        = 11
  205           000C      VI_GWINDOW      = 12
  206           000D      VI_GFONT        = 13
  207           000E      VI_PUTFONT      = 14
  208           000F      VI_SYMBOL       = 15
  209                     
#[2]   startup.asm
   65                     
   66                             .else           ; ie HuCard
   95                             .endif
   96                     
   97           2244                      .org    $2244
   98  --:2244            scr_mode:       .ds 1   ; screen mode and dimensions - set by <ex_scrmod>
   99  --:2245            scr_w:          .ds 1
  100  --:2246            scr_h:          .ds 1
  101                     
  102           2284                      .org    $2284
  103  --:2284            soft_reset:     .ds 2   ; soft reset jump loc (run+select)
  104                     
  105           0000              .if  !(CDROM)
  107                             .endif
  108                     
  109           2680                      .org    $2680
  110  --:2680            vsync_cnt:      .ds 1   ; counter for 'wait_vsync' routine
  111                     
  112  --:2681            joybuf:         .ds 5   ; 'delta' pad values collector
  113  --:2686            joyhook:        .ds 2   ; 'read_joypad' routine hook
  114  --:2688            joycallback:    .ds 6   ; joypad enhanced callback support
  115  --:268E            disp_cr:        .ds 1   ; display control (1 = on, 0 = off)
  116  --:268F            clock_hh        .ds 1   ; system clock, hours since startup (0-255)
  117  --:2690            clock_mm        .ds 1   ; system clock, minutes since startup (0-59)
  118  --:2691            clock_ss        .ds 1   ; system clock, seconds since startup (0-59)
  119  --:2692            clock_tt        .ds 1   ; system clock, ticks (1/60th sec) since startup (0-59)
  120                     
  121  --:2693            joy6:           .ds 5   ; second byte for 6-button joysticks
  122  --:2698            joytrg6:        .ds 5
  123  --:269D            joyold6:        .ds 5
  124  --:26A2            joybuf6:        .ds 5
  125                     
  126  --:26A7            joytmp:         .ds 5
  127  --:26AC            joytmp6:        .ds 5
  128                     
  129           0001              .if (CDROM)
  130  --:26B1            ovl_running     .ds   1 ; overlay # that is currently running
  131  --:26B2            cd_super        .ds   1 ; Major CDROM version #
  132  --:26B3            irq_storea      .ds   1 ; CDROM IRQ-specific handling stuff
  133  --:26B4            irq_storeb      .ds   1
  134  --:26B5            ram_vsync_hndl  .ds   25
  135  --:26CE            ram_hsync_hndl  .ds   25
  136                             .endif  ; (CDROM)
  137                     
  138                     ;[ STARTUP CODE ]
  139                     
  140                     ; Let's prepare this secondary libray bank first, for use later.
  141                     ; The reason, as you will see, is because code for a given function
  142                     ; which sits together in a file, may have things in zero-page,
  143                     ; bss, LIB1_BANK (ie. START_BANK), and LIB2_BANK.
  144                     ;
  145                     ; The assembler must know beforehand what address etc. to use as a basis.
  146                     ;
  147           E000              .data
  148           0001              .bank LIB2_BANK,"Base Library 2/Font"
  149           6000              .org  $6000
#[3]   font.inc
  150                              .include "font.inc"
    1                     ; 8x8 monochrome font(s)
    2                     
    3  01:6000            font_1:
    4  01:6000  00 00 00          .db $00,$00,$00,$00,$00,$00,$00,$00     ;SPACE
       01:6003  00 00 00  
       01:6006  00 00     
    5  01:6008  CC CC CC          .db $cc,$cc,$cc,$88,$88,$00,$cc,$00     ;!
       01:600B  88 88 00  
       01:600E  CC 00     
    6  01:6010  6C 6C D8          .db $6c,$6c,$d8,$00,$00,$00,$00,$00     ;"
       01:6013  00 00 00  
       01:6016  00 00     
    7  01:6018  6C FE 6C          .db $6c,$fe,$6c,$6c,$6c,$fe,$6c,$00     ;#
       01:601B  6C 6C FE  
       01:601E  6C 00     
    8  01:6020  10 38 40          .db $10,$38,$40,$38,$04,$38,$10,$00     ;$
       01:6023  38 04 38  
       01:6026  10 00     
    9  01:6028  42 A4 48          .db $42,$a4,$48,$10,$24,$4a,$84,$00     ;%
       01:602B  10 24 4A  
       01:602E  84 00     
   10  01:6030  20 50 20          .db $20,$50,$20,$54,$88,$94,$62,$00     ;&
       01:6033  54 88 94  
       01:6036  62 00     
   11  01:6038  18 30 60          .db $18,$30,$60,$00,$00,$00,$00,$00     ;'
       01:603B  00 00 00  
       01:603E  00 00     
   12  01:6040  18 30 60          .db $18,$30,$60,$60,$60,$30,$18,$00     ;(
       01:6043  60 60 30  
       01:6046  18 00     
   13  01:6048  30 18 0C          .db $30,$18,$0c,$0c,$0c,$18,$30,$00     ;)
       01:604B  0C 0C 18  
       01:604E  30 00     
   14  01:6050  54 38 7C          .db $54,$38,$7c,$38,$54,$00,$00,$00     ;*
       01:6053  38 54 00  
       01:6056  00 00     
   15  01:6058  00 10 10          .db $00,$10,$10,$7c,$10,$10,$00,$00     ;+
       01:605B  7C 10 10  
       01:605E  00 00     
   16  01:6060  00 00 00          .db $00,$00,$00,$18,$18,$08,$10,$00     ;,
       01:6063  18 18 08  
       01:6066  10 00     
   17  01:6068  00 00 00          .db $00,$00,$00,$78,$00,$00,$00,$00     ;-
       01:606B  78 00 00  
       01:606E  00 00     
   18  01:6070  00 00 00          .db $00,$00,$00,$00,$60,$60,$00,$00     ;.
       01:6073  00 60 60  
       01:6076  00 00     
   19  01:6078  06 0C 18          .db $06,$0c,$18,$30,$60,$c0,$00,$00     ;/
       01:607B  30 60 C0  
       01:607E  00 00     
   20                     
   21  01:6080  38 4C C6          .db $38,$4c,$c6,$c6,$c6,$64,$38,$00     ;0
       01:6083  C6 C6 64  
       01:6086  38 00     
   22  01:6088  18 78 18          .db $18,$78,$18,$18,$18,$18,$7e,$00     ;1
       01:608B  18 18 18  
       01:608E  7E 00     
   23  01:6090  7C C6 0E          .db $7c,$c6,$0e,$3c,$78,$e0,$fe,$00     ;2
       01:6093  3C 78 E0  
       01:6096  FE 00     
   24  01:6098  FE 0C 18          .db $fe,$0c,$18,$7c,$06,$c6,$7c,$00     ;3
       01:609B  7C 06 C6  
       01:609E  7C 00     
   25  01:60A0  3C 6C CC          .db $3c,$6c,$cc,$cc,$cc,$fe,$0c,$00     ;4
       01:60A3  CC CC FE  
       01:60A6  0C 00     
   26  01:60A8  FE C0 FC          .db $fe,$c0,$fc,$06,$06,$c6,$7c,$00     ;5
       01:60AB  06 06 C6  
       01:60AE  7C 00     
   27  01:60B0  3C 60 C0          .db $3c,$60,$c0,$fc,$c6,$c6,$7c,$00     ;6
       01:60B3  FC C6 C6  
       01:60B6  7C 00     
   28  01:60B8  FE C6 0C          .db $fe,$c6,$0c,$18,$30,$30,$30,$00     ;7
       01:60BB  18 30 30  
       01:60BE  30 00     
   29  01:60C0  7C C6 C6          .db $7c,$c6,$c6,$7c,$c6,$c6,$7c,$00     ;8
       01:60C3  7C C6 C6  
       01:60C6  7C 00     
   30  01:60C8  7C C6 C6          .db $7c,$c6,$c6,$7e,$06,$0c,$78,$00     ;9
       01:60CB  7E 06 0C  
       01:60CE  78 00     
   31  01:60D0  00 18 18          .db $00,$18,$18,$00,$18,$18,$00,$00     ;:
       01:60D3  00 18 18  
       01:60D6  00 00     
   32  01:60D8  00 18 18          .db $00,$18,$18,$00,$18,$18,$30,$00     ;;
       01:60DB  00 18 18  
       01:60DE  30 00     
   33  01:60E0  0C 18 30          .db $0c,$18,$30,$60,$30,$18,$0c,$00     ;<
       01:60E3  60 30 18  
       01:60E6  0C 00     
   34  01:60E8  00 00 7C          .db $00,$00,$7c,$00,$7c,$00,$00,$00     ;=
       01:60EB  00 7C 00  
       01:60EE  00 00     
   35  01:60F0  60 30 18          .db $60,$30,$18,$0c,$18,$30,$60,$00     ;>
       01:60F3  0C 18 30  
       01:60F6  60 00     
   36  01:60F8  7C C6 9E          .db $7c,$c6,$9e,$38,$20,$00,$30,$00     ;?
       01:60FB  38 20 00  
       01:60FE  30 00     
   37                     
   38  01:6100  3C 42 9A          .db $3c,$42,$9a,$aa,$aa,$5c,$00,$00     ;@
       01:6103  AA AA 5C  
       01:6106  00 00     
   39  01:6108  38 6C C6          .db $38,$6c,$c6,$c6,$fe,$c6,$c6,$00     ;A
       01:610B  C6 FE C6  
       01:610E  C6 00     
   40  01:6110  FC C6 C6          .db $fc,$c6,$c6,$fc,$c6,$c6,$fc,$00     ;B
       01:6113  FC C6 C6  
       01:6116  FC 00     
   41  01:6118  3C 66 C0          .db $3c,$66,$c0,$c0,$c0,$66,$3c,$00     ;C
       01:611B  C0 C0 66  
       01:611E  3C 00     
   42  01:6120  F8 CC C6          .db $f8,$cc,$c6,$c6,$c6,$cc,$f8,$00     ;D
       01:6123  C6 C6 CC  
       01:6126  F8 00     
   43  01:6128  FE C0 C0          .db $fe,$c0,$c0,$fc,$c0,$c0,$fe,$00     ;E
       01:612B  FC C0 C0  
       01:612E  FE 00     
   44  01:6130  FE C0 C0          .db $fe,$c0,$c0,$fc,$c0,$c0,$c0,$00     ;F
       01:6133  FC C0 C0  
       01:6136  C0 00     
   45  01:6138  3C 66 C0          .db $3c,$66,$c0,$ce,$c6,$66,$3e,$00     ;G
       01:613B  CE C6 66  
       01:613E  3E 00     
   46  01:6140  C6 C6 C6          .db $c6,$c6,$c6,$fe,$c6,$c6,$c6,$00     ;H
       01:6143  FE C6 C6  
       01:6146  C6 00     
   47  01:6148  7E 18 18          .db $7e,$18,$18,$18,$18,$18,$7e,$00     ;I
       01:614B  18 18 18  
       01:614E  7E 00     
   48  01:6150  06 06 06          .db $06,$06,$06,$06,$06,$c6,$7c,$00     ;J
       01:6153  06 06 C6  
       01:6156  7C 00     
   49  01:6158  C6 CC D8          .db $c6,$cc,$d8,$f0,$d8,$cc,$c6,$00     ;K
       01:615B  F0 D8 CC  
       01:615E  C6 00     
   50  01:6160  C0 C0 C0          .db $c0,$c0,$c0,$c0,$c0,$c0,$fe,$00     ;L
       01:6163  C0 C0 C0  
       01:6166  FE 00     
   51  01:6168  82 C6 EE          .db $82,$c6,$ee,$fe,$d6,$c6,$c6,$00     ;M
       01:616B  FE D6 C6  
       01:616E  C6 00     
   52  01:6170  86 C6 E6          .db $86,$c6,$e6,$f6,$de,$ce,$c6,$00     ;N
       01:6173  F6 DE CE  
       01:6176  C6 00     
   53  01:6178  7C C6 C6          .db $7c,$c6,$c6,$c6,$c6,$c6,$7c,$00     ;O
       01:617B  C6 C6 C6  
       01:617E  7C 00     
   54                     
   55  01:6180  FC C6 C6          .db $fc,$c6,$c6,$c6,$fc,$c0,$c0,$00     ;P
       01:6183  C6 FC C0  
       01:6186  C0 00     
   56  01:6188  7C C6 C6          .db $7c,$c6,$c6,$c6,$de,$cc,$76,$00     ;Q
       01:618B  C6 DE CC  
       01:618E  76 00     
   57  01:6190  FC C6 C6          .db $fc,$c6,$c6,$fc,$d8,$cc,$c6,$00     ;R
       01:6193  FC D8 CC  
       01:6196  C6 00     
   58  01:6198  7C C6 F0          .db $7c,$c6,$f0,$7c,$1e,$c6,$7c,$00     ;S
       01:619B  7C 1E C6  
       01:619E  7C 00     
   59  01:61A0  7E 18 18          .db $7e,$18,$18,$18,$18,$18,$18,$00     ;T
       01:61A3  18 18 18  
       01:61A6  18 00     
   60  01:61A8  C6 C6 C6          .db $c6,$c6,$c6,$c6,$c6,$c6,$7c,$00     ;U
       01:61AB  C6 C6 C6  
       01:61AE  7C 00     
   61  01:61B0  C6 C6 C6          .db $c6,$c6,$c6,$c6,$c6,$6c,$38,$00     ;V
       01:61B3  C6 C6 6C  
       01:61B6  38 00     
   62  01:61B8  C6 C6 C6          .db $c6,$c6,$c6,$d6,$fe,$ee,$c6,$00     ;W
       01:61BB  D6 FE EE  
       01:61BE  C6 00     
   63  01:61C0  C6 EE 7C          .db $c6,$ee,$7c,$38,$7c,$ee,$c6,$00     ;X
       01:61C3  38 7C EE  
       01:61C6  C6 00     
   64  01:61C8  66 66 66          .db $66,$66,$66,$3c,$18,$18,$18,$00     ;Y
       01:61CB  3C 18 18  
       01:61CE  18 00     
   65  01:61D0  FE 0E 1C          .db $fe,$0e,$1c,$38,$70,$e0,$fe,$00     ;Z
       01:61D3  38 70 E0  
       01:61D6  FE 00     
   66  01:61D8  78 60 60          .db $78,$60,$60,$60,$60,$60,$78,$00     ;[
       01:61DB  60 60 60  
       01:61DE  78 00     
   67  01:61E0  C0 60 30          .db $c0,$60,$30,$18,$0c,$06,$00,$00     ;\
       01:61E3  18 0C 06  
       01:61E6  00 00     
   68  01:61E8  3C 0C 0C          .db $3c,$0c,$0c,$0c,$0c,$0c,$3c,$00     ;]
       01:61EB  0C 0C 0C  
       01:61EE  3C 00     
   69  01:61F0  10 28 44          .db $10,$28,$44,$00,$00,$00,$00,$00     ;^
       01:61F3  00 00 00  
       01:61F6  00 00     
   70  01:61F8  00 00 00          .db $00,$00,$00,$00,$00,$00,$fe,$00     ;_
       01:61FB  00 00 00  
       01:61FE  FE 00     
   71                     
   72  01:6200  00 00 00          .db $00,$00,$00,$00,$00,$00,$00,$00     ; 
       01:6203  00 00 00  
       01:6206  00 00     
   73  01:6208  00 00 3C          .db $00,$00,$3c,$06,$7e,$c6,$7e,$00     ;a
       01:620B  06 7E C6  
       01:620E  7E 00     
   74  01:6210  C0 C0 FC          .db $c0,$c0,$fc,$c6,$c6,$c6,$fc,$00     ;b
       01:6213  C6 C6 C6  
       01:6216  FC 00     
   75  01:6218  00 00 7C          .db $00,$00,$7c,$c6,$c0,$c6,$7c,$00     ;c
       01:621B  C6 C0 C6  
       01:621E  7C 00     
   76  01:6220  06 06 7E          .db $06,$06,$7e,$c6,$c6,$c6,$7e,$00     ;d
       01:6223  C6 C6 C6  
       01:6226  7E 00     
   77  01:6228  00 00 7C          .db $00,$00,$7c,$c6,$fc,$c0,$7e,$00     ;e
       01:622B  C6 FC C0  
       01:622E  7E 00     
   78  01:6230  3E 60 60          .db $3e,$60,$60,$f8,$60,$60,$60,$00     ;f
       01:6233  F8 60 60  
       01:6236  60 00     
   79  01:6238  00 00 7C          .db $00,$00,$7c,$c6,$c6,$7e,$06,$7c     ;g
       01:623B  C6 C6 7E  
       01:623E  06 7C     
   80  01:6240  C0 C0 FC          .db $c0,$c0,$fc,$c6,$c6,$c6,$c6,$00     ;h
       01:6243  C6 C6 C6  
       01:6246  C6 00     
   81  01:6248  18 00 18          .db $18,$00,$18,$18,$18,$18,$18,$00     ;i
       01:624B  18 18 18  
       01:624E  18 00     
   82  01:6250  0C 0C 00          .db $0c,$0c,$00,$0c,$0c,$0c,$0c,$78     ;j
       01:6253  0C 0C 0C  
       01:6256  0C 78     
   83  01:6258  C0 C0 D8          .db $c0,$c0,$d8,$f0,$e0,$f0,$d8,$00     ;k
       01:625B  F0 E0 F0  
       01:625E  D8 00     
   84  01:6260  70 30 30          .db $70,$30,$30,$30,$30,$30,$78,$00     ;l
       01:6263  30 30 30  
       01:6266  78 00     
   85  01:6268  00 00 7C          .db $00,$00,$7c,$d6,$d6,$d6,$d6,$00     ;m
       01:626B  D6 D6 D6  
       01:626E  D6 00     
   86  01:6270  00 00 7C          .db $00,$00,$7c,$66,$66,$66,$66,$00     ;n
       01:6273  66 66 66  
       01:6276  66 00     
   87  01:6278  00 00 3C          .db $00,$00,$3c,$66,$66,$66,$3c,$00     ;o
       01:627B  66 66 66  
       01:627E  3C 00     
   88                     
   89  01:6280  00 00 7C          .db $00,$00,$7c,$66,$66,$7c,$60,$60     ;p
       01:6283  66 66 7C  
       01:6286  60 60     
   90  01:6288  00 00 3E          .db $00,$00,$3e,$66,$66,$3e,$06,$06     ;q
       01:628B  66 66 3E  
       01:628E  06 06     
   91  01:6290  00 00 D8          .db $00,$00,$d8,$fc,$e0,$c0,$c0,$00     ;r
       01:6293  FC E0 C0  
       01:6296  C0 00     
   92  01:6298  00 00 3C          .db $00,$00,$3c,$60,$38,$0c,$78,$00     ;s
       01:629B  60 38 0C  
       01:629E  78 00     
   93  01:62A0  30 30 78          .db $30,$30,$78,$30,$30,$30,$1c,$00     ;t
       01:62A3  30 30 30  
       01:62A6  1C 00     
   94  01:62A8  00 00 66          .db $00,$00,$66,$66,$66,$66,$3e,$00     ;u
       01:62AB  66 66 66  
       01:62AE  3E 00     
   95  01:62B0  00 00 C6          .db $00,$00,$c6,$c6,$6c,$38,$10,$00     ;v
       01:62B3  C6 6C 38  
       01:62B6  10 00     
   96  01:62B8  00 00 C6          .db $00,$00,$c6,$d6,$d6,$d6,$6c,$00     ;w
       01:62BB  D6 D6 D6  
       01:62BE  6C 00     
   97  01:62C0  00 00 C6          .db $00,$00,$c6,$6c,$10,$6c,$c6,$00     ;x
       01:62C3  6C 10 6C  
       01:62C6  C6 00     
   98  01:62C8  00 00 66          .db $00,$00,$66,$66,$66,$3e,$06,$3c     ;y
       01:62CB  66 66 3E  
       01:62CE  06 3C     
   99  01:62D0  00 00 FE          .db $00,$00,$fe,$0c,$38,$60,$fe,$00     ;z
       01:62D3  0C 38 60  
       01:62D6  FE 00     
  100  01:62D8  00 00 00          .db $00,$00,$00,$00,$00,$00,$00,$00     ;
       01:62DB  00 00 00  
       01:62DE  00 00     
  101  01:62E0  00 00 00          .db $00,$00,$00,$00,$00,$00,$00,$00     ;
       01:62E3  00 00 00  
       01:62E6  00 00     
  102  01:62E8  00 00 00          .db $00,$00,$00,$00,$00,$00,$00,$00     ;
       01:62EB  00 00 00  
       01:62EE  00 00     
  103  01:62F0  00 00 00          .db $00,$00,$00,$00,$00,$00,$00,$00     ;
       01:62F3  00 00 00  
       01:62F6  00 00     
  104  01:62F8  00 00 00          .db $00,$00,$00,$00,$00,$00,$00,$00     ;
       01:62FB  00 00 00  
       01:62FE  00 00     
  105                     
  106  01:6300            font_2:
  107  01:6300  00 00 00          .db $00,$00,$00,$00,$00,$00,$00,$00     ;SPACE
       01:6303  00 00 00  
       01:6306  00 00     
  108  01:6308  04 0C 0C          .db $04,$0c,$0c,$08,$08,$00,$10,$00     ;!
       01:630B  08 08 00  
       01:630E  10 00     
  109  01:6310  36 12 24          .db $36,$12,$24,$00,$00,$00,$00,$00     ;"
       01:6313  00 00 00  
       01:6316  00 00     
  110  01:6318  12 3F 12          .db $12,$3f,$12,$22,$24,$7e,$24,$00     ;#
       01:631B  22 24 7E  
       01:631E  24 00     
  111  01:6320  00 00 00          .db $00,$00,$00,$00,$00,$00,$00,$00     ;$
       01:6323  00 00 00  
       01:6326  00 00     
  112  01:6328  00 31 32          .db $00,$31,$32,$04,$18,$26,$46,$00     ;%
       01:632B  04 18 26  
       01:632E  46 00     
  113  01:6330  08 14 14          .db $08,$14,$14,$38,$4a,$44,$3a,$00     ;&
       01:6333  38 4A 44  
       01:6336  3A 00     
  114  01:6338  18 08 10          .db $18,$08,$10,$00,$00,$00,$00,$00     ;'
       01:633B  00 00 00  
       01:633E  00 00     
  115  01:6340  0C 10 20          .db $0c,$10,$20,$20,$20,$10,$08,$00     ;(
       01:6343  20 20 10  
       01:6346  08 00     
  116  01:6348  10 08 04          .db $10,$08,$04,$04,$04,$08,$30,$00     ;)
       01:634B  04 04 08  
       01:634E  30 00     
  117  01:6350  00 08 2A          .db $00,$08,$2a,$1c,$1c,$2a,$08,$00     ;*
       01:6353  1C 1C 2A  
       01:6356  08 00     
  118  01:6358  00 08 08          .db $00,$08,$08,$3e,$08,$08,$00,$00     ;+
       01:635B  3E 08 08  
       01:635E  00 00     
  119  01:6360  00 00 00          .db $00,$00,$00,$00,$60,$60,$20,$40     ;,
       01:6363  00 60 60  
       01:6366  20 40     
  120  01:6368  00 00 00          .db $00,$00,$00,$1e,$00,$00,$00,$00     ;-
       01:636B  1E 00 00  
       01:636E  00 00     
  121  01:6370  00 00 00          .db $00,$00,$00,$00,$00,$60,$60,$00     ;.
       01:6373  00 00 60  
       01:6376  60 00     
  122  01:6378  00 02 04          .db $00,$02,$04,$08,$10,$20,$40,$00     ;/
       01:637B  08 10 20  
       01:637E  40 00     
  123                     
  124  01:6380  1C 22 22          .db $1c,$22,$22,$42,$42,$44,$38,$00     ;0
       01:6383  42 42 44  
       01:6386  38 00     
  125  01:6388  0C 1C 04          .db $0c,$1c,$04,$08,$08,$08,$3c,$00     ;1
       01:638B  08 08 08  
       01:638E  3C 00     
  126  01:6390  1C 22 02          .db $1c,$22,$02,$0c,$30,$40,$7c,$00     ;2
       01:6393  0C 30 40  
       01:6396  7C 00     
  127  01:6398  1C 22 02          .db $1c,$22,$02,$0c,$02,$44,$38,$00     ;3
       01:639B  0C 02 44  
       01:639E  38 00     
  128  01:63A0  0E 12 24          .db $0e,$12,$24,$44,$7f,$08,$08,$00     ;4
       01:63A3  44 7F 08  
       01:63A6  08 00     
  129  01:63A8  1F 10 20          .db $1f,$10,$20,$3c,$02,$42,$3c,$00     ;5
       01:63AB  3C 02 42  
       01:63AE  3C 00     
  130  01:63B0  1E 21 20          .db $1e,$21,$20,$7c,$42,$42,$3c,$00     ;6
       01:63B3  7C 42 42  
       01:63B6  3C 00     
  131  01:63B8  3E 22 44          .db $3e,$22,$44,$04,$08,$08,$10,$00     ;7
       01:63BB  04 08 08  
       01:63BE  10 00     
  132  01:63C0  1C 22 22          .db $1c,$22,$22,$3c,$42,$42,$3c,$00     ;8
       01:63C3  3C 42 42  
       01:63C6  3C 00     
  133  01:63C8  1C 22 22          .db $1c,$22,$22,$1e,$02,$44,$38,$00     ;9
       01:63CB  1E 02 44  
       01:63CE  38 00     
  134  01:63D0  00 00 08          .db $00,$00,$08,$00,$00,$00,$10,$00     ;:
       01:63D3  00 00 00  
       01:63D6  10 00     
  135  01:63D8  00 00 08          .db $00,$00,$08,$00,$00,$00,$10,$20     ;;
       01:63DB  00 00 00  
       01:63DE  10 20     
  136  01:63E0  00 04 08          .db $00,$04,$08,$10,$10,$08,$04,$00     ;<
       01:63E3  10 10 08  
       01:63E6  04 00     
  137  01:63E8  00 00 00          .db $00,$00,$00,$1e,$00,$1e,$00,$00     ;=
       01:63EB  1E 00 1E  
       01:63EE  00 00     
  138  01:63F0  00 10 08          .db $00,$10,$08,$04,$04,$08,$10,$00     ;>
       01:63F3  04 04 08  
       01:63F6  10 00     
  139  01:63F8  1C 22 02          .db $1c,$22,$02,$04,$08,$00,$10,$00     ;?
       01:63FB  04 08 00  
       01:63FE  10 00     
  140                     
  141  01:6400  00 00 00          .db $00,$00,$00,$00,$00,$00,$00,$00     ;@
       01:6403  00 00 00  
       01:6406  00 00     
  142  01:6408  0E 12 12          .db $0e,$12,$12,$22,$3e,$42,$42,$00     ;A
       01:640B  22 3E 42  
       01:640E  42 00     
  143  01:6410  1C 12 22          .db $1c,$12,$22,$3c,$22,$42,$7c,$00     ;B
       01:6413  3C 22 42  
       01:6416  7C 00     
  144  01:6418  1C 22 22          .db $1c,$22,$22,$40,$40,$44,$38,$00     ;C
       01:641B  40 40 44  
       01:641E  38 00     
  145  01:6420  18 14 22          .db $18,$14,$22,$22,$42,$44,$f8,$00     ;D
       01:6423  22 42 44  
       01:6426  F8 00     
  146  01:6428  1E 10 20          .db $1e,$10,$20,$3c,$20,$40,$7c,$00     ;E
       01:642B  3C 20 40  
       01:642E  7C 00     
  147  01:6430  1E 10 20          .db $1e,$10,$20,$3c,$20,$40,$40,$00     ;F
       01:6433  3C 20 40  
       01:6436  40 00     
  148  01:6438  1C 22 20          .db $1c,$22,$20,$40,$47,$44,$38,$00     ;G
       01:643B  40 47 44  
       01:643E  38 00     
  149  01:6440  11 11 22          .db $11,$11,$22,$3e,$22,$44,$44,$00     ;H
       01:6443  3E 22 44  
       01:6446  44 00     
  150  01:6448  1E 08 08          .db $1e,$08,$08,$10,$10,$20,$f0,$00     ;I
       01:644B  10 10 20  
       01:644E  F0 00     
  151  01:6450  1E 04 04          .db $1e,$04,$04,$08,$88,$90,$60,$00     ;J
       01:6453  08 88 90  
       01:6456  60 00     
  152  01:6458  10 12 24          .db $10,$12,$24,$38,$28,$44,$44,$00     ;K
       01:645B  38 28 44  
       01:645E  44 00     
  153  01:6460  10 10 20          .db $10,$10,$20,$20,$20,$40,$7c,$00     ;L
       01:6463  20 20 40  
       01:6466  7C 00     
  154  01:6468  21 27 5A          .db $21,$27,$5a,$52,$42,$84,$84,$00     ;M
       01:646B  52 42 84  
       01:646E  84 00     
  155  01:6470  21 21 52          .db $21,$21,$52,$52,$4a,$84,$84,$00     ;N
       01:6473  52 4A 84  
       01:6476  84 00     
  156  01:6478  1C 22 22          .db $1c,$22,$22,$42,$42,$44,$38,$00     ;O
       01:647B  42 42 44  
       01:647E  38 00     
  157                     
  158  01:6480  1C 12 22          .db $1c,$12,$22,$3c,$20,$40,$40,$00     ;P
       01:6483  3C 20 40  
       01:6486  40 00     
  159  01:6488  1C 22 22          .db $1c,$22,$22,$42,$4a,$44,$34,$02     ;Q
       01:648B  42 4A 44  
       01:648E  34 02     
  160  01:6490  1C 12 22          .db $1c,$12,$22,$3c,$28,$48,$46,$00     ;R
       01:6493  3C 28 48  
       01:6496  46 00     
  161  01:6498  1C 22 20          .db $1c,$22,$20,$18,$04,$44,$38,$00     ;S
       01:649B  18 04 44  
       01:649E  38 00     
  162  01:64A0  3E 08 10          .db $3e,$08,$10,$10,$10,$20,$20,$00     ;T
       01:64A3  10 10 20  
       01:64A6  20 00     
  163  01:64A8  22 22 42          .db $22,$22,$42,$44,$44,$44,$38,$00     ;U
       01:64AB  44 44 44  
       01:64AE  38 00     
  164  01:64B0  42 44 44          .db $42,$44,$44,$48,$50,$50,$60,$00     ;V
       01:64B3  48 50 50  
       01:64B6  60 00     
  165  01:64B8  41 41 42          .db $41,$41,$42,$52,$52,$6c,$44,$00     ;W
       01:64BB  52 52 6C  
       01:64BE  44 00     
  166  01:64C0  22 24 18          .db $22,$24,$18,$18,$28,$44,$44,$00     ;X
       01:64C3  18 28 44  
       01:64C6  44 00     
  167  01:64C8  42 42 24          .db $42,$42,$24,$18,$10,$20,$20,$00     ;Y
       01:64CB  18 10 20  
       01:64CE  20 00     
  168  01:64D0  3E 02 04          .db $3e,$02,$04,$18,$20,$40,$7c,$00     ;Z
       01:64D3  18 20 40  
       01:64D6  7C 00     
  169  01:64D8  00 00 00          .db $00,$00,$00,$00,$00,$00,$00,$00     ;[
       01:64DB  00 00 00  
       01:64DE  00 00     
  170  01:64E0  00 00 00          .db $00,$00,$00,$00,$00,$00,$00,$00     ;\
       01:64E3  00 00 00  
       01:64E6  00 00     
  171  01:64E8  00 00 00          .db $00,$00,$00,$00,$00,$00,$00,$00     ;]
       01:64EB  00 00 00  
       01:64EE  00 00     
  172  01:64F0  00 00 00          .db $00,$00,$00,$00,$00,$00,$00,$00     ;^
       01:64F3  00 00 00  
       01:64F6  00 00     
  173  01:64F8  00 00 00          .db $00,$00,$00,$00,$00,$00,$3e,$00     ;_
       01:64FB  00 00 00  
       01:64FE  3E 00     
  174                     
  175  01:6500  00 10 18          .db $00,$10,$18,$18,$00,$00,$00,$00     ; 
       01:6503  18 00 00  
       01:6506  00 00     
  176  01:6508  00 1C 02          .db $00,$1c,$02,$3c,$44,$48,$34,$00     ;a
       01:650B  3C 44 48  
       01:650E  34 00     
  177  01:6510  00 08 08          .db $00,$08,$08,$1c,$12,$22,$3c,$00     ;b
       01:6513  1C 12 22  
       01:6516  3C 00     
  178  01:6518  00 00 1C          .db $00,$00,$1c,$22,$40,$40,$38,$00     ;c
       01:651B  22 40 40  
       01:651E  38 00     
  179  01:6520  00 02 02          .db $00,$02,$02,$3c,$44,$48,$38,$00     ;d
       01:6523  3C 44 48  
       01:6526  38 00     
  180  01:6528  00 00 1C          .db $00,$00,$1c,$22,$7e,$40,$38,$00     ;e
       01:652B  22 7E 40  
       01:652E  38 00     
  181  01:6530  00 06 08          .db $00,$06,$08,$3c,$10,$20,$20,$00     ;f
       01:6533  3C 10 20  
       01:6536  20 00     
  182  01:6538  00 00 3A          .db $00,$00,$3a,$44,$44,$38,$08,$70     ;g
       01:653B  44 44 38  
       01:653E  08 70     
  183  01:6540  00 08 08          .db $00,$08,$08,$1c,$12,$22,$24,$00     ;h
       01:6543  1C 12 22  
       01:6546  24 00     
  184  01:6548  00 04 00          .db $00,$04,$00,$08,$08,$10,$10,$00     ;i
       01:654B  08 08 10  
       01:654E  10 00     
  185  01:6550  00 02 00          .db $00,$02,$00,$04,$44,$48,$38,$00     ;j
       01:6553  04 44 48  
       01:6556  38 00     
  186  01:6558  00 10 12          .db $00,$10,$12,$24,$38,$48,$46,$00     ;k
       01:655B  24 38 48  
       01:655E  46 00     
  187  01:6560  00 0C 04          .db $00,$0c,$04,$08,$08,$10,$10,$00     ;l
       01:6563  08 08 10  
       01:6566  10 00     
  188  01:6568  00 00 2A          .db $00,$00,$2a,$15,$25,$29,$4a,$00     ;m
       01:656B  15 25 29  
       01:656E  4A 00     
  189  01:6570  00 00 2C          .db $00,$00,$2c,$12,$12,$24,$26,$00     ;n
       01:6573  12 12 24  
       01:6576  26 00     
  190  01:6578  00 00 0C          .db $00,$00,$0c,$12,$22,$24,$18,$00     ;o
       01:657B  12 22 24  
       01:657E  18 00     
  191                     
  192  01:6580  00 0E 09          .db $00,$0e,$09,$11,$1e,$20,$20,$00     ;p
       01:6583  11 1E 20  
       01:6586  20 00     
  193  01:6588  00 1E 22          .db $00,$1e,$22,$24,$1c,$08,$08,$00     ;q
       01:658B  24 1C 08  
       01:658E  08 00     
  194  01:6590  00 00 2C          .db $00,$00,$2c,$12,$10,$20,$20,$00     ;r
       01:6593  12 10 20  
       01:6596  20 00     
  195  01:6598  00 00 1C          .db $00,$00,$1c,$22,$18,$44,$38,$00     ;s
       01:659B  22 18 44  
       01:659E  38 00     
  196  01:65A0  00 08 3C          .db $00,$08,$3c,$10,$20,$20,$18,$00     ;t
       01:65A3  10 20 20  
       01:65A6  18 00     
  197  01:65A8  00 00 22          .db $00,$00,$22,$42,$44,$48,$34,$00     ;u
       01:65AB  42 44 48  
       01:65AE  34 00     
  198  01:65B0  00 00 22          .db $00,$00,$22,$24,$28,$28,$10,$00     ;v
       01:65B3  24 28 28  
       01:65B6  10 00     
  199  01:65B8  00 00 21          .db $00,$00,$21,$41,$49,$5a,$2c,$00     ;w
       01:65BB  41 49 5A  
       01:65BE  2C 00     
  200  01:65C0  00 00 11          .db $00,$00,$11,$0a,$0c,$14,$22,$00     ;x
       01:65C3  0A 0C 14  
       01:65C6  22 00     
  201  01:65C8  00 00 11          .db $00,$00,$11,$21,$22,$1e,$04,$38     ;y
       01:65CB  21 22 1E  
       01:65CE  04 38     
  202  01:65D0  00 00 3E          .db $00,$00,$3e,$04,$18,$20,$7c,$00     ;z
       01:65D3  04 18 20  
       01:65D6  7C 00     
  203  01:65D8  00 00 00          .db $00,$00,$00,$00,$00,$00,$00,$00     ;
       01:65DB  00 00 00  
       01:65DE  00 00     
  204  01:65E0  00 00 00          .db $00,$00,$00,$00,$00,$00,$00,$00     ;
       01:65E3  00 00 00  
       01:65E6  00 00     
  205  01:65E8  00 00 00          .db $00,$00,$00,$00,$00,$00,$00,$00     ;
       01:65EB  00 00 00  
       01:65EE  00 00     
  206  01:65F0  00 00 00          .db $00,$00,$00,$00,$00,$00,$00,$00     ;
       01:65F3  00 00 00  
       01:65F6  00 00     
  207  01:65F8  00 00 00          .db $00,$00,$00,$00,$00,$00,$00,$00     ;
       01:65FB  00 00 00  
       01:65FE  00 00     
#[2]   startup.asm
  151           E000              .code
  152           0001              .bank LIB2_BANK
  153           A600              .org  $A600
  154                     
  155                     
  156           6600              .data
  157           0002              .bank CONST_BANK,"Constants"
  158                     
  159           0000              .data
  160           0003              .bank DATA_BANK,"User Program"
  161           6000              .org  $6000
  162                     ;
  163                     ; place overlay array here
  164                     ; 50 entries, each containing
  165                     ; 2 bytes for start sector,
  166                     ; 2 bytes for # sectors
  167                     ;
  168  03:6000            ovlarray:       .ds     200
  169                     
  170                     
  171           A600              .code
  172           0000              .bank START_BANK,"Base Library 1"
  173                     
  174                     ; A little introduction to the boot sequence:
  175                     ;
  176                     ; A HuCard has its origin at bank 0, and is mapped at $E000
  177                     ; It needs to grab the interrupt vectors at $FFF6 and implement
  178                     ; implement handlers for them
  179                     ;
  180                     ; A CDROM will load at bank $80 ($68 for SCD), and the initial
  181                     ; loader will be mapped at $4000.  The current MagicKit sequence
  182                     ; also maps $C000 to this same bank.  However, the initial boot
  183                     ; sequence will execute at $4070, proceeding to load additional
  184                     ; code and data, and then jump to a post-boot section called
  185                     ; 'init_go'.  This is the point at which the loader explicitly
  186                     ; relinquishes the $4000 segment.  It should be noted that there
  187                     ; are library subroutines loaded as part of this initial segment,
  188                     ; and those routines are located in the $C000 range as well.
  189                     ;
  190                     ; Sectors are loaded, up to and including the first "DATA_BANK",
  191                     ; where the overlay array is stored - so that the CDROM error
  192                     ; overlay can be located and executed in the event of a CDROM
  193                     ; system version mismatch (ie. playing SCD games on CDROM)
  194                     ;
  195                     ; A second entry point is defined for overlays that are not
  196                     ; being booted (ie. they are loaded and executed from another
  197                     ; overlay).  This entry point is at $4000, after the segments
  198                     ; have all found their natural loading spots (ie. segment $68
  199                     ; for Super CDROMs).  This entry point maps the necessary
  200                     ; segments and resets the stack, without clearing memory or
  201                     ; performing other setup chores, and then maps and executes
  202                     ; _main() to run the module.  The user has no choice regarding
  203                     ; this function, although he can pass values through the global
  204                     ; variables which main() can use to decide what to do next.
  205                     ;
  206                     ; An additional "Hook" area has now been defined at $4028,
  207                     ; which is used at initial load time, in case a SCD overlay
  208                     ; program is run on plain CDROM hardware, and the author
  209                     ; wishes to override the default text error message by
  210                     ; loading and executing a plain CDROM program instead
  211                     ;
  212                         ; ----
  213                         ; interrupt vectors
  214                     
  215           0000             .if !(CDROM)
  223                            .endif   ; !(CDROM)
  224                     
  225                         ; ----
  226                         ; develo startup code
  227                     
  228           0000             .if (DEVELO)
  238                            .endif   ; (DEVELO)
  239                     
  240                     
  241                     ; ----
  242                     ; reset
  243                     ; ----
  244                     ; things start here
  245                     ; ----
  246                     
  247                         ; ----
  248                         ; CDROM re-map library bank
  249                         ;
  250                     ;
  251                     ; overlay entry point
  252                     ;
  253                     ; assume MMR0, MMR1, MMR6, MMR7 are set.
  254                     ; set others & reset stack pointer
  255                     ;
  256           0001             .if (CDROM)
  257           C000              .org $C000
  258                     
  259                     ; current overlay number that is running
  260                     ; this is overwritten by the isolink prgram; the load
  261                     ; statement must be the first in the block
  262                     ;
  263  00:C000            ovlentry:
  264  00:C000  A9 01             lda  #1
  265  00:C002  8D B1 26          sta  ovl_running
  266                     
  267  00:C005  A9 82             lda  #CONST_BANK+_bank_base
  268  00:C007  53 04             tam  #2
  269  00:C009  A9 83             lda  #DATA_BANK+_bank_base
  270  00:C00B  53 08             tam  #3
  271  00:C00D  A9 86             lda  #_call_bank
  272  00:C00F  53 10             tam  #4
  273                     
  274  00:8011                    stw  #$4000,<__sp
  275  00:C019  A2 FF             ldx  #$ff
  276  00:C01B  9A                txs
  277                     
  278  00:801C                    map  _main
  279  00:C020  20 00 A0          jsr  _main
  280  00:C023  80 FE             bra  *
  281                     
  282                     ;
  283                     ; CDROM error message alternate load entry point
  284                     ;
  285           4028              .org  $4028
  286                     
  287  00:4028  00        cderr_override:         .db     0
  288  00:4029  00        cderr_overlay_num:      .db     0
  289                     
  290  00:402A            cdrom_err_load:
  291                     
  292                             ; since CDROM program will load into same area in RAM,
  293                             ; this load routine must be executed from scratch RAM
  294                             ; re-use the ram interrupt handler areas (not yet initialized)
  295                     
  296  00:402A  73 34 40          tii     .load_cd_ovl, ram_vsync_hndl, 64
       00:402D  B5 26 40  
       00:4030  00        
  297  00:4031  4C B5 26          jmp     ram_vsync_hndl
  298                     
  299  00:4034            .load_cd_ovl:
  300  00:4034  AD 29 40          lda     cderr_overlay_num
  301  00:4037  0A                asl     A
  302  00:4038  0A                asl     A
  303  00:4039  A8                tay
  304  00:403A  A9 83             lda     #DATA_BANK+$80
  305  00:403C  53 08             tam     #3
  306  00:403E  BE 00 60          ldx     ovlarray,Y++
       00:4041  C8        
  307  00:4042  B9 00 60          lda     ovlarray,Y++
       00:4045  C8        
  308  00:4046  64 FC             stz     <_cl            ; sector (offset from base of track)
  309  00:4048  85 FD             sta     <_ch
  310  00:404A  86 FE             stx     <_dl
  311  00:404C  B9 00 60          lda     ovlarray,Y
  312  00:404F  85 F8             sta     <_al            ; # sectors
  313  00:4051  A9 80             lda     #$80
  314  00:4053  85 FA             sta     <_bl            ; bank #
  315  00:4055  A9 03             lda     #3
  316  00:4057  85 FF             sta     <_dh            ; MPR #
  317  00:4059  20 09 E0          jsr     cd_read
  318  00:405C  C9 00             cmp     #0
  319  00:405E  D0 07             bne     .error
  320  00:4060  A9 80             lda     #$80
  321  00:4062  53 04             tam     #2
  322  00:4064  4C 70 40          jmp     _boot
  323                     
  324  00:4067  4C 00 E0  .error: jmp     cd_boot         ; Can't load - reboot CDROM system card
  325                             
  326                     
  327                     ;
  328                     ; Proper Boot-time entry point
  329                     ;
  330           4070              .org  $4070
  331  00:4070            _boot:
  332  00:4070  9C 80 26          stz   $2680             ; clear program RAM
  333  00:4073  73 80 26          tii   $2680,$2681,$197F
       00:4076  81 26 7F  
       00:4079  19        
  334                     
  335                     ;
  336                     ; Note: All CDROM boot loaders will load into MMR $80 region
  337                     ;       regardless of whether they are CD or SCD.
  338                     ;       Here, we will move the information to occupy
  339                     ;       base memory at MMR $68 if appropriate
  340                     ;
  341           0000              .if (CDROM = SUPER_CD)
  355                             .endif  ; (CDROM = SUPER_CD)
  356                     
  357                            .else            ; (ie. if HuCard...)
  373                            .endif   ; (CDROM)
  374                     
  375                         ; ----
  376                         ; initialize the hardware
  377                     
  378  00:407A            _init:
  379           0001             .if (CDROM)
  380  00:407A  20 99 E0          jsr   ex_dspoff
  381  00:407D  20 81 E0          jsr   ex_rcroff
  382  00:4080  20 87 E0          jsr   ex_irqoff
  383  00:4083  20 30 E0          jsr   ad_reset
  384                            .else
  386                            .endif   ; (CDROM)
  387                     
  388  00:4086  20 97 C5          jsr   init_psg          ; init sound
  389  00:4089  20 78 C4          jsr   init_vdc          ; init video
  390  00:408C  A9 1F             lda   #$1F              ; init joypad
  391  00:408E  8D 27 22          sta   joyena
  392                     
  393                         ; ----
  394                         ; initialize interrupt vectors
  395                     
  396           0001             .if  (CDROM)
  397  00:4091  20 96 E0          jsr   ex_dspon
  398  00:4094  20 7E E0          jsr   ex_rcron
  399  00:4097  20 84 E0          jsr   ex_irqon
  400                            .else
  433                            .endif   ; (CDROM)
  434                     
  435                         ; ----
  436                         ; init TIA instruction in RAM (fast BLiTter to hardware)
  437                     
  438  00:409A  A9 E3             lda   #$E3              ; TIA instruction opcode
  439  00:409C  8D 02 27          sta   _ram_hdwr_tia
  440  00:409F  A9 60             lda   #$60              ; RTS instruction opcode
  441  00:40A1  8D 09 27          sta   _ram_hdwr_tia_rts
  442                     
  443                         ; ----
  444                         ; init random number generator
  445                     
  446  00:40A4  A9 01             lda   #1
  447  00:40A6  20 42 DE          jsr   wait_vsync        ; wait for one frame & randomize _rndseed
  448  00:80A9                    stw   #$03E7,<_cx       ; set random seed
  449  00:80B1                    stw   _rndseed,<_dx
  450  00:40BB  20 73 C7          jsr   srand
  451                     
  452           0001             .if (CDROM)
  453           0000              .if (CDROM = SUPER_CD)
  460                             .endif  ; (SUPER_CD)
  461                     
  462                         ; ----
  463                         ; load program
  464                         ; ----
  465                         ; CL/CH/DL = sector address
  466                         ; DH = load mode - bank mode ($6000-$7FFF)
  467                         ; BL = bank index
  468                         ; AL = number of sectors
  469                         ;
  470  00:40BE            loadprog:
  471  00:40BE  AD 01 C0          lda   ovlentry+1        ; current overlay (as written by ISOLINK)
  472  00:40C1  C9 01             cmp   #1                ; is it initial overlay ?
  473  00:80C3                    lbne  _init_go          ; if not initial overlay, somebody else already
  474                                                     ; loaded us completely; do not try to load remainder
  475                                                     ; (ie. executing CDROM error overlay)
  476                     
  477  00:40C8  64 FC             stz   <_cl              ; initial boot doesn't load complete program;
  478  00:40CA  64 FD             stz   <_ch              ; prepare to load remainder
  479  00:40CC  A9 0A             lda   #10               ; 10th sector (0-1 are boot;
  480                                                     ; 2-9 are this library...)
  481  00:40CE  85 FE             sta   <_dl
  482  00:40D0  A9 03             lda   #3                ; load mode (consecutive banks; use MPR 3)
  483  00:40D2  85 FF             sta   <_dh
  484  00:80D4                    stw   #(_bank_base+2),<_bx      ; 2 banks are boot/base library
  485  00:80DC                    stw   #(_nb_bank-2)*4,<_ax
  486  00:40E4  20 09 E0          jsr   cd_read
  487  00:40E7  C9 00             cmp   #$00
  488  00:80E9                    lbeq  _init_go
  489                     
  490                             ; ----
  491  00:40EE  4C 00 E0          jmp   cd_boot           ; reset
  492                     
  493                     
  494                     ; This is the point in the CDROM loader where the code no longer
  495                     ; executes in the $4000 segment, in favour of using the $C000
  496                     ; segment (also used for the library subroutines)
  497                     
  498           C130             .org   $C130
  499                     
  500                     
  501                     ; These routines will be run from RAM @ $2000 so we
  502                     ; need to count bytes to determine how much to xfer
  503                     ; (The total is 24 bytes, but we copy 25)
  504                     
  505           0001              .bank   LIB2_BANK
  506                     
  507  01:A600            vsync_irq_ramhndlr:
  508  01:A600  08                php                     ; 1 byte
  509  01:A601  48                pha                     ; 1
  510  01:A602  43 40             tma   #6                ; 2
  511  01:A604  8D B3 26          sta   irq_storea        ; 3
  512  01:A607  A9 80             lda   #BANK(_vsync_hndl) ;  2
  513  01:A609  53 40             tam   #6                ; 2
  514  01:A60B  68                pla                     ; 1
  515  01:A60C  48                pha                     ; 1
  516  01:A60D  20 EF C1          jsr   _vsync_hndl       ; 3
  517  01:A610  AD B3 26          lda   irq_storea        ; 3
  518  01:A613  53 40             tam   #6                ; 2
  519  01:A615  68                pla                     ; 1
  520  01:A616  28                plp                     ; 1
  521  01:A617  60                rts                     ; 1 = 24 bytes
  522                     
  523  01:A618            hsync_irq_ramhndlr:
  524  01:A618  08                php                     ; 1 byte
  525  01:A619  48                pha                     ; 1
  526  01:A61A  43 40             tma   #6                ; 2
  527  01:A61C  8D B4 26          sta   irq_storeb        ; 3
  528  01:A61F  A9 80             lda   #BANK(_hsync_hndl) ;  2
  529  01:A621  53 40             tam   #6                ; 2
  530  01:A623  68                pla                     ; 1
  531  01:A624  48                pha                     ; 1
  532  01:A625  20 55 C2          jsr   _hsync_hndl       ; 3
  533  01:A628  AD B4 26          lda   irq_storeb        ; 3
  534  01:A62B  53 40             tam   #6                ; 2
  535  01:A62D  68                pla                     ; 1
  536  01:A62E  28                plp                     ; 1
  537  01:A62F  60                rts                     ; 1 = 24 bytes
  538                     
  539           0000              .bank   LIB1_BANK
  540                     
  541  00:C130            _init_go:
  542           0000              .if (CDROM = SUPER_CD)
  544                             .endif
  545                     
  546                            .endif   ; (CDROM)
  547                     
  548                         ; ----
  549                         ; jump to main routine
  550                     
  551                         ; ----
  552                         ; load font
  553                     
  554           0001             .ifdef HUC
  555  00:8130                    stw   #$4000,<__sp      ; init stack ptr first
  556                     
  557  00:8138                    stw   #FONT_VADDR,<_di  ; Load Font @ VRAM addr
  558                     
  559                             ;
  560                             ; this section of font loading was stolen
  561                             ; from _load_default_font because the default
  562                             ; FONT segment number is not yet guaranteed
  563                             ; if the SCD is being run on a plain CDROM system
  564                             ; so we need to trick the segment pointer
  565                             ; with a reliable one
  566                             ;
  567  00:8140                  __ldw   <_di      ; stolen from _load_default_font
  568                                             ; because segment# default not reliable
  569                     
  570  00:C144  20 0A CD          jsr   _set_font_addr            ; set VRAM
  571                     
  572           0001             .if  (CDROM)
  573  00:8147                    stb   #FONT_BANK+$80,<_bl       ; guarantee FONT_BANK even if
  574                                                             ; SCD on regular CDROM system
  575                            .else
  577                            .endif
  578                     
  579  00:814B                    stb   #96,<_cl
  580  00:814F                    stb   _font_color+1,<_ah
  581  00:C154  AD A7 27          lda   _font_color
  582  00:C157  D0 01             bne   .fntld
  583  00:C159  1A                inc   A
  584  00:C15A  85 F8     .fntld: sta   <_al
  585  00:C15C  82                clx
  586  00:C15D  BD 48 C3          lda   font_table,X
  587  00:C160  85 EE             sta   <_si
  588  00:C162  E8                inx
  589  00:C163  BD 48 C3          lda   font_table,X
  590  00:C166  85 EF             sta   <_si+1
  591                     
  592                     
  593                             ; Now, load the font
  594                             ;
  595                             ;   Note for CDROM/Super CDROM:
  596                             ;
  597                             ; The 'REAL' mapping for the lib2_load_font function
  598                             ; maybe doesn't exist yet (we are executing from bank $80,
  599                             ; not from $68 if it's a Super CDROM)
  600                             ;
  601                             ; So we must map the version at bank ($80 + LIB2_BANK)
  602                             ; before executing it.  We remap the bank after completion,
  603                             ; 'just in case'
  604                     
  605           0001             .if  (CDROM)
  606  00:C168  43 20             tma   #page(lib2_load_font)
  607  00:C16A  48                pha
  608  00:C16B  A9 81             lda   #LIB2_BANK+$80
  609  00:C16D  53 20             tam   #page(lib2_load_font)
  610  00:C16F  20 5E A9          jsr   lib2_load_font
  611  00:C172  68                pla
  612  00:C173  53 20             tam   #page(lib2_load_font)
  613                            .else
  615                            .endif
  616                     
  617                             ;
  618                             ; END stolen font-load
  619                             ;
  620                     
  621  00:C175  20 BE CC          jsr   _cls
  622                     
  623  00:C178  9C 02 04          stz  color_reg  ; set color #0 = 0/0/0 rgb
  624  00:C17B  9C 03 04          stz  color_reg+1
  625  00:C17E  9C 04 04          stz  color_data
  626  00:C181  9C 05 04          stz  color_data+1
  627                     
  628  00:C184  A9 01             lda  #1         ; set color #1 = 7/7/7 rgb
  629  00:C186  8D 02 04          sta  color_reg
  630  00:C189  9C 03 04          stz  color_reg+1
  631  00:C18C  A2 FF             ldx  #$ff
  632  00:C18E  8E 04 04          stx  color_data
  633  00:C191  8D 05 04          sta  color_data+1
  634                     
  635                         ; ----
  636                         ; Super CDROM error message
  637                         ; ----
  638                     
  639           0001              .if (CDROM)
  640           0000               .if (CDROM = SUPER_CD)
  685                              .endif         ; (CDROM = SUPER_CD)
  686                     
  687                             .endif          ; (CDROM)
  688                            .endif           ; (HUC)
  689                     
  690                     
  691           0001             .ifdef SUPPORT_MOUSE
  692  00:C194  20 8B DB          jsr  mousinit           ; check existence of mouse
  693                            .endif   ; SUPPORT_MOUSE
  694                     
  695           0001             .if  (CDROM)
  696                     
  697                     ; Now, install the RAM-based version of the
  698                     ; interrupt-handlers and activate them
  699                     
  700  00:C197  43 20             tma   #page(vsync_irq_ramhndlr)
  701  00:C199  48                pha
  702  00:C19A  A9 81             lda   #bank(vsync_irq_ramhndlr)
  703  00:C19C  53 20             tam   #page(vsync_irq_ramhndlr)
  704  00:C19E  73 00 A6          tii   vsync_irq_ramhndlr,ram_vsync_hndl,25
       00:C1A1  B5 26 19  
       00:C1A4  00        
  705  00:C1A5  73 18 A6          tii   hsync_irq_ramhndlr,ram_hsync_hndl,25
       00:C1A8  CE 26 19  
       00:C1AB  00        
  706  00:C1AC  68                pla
  707  00:C1AD  53 20             tam   #page(vsync_irq_ramhndlr)
  708                     
  709  00:81AF                    stw   #ram_vsync_hndl,vsync_hook        ; set VSYNC handler
  710  00:C1B9  C7 F5             smb   #4,<irq_m         ; enable new code
  711  00:C1BB  D7 F5             smb   #5,<irq_m         ; disable system card code
  712                     
  713  00:81BD                    stw   #ram_hsync_hndl,hsync_hook        ; set HSYNC handler
  714  00:C1C7  E7 F5             smb   #6,<irq_m         ; enable new code
  715  00:C1C9  F7 F5             smb   #7,<irq_m         ; disable system card code
  716                     
  717                            .endif   ; (CDROM)
  718                     
  719           0001             .ifdef HUC
  720                         ; ----
  721                         ; Map the final stuff before executing main()
  722                         ; ----
  723                     
  724  00:C1CB  A9 82             lda   #CONST_BANK+_bank_base    ; map string constants bank
  725  00:C1CD  53 04             tam   #2                ; (ie. $4000-$5FFF)
  726  00:C1CF  A9 86             lda   #_call_bank       ; map call bank
  727  00:C1D1  53 10             tam   #4                ; (ie. $8000-$9FFF)
  728                             ; ---
  729           0001              .if   (CDROM)
  730  00:C1D3  A9 01             lda   #1                ; first overlay to run at boot time
  731  00:C1D5  8D B1 26          sta   ovl_running       ; store for later use
  732                             .endif
  733                             ; ---
  734  00:C1D8  9C 8F 26          stz   clock_hh          ; clear clock
  735  00:C1DB  9C 90 26          stz   clock_mm
  736  00:C1DE  9C 91 26          stz   clock_ss
  737  00:C1E1  9C 92 26          stz   clock_tt
  738                     
  739  00:81E4                    map   _main
  740  00:C1E8  20 00 A0          jsr   _main             ; go!
  741  00:C1EB  80 FE             bra   *
  742                            .else
  745                            .endif   ; HUC
  746                     
  747                     
  748                     ; ----
  749                     ; system
  750                     ; ----
  751                     ; give back control to the Develo system
  752                     ; ----
  753                     
  754           0000             .if (DEVELO)
  790                            .endif   ; (DEVELO)
  791                     
  792                     ;[ INTERRUPT CODE ]
  793                     
  794  00:C1ED            _rts:
  795  00:C1ED  60                rts
  796  00:C1EE            _rti:
  797  00:C1EE  40                rti
  798                     
  799                     ; ----
  800                     ; irq2
  801                     ; ----
  802                     ; IRQ2 interrupt handler
  803                     ; ----
  804                     
  805           0000             .if !(CDROM)
  811                            .endif   ; !(CDROM)
  812                     
  813                     ; ----
  814                     ; irq1
  815                     ; ----
  816                     ; VDC interrupt handler
  817                     ; ----
  818                     
  819           0000             .if !(CDROM)
  884                            .endif   ; !(CDROM)
  885                     
  886                     
  887                     ; ----
  888                     ; _vsync_hndl
  889                     ; ----
  890                     ; Handle VSYNC interrupts
  891                     ; ----
  892  00:C1EF            _vsync_hndl:
  893           0000             .if  !(CDROM)
  901                            .endif
  902  00:C1EF  20 A6 C2  .l1:    jsr   rcr_init          ; init display list
  903                     
  904  00:C1F2  03 07     .l2:    st0   #7                ; scrolling
  905  00:81F4                    stw   bg_x1,video_data
  906  00:C200  03 08             st0   #8
  907  00:8202                    stw   bg_y1,video_data
  908                     
  909                             ; --
  910  00:C20E  AD 92 26          lda   clock_tt          ; keep track of time
  911  00:C211  1A                inc   A
  912  00:C212  C9 3C             cmp   #60
  913  00:C214  D0 1C             bne   .lcltt
  914  00:C216  AD 91 26          lda   clock_ss
  915  00:C219  1A                inc   A
  916  00:C21A  C9 3C             cmp   #60
  917  00:C21C  D0 10             bne   .lclss
  918  00:C21E  AD 90 26          lda   clock_mm
  919  00:C221  1A                inc   A
  920  00:C222  C9 3C             cmp   #60
  921  00:C224  D0 04             bne   .lclmm
  922  00:C226  EE 8F 26          inc   clock_hh
  923  00:C229  62                cla
  924  00:C22A  8D 90 26  .lclmm: sta   clock_mm
  925  00:C22D  62                cla
  926  00:C22E  8D 91 26  .lclss: sta   clock_ss
  927  00:C231  62                cla
  928  00:C232  8D 92 26  .lcltt: sta   clock_tt
  929                             ; --
  930                     
  931           0001             .if  (CDROM)
  932  00:C235  20 E4 E0          jsr   ex_colorcmd
  933  00:C238  EE 49 22          inc   rndseed
  934  00:C23B  20 A7 C7          jsr   randomize
  935  00:C23E  A5 E7             lda   <$e7
  936  00:C240  C9 01             cmp   #$01
  937  00:C242  D0 03             bne  .skip_psg
  938  00:C244  20 E1 E0          jsr   psg_driver
  939  00:C247            .skip_psg:
  940                            .endif
  941                     
  942           0001             .ifdef SUPPORT_MOUSE
  943  00:C247  AD BA 29          lda   msflag            ; if mouse supported, and exists
  944  00:C24A  F0 05             beq  .l3                ; then read mouse instead of pad
  945  00:C24C  20 9D DB          jsr   mousread
  946  00:C24F  80 03             bra  .out
  947                            .endif   ; SUPPORT_MOUSE
  948                     
  949  00:C251  20 B5 DE  .l3:    jsr   read_joypad       ; else read joypad
  950  00:C254  60        .out:   rts
  951                     
  952                     
  953                     ; ----
  954                     ; _hsync_hndl
  955                     ; ----
  956                     ; Handle HSYNC interrupts
  957                     ; ----
  958                         ; ----
  959                         ; hsync scrolling handler
  960                         ;
  961  00:C255            _hsync_hndl:
  962  00:C255  AC 32 27          ldy   s_idx
  963  00:C258  10 13             bpl  .r1
  964                             ; --
  965  00:C25A  A5 F3             lda  <vdc_crl
  966  00:C25C  29 3F             and   #$3F
  967  00:C25E  85 F3             sta  <vdc_crl
  968  00:C260  9C 32 27          stz   s_idx
  969  00:C263  AE 6C 27          ldx   s_list
  970  00:C266  BD 5B 27          lda   s_top,X
  971  00:C269  20 0E C3          jsr   rcr5
  972  00:C26C  60                rts
  973                             ; --
  974  00:C26D  BE 6C 27  .r1:    ldx   s_list,Y
  975  00:C270  A5 F3             lda  <vdc_crl
  976  00:C272  29 3F             and   #$3F
  977  00:C274  1D 53 27          ora   s_cr,X
  978  00:C277  85 F3             sta  <vdc_crl
  979                             ; --
  980  00:C279  20 E8 C2          jsr   rcr_set
  981                             ; --
  982  00:C27C  BD 5B 27          lda   s_top,X
  983  00:C27F  C9 FF             cmp   #$FF
  984  00:C281  F0 22             beq  .out
  985                             ; --
  986  00:C283  03 07             st0   #7
  987  00:C285  BD 33 27          lda   s_xl,X
  988  00:C288  BC 3B 27          ldy   s_xh,X
  989  00:C28B  8D 02 00          sta   video_data_l
  990  00:C28E  8C 03 00          sty   video_data_h
  991  00:C291  03 08             st0   #8
  992  00:C293  BD 43 27          lda   s_yl,X
  993  00:C296  BC 4B 27          ldy   s_yh,X
  994  00:8299                    sub   #1
  995  00:C29C  B0 01             bcs  .r2
  996  00:C29E  88                dey
  997  00:C29F  8D 02 00  .r2:    sta   video_data_l
  998  00:C2A2  8C 03 00          sty   video_data_h
  999  00:C2A5  60        .out:   rts
 1000                     
 1001                         ; ----
 1002                         ; init display list
 1003                         ;
 1004  00:C2A6            rcr_init:
 1005  00:82A6                    maplibfunc   build_disp_list
 1006  00:C2B7  B0 01             bcs  .r3
 1007  00:C2B9  60                rts
 1008                             ; --
 1009  00:C2BA  F7 F3     .r3:    smb   #7,<vdc_crl
 1010  00:C2BC  A9 FF             lda   #$FF
 1011  00:C2BE  8D 32 27          sta   s_idx
 1012  00:C2C1  AE 6C 27          ldx   s_list
 1013  00:C2C4  BC 5B 27          ldy   s_top,X
 1014  00:C2C7  C0 FF             cpy   #$FF
 1015  00:C2C9  D0 43             bne   rcr5
 1016                             ; --
 1017  00:C2CB  BC 33 27          ldy   s_xl,X
 1018  00:C2CE  8C 0C 22          sty   bg_x1
 1019  00:C2D1  BC 3B 27          ldy   s_xh,X
 1020  00:C2D4  8C 0D 22          sty   bg_x1+1
 1021  00:C2D7  BC 43 27          ldy   s_yl,X
 1022  00:C2DA  8C 10 22          sty   bg_y1
 1023  00:C2DD  BC 4B 27          ldy   s_yh,X
 1024  00:C2E0  8C 11 22          sty   bg_y1+1
 1025  00:C2E3  9C 32 27          stz   s_idx
 1026  00:C2E6  80 26             bra   rcr5
 1027                     
 1028                         ; ----
 1029                         ; program scanline interrupt
 1030                         ;
 1031  00:C2E8            rcr_set:
 1032  00:C2E8  C8                iny
 1033  00:C2E9  8C 32 27          sty   s_idx
 1034  00:C2EC  B9 6C 27          lda   s_list,Y
 1035  00:C2EF  A8                tay
 1036  00:C2F0  B9 5B 27          lda   s_top,Y
 1037  00:C2F3  CD 10 27          cmp   scr_height
 1038  00:82F6                    bhs   rcr6
 1039  00:C2F8  DD 64 27          cmp   s_bottom,X
 1040  00:82FB                    blo   rcr5
 1041                             ; --
 1042  00:C2FD  BD 64 27          lda   s_bottom,X
 1043  00:C300  3A        rcr4:   dec   A
 1044  00:C301  48                pha
 1045  00:C302  A9 F0             lda   #$F0
 1046  00:C304  9D 64 27          sta   s_bottom,X
 1047  00:C307  9E 53 27          stz   s_cr,X
 1048  00:C30A  CE 32 27          dec   s_idx
 1049  00:C30D  68                pla
 1050                             ; --
 1051  00:C30E  03 06     rcr5:   st0   #6                ; set scanline counter
 1052  00:8310                    add   #64
 1053  00:C313  8D 02 00          sta   video_data_l
 1054  00:C316  62                cla
 1055  00:C317  69 00             adc   #0
 1056  00:C319  8D 03 00          sta   video_data_h
 1057  00:C31C  80 0E             bra   __rcr_on
 1058                             ;--
 1059  00:C31E  BD 64 27  rcr6:   lda   s_bottom,X
 1060  00:C321  CD 10 27          cmp   scr_height
 1061  00:8324                    blo   rcr4
 1062  00:C326  80 14             bra   __rcr_off
 1063                     
 1064                     ; ----
 1065                     ; rcr_on
 1066                     ; ----
 1067                     ; enable scanline interrupt
 1068                     ; ----
 1069                     
 1070  00:C328              rcr_on:
 1071  00:C328             _rcr_on:
 1072  00:C328  A9 05             lda   #5
 1073  00:C32A  85 F7             sta  <vdc_reg
 1074  00:C32C            __rcr_on:
 1075  00:C32C  03 05             st0   #5
 1076  00:C32E  A5 F3             lda  <vdc_crl
 1077  00:C330  09 04             ora   #$04
 1078  00:C332  85 F3             sta  <vdc_crl
 1079  00:C334  8D 02 00          sta   video_data_l
 1080  00:C337  60                rts
 1081                     
 1082                     ; ----
 1083                     ; rcr_off
 1084                     ; ----
 1085                     ; disable scanline interrupt
 1086                     ; ----
 1087                     
 1088  00:C338              rcr_off:
 1089  00:C338             _rcr_off:
 1090  00:C338  A9 05             lda   #5
 1091  00:C33A  85 F7             sta  <vdc_reg
 1092  00:C33C            __rcr_off:
 1093  00:C33C  03 05             st0   #5
 1094  00:C33E  A5 F3             lda  <vdc_crl
 1095  00:C340  29 FB             and   #$FB
 1096  00:C342  85 F3             sta  <vdc_crl
 1097  00:C344  8D 02 00          sta   video_data_l
 1098  00:C347  60                rts
 1099                     
 1100                     
 1101                     
 1102                     ; ----
 1103                     ; timer
 1104                     ; ----
 1105                     ; timer interrupt handler
 1106                     ; ----
 1107                     
 1108           0000             .if  !(CDROM)
 1171                            .endif   ; !(CDROM)
 1172                     
 1173                     ; ----
 1174                     ; nmi
 1175                     ; ----
 1176                     ; NMI interrupt handler
 1177                     ; ----
 1178                     
 1179           0000             .if  !(CDROM)
 1186                            .endif   ; !(CDROM)
 1187                     
 1188                     
 1189                     ;[ DATA ]
 1190                     
 1191                     ; ----
 1192                     ; font
 1193                     ; ----
 1194                     
 1195           0001              .ifdef HUC
 1196  00:C348            font_table:
 1197  00:C348  00 60              .dw font_1
 1198  00:C34A  00 63              .dw font_2
 1199  00:C34C  00 60              .dw font_1
 1200  00:C34E  00 60              .dw font_1
 1201                     
 1202                             .endif  ; HUC
 1203                     
 1204                     
 1205                     ;[ LIBRARY ]
 1206                     
 1207                     ; ----
 1208                     ; standard library
 1209                     ; ----
 1210                     
#[3]   library.asm
 1211                             .include "library.asm"
    1                     ;
    2                     ; LIBRARY.ASM  -  MagicKit Standard Library
    3                     ;
    4                     ;
    5                     
    6                     ; IMPORTANT NOTE:
    7                     ; ----
    8                     ; almost all the library functions have been changed to automaticaly
    9                     ; handle bank mapping (you don't have to map data yourself anymore),
   10                     ; the change will be transparent to you if you were using only library
   11                     ; macros to call functions, but you will have to update your code
   12                     ; in case you were directly calling those functions!
   13                     
   14                     
   15                     ; ----
   16                     ; map_data
   17                     ; ----
   18                     ; map data in page 3-4 ($6000-$9FFF)
   19                     ; ----
   20                     ; IN :  _BL = data bank
   21                     ;       _SI = data address
   22                     ; ----
   23                     ; OUT:  _BX = old banks
   24                     ;       _SI = remapped data address
   25                     ; ----
   26                     
   27  00:C350            map_data:
   28  00:C350  A6 FA             ldx   <_bl
   29                     
   30                         ; ----
   31                         ; save current bank mapping
   32                         ;
   33  00:C352  43 08             tma   #3
   34  00:C354  85 FA             sta   <_bl
   35  00:C356  43 10             tma   #4
   36  00:C358  85 FB             sta   <_bh
   37                             ; --
   38  00:C35A  E0 FE             cpx   #$FE
   39  00:C35C  D0 03             bne   .l1
   40                             ; --
   41  00:C35E  86 EC             stx   <_bp
   42  00:C360  60                rts
   43                     
   44                         ; ----
   45                         ; map new bank
   46                         ;
   47  00:C361  64 EC     .l1:    stz   <_bp
   48                             ; --
   49  00:C363  8A                txa
   50  00:C364  53 08             tam   #3
   51  00:C366  1A                inc   A
   52  00:C367  53 10             tam   #4
   53                     
   54                         ; ----
   55                         ; remap data address to page 3
   56                         ;
   57  00:C369  A5 EF             lda   <_si+1
   58  00:C36B  29 1F             and   #$1F
   59  00:C36D  09 60             ora   #$60
   60  00:C36F  85 EF             sta   <_si+1
   61  00:C371  60                rts
   62                     
   63                     
   64                     ; ----
   65                     ; unmap_data
   66                     ; ----
   67                     ; IN :  _BX = old banks
   68                     ; ----
   69                     
   70  00:C372            unmap_data:
   71                     
   72  00:C372  A5 FA             lda     <_bl
   73  00:C374  53 08             tam     #3
   74  00:C376  A5 FB             lda     <_bh
   75  00:C378  53 10             tam     #4
   76  00:C37A  60                rts
   77                     
   78                     ; ----
   79                     ; remap_data
   80                     ; ----
   81                     
   82  00:C37B            remap_data:
   83  00:C37B  A5 EC             lda   <_bp
   84  00:C37D  D0 10             bne   .l1
   85  00:C37F  A5 EF             lda   <_si+1
   86  00:C381  10 0C             bpl   .l1
   87  00:8383                    sub   #$20
   88  00:C386  85 EF             sta   <_si+1
   89  00:C388  43 10             tma   #4
   90  00:C38A  53 08             tam   #3
   91  00:C38C  1A                inc   A
   92  00:C38D  53 10             tam   #4
   93  00:C38F            .l1:
   94  00:C38F  60                rts
   95                     
   96                     
   97                     ; ----
   98                     ; load_palette
   99                     ; ----
  100                     ; initialize one or more sub-palette
  101                     ; ----
  102                     ; IN :  _AL = index of the first sub-palette (0-31)
  103                     ;       _BL = data bank
  104                     ;       _SI = address of data
  105                     ;       _CL = number of sub-palette to copy
  106                     ; ----
  107                     
  108           0001              .ifdef HUC
  109  00:C390            _load_palette.3:
  110                             .endif
  111  00:C390             load_palette:
  112  00:8390                    maplibfunc      lib2_load_palette
  113  00:C3A1  60                rts
  114                     
  115           0001              .bank   LIB2_BANK
  116  01:A630            lib2_load_palette:
  117                     
  118                         ; ----
  119                         ; map data
  120                         ;
  121  01:A630  20 50 C3          jsr   map_data
  122                     
  123                         ; ----
  124                         ; multiply the sub-palette index by 16
  125                         ; and set the VCE color index register
  126                         ;
  127  01:A633  A5 F8             lda   <_al
  128  01:A635  64 F9             stz   <_ah
  129  01:A637  0A                asl   A
  130  01:A638  0A                asl   A
  131  01:A639  0A                asl   A
  132  01:A63A  0A                asl   A
  133  01:A63B  26 F9             rol   <_ah
  134  01:A63D  8D 02 04          sta   color_reg_l
  135  01:A640  A5 F9             lda   <_ah
  136  01:A642  8D 03 04          sta   color_reg_h
  137                     
  138                         ; ----
  139                         ; load new colors
  140                         ;
  141                     
  142                     ; Use TIA, but BLiT 16 words at a time (32 bytes)
  143                     ; Because interrupt must not be deferred too much
  144                     ;
  145  01:4645                    stw   #32, _ram_hdwr_tia_size
  146  01:464F                    stw   #color_data, _ram_hdwr_tia_dest
  147                     
  148  01:A659            .loop_a:
  149  01:4659                    stw   <_si, _ram_hdwr_tia_src
  150  01:A663  20 02 27          jsr   _ram_hdwr_tia
  151  01:4666                    addw  #32, <_si
  152  01:A673  C6 FC             dec   <_cl
  153  01:A675  D0 E2             bne   .loop_a
  154                     
  155                         ; ----
  156                         ; unmap data
  157                         ;
  158  01:A677  4C 72 C3          jmp   unmap_data
  159                     
  160           0000              .bank   LIB1_BANK
  161                     
  162                     
  163                     ; ----
  164                     ; load_bat
  165                     ; ----
  166                     ; transfer a BAT in VRAM
  167                     ; ----
  168                     ; IN :  _DI = VRAM base address
  169                     ;       _BL = BAT bank
  170                     ;       _SI = BAT memory location
  171                     ;       _CL = nb of column to copy
  172                     ;       _CH = nb of row
  173                     ; ----
  174                     
  175           0001              .ifdef HUC
  176  00:C3A2            _load_bat.4:
  177                             .endif
  178  00:C3A2             load_bat:
  179  00:83A2                    maplibfunc      lib2_load_bat
  180  00:C3B3  60                rts
  181                     
  182           0001              .bank   LIB2_BANK
  183                     
  184  01:A67A            lib2_load_bat:
  185                     
  186                         ; ----
  187                         ; map data
  188                         ;
  189  01:A67A  20 50 C3          jsr   map_data
  190                     
  191                         ; ----
  192                         ; copy BAT
  193                         ;
  194  01:A67D  C2                cly
  195                             ; --
  196  01:A67E  20 36 C4  .l1:    jsr   set_write
  197  01:A681  A6 FC             ldx   <_cl
  198                             ; --
  199  01:A683  B1 EE     .l2:    lda   [_si],Y
  200  01:A685  8D 02 00          sta   video_data_l
  201  01:A688  C8                iny
  202  01:A689  B1 EE             lda   [_si],Y
  203  01:A68B  8D 03 00          sta   video_data_h
  204  01:A68E  C8                iny
  205  01:A68F  D0 02             bne   .l3
  206  01:A691  E6 EF             inc   <_si+1
  207  01:A693  CA        .l3:    dex
  208  01:A694  D0 ED             bne   .l2
  209                             ; --
  210  01:A696  20 7B C3          jsr   remap_data
  211                             ; --
  212  01:4699                    addw  bat_width,<_di
  213  01:A6A8  C6 FD             dec   <_ch
  214  01:A6AA  D0 D2             bne   .l1
  215                     
  216                         ; ----
  217                         ; unmap data
  218                         ;
  219  01:A6AC  4C 72 C3          jmp   unmap_data
  220                     
  221           0000              .bank   LIB1_BANK
  222                     
  223                     ; ----
  224                     ; load_map_8/16
  225                     ; ----
  226                     ; transfer a tiled map in VRAM
  227                     ; ----
  228                     ; IN :  _AL = x screen coordinate (tile unit)
  229                     ;       _AH = y screen coordinate
  230                     ;       _CL = x start coordinate in the map
  231                     ;       _CH = y start coordinate
  232                     ;       _DL = nb of column to copy
  233                     ;       _DH = nb of row
  234                     ; ----
  235                     
  236           26E7                      .bss
  237  --:26E7            mapbank         .ds 1
  238  --:26E8            mapaddr         .ds 2
  239  --:26EA            mapwidth        .ds 2
  240  --:26EC            mapheight       .ds 2
  241  --:26EE            maptiletype     .ds 1
  242  --:26EF            maptilebank     .ds 1
  243  --:26F0            maptileaddr     .ds 2
  244  --:26F2            maptilebase     .ds 2
  245  --:26F4            mapnbtile       .ds 2
  246  --:26F6            mapctablebank   .ds 1
  247  --:26F7            mapctable       .ds 2
  248  --:26F9            mapwrap         .ds 1
  249  --:26FA            mapbat_ptr      .ds 2
  250  --:26FC            mapbat_top_base .ds 2
  251  --:26FE            mapbat_top      .ds 1
  252  --:26FF            mapbat_bottom   .ds 1
  253  --:2700            mapbat_x        .ds 2
  254           C3B4                      .code
  255  00:C3B4            load_map:
  256  00:C3B4  AD EE 26          lda   maptiletype
  257  00:C3B7  C9 08             cmp   #8
  258  00:C3B9  F0 12             beq   .l1
  259                             ; --
  260  00:83BB                    maplibfunc      lib2_load_map_16
  261  00:C3CC  60                rts
  262  00:83CD            .l1:    maplibfunc      lib2_load_map_8
  263  00:C3DE  60                rts
  264                     
  265           0001              .bank   LIB2_BANK
  266                     
  267  01:A6AF            lib2_load_map_16:
  268                     
  269                         ; ----
  270                         ; save bank mapping
  271                         ;
  272  01:A6AF  43 04             tma   #2
  273  01:A6B1  48                pha
  274  01:A6B2  43 08             tma   #3
  275  01:A6B4  48                pha
  276  01:A6B5  43 10             tma   #4
  277  01:A6B7  48                pha
  278                     
  279                         ; ----
  280                         ; init
  281                         ;
  282  01:A6B8  20 43 A8          jsr   load_map_init
  283  01:A6BB  A5 FD             lda   <_ch
  284  01:A6BD  8D 01 27          sta   mapbat_x+1
  285                     
  286                         ; ----
  287                         ; vertical loop
  288                         ;
  289  01:A6C0  A4 F9     .l1:    ldy   <_ah
  290  01:A6C2  A5 FE             lda   <_dl
  291  01:A6C4  85 F8             sta   <_al
  292  01:A6C6  AD 01 27          lda   mapbat_x+1
  293  01:A6C9  8D 00 27          sta   mapbat_x
  294  01:A6CC  80 43             bra   .l5
  295                     
  296                         ; ----
  297                         ; horizontal loop
  298                         ;
  299  01:A6CE  AD 00 27  .l2:    lda   mapbat_x          ; bat wrapping
  300  01:46D1                    add   #2
  301  01:A6D4  2D 0D 27          and   bat_hmask
  302  01:A6D7  8D 00 27          sta   mapbat_x
  303  01:A6DA  D0 0B             bne   .l3
  304                             ; --
  305  01:A6DC  AD 0D 27          lda   bat_hmask
  306  01:A6DF  49 FF             eor   #$ff
  307  01:A6E1  25 F0             and   <_di
  308  01:A6E3  85 F0             sta   <_di
  309  01:A6E5  80 0C             bra   .l4
  310  01:A6E7            .l3:
  311  01:46E7                    incw  <_di
  312  01:46ED                    incw  <_di
  313  01:A6F3            .l4:
  314  01:A6F3  C8                iny
  315                             ; --
  316  01:A6F4  CC EA 26          cpy   mapwidth          ; horizontal map wrapping
  317  01:A6F7  D0 18             bne   .l5
  318  01:A6F9  C2                cly
  319  01:A6FA  AE F9 26          ldx   mapwrap
  320  01:A6FD  D0 12             bne   .l5
  321  01:A6FF  AC EA 26          ldy   mapwidth
  322  01:A702  AD F2 26          lda   maptilebase
  323  01:A705  85 FC             sta   <_cl
  324  01:A707  AD F3 26          lda   maptilebase+1
  325  01:A70A  12 EC             ora   [_bp]
  326  01:A70C  85 FD             sta   <_ch
  327  01:A70E  88                dey
  328  01:A70F  80 1C             bra   .l6
  329  01:A711            .l5:
  330  01:A711  B1 EE             lda   [_si],Y           ; get tile index
  331  01:A713  AA                tax                     ; calculate BAT value (tile + palette)
  332  01:A714  02                sxy
  333  01:A715  64 FD             stz   <_ch
  334  01:A717  0A                asl   A
  335  01:A718  26 FD             rol   <_ch
  336  01:A71A  0A                asl   A
  337  01:A71B  26 FD             rol   <_ch
  338  01:471D                    add   maptilebase
  339  01:A721  85 FC             sta   <_cl
  340  01:A723  A5 FD             lda   <_ch
  341  01:A725  6D F3 26          adc   maptilebase+1
  342  01:A728  71 EC             adc   [_bp],Y
  343  01:A72A  85 FD             sta   <_ch
  344  01:A72C  02                sxy
  345  01:A72D            .l6:
  346  01:472D                    vreg  #0                ; copy tile
  347  01:4733                    stw   <_di,video_data
  348  01:473D                    vreg  #2
  349  01:4743                    stw   <_cx,video_data
  350  01:474D                    incw  <_cx
  351  01:4753                    stw   <_cx,video_data
  352  01:475D                    incw  <_cx
  353  01:4763                    vreg  #0
  354  01:4769                    addw  bat_width,<_di,video_data
  355  01:477A                    vreg  #2
  356  01:4780                    stw   <_cx,video_data
  357  01:478A                    incw  <_cx
  358  01:4790                    stw   <_cx,video_data
  359                     
  360  01:A79A  C6 F8             dec   <_al              ; next tile
  361  01:479C                    lbne  .l2
  362                     
  363                         ; ----
  364                         ; next line
  365                         ;
  366  01:A7A1  A2 02             ldx   #2
  367  01:A7A3  20 D0 A8          jsr   load_map_next_line
  368  01:A7A6  C6 FF             dec   <_dh
  369  01:47A8                    lbne  .l1
  370                     
  371                         ; ----
  372                         ; restore bank mapping
  373                         ;
  374  01:A7AD  4C 39 A8          jmp   load_map_exit
  375                     
  376  01:A7B0            lib2_load_map_8:
  377                     
  378                         ; ----
  379                         ; save bank mapping
  380                         ;
  381  01:A7B0  43 04             tma   #2
  382  01:A7B2  48                pha
  383  01:A7B3  43 08             tma   #3
  384  01:A7B5  48                pha
  385  01:A7B6  43 10             tma   #4
  386  01:A7B8  48                pha
  387                     
  388                         ; ----
  389                         ; init
  390                         ;
  391  01:A7B9  20 43 A8          jsr   load_map_init
  392  01:A7BC  80 05             bra   .l2
  393                     
  394                         ; ----
  395                         ; vertical loop
  396                         ;
  397  01:A7BE  A2 01     .l1:    ldx   #1
  398  01:A7C0  20 D0 A8          jsr   load_map_next_line
  399                             ; --
  400  01:A7C3  A4 F9     .l2:    ldy   <_ah
  401  01:A7C5  A5 FE             lda   <_dl
  402  01:A7C7  85 F8             sta   <_al
  403  01:A7C9  A5 FD             lda   <_ch
  404  01:A7CB  85 FC             sta   <_cl
  405  01:47CD                    vreg  #0                ; set vram write ptr
  406  01:47D3                    stw   <_di,video_data
  407  01:47DD                    vreg  #2
  408  01:A7E3  80 38             bra   .l5
  409                     
  410                         ; ----
  411                         ; horizontal loop
  412                         ;
  413  01:A7E5  A5 FC     .l3:    lda   <_cl              ; bat wrapping
  414  01:A7E7  1A                inc   A
  415  01:A7E8  2D 0D 27          and   bat_hmask
  416  01:A7EB  85 FC             sta   <_cl
  417  01:A7ED  D0 1B             bne   .l4
  418                             ; --
  419  01:47EF                    vreg  #0
  420  01:A7F5  AD 0D 27          lda   bat_hmask
  421  01:A7F8  49 FF             eor   #$ff
  422  01:A7FA  25 F0             and   <_di
  423  01:A7FC  8D 02 00          sta   video_data_l
  424  01:A7FF  A5 F1             lda   <_di+1
  425  01:A801  8D 03 00          sta   video_data_h
  426  01:4804                    vreg  #2
  427  01:A80A            .l4:
  428  01:A80A  C8                iny                     ; next tile
  429                             ; --
  430  01:A80B  CC EA 26          cpy   mapwidth          ; map wrapping
  431  01:A80E  D0 0D             bne   .l5
  432                             ; --
  433  01:A810  C2                cly
  434  01:A811  AD F9 26          lda   mapwrap
  435  01:A814  D0 07             bne   .l5
  436  01:A816  AC EA 26          ldy   mapwidth
  437  01:A819  88                dey
  438  01:A81A  62                cla
  439  01:A81B  80 02             bra   .l6
  440  01:A81D            .l5:
  441  01:A81D  B1 EE             lda   [_si],Y           ; get tile index
  442  01:A81F  AA        .l6:    tax                     ; calculate BAT value (tile + palette)
  443  01:A820  02                sxy
  444  01:4821                    add   maptilebase
  445  01:A825  8D 02 00          sta   video_data_l
  446  01:A828  AD F3 26          lda   maptilebase+1
  447  01:A82B  71 EC             adc   [_bp],Y
  448  01:A82D  8D 03 00          sta   video_data_h
  449  01:A830  02                sxy
  450                     
  451  01:A831  C6 F8             dec   <_al
  452  01:A833  D0 B0             bne   .l3
  453                     
  454                         ; ----
  455                         ; next line
  456                         ;
  457  01:A835  C6 FF             dec   <_dh
  458  01:A837  D0 85             bne   .l1
  459                     
  460                         ; ----
  461                         ; restore bank mapping
  462                         ;
  463  01:A839            load_map_exit:
  464  01:A839  68                pla
  465  01:A83A  53 10             tam   #4
  466  01:A83C  68                pla
  467  01:A83D  53 08             tam   #3
  468  01:A83F  68                pla
  469  01:A840  53 04             tam   #2
  470  01:A842  60                rts
  471                     
  472                     
  473                     ; ----
  474                     ; load_map_init
  475                     ; ----
  476                     ; load_map sub routine
  477                     ; ----
  478                     ; OUT:  _DI = BAT address
  479                     ;       _SI = map address
  480                     ;       _BP = palette index table ptr
  481                     ;       _AH = map X pos
  482                     ;       _BH = map Y pos
  483                     ;       _CH = BAT X pos
  484                     ;       _BL = BAT Y pos
  485                     ; ----
  486                     
  487  01:A843            load_map_init:
  488                     
  489                         ; ----
  490                         ; calculate vram address
  491                         ;
  492  01:A843  A6 F8             ldx   <_al
  493  01:A845  A5 F9             lda   <_ah
  494  01:A847  AC EE 26          ldy   maptiletype
  495  01:A84A  C0 08             cpy   #8
  496  01:A84C  F0 04             beq   .l1
  497  01:A84E  0A                asl   A
  498  01:A84F  22                sax
  499  01:A850  0A                asl   A
  500  01:A851  22                sax
  501  01:A852  DA        .l1:    phx
  502  01:A853  48                pha
  503  01:A854  20 53 C4          jsr   calc_vram_addr
  504  01:4857                    stw   <_di,mapbat_ptr
  505                     
  506                         ; ----
  507                         ; calculate map address
  508                         ;
  509  01:4861                    stb   mapaddr,<_si
  510  01:A866  AD E9 26          lda   mapaddr+1
  511  01:A869  29 1F             and   #$1F
  512  01:A86B  85 EF             sta   <_si+1
  513                             ; --
  514  01:A86D  A6 FC             ldx   <_cl
  515  01:A86F  86 F9             stx   <_ah
  516  01:A871  A4 FD             ldy   <_ch
  517  01:A873  84 FB             sty   <_bh
  518                             ; --
  519  01:A875  AD EB 26          lda   mapwidth+1
  520  01:A878  F0 08             beq   .l2
  521  01:A87A  98                tya
  522  01:487B                    add   <_si+1
  523  01:A87E  85 EF             sta   <_si+1
  524  01:A880  80 17             bra   .l3
  525                             ; --
  526  01:A882  84 F8     .l2:    sty   <_al
  527  01:A884  AD EA 26          lda   mapwidth
  528  01:A887  85 FA             sta   <_bl
  529  01:A889  20 BD E0          jsr   mulu8
  530  01:488C                    addw  <_cx,<_si
  531                     
  532                         ; ----
  533                         ; calculate map bank
  534                         ;
  535  01:A899  2A        .l3:    rol   A
  536  01:A89A  2A                rol   A
  537  01:A89B  2A                rol   A
  538  01:A89C  2A                rol   A
  539  01:A89D  29 0F             and   #$0F
  540  01:489F                    add   mapbank
  541                     
  542                         ; ----
  543                         ; map data
  544                         ;
  545  01:A8A3  53 08             tam   #3
  546  01:A8A5  1A                inc   A
  547  01:A8A6  53 10             tam   #4
  548  01:A8A8  AD F6 26          lda   mapctablebank
  549  01:A8AB  53 04             tam   #2
  550                     
  551                         ; ----
  552                         ; adjust data addresses
  553                         ;
  554  01:A8AD  A5 EF             lda   <_si+1            ; tile ptr
  555  01:A8AF  29 1F             and   #$1F
  556  01:A8B1  09 60             ora   #$60
  557  01:A8B3  85 EF             sta   <_si+1
  558                             ; --
  559  01:48B5                    stb   mapctable,<_bp    ; color table ptr
  560  01:A8BA  AD F8 26          lda   mapctable+1
  561  01:A8BD  29 1F             and   #$1F
  562  01:A8BF  09 40             ora   #$40
  563  01:A8C1  85 ED             sta   <_bp+1
  564                     
  565                         ; ----
  566                         ; bat pos
  567                         ;
  568  01:A8C3  68                pla
  569  01:A8C4  2D 0E 27          and   bat_vmask
  570  01:A8C7  85 FA             sta   <_bl
  571  01:A8C9  68                pla
  572  01:A8CA  2D 0D 27          and   bat_hmask
  573  01:A8CD  85 FD             sta   <_ch
  574  01:A8CF  60                rts
  575                     
  576                     
  577                     ; ----
  578                     ; load_map_next_line
  579                     ; ----
  580                     ; load_map sub routine
  581                     ; ----
  582                     ; IN :    X = BAT line inc value (1-2)
  583                     ; ----
  584                     ; OUT:  _DI = BAT address
  585                     ;       _SI = map address
  586                     ; ----
  587                     ; USE:  _BL = BAT Y pos
  588                     ;       _BH = map Y pos
  589                     ;       _SI = map address
  590                     ; ----
  591                     
  592  01:A8D0            load_map_next_line:
  593                     
  594                         ; ----
  595                         ; incremente vram address
  596                         ;
  597  01:A8D0  8A                txa
  598  01:48D1                    add   <_bl
  599  01:A8D4  CD FF 26          cmp   mapbat_bottom
  600  01:48D7                    blo   .l1
  601                             ; --
  602  01:48D9                    sub   mapbat_bottom     ; 1/ vram wrapping
  603  01:A8DD  AA                tax
  604  01:A8DE  E8                inx
  605  01:48DF                    add   mapbat_top
  606  01:A8E3  85 FA             sta   <_bl
  607  01:A8E5  AD FA 26          lda   mapbat_ptr
  608  01:A8E8  2D 0D 27          and   bat_hmask
  609  01:48EB                    add   mapbat_top_base
  610  01:A8EF  8D FA 26          sta   mapbat_ptr
  611  01:A8F2  62                cla
  612  01:A8F3  6D FD 26          adc   mapbat_top_base+1
  613  01:A8F6  8D FB 26          sta   mapbat_ptr+1
  614  01:A8F9  80 13             bra   .l3
  615                             ; -- 
  616  01:A8FB  85 FA     .l1:    sta   <_bl              ; 2/ vram inc
  617  01:A8FD  AD 0A 27  .l2:    lda   bat_width
  618  01:4900                    add   mapbat_ptr
  619  01:A904  8D FA 26          sta   mapbat_ptr
  620  01:A907  62                cla
  621  01:A908  6D FB 26          adc   mapbat_ptr+1
  622  01:A90B  8D FB 26          sta   mapbat_ptr+1
  623                             ; --
  624  01:A90E  CA        .l3:    dex
  625  01:A90F  D0 EC             bne   .l2
  626                             ; --
  627  01:4911                    stw   mapbat_ptr,<_di
  628                     
  629                         ; ----
  630                         ; incremente map address
  631                         ;
  632  01:A91B  E6 FB             inc   <_bh
  633  01:A91D  A5 FB             lda   <_bh
  634  01:A91F  CD EC 26          cmp   mapheight
  635  01:A922  D0 1A             bne   .l4
  636                             ; --
  637  01:A924  AD E7 26          lda   mapbank           ; 1/ map wrapping
  638  01:A927  53 08             tam   #3
  639  01:A929  1A                inc   A
  640  01:A92A  53 10             tam   #4
  641  01:492C                    stb   mapaddr,<_si
  642  01:A931  AD E9 26          lda   mapaddr+1
  643  01:A934  29 1F             and   #$1F
  644  01:A936  09 60             ora   #$60
  645  01:A938  85 EF             sta   <_si+1
  646  01:A93A  64 FB             stz   <_bh
  647  01:A93C  80 1F             bra   .l5
  648                             ; --
  649  01:493E            .l4:    addw  mapwidth,<_si     ; 2/ map inc
  650  01:A94D  C9 80             cmp   #$80
  651  01:494F                    blo   .l5
  652  01:4951                    sub   #$20
  653  01:A954  85 EF             sta   <_si+1
  654  01:A956  43 10             tma   #4
  655  01:A958  53 08             tam   #3
  656  01:A95A  1A                inc   A
  657  01:A95B  53 10             tam   #4
  658  01:A95D            .l5:
  659  01:A95D  60                rts
  660                     
  661                     
  662           0000              .bank   LIB1_BANK
  663                     
  664                     ; ----
  665                     ; load_font
  666                     ; ----
  667                     ; transfer a 8x8 monochrome font into VRAM, slow but can be useful
  668                     ; ----
  669                     ; IN :  _DI = VRAM base address
  670                     ;       _BL = font bank
  671                     ;       _SI = font memory location
  672                     ;       _AL = font color (0-15)
  673                     ;       _AH = bg color (0-15)
  674                     ;       _CL = number of characters to copy
  675                     ; ----
  676                     
  677  00:C3DF            load_font:
  678  00:83DF                    maplibfunc      lib2_load_font
  679  00:C3F0  60                rts
  680                     
  681           0001              .bank   LIB2_BANK
  682                     
  683                         ; ----
  684                         ; map data
  685                         ;
  686  01:A95E            lib2_load_font:
  687  01:A95E  20 50 C3          jsr   map_data
  688  01:A961  20 36 C4          jsr   set_write
  689                     
  690                         ; ----
  691                         ; init bg color
  692                         ;
  693  01:A964  A5 FC             lda   <_cl
  694  01:A966  48                pha
  695                             ; --
  696  01:A967  A2 03             ldx   #3
  697  01:A969  62        .l1:    cla
  698  01:A96A  46 F9             lsr   <_ah
  699  01:A96C  90 02             bcc   .l2
  700  01:A96E  A9 FF             lda   #$FF
  701  01:A970  95 FC     .l2:    sta   <_cl,X
  702  01:A972  CA                dex
  703  01:A973  10 F4             bpl   .l1
  704                     
  705                         ; ----
  706                         ; character loop
  707                         ;
  708  01:A975  FA                plx
  709  01:A976            .copy:
  710                     
  711                         ; ----
  712                         ; plane 1
  713                         ;
  714  01:A976  C2                cly
  715  01:A977  8F F8 08  .p1:    bbs0  <_al,.p2
  716  01:A97A  B1 EE             lda   [_si],Y
  717  01:A97C  49 FF             eor   #$FF
  718  01:A97E  25 FF             and   <_dh
  719  01:A980  80 04             bra   .p3
  720                             ; --
  721  01:A982  A5 FF     .p2:    lda   <_dh
  722  01:A984  11 EE             ora   [_si],Y
  723  01:A986  8D 02 00  .p3:    sta   video_data_l
  724                     
  725                         ; ----
  726                         ; plane 2
  727                         ;
  728  01:A989  9F F8 08          bbs1  <_al,.p4
  729  01:A98C  B1 EE             lda   [_si],Y
  730  01:A98E  49 FF             eor   #$FF
  731  01:A990  25 FE             and   <_dl
  732  01:A992  80 04             bra   .p5
  733                             ; --
  734  01:A994  A5 FE     .p4:    lda   <_dl
  735  01:A996  11 EE             ora   [_si],Y
  736  01:A998  8D 03 00  .p5:    sta   video_data_h
  737                             ; --
  738  01:A99B  C8                iny
  739  01:A99C  C0 08             cpy   #8
  740  01:A99E  D0 D7             bne   .p1
  741                     
  742                         ; ----
  743                         ; plane 3
  744                         ;
  745  01:A9A0  C2                cly
  746  01:A9A1  AF F8 08  .t1:    bbs2  <_al,.t2
  747  01:A9A4  B1 EE             lda   [_si],Y
  748  01:A9A6  49 FF             eor   #$FF
  749  01:A9A8  25 FD             and   <_ch
  750  01:A9AA  80 04             bra   .t3
  751                             ; --
  752  01:A9AC  A5 FD     .t2:    lda   <_ch
  753  01:A9AE  11 EE             ora   [_si],Y
  754  01:A9B0  8D 02 00  .t3:    sta   video_data_l
  755                     
  756                         ; ----
  757                         ; plane 4
  758                         ;
  759  01:A9B3  BF F8 08          bbs3  <_al,.t4
  760  01:A9B6  B1 EE             lda   [_si],Y
  761  01:A9B8  49 FF             eor   #$FF
  762  01:A9BA  25 FC             and   <_cl
  763  01:A9BC  80 04             bra   .t5
  764                             ; --
  765  01:A9BE  A5 FC     .t4:    lda   <_cl
  766  01:A9C0  11 EE             ora   [_si],Y
  767  01:A9C2  8D 03 00  .t5:    sta   video_data_h
  768                             ; --
  769  01:A9C5  C8                iny
  770  01:A9C6  C0 08             cpy   #8
  771  01:A9C8  D0 D7             bne   .t1
  772                     
  773                         ; ----
  774                         ; next character
  775                         ;
  776  01:49CA                    addw  #8,<_si
  777                             ; --
  778  01:A9D7  CA                dex
  779  01:A9D8  D0 9C             bne   .copy
  780                     
  781                         ; ----
  782                         ; unmap data
  783                         ;
  784  01:A9DA  4C 72 C3          jmp   unmap_data
  785                     
  786                         ; ----
  787                         ; restore bank mapping
  788                         ;
  789           0000              .bank   LIB1_BANK
  790                     
  791                     
  792                     ; ----
  793                     ; load_vram
  794                     ; ----
  795                     ; copy a block of memory to VRAM
  796                     ; ----
  797                     ; IN :  _DI = VRAM location
  798                     ;       _BL = data bank
  799                     ;       _SI = data memory location
  800                     ;       _CX = number of words to copy
  801                     ; ----
  802           2702              .bss
  803                     
  804                     ; This actually places a 'TIA' command
  805                     ; into RAM, from which to execute
  806                     ; for BLiT to VRAM for SATB transfer
  807                     ; and other VRAM load functions
  808                     
  809  --:2702            _ram_hdwr_tia           .ds     1
  810  --:2703            _ram_hdwr_tia_src       .ds     2
  811  --:2705            _ram_hdwr_tia_dest      .ds     2
  812  --:2707            _ram_hdwr_tia_size      .ds     2
  813  --:2709            _ram_hdwr_tia_rts       .ds     1
  814                     
  815           C3F1              .code
  816                     
  817           0001              .ifdef HUC
  818  00:C3F1            _load_vram.3:
  819                             .endif
  820  00:C3F1             load_vram:
  821                     
  822                         ; ----
  823                         ; map data
  824                         ;
  825  00:C3F1  20 50 C3          jsr   map_data
  826                     
  827                     ;    ; ----
  828                     ;    ; setup call to TIA operation (fastest transfer)
  829                     ;    ;
  830                     ;    ; (instruction setup done during bootup...)
  831                     ;
  832                     ;       stw   #video_data, _ram_hdwr_tia_dest
  833                     ;       stw   <_si, _ram_hdwr_tia_src
  834                     ;
  835                     ;        asl   <_cl             ; change from words to bytes (# to xfer)
  836                     ;       rol   <_ch
  837                     
  838                         ; ----
  839                         ; set vram address
  840                         ;
  841  00:C3F4  20 36 C4          jsr   set_write
  842                     
  843                         ; ----
  844                         ; copy data
  845                         ;
  846  00:C3F7  C2                cly
  847  00:C3F8  A6 FC             ldx   <_cl
  848  00:C3FA  F0 16             beq   .l3
  849                             ; --
  850  00:C3FC  B1 EE     .l1:    lda   [_si],Y
  851  00:C3FE  8D 02 00          sta   video_data_l
  852  00:C401  C8                iny
  853  00:C402  B1 EE             lda   [_si],Y
  854  00:C404  8D 03 00          sta   video_data_h
  855  00:C407  C8                iny
  856  00:C408  D0 02             bne   .l2
  857  00:C40A  E6 EF             inc   <_si+1
  858                             ; --
  859  00:C40C  CA        .l2:    dex
  860  00:C40D  D0 ED             bne   .l1
  861                             ; --
  862  00:C40F  20 7B C3          jsr   remap_data
  863                             ; --
  864  00:C412  C6 FD     .l3:    dec   <_ch
  865  00:C414  10 E6             bpl   .l1
  866                     
  867                     ;.l1:   lda   <_ch              ; if zero-transfer, exit
  868                     ;       ora   <_cl
  869                     ;       beq   .out
  870                     ;
  871                     ;       lda   <_ch
  872                     ;       cmp   #$20              ; if more than $2000, repeat xfers of $2000
  873                     ;        blo   .l2              ; while adjusting banks
  874                     ;       sub   #$20              ; reduce remaining transfer amount
  875                     ;       sta   <_ch
  876                     ;
  877                     ;       stw   #$2000, _ram_hdwr_tia_size
  878                     ;       jsr   _ram_hdwr_tia
  879                     ;
  880                     ;       lda   <_si+1            ; force bank adjust
  881                     ;       add   #$20              ; and next move starts at same location
  882                     ;       sta   <_si+1
  883                     ;
  884                     ;       jsr   remap_data        ; adjust banks
  885                     ;       bra   .l1
  886                     ;
  887                     ;.l2:   sta   HIGH_BYTE _ram_hdwr_tia_size      ; 'remainder' transfer of < $2000
  888                     ;       lda   <_cl
  889                     ;       sta   LOW_BYTE  _ram_hdwr_tia_size
  890                     ;       jsr   _ram_hdwr_tia
  891                     
  892                         ; ----
  893                         ; unmap data
  894                         ;
  895                     
  896  00:C416  4C 72 C3  .out:   jmp   unmap_data
  897                     
  898                     
  899                     
  900                     ; ----
  901                     ; set_read
  902                     ; ----
  903                     ; set the VDC VRAM read pointer
  904                     ; ----
  905                     ; IN :  _DI = VRAM location
  906                     ; ----
  907                     
  908  00:C419            set_read:
  909  00:8419                    vreg  #$01
  910  00:C41F  A5 F0             lda   <_di 
  911  00:C421  8D 02 00          sta   video_data_l
  912           0001              .ifdef HUC
  913  00:C424  8D 7F 27           sta   _vdc+2
  914                             .endif
  915  00:C427  A5 F1             lda   <_di+1
  916  00:C429  8D 03 00          sta   video_data_h
  917           0001              .ifdef HUC
  918  00:C42C  8D 80 27           sta   _vdc+3
  919                             .endif
  920  00:842F                    vreg  #$02
  921  00:C435  60                rts 
  922                     
  923                     
  924                     ; ----
  925                     ; set_write
  926                     ; ----
  927                     ; set the VDC VRAM write pointer
  928                     ; ----
  929                     ; IN :  _DI = VRAM location
  930                     ; ----
  931                     
  932  00:C436            set_write:
  933  00:8436                    vreg  #$00
  934  00:C43C  A5 F0             lda   <_di 
  935  00:C43E  8D 02 00          sta   video_data_l
  936           0001              .ifdef HUC
  937  00:C441  8D 7D 27           sta   _vdc
  938                             .endif
  939  00:C444  A5 F1             lda   <_di+1
  940  00:C446  8D 03 00          sta   video_data_h
  941           0001              .ifdef HUC
  942  00:C449  8D 7E 27           sta   _vdc+1
  943                             .endif
  944  00:844C                    vreg  #$02
  945  00:C452  60                rts 
  946                     
  947                     
  948                     ; ----
  949                     ; calc_vram_addr
  950                     ; ----
  951                     ; calculate VRAM address
  952                     ; ----
  953                     ; IN :    X = x coordinates
  954                     ;         A = y     "
  955                     ; ----
  956                     ; OUT:  _DI = VRAM location
  957                     ; ----
  958                     
  959  00:C453            calc_vram_addr:
  960  00:C453  DA                phx
  961  00:C454  2D 0E 27          and   bat_vmask
  962  00:C457  64 F0             stz   <_di
  963  00:C459  AE 0A 27          ldx   bat_width
  964  00:C45C  E0 40             cpx   #64
  965  00:C45E  F0 07             beq   .s64
  966  00:C460  E0 80             cpx   #128
  967  00:C462  F0 06             beq   .s128
  968                             ; --
  969  00:C464  4A        .s32:   lsr   A
  970  00:C465  66 F0             ror   <_di
  971                             ; --
  972  00:C467  4A        .s64:   lsr   A
  973  00:C468  66 F0             ror   <_di
  974                             ; --
  975  00:C46A  4A        .s128:  lsr   A
  976  00:C46B  66 F0             ror   <_di
  977  00:C46D  85 F1             sta   <_di+1
  978                             ; --
  979  00:C46F  68                pla
  980  00:C470  2D 0D 27          and   bat_hmask
  981  00:C473  05 F0             ora   <_di
  982  00:C475  85 F0             sta   <_di
  983  00:C477  60                rts
  984                     
  985                     ; ----
  986                     ; HSR(xres)
  987                     ; ----
  988                     ; macros to calculate the value of the HSR VDC register
  989                     ; ----
  990                     ; IN :  xres, horizontal screen resolution
  991                     ; ----
  992                     
  993                     HSR     .macro
  994                              .if (\1 < 268)
  995                               ; low res
  996                               .db $02
  997                               .db (18 - (\1 / 16))
  998                              .else
  999                               .if (\1 < 356)
 1000                                ; high res
 1001                                .db $03
 1002                                .db (25 - (\1 / 16))
 1003                               .else
 1004                                ; very high res
 1005                                .db $05
 1006                                .db (42 - (\1 / 16))
 1007                               .endif
 1008                              .endif
 1009                             .endm
 1010                     
 1011                     
 1012                     ; ----
 1013                     ; HDR(xres)
 1014                     ; ----
 1015                     ; macros to calculate the value of the HDR VDC register
 1016                     ; ----
 1017                     ; IN :  xres, horizontal screen resolution
 1018                     ; ----
 1019                     
 1020                     HDR     .macro
 1021                              .db ((\1 / 8) - 1)
 1022                              .if (\1 < 268)
 1023                               ; low res
 1024                               .db (38 - ((18 - (\1 / 16)) + (\1 / 8)))
 1025                              .else
 1026                               .if (\1 < 356)
 1027                                ; high res
 1028                                .db (51 - ((25 - (\1 / 16)) + (\1 / 8)))
 1029                               .else
 1030                                ; high res
 1031                                .db (82 - ((42 - (\1 / 16)) + (\1 / 8)))
 1032                               .endif
 1033                              .endif
 1034                             .endm
 1035                     
 1036                     
 1037                     ; ----
 1038                     ; init_vdc
 1039                     ; ----
 1040                     ; initialize the video controller
 1041                     ;  - 256x224 screen mode
 1042                     ;  - 64x32 virtual bgmap size
 1043                     ;  - display and sprites off
 1044                     ;  - interrupts disabled
 1045                     ;  - SATB at $7F00
 1046                     ;  - VRAM cleared
 1047                     ; ----
 1048                     
 1049           270A                 .bss
 1050  --:270A            bat_width  .ds 2
 1051  --:270C            bat_height .ds 1
 1052  --:270D            bat_hmask  .ds 1
 1053  --:270E            bat_vmask  .ds 1
 1054  --:270F            scr_width  .ds 1
 1055  --:2710            scr_height .ds 1
 1056           C478                 .code
 1057                     
 1058  00:C478            init_vdc:
 1059                         ; ----
 1060                         ; default screen resolution
 1061                         ;
 1062           0000             .ifndef _xres
 1064                            .endif
 1065                     
 1066                         ; ----
 1067                         ; initialize the VDC registers
 1068                         ;
 1069  00:8478                    stw   #.table,<_si      ; register table address in '_si'
 1070  00:C480  C2                cly 
 1071  00:C481  B1 EE     .l1:    lda   [_si],Y           ; select the VDC register
 1072  00:C483  C8                iny
 1073  00:C484  85 F7             sta   <vdc_reg
 1074  00:C486  8D 00 00          sta   video_reg
 1075           0001              .ifdef HUC
 1076  00:C489  0A                 asl   A
 1077  00:C48A  AA                 tax
 1078                             .endif
 1079  00:C48B  B1 EE             lda   [_si],Y           ; send the 16-bit data
 1080  00:C48D  C8                iny 
 1081  00:C48E  8D 02 00          sta   video_data_l
 1082           0001              .ifdef HUC
 1083  00:C491  9D 7D 27           sta   _vdc,X
 1084                             .endif
 1085  00:C494  B1 EE             lda   [_si],Y
 1086  00:C496  C8                iny 
 1087  00:C497  8D 03 00          sta   video_data_h
 1088           0001              .ifdef HUC
 1089  00:C49A  9D 7E 27           sta   _vdc+1,X
 1090                             .endif
 1091  00:C49D  C0 24             cpy   #36               ; loop if not at the end of the
 1092  00:C49F  D0 E0             bne   .l1               ; table
 1093                     
 1094                         ; ----
 1095                         ; set the screen mode
 1096                         ;
 1097           0001              .if (_xres < 268)
 1098  00:C4A1  A9 04              lda  #(0 | XRES_SOFT)
 1099                             .else
 1105                             .endif
 1106                     
 1107                     ; This stuff alters display position from HuCard position
 1108                     
 1109                     ;        .if (CDROM)
 1110                     ;
 1111                     ;        ldx  #_xres/8
 1112                     ;        ldy  #30
 1113                     ;        jsr  ex_scrmod
 1114                     ;        lda  #$01
 1115                     ;        jsr  ex_scrsiz
 1116                     ;        lda  #0
 1117                     ;        jsr  ex_imode
 1118                     ;
 1119                     ;        .else
 1120                     
 1121                              ; pixel clock frequency
 1122  00:C4A3  8D 00 04           sta  color_ctrl
 1123                     ;
 1124                     ;        .endif
 1125                     
 1126                     
 1127                         ; ----
 1128                         ; set the background & border colors to black
 1129                         ;
 1130  00:84A6                    stw   #256,color_reg
 1131  00:84B0                    stwz  color_data
 1132  00:84B6                    stwz  color_reg
 1133  00:84BC                    stwz  color_data
 1134                     
 1135           0001             .if (CDROM)
 1136                     
 1137                         ; ----
 1138                         ; reset scrolling position (0,0)
 1139                         ;
 1140  00:84C2                    vreg  #7
 1141  00:84C8                    stwz  video_data
 1142  00:84CE                    vreg  #8
 1143  00:84D4                    stwz  video_data
 1144  00:84DA                    stwz  bg_x1
 1145  00:84E0                    stwz  bg_y1
 1146                     
 1147                         ; ----
 1148                         ; set SATB address
 1149                         ;
 1150  00:84E6                    stw   #$7F00,satb_addr
 1151  00:C4F0  20 9F E0          jsr   ex_sprdma
 1152  00:C4F3  A9 10             lda   #$10
 1153  00:C4F5  20 9C E0          jsr   ex_dmamod
 1154                     
 1155                            .endif   ; (CDROM)
 1156                     
 1157                         ; ----
 1158                         ; clear the video RAM
 1159                         ;
 1160  00:C4F8  03 00             st0   #0
 1161  00:C4FA  13 00             st1   #0
 1162  00:C4FC  23 00             st2   #0
 1163  00:C4FE  03 02             st0   #2
 1164                     
 1165  00:C500  A2 80             ldx   #128
 1166  00:C502  C2        .l2:    cly
 1167  00:C503  13 00     .l3:    st1   #0
 1168  00:C505  23 00             st2   #0
 1169  00:C507  88                dey
 1170  00:C508  D0 F9             bne   .l3
 1171  00:C50A  CA                dex
 1172  00:C50B  D0 F5             bne   .l2
 1173                     
 1174                         ; ----
 1175                         ; save screen infos
 1176                         ;
 1177  00:850D                    stw   #_xres,scr_width  ; resolution
 1178  00:8517                    stw   #224,scr_height
 1179                             ; --
 1180  00:C521  A9 01             lda   #BGMAP_SIZE_64x32 ; virtual size
 1181  00:C523  4C 5C C5          jmp   set_bat_size
 1182                     
 1183                         ; ----
 1184                         ; VDC register table
 1185                         ;
 1186  00:C526  05 00 00  .table: .db $05,$00,$00         ; CR    control register
 1187  00:C529  06 00 00          .db $06,$00,$00         ; RCR   scanline interrupt counter
 1188  00:C52C  07 00 00          .db $07,$00,$00         ; BXR   background horizontal scroll offset
 1189  00:C52F  08 00 00          .db $08,$00,$00         ; BYR        "     vertical     "      "
 1190  00:C532  09 10 00          .db $09,$10,$00         ; MWR   size of the virtual screen
 1191  00:C535  0A                .db $0A                 ; HSR +
 1192  00:8536                     HSR _xres              ;     |                 [$02,$02]
 1193  00:C538  0B                .db $0B                 ; HDR | display size
 1194  00:8539                     HDR _xres              ;     | and synchro     [$1F,$04]
 1195  00:C53B  0C 02 17          .db $0C,$02,$17         ; VPR |
 1196  00:C53E  0D DF 00          .db $0D,$DF,$00         ; VDW |
 1197  00:C541  0E 0C 00          .db $0E,$0C,$00         ; VCR +
 1198  00:C544  0F 10 00          .db $0F,$10,$00         ; DCR   DMA control register
 1199  00:C547  13 00 7F          .db $13,$00,$7F         ; SATB  address of the SATB
 1200                     
 1201                     
 1202                     ; ----
 1203                     ; set_xres
 1204                     ; ----
 1205                     ; set horizontal display resolution
 1206                     ; ----
 1207                     ; IN  : _AX = new x resolution (ie. 320)
 1208                     ;       _CL = 'blur bit' for color register
 1209                     ; USES: _BX
 1210                     ; ----
 1211                     
 1212  00:C54A            set_xres:
 1213  00:854A                    maplibfunc      lib2_set_xres
 1214  00:C55B  60                rts
 1215                     
 1216                     
 1217           0001              .bank   LIB2_BANK
 1218                     
 1219           2711              .bss
 1220  --:2711            vdc_blur  .ds 1         ; blur bit
 1221  --:2712            hsw       .ds 1         ; temporary parameters for calculating video registers
 1222  --:2713            hds       .ds 1
 1223  --:2714            hdw       .ds 1
 1224  --:2715            hde       .ds 1
 1225           A9DD              .code
 1226                     
 1227  01:A9DD            lib2_set_xres:
 1228  01:A9DD  A9 20             lda     #$20            ; reset resource-usage flag
 1229  01:A9DF  04 F5             tsb     <irq_m          ; to skip joystick read portion of vsync
 1230                                                     ; (temporarily disable VSYNC processing)
 1231  01:A9E1  A5 F9             lda     <_ah
 1232  01:A9E3  85 FB             sta     <_bh
 1233  01:A9E5  A5 F8             lda     <_al
 1234  01:A9E7  85 FA             sta     <_bl            ; bx now has x-res
 1235                     
 1236  01:A9E9  46 FB             lsr     <_bh
 1237  01:A9EB  66 FA             ror     <_bl
 1238  01:A9ED  46 FB             lsr     <_bh
 1239  01:A9EF  66 FA             ror     <_bl
 1240  01:A9F1  46 FA             lsr     <_bl            ; bl now has x/8
 1241                     
 1242  01:A9F3  C2                cly                     ; offset into numeric tables
 1243                                                     ; 0=low-res, 1=mid-res, 2=high-res
 1244                     
 1245  01:A9F4  A5 F9             lda     <_ah
 1246  01:A9F6  F0 1E             beq    .xres_calc       ; < 256
 1247  01:A9F8  C9 03             cmp     #3
 1248  01:49FA                    bhs   .xres_calc
 1249                     
 1250  01:49FC                    cmpw    #$10C,<_ax
 1251  01:4A06                    blo    .xres_calc       ; < 268
 1252                     
 1253  01:AA08  C8                iny
 1254  01:4A09                    cmpw    #$164,<_ax
 1255  01:4A13                    blo    .xres_calc       ; < 356
 1256                     
 1257  01:AA15  C8                iny                     ; 356 < x < 512
 1258                     
 1259  01:AA16            .xres_calc:
 1260  01:AA16  B9 82 AA          lda     .vce_tab,Y
 1261  01:AA19  05 FC             ora     <_cl
 1262  01:AA1B  8D 00 04          sta     color_ctrl      ; dot-clock (x-resolution)
 1263                     
 1264  01:AA1E  B9 85 AA          lda     .hsw_tab,Y      ; example calc's (using "low-res" numbers)
 1265  01:AA21  8D 12 27          sta     hsw             ; hsw = $2
 1266  01:AA24  A5 FA             lda     <_bl
 1267  01:AA26  8D 13 27          sta     hds             ; hds = (x/8) temporarily
 1268  01:AA29  3A                dec     A
 1269  01:AA2A  8D 14 27          sta     hdw             ; hdw = (x/8)-1
 1270  01:AA2D  4E 13 27          lsr     hds             ; hds = (x/16) temporarily
 1271                     
 1272  01:AA30  B9 88 AA          lda     .hds_tab,Y
 1273  01:4A33                    sub     hds
 1274  01:AA37  8D 13 27          sta     hds             ; hds = 18 - (x/16)
 1275                     
 1276  01:AA3A  B9 8B AA          lda     .hde_tab,Y
 1277  01:4A3D                    sub     hds
 1278  01:4A41                    sub     <_bl            ; hde = (38 - ( (18-(x/16)) + (x/8) ))
 1279  01:AA44  8D 15 27          sta     hde
 1280                     
 1281  01:AA47            .xres_putit:
 1282  01:AA47  A9 0A             lda     #$0a
 1283  01:AA49  85 F7             sta     <vdc_reg
 1284  01:AA4B  8D 00 00          sta     video_reg
 1285           0001              .ifdef HUC
 1286  01:AA4E  0A                 asl    A
 1287  01:AA4F  22                 sax
 1288                             .endif
 1289  01:AA50  AD 12 27          lda     hsw
 1290  01:AA53  8D 02 00          sta     video_data_l
 1291           0001              .ifdef HUC
 1292  01:AA56  9D 7D 27           sta    _vdc,X
 1293                             .endif
 1294  01:AA59  AD 13 27          lda     hds
 1295  01:AA5C  8D 03 00          sta     video_data_h
 1296           0001              .ifdef HUC
 1297  01:AA5F  9D 7E 27           sta    _vdc+1,X
 1298                             .endif
 1299                     
 1300  01:AA62  A9 0B             lda     #$0b
 1301  01:AA64  85 F7             sta     <vdc_reg
 1302  01:AA66  8D 00 00          sta     video_reg
 1303           0001              .ifdef HUC
 1304  01:AA69  0A                 asl    A
 1305  01:AA6A  22                 sax
 1306                             .endif
 1307  01:AA6B  AD 14 27          lda     hdw
 1308  01:AA6E  8D 02 00          sta     video_data_l
 1309           0001              .ifdef HUC
 1310  01:AA71  9D 7D 27           sta    _vdc,X
 1311                             .endif
 1312  01:AA74  AD 15 27          lda     hde
 1313  01:AA77  8D 03 00          sta     video_data_h
 1314           0001              .ifdef HUC
 1315  01:AA7A  9D 7E 27           sta    _vdc+1,X
 1316                             .endif
 1317                     
 1318  01:AA7D            .xres_err:
 1319  01:AA7D  A9 20             lda     #$20
 1320  01:AA7F  14 F5             trb     <irq_m          ; re-enable VSYNC processing
 1321  01:AA81  60                rts
 1322                     
 1323  01:AA82  00 01 02  .vce_tab:       .db      0, 1, 2
 1324  01:AA85  02 03 05  .hsw_tab:       .db      2, 3, 5
 1325  01:AA88  12 19 2A  .hds_tab:       .db     18,25,42
 1326  01:AA8B  26 33 52  .hde_tab:       .db     38,51,82
 1327                     
 1328           0000              .bank   LIB1_BANK       ; restore bank context
 1329                     
 1330                     ; ----
 1331                     ; set_bat_size
 1332                     ; ----
 1333                     ; set bg map virtual size
 1334                     ; ----
 1335                     ; IN : A = new size (0-7)
 1336                     ; ----
 1337                     
 1338  00:C55C            set_bat_size:
 1339  00:C55C  29 07             and   #$07
 1340  00:C55E  48                pha
 1341                             ; --
 1342           0001              .if (CDROM)
 1343  00:C55F  20 69 E0           jsr   ex_scrsiz
 1344  00:C562  FA                 plx
 1345                             .else
 1357                             .endif
 1358                             ; --
 1359  00:C563  BD 87 C5          lda  .width,X
 1360  00:C566  8D 0A 27          sta   bat_width
 1361  00:C569  9C 0B 27          stz   bat_width+1
 1362  00:C56C  3A                dec   A
 1363  00:C56D  8D 0D 27          sta   bat_hmask
 1364                             ; --
 1365  00:C570  BD 8F C5          lda  .height,X
 1366  00:C573  8D 0C 27          sta   bat_height
 1367  00:C576  8D FF 26          sta   mapbat_bottom
 1368  00:C579  9C FE 26          stz   mapbat_top
 1369  00:C57C  9C FC 26          stz   mapbat_top_base
 1370  00:C57F  9C FD 26          stz   mapbat_top_base+1
 1371  00:C582  3A                dec   A
 1372  00:C583  8D 0E 27          sta   bat_vmask
 1373  00:C586  60                rts
 1374                     
 1375  00:C587  20 40 80  .width:  .db $20,$40,$80,$80,$20,$40,$80,$80
       00:C58A  80 20 40  
       00:C58D  80 80     
 1376  00:C58F  20 20 20  .height: .db $20,$20,$20,$20,$40,$40,$40,$40
       00:C592  20 40 40  
       00:C595  40 40     
 1377                     
 1378                     
 1379                     ; ----
 1380                     ; init_psg
 1381                     ; ----
 1382                     ; initialize the sound generator.
 1383                     ; ----
 1384                     
 1385  00:C597            init_psg:
 1386           0000             .if !(CDROM)
 1390                            .endif
 1391                     
 1392  00:C597  9C 01 08          stz   psg_mainvol       ; main volume to zero
 1393  00:C59A  9C 09 08          stz   psg_lfoctrl       ; disable the LFO
 1394                             
 1395  00:C59D  A9 05             lda   #5                ; set volume to zero for each channel
 1396  00:C59F  8D 00 08  .clear: sta   psg_ch            ; and disable them
 1397  00:C5A2  9C 04 08          stz   psg_ctrl
 1398  00:C5A5  9C 05 08          stz   psg_pan
 1399  00:C5A8  3A                dec   A
 1400  00:C5A9  10 F4             bpl   .clear
 1401                     
 1402  00:C5AB  A9 04             lda   #4                ; disable noise for channel 5 & 6
 1403  00:C5AD  8D 00 08          sta   psg_ch
 1404  00:C5B0  9C 07 08          stz   psg_noise
 1405  00:C5B3  A9 05             lda   #5
 1406  00:C5B5  8D 00 08          sta   psg_ch
 1407  00:C5B8  9C 07 08          stz   psg_noise
 1408  00:C5BB  60                rts
 1409                     
 1410                     
 1411                     ; ----------------------------------
 1412                     ; Some simple copy/compare functions
 1413                     ; ----------------------------------
 1414                     
 1415                     ; ----
 1416                     ; _strcpy(char *dest [di], char *src [si])
 1417                     ; _strcat(char *dest [di], char *src [si])
 1418                     ; ----
 1419                     ; Copy/Concatenate a string to another string
 1420                     ; ----
 1421                     ;
 1422  00:C5BC            _strcat.2:
 1423  00:C5BC  B2 F0     .endlp:   lda   [_di]           ; same as strcpy, but find end
 1424  00:C5BE  F0 08               beq   _strcpy.2       ; of dest string first
 1425  00:85C0                      incw  <_di
 1426  00:C5C6  80 F4               bra   .endlp
 1427                     
 1428  00:C5C8            _strcpy.2:
 1429  00:C5C8  B2 EE     .cpylp:   lda   [_si]
 1430  00:C5CA  92 F0               sta   [_di]
 1431  00:C5CC  F0 0E               beq   .out
 1432  00:85CE                      incw  <_di
 1433  00:85D4                      incw  <_si
 1434  00:C5DA  80 EC               bra   .cpylp
 1435  00:C5DC  60        .out:     rts
 1436                     
 1437                     
 1438                     ; ----
 1439                     ; _strncpy(char *dest [di], char *src [si], int count [acc])
 1440                     ; _strncat(char *dest [di], char *src [si], int count [acc])
 1441                     ; ----
 1442                     ; Copy/Concatenate a string to another string
 1443                     ; ----
 1444                     ;
 1445                     
 1446  00:C5DD            _strncat.3:
 1447  00:85DD                    __stw   <_ax
 1448  00:C5E1  B2 F0     .endlp:   lda   [_di]
 1449  00:C5E3  F0 08               beq   .cpylp
 1450  00:85E5                      incw  <_di
 1451  00:C5EB  80 F4               bra   .endlp
 1452  00:C5ED            .cpylp:
 1453  00:C5ED  B2 EE               lda   [_si]
 1454  00:C5EF  92 F0               sta   [_di]
 1455  00:C5F1  F0 22               beq   .out
 1456  00:85F3                      incw  <_di
 1457  00:85F9                      incw  <_si
 1458  00:85FF                      decw  <_ax
 1459  00:860C                      tstw  <_ax
 1460  00:C610  D0 DB               bne   .cpylp
 1461  00:C612  62                  cla
 1462  00:C613  92 F0               sta   [_di]
 1463  00:C615  60        .out:     rts
 1464                     
 1465                     
 1466  00:C616            _strncpy.3:
 1467  00:8616                    __stw   <_ax
 1468  00:C61A            .lp:
 1469  00:C61A  B2 EE               lda   [_si]
 1470  00:C61C  92 F0               sta   [_di]
 1471  00:C61E  F0 21               beq   .out
 1472  00:8620                      incw  <_di
 1473  00:8626                      incw  <_si
 1474  00:862C                      decw  <_ax
 1475  00:8639                      tstw  <_ax
 1476  00:C63D  F0 02               beq   .out
 1477  00:C63F  80 D9               bra   .lp
 1478  00:C641  60        .out:     rts
 1479                     
 1480                     
 1481                     ; ----
 1482                     ; _memcpy(char *dest [di], char *src [si], int count [acc])
 1483                     ; ----
 1484                     ; Copy memory
 1485                     ; ----
 1486                     ;
 1487  00:C642            _memcpy.3:
 1488  00:8642                    __stw   <_ax
 1489  00:C646  B2 EE     .cpylp:   lda   [_si]
 1490  00:C648  92 F0               sta   [_di]
 1491  00:864A                      incw  <_si
 1492  00:8650                      incw  <_di
 1493  00:8656                      decw  <_ax
 1494  00:8663                      tstw  <_ax
 1495  00:C667  D0 DD               bne   .cpylp
 1496  00:C669  60                  rts
 1497                     
 1498                     ; ----
 1499                     ; _memcmp(char *dest [di], char *src [si], int count [acc])
 1500                     ; ----
 1501                     ; Compare memory
 1502                     ; ----
 1503                     ;
 1504  00:C66A            _memcmp.3:
 1505  00:866A                    __stw   <_ax
 1506  00:C66E  B2 F0     .cmplp:   lda   [_di]
 1507  00:8670                      sub   [_si]
 1508  00:C673  30 05               bmi   .minus
 1509  00:C675  F0 07               beq   .cont
 1510  00:C677  AA        .plus:    tax
 1511  00:C678  62                  cla
 1512  00:C679  60                  rts
 1513  00:C67A  AA        .minus:   tax
 1514  00:C67B  A9 FF               lda   #$ff
 1515  00:C67D  60                  rts
 1516  00:867E            .cont:    incw  <_di
 1517  00:8684                      incw  <_si
 1518  00:868A                      decw  <_ax
 1519  00:8697                      tstw  <_ax
 1520  00:C69B  D0 D1               bne   .cmplp
 1521  00:C69D  82                  clx
 1522  00:C69E  60                  rts
 1523                     
 1524                     ; ----
 1525                     ; _strcmp(char *dest [di], char *src [si])
 1526                     ; ----
 1527                     ; Compare strings
 1528                     ; ----
 1529                     ;
 1530  00:C69F            _strcmp.2:
 1531  00:C69F  B2 F0     .cmplp:   lda   [_di]
 1532  00:86A1                      sub   [_si]
 1533  00:C6A4  30 05               bmi   .minus
 1534  00:C6A6  F0 07               beq   .cont
 1535  00:C6A8  AA        .plus:    tax
 1536  00:C6A9  62                  cla
 1537  00:C6AA  60                  rts
 1538  00:C6AB  AA        .minus:   tax
 1539  00:C6AC  A9 FF               lda   #$ff
 1540  00:C6AE  60                  rts
 1541  00:C6AF  B2 F0     .cont:    lda   [_di]
 1542  00:C6B1  F0 0E               beq   .out
 1543  00:86B3                      incw  <_di
 1544  00:86B9                      incw  <_si
 1545  00:C6BF  80 DE               bra   .cmplp
 1546  00:C6C1  82        .out:     clx
 1547  00:C6C2  60                  rts
 1548                     
 1549                     ; ----
 1550                     ; _strncmp(char *dest [di], char *src [si], int count [acc])
 1551                     ; ----
 1552                     ; Compare strings
 1553                     ; ----
 1554                     ;
 1555  00:C6C3            _strncmp.3:
 1556  00:86C3                    __stw   <_ax
 1557  00:C6C7  B2 F0     .cmplp:   lda   [_di]
 1558  00:86C9                      sub   [_si]
 1559  00:C6CC  30 05               bmi   .minus
 1560  00:C6CE  F0 07               beq   .cont
 1561  00:C6D0  AA        .plus:    tax
 1562  00:C6D1  62                  cla
 1563  00:C6D2  60                  rts
 1564  00:C6D3  AA        .minus:   tax
 1565  00:C6D4  A9 FF               lda   #$ff
 1566  00:C6D6  60                  rts
 1567  00:C6D7  B2 F0     .cont:    lda   [_di]
 1568  00:C6D9  F0 1F               beq   .out
 1569  00:86DB                      incw  <_di
 1570  00:86E1                      incw  <_si
 1571  00:86E7                      decw  <_ax
 1572  00:86F4                      tstw  <_ax
 1573  00:C6F8  D0 CD               bne   .cmplp
 1574  00:C6FA  82        .out      clx
 1575  00:C6FB  62                  cla
 1576  00:C6FC  60                  rts
 1577                     
#[2]   startup.asm
#[3]   scroll.asm
 1212                             .include "scroll.asm"
    1                     ;
    2                     ; SCROLL.ASM  -  MagicKit Scrolling Library
    3                     ;
    4                     ;
    5                     
    6                     ; [ 28] user scrolling vars
    7           2716                      .bss
    8  --:2716            scroll_xl:      .ds 4   ; x       |
    9  --:271A            scroll_xh:      .ds 4   ;         |
   10  --:271E            scroll_yl:      .ds 4   ; y       |
   11  --:2722            scroll_yh:      .ds 4   ;         | scrolling table
   12  --:2726            scroll_top:     .ds 4   ; top     |
   13  --:272A            scroll_bottom:  .ds 4   ; bottom  |
   14  --:272E            scroll_cr:      .ds 4   ; control |
   15                     
   16                     ; [ 69] display list
   17           2732                      .bss
   18  --:2732            s_idx           .ds 1
   19  --:2733            s_xl            .ds 8
   20  --:273B            s_xh            .ds 8
   21  --:2743            s_yl            .ds 8
   22  --:274B            s_yh            .ds 8
   23  --:2753            s_cr            .ds 8
   24  --:275B            s_top           .ds 9
   25  --:2764            s_bottom        .ds 8
   26  --:276C            s_list          .ds 8
   27  --:2774            s_work          .ds 3
   28                     
   29           C6FD                      .code
   30           0001                      .bank   LIB2_BANK
   31                     ; ----
   32                     ; build_display_list
   33                     ; ----
   34                     
   35  01:AA8E            build_disp_list:
   36                     
   37                         ; ----
   38                         ; quick test
   39                         ;
   40  01:AA8E  AD 2E 27          lda   scroll_cr
   41  01:AA91  0D 2F 27          ora   scroll_cr+1
   42  01:AA94  0D 30 27          ora   scroll_cr+2
   43  01:AA97  0D 31 27          ora   scroll_cr+3
   44  01:AA9A  29 01             and   #$01
   45  01:AA9C  D0 02             bne   .l0
   46                             ; --
   47  01:AA9E  18                clc
   48  01:AA9F  60                rts
   49                     
   50                         ; ----
   51                         ; parse user scroll list
   52                         ;
   53  01:AAA0  82        .l0:    clx
   54  01:AAA1  C2                cly
   55                             ; --
   56  01:AAA2  B9 2E 27  .l1:    lda   scroll_cr,Y
   57  01:AAA5  29 01             and   #$01
   58  01:AAA7  F0 38             beq   .l2
   59  01:AAA9  B9 26 27          lda   scroll_top,Y
   60  01:AAAC  CD 10 27          cmp   scr_height
   61  01:4AAF                    bhs   .l2
   62  01:AAB1  3A                dec   A
   63  01:AAB2  20 48 AB          jsr   .check_list
   64  01:AAB5  B0 2A             bcs   .l2
   65                             ; -- copy scanline
   66  01:AAB7  9D 5B 27          sta   s_top,X
   67  01:AABA  B9 2A 27          lda   scroll_bottom,Y
   68  01:AABD  9D 64 27          sta   s_bottom,X
   69                             ; -- copy display control bits
   70  01:AAC0  B9 2E 27          lda   scroll_cr,Y
   71  01:AAC3  29 C0             and   #$C0
   72  01:AAC5  9D 53 27          sta   s_cr,X
   73                             ; -- copy bat coordinates
   74  01:AAC8  B9 16 27          lda   scroll_xl,Y
   75  01:AACB  9D 33 27          sta   s_xl,X
   76  01:AACE  B9 1A 27          lda   scroll_xh,Y
   77  01:AAD1  9D 3B 27          sta   s_xh,X
   78  01:AAD4  B9 1E 27          lda   scroll_yl,Y
   79  01:AAD7  9D 43 27          sta   s_yl,X
   80  01:AADA  B9 22 27          lda   scroll_yh,Y
   81  01:AADD  9D 4B 27          sta   s_yh,X
   82  01:AAE0  E8                inx
   83  01:AAE1            .l2:
   84  01:AAE1  C8                iny
   85  01:AAE2  C0 04             cpy   #4
   86  01:4AE4                    blo   .l1
   87                     
   88                         ; ----
   89                         ; init display list
   90                         ;
   91  01:AAE6  A9 F0             lda   #$F0
   92  01:AAE8  9D 5B 27          sta   s_top,X
   93  01:AAEB  9D 64 27          sta   s_bottom,X
   94  01:AAEE  E8                inx
   95  01:AAEF  8E 32 27          stx   s_idx
   96                             ; --
   97  01:AAF2  C2                cly
   98  01:AAF3  62                cla
   99  01:AAF4  99 6C 27  .l3:    sta   s_list,Y
  100  01:AAF7  1A                inc   A
  101  01:AAF8  C8                iny
  102  01:AAF9  CA                dex
  103  01:AAFA  D0 F8             bne   .l3
  104                     
  105                         ; ----
  106                         ; sort display list
  107                         ;
  108  01:AAFC  AD 32 27          lda   s_idx
  109  01:AAFF  8D 74 27          sta   s_work
  110  01:AB02  80 39             bra   .t4
  111  01:AB04            .t1:
  112  01:AB04  9C 75 27          stz   s_work+1
  113  01:AB07  A0 01             ldy   #1
  114  01:AB09            .t2:
  115  01:AB09  BE 6B 27          ldx   s_list-1,Y
  116  01:AB0C  BD 5B 27          lda   s_top,X
  117  01:AB0F  1A                inc   A
  118  01:AB10  8D 76 27          sta   s_work+2
  119  01:AB13  BE 6C 27          ldx   s_list,Y
  120  01:AB16  BD 5B 27          lda   s_top,X
  121  01:AB19  1A                inc   A
  122  01:AB1A  CD 76 27          cmp   s_work+2
  123  01:4B1D                    bhs   .t3
  124                             ; --
  125  01:AB1F  B9 6B 27          lda   s_list-1,Y
  126  01:AB22  99 6C 27          sta   s_list,Y
  127  01:AB25  8A                txa
  128  01:AB26  99 6B 27          sta   s_list-1,Y
  129  01:AB29  EE 75 27          inc   s_work+1
  130  01:AB2C            .t3:
  131  01:AB2C  C8                iny
  132  01:AB2D  CC 74 27          cpy   s_work
  133  01:4B30                    blo   .t2
  134  01:AB32  AD 75 27          lda   s_work+1
  135  01:AB35  F0 0A             beq   .t5
  136  01:AB37  CE 74 27          dec   s_work
  137  01:AB3A  AD 74 27          lda   s_work
  138  01:AB3D  C9 02     .t4:    cmp   #2
  139  01:4B3F                    bhs   .t1
  140  01:AB41            .t5:
  141                         ; ----
  142                         ; return
  143                         ;
  144  01:AB41  AD 32 27          lda   s_idx
  145  01:4B44                    add   #$FE
  146  01:AB47  60                rts
  147                     
  148                         ; ----
  149                         ; scan display list
  150                         ;
  151  01:AB48            .check_list:
  152                     
  153  01:AB48  DA                phx
  154  01:AB49  CA        .x1:    dex
  155  01:AB4A  30 08             bmi   .x2
  156  01:AB4C  DD 5B 27          cmp   s_top,X
  157  01:AB4F  D0 F8             bne   .x1
  158  01:AB51  FA                plx
  159  01:AB52  38                sec
  160  01:AB53  60                rts
  161                             ; --
  162  01:AB54  FA        .x2:    plx
  163  01:AB55  18                clc
  164  01:AB56  60                rts
  165                     
  166           0000                      .bank   LIB1_BANK       ; restore context
  167                     
#[2]   startup.asm
#[3]   math.asm
 1213                             .include "math.asm"
    1                     ;
    2                     ; MATH.ASM  -  MagicKit Standard Math Routines
    3                     ;
    4                     ;
    5                     
    6                     
    7                     ; ----
    8                     ; divu8
    9                     ; ----
   10                     ; 8-bit unsigned division
   11                     ; ----
   12                     ; OUT : _CL = _AL / _BL
   13                     ;       _DL = _AL % _BL
   14                     ; ----
   15                     
   16  00:C6FD            divu8:
   17  00:C6FD  A5 F8             lda   <_al
   18  00:C6FF  0A                asl   A
   19  00:C700  85 FC             sta   <_cl
   20  00:C702  62                cla
   21  00:C703  A0 08             ldy   #8
   22  00:C705            .l1:
   23  00:C705  2A                rol   A
   24  00:C706  C5 FA             cmp   <_bl
   25  00:C708  90 02             bcc   .l2
   26  00:C70A  E5 FA             sbc   <_bl
   27  00:C70C            .l2:
   28  00:C70C  26 FC             rol   <_cl
   29  00:C70E  88                dey
   30  00:C70F  D0 F4             bne   .l1
   31                     
   32  00:C711  85 FE             sta   <_dl
   33  00:C713  60                rts
   34                     
   35                     
   36                     ; ----
   37                     ; divu10
   38                     ; ----
   39                     ; 16-bit unsigned division by 10
   40                     ; ----
   41                     ; OUT : _DX = _DX / 10
   42                     ;         A = _DX % 10
   43                     ; ----
   44                     
   45  00:C714            divu10:
   46  00:C714  A0 10               ldy   #16
   47  00:C716  62                  cla
   48  00:C717  06 FE               asl   <_dl
   49  00:C719  26 FF               rol   <_dh
   50  00:C71B  2A        .l1:      rol   a
   51  00:C71C  C9 0A               cmp   #10
   52  00:871E                      blo   .l2
   53  00:C720  E9 0A               sbc   #10
   54  00:C722  26 FE     .l2:      rol   <_dl
   55  00:C724  26 FF               rol   <_dh
   56  00:C726  88                  dey
   57  00:C727  D0 F2               bne   .l1
   58  00:C729  60                  rts
   59                     
   60           0000              .if (!CDROM)
  121                             .endif
  122                     
  123                     ; ----
  124                     ; mulu32
  125                     ; ----
  126                     ; 32-bit unsigned multiplication
  127                     ; ----
  128                     ; OUT : _DX/CX = _BX/AX * _DX/CX
  129                     ; ----
  130                     
  131  00:C72A            mulu32:
  132  00:872A                    stw   <_cx,<_si
  133  00:8732                    stw   <_dx,<_di
  134  00:873A                    stwz  <_cx
  135  00:873E                    stwz  <_dx
  136  00:C742  A0 20             ldy   #32
  137  00:C744            .loop:
  138  00:8744                    aslw  <_cx
  139  00:8748                    rolw  <_dx
  140  00:874C                    rolw  <_si
  141  00:8750                    rolw  <_di
  142  00:C754  90 19             bcc   .next
  143                     
  144  00:8756                    addw  <_ax,<_cx
  145  00:8763                    adcw  <_bx,<_dx
  146  00:C76F            .next:
  147  00:C76F  88                dey
  148  00:C770  D0 D2             bne   .loop
  149  00:C772  60                rts
  150                     
  151                     
  152                     ; ----
  153                     ; srand
  154                     ; ----
  155                     ; set random seed
  156                     ; ----
  157                     ; IN : _DX/CX = 32-bit seed
  158                     ; ----
  159                     
  160           2777              .bss
  161  --:2777            _rndptr         .ds 2
  162  --:2779            _rndseed        .ds 2
  163  --:277B            _rndn1          .ds 1
  164  --:277C            _rndn2          .ds 1
  165                     
  166           C773              .code
  167  00:C773            srand:
  168  00:8773                    stw     <_cx,_rndptr
  169  00:877D                    stw     <_dx,_rndn1
  170  00:C787  AD 78 27          lda     _rndptr+1
  171  00:C78A  09 E0             ora     #$e0
  172  00:C78C  8D 78 27          sta     _rndptr+1
  173  00:C78F  C9 F4             cmp     #$f4
  174  00:8791                    blo     .exit
  175  00:C793  A9 E0             lda     #$e0
  176  00:C795  8D 78 27          sta     _rndptr+1
  177  00:C798            .exit:
  178  00:C798  60                rts
  179                     
  180                     ; ----
  181                     ; rand
  182                     ; ----
  183                     ; return 16-bit random number
  184                     ; ----
  185                     ; OUT: _DX
  186                     ; ----
  187                     
  188           2014              .zp
  189  --:2014            _rndzp  .ds     2
  190                     
  191           C799              .code
  192  00:C799  20 A7 C7  rand:   jsr     randomize
  193  00:879C                    stw     _rndn1,<_dx
  194  00:C7A6  60                rts
  195                     
  196  00:C7A7            randomize:
  197  00:87A7                    stw     _rndptr,<_rndzp
  198                     
  199  00:C7B1  AD 7B 27          lda     _rndn1  ; rotate 3 bits right
  200  00:C7B4  AE 7C 27          ldx     _rndn2
  201  00:C7B7  6A                ror     A
  202  00:C7B8  22                sax
  203  00:C7B9  6A                ror     A
  204  00:C7BA  22                sax
  205  00:C7BB  6A                ror     A
  206  00:C7BC  22                sax
  207  00:C7BD  6A                ror     A
  208  00:C7BE  22                sax
  209  00:C7BF  6A                ror     A
  210  00:C7C0  22                sax
  211  00:C7C1  6A                ror     A
  212  00:C7C2  8E 7B 27          stx     _rndn1
  213  00:C7C5  8D 7C 27          sta     _rndn2
  214                     
  215  00:87C8                    addw    #$05A2,_rndn1 ; add #$05A2 to number
  216                     
  217  00:87D9                    incw    <_rndzp ; eor with next 2 bytes of ROM
  218  00:C7DF  AD 7C 27          lda     _rndn2
  219  00:C7E2  52 14             eor     [_rndzp]
  220  00:C7E4  8D 7C 27          sta     _rndn2
  221                     
  222  00:87E7                    incw    <_rndzp
  223  00:C7ED  AD 7B 27          lda     _rndn1
  224  00:C7F0  52 14             eor     [_rndzp]
  225  00:C7F2  8D 7B 27          sta     _rndn1
  226                     
  227  00:87F5                    incw    <_rndzp ; don't use every consecutive byte
  228                     
  229  00:C7FB  A5 15             lda     <_rndzp+1       ; reset pointer to $e000 if > $f400
  230  00:C7FD  C9 F4             cmp     #$f4
  231  00:87FF                    blo     .l1
  232  00:C801  A9 E0             lda     #$e0
  233  00:C803  85 15             sta     <_rndzp+1
  234  00:C805            .l1:
  235  00:8805                    stw     <_rndzp,_rndptr
  236  00:C80F  60                rts
  237                     
  238                     
  239                     ; ----
  240                     ; random
  241                     ; ----
  242                     ; return a random number in the interval 0 <= x < A
  243                     ; ----
  244                     ; IN  : A = range (1 - 128)
  245                     ; ----
  246                     ; OUT : A = random number
  247                     ; ----
  248                     ;
  249  00:C810            random:
  250  00:C810  48                pha
  251  00:C811  20 99 C7          jsr     rand
  252  00:C814  68                pla
  253                             ; ----
  254  00:C815  C9 80             cmp     #128
  255  00:8817                    blo     .l1
  256                     
  257  00:C819  A5 FF             lda     <_dh
  258  00:C81B  29 7F             and     #$7f
  259  00:C81D  60                rts
  260                     
  261  00:C81E            .l1:    ; asl   A
  262  00:C81E  85 F8             sta     <_al
  263  00:C820  A5 FE             lda     <_dl
  264  00:C822  85 FA             sta     <_bl
  265  00:C824  20 BD E0          jsr     mulu8
  266                     
  267  00:C827  A5 FD             lda     <_ch
  268  00:C829  60                rts
  269                     
#[2]   startup.asm
 1214                     
 1215           0001             .ifdef HUC
#[3]   huc.asm
 1216                             .include "huc.asm"
    1                     ;
    2                     ; HUC.ASM  -  HuC Internal Library
    3                     ;
    4                     
    5                     ; ----
    6                     ; local variables
    7                     
    8           277D                .bss
    9  --:277D            _vdc      .ds 20*2
   10                     
   11           2016                .zp
   12  --:2016            __sign
   13  --:2016            __remain  .ds 2
   14                     
   15           C82A                .code
   17                     
   18                     ; ----
   19                     ; eq
   20                     ; ----
   21                     ; test egality of two words
   22                     ; ----
   23                     ; IN :  First word on the C stack
   24                     ;       Another word in A:X
   25                     ; ----
   26                     ; OUT : word A:X equals 0 is the two args are egals
   27                     ;       else non nul
   28                     ; ----
   29                     ; REMARK : signed compatible
   30                     ; ----
   31                     
   32                                     ; old version is 75 bytes long
   33                                     ; new version is 31 bytes long (58% shorter :)
   34                                     ; DAVE: newer version 45 bytes but much faster
   35                                     ; best case was: 56 cycles (worst = 70)
   36                                     ; best case now: 45 cycles (worst = 59)
   37                     
   38  00:C82A            eq:
   39  00:C82A  22           sax
   40  00:C82B  D2 00        cmp [__stack]
   41  00:C82D  D0 18        bne .eq_endno
   42                     
   43  00:C82F  A0 01        ldy #1
   44  00:C831  22           sax
   45  00:C832  D1 00        cmp [__stack],Y
   46  00:C834  D0 11        bne .eq_endno
   47                     
   48  00:C836            .eq_endyes:
   49                        addw #2,<__stack   ; don't push A/X; they are thrown away
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       00:C836  18                 clc
       00:C837  A5 00              lda    LOW_BYTE <__stack
       00:C839  69 02              adc    LOW_BYTE #2
       00:C83B  85 00              sta    LOW_BYTE <__stack
       00:C83D  A5 01              lda    HIGH_BYTE <__stack
       00:C83F  69 00              adc    HIGH_BYTE #2
       00:C841  85 01              sta    HIGH_BYTE <__stack
                                  .endif
   50  00:C843  A9 FF        lda  #$FF        ; A=255 -> true
   51  00:C845  82           clx
   52  00:C846  60           rts
   53                     
   54  00:C847            .eq_endno:
   55                        addw #2,<__stack
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       00:C847  18                 clc
       00:C848  A5 00              lda    LOW_BYTE <__stack
       00:C84A  69 02              adc    LOW_BYTE #2
       00:C84C  85 00              sta    LOW_BYTE <__stack
       00:C84E  A5 01              lda    HIGH_BYTE <__stack
       00:C850  69 00              adc    HIGH_BYTE #2
       00:C852  85 01              sta    HIGH_BYTE <__stack
                                  .endif
   56  00:C854  A9 00        lda  #0
   57  00:C856  82           clx
   58  00:C857  60           rts
   59                     
   60                     ; streamlined version MACRO - uses zp ( <__temp ) instead of stack
   61                     ; returns A:X = 0 if false, FF00 if true
   62                     ; 15 bytes, best = 12 cycles; worst = 23
   63                             
   64  00:C858            eqzp:
   65  00:C858  C5 04             cmp   <__temp+1
   66  00:C85A  D0 09             bne   .x_ne
   67  00:C85C  22                sax
   68  00:C85D  C5 03             cmp   <__temp
   69  00:C85F  D0 04             bne   .x_ne
   70  00:C861  A9 FF             lda   #$FF      ; ensure Z flag not set
   71  00:C863  80 02             bra   .x1_eq
   72  00:C865            .x_ne:
   73  00:C865  A9 00             lda   #0        ; ensure Z flag set
   74  00:C867            .x1_eq:
   75  00:C867  82                clx
   76  00:C868  60                rts
   77                     
   78                     
   79                     ; ----
   80                     ; lt
   81                     ; ----
   82                     ; compare two words
   83                     ; ----
   84                     ; IN :  First word on the C stack
   85                     ;       Another word in A:X
   86                     ; ----
   87                     ; OUT : word A:X is non nul if pushed word is strictly lower than
   88                     ;       the word in A:X else nul
   89                     ; ----
   90                     
   91  00:C869            lt:     ; signed version
   92  00:C869  A0 01        ldy #1
   93  00:C86B  C9 80        cmp #$80
   94  00:C86D  B0 0A        bcs lt_primary_minus
   95                     
   96                             ; if here, the A:X value is positive
   97                     
   98  00:C86F  85 03        sta <__temp
   99  00:C871  B1 00        lda [__stack], Y
  100  00:C873  30 55        bmi cmp_ok   ; stack value is negative, so reply OK
  101                     
  102  00:C875  A5 03        lda <__temp   ; stack value is also positive, so just go for the unsigned version
  103  00:C877  80 1B        bra ult_y1
  104                     
  105                        
  106  00:C879            lt_primary_minus:
  107                     
  108                             ; if here, the A:X value is negative
  109                     
  110  00:C879  85 03        sta <__temp
  111  00:C87B  B1 00        lda [__stack], Y
  112  00:C87D  30 11        bmi getA_ult ; stack value is also negative, so restore A val from
  113                                             ; __temp and call ult
  114                     
  115  00:C87F            cmp_false:
  116                        addw #2,<__stack     ; OK to kill A/X
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       00:C87F  18                 clc
       00:C880  A5 00              lda    LOW_BYTE <__stack
       00:C882  69 02              adc    LOW_BYTE #2
       00:C884  85 00              sta    LOW_BYTE <__stack
       00:C886  A5 01              lda    HIGH_BYTE <__stack
       00:C888  69 00              adc    HIGH_BYTE #2
       00:C88A  85 01              sta    HIGH_BYTE <__stack
                                  .endif
  117  00:C88C  A9 00        lda  #0
  118  00:C88E  82           clx
  119  00:C88F  60           rts
  120                     
  121  00:C890            getA_ult:
  122  00:C890  A5 03        lda <__temp
  123                     
  124  00:C892            ult:    ; unsigned version
  125  00:C892  A0 01        ldy #1       ; false by default
  126                     
  127  00:C894            ult_y1: ; same thing but Y is assumed to be egal to 1
  128                     
  129  00:C894  D1 00        cmp [__stack],Y
  130  00:C896  F0 04        beq .lt_must_test_lobyte
  131  00:C898  B0 30        bcs cmp_ok
  132  00:C89A  80 07        bra .lt_end ; hibyte of the reg var < hibyte of the pushed var
  133                     
  134  00:C89C            .lt_must_test_lobyte:
  135  00:C89C  22           sax
  136  00:C89D  D2 00        cmp [__stack]
  137  00:C89F  F0 02        beq .lt_end
  138  00:C8A1  B0 27        bcs cmp_ok        ; set result to true
  139                                          ; lobyte of the reg var < lobyte of the pushed var
  140                     
  141  00:C8A3            .lt_end:
  142                        addw      #2,<__stack
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       00:C8A3  18                 clc
       00:C8A4  A5 00              lda    LOW_BYTE <__stack
       00:C8A6  69 02              adc    LOW_BYTE #2
       00:C8A8  85 00              sta    LOW_BYTE <__stack
       00:C8AA  A5 01              lda    HIGH_BYTE <__stack
       00:C8AC  69 00              adc    HIGH_BYTE #2
       00:C8AE  85 01              sta    HIGH_BYTE <__stack
                                  .endif
  143                     
  144  00:C8B0  98           tya          ; if Y was 1, return A=X=0 -> false
  145  00:C8B1  3A           dec A        ; if Y was 0, return A=255 -> true
  146                     
  147  00:C8B2  82           clx
  148  00:C8B3  60           rts
  149                     
  150                     
  151                     
  152                     ; ----
  153                     ; gt
  154                     ; ----
  155                     ; compare two words
  156                     ; ----
  157                     ; IN :  First word on the C stack
  158                     ;       Another word in A:X
  159                     ; ----
  160                     ; OUT : word A:X is non nul if pushed word is strictly greater than
  161                     ;       the word in A:X else nul
  162                     ; ----
  163                     
  164  00:C8B4            gt:     ; signed version of >
  165  00:C8B4  A0 01        ldy #1
  166  00:C8B6  C9 80        cmp #$80
  167  00:C8B8  B0 0A        bcs .gt_primary_minus
  168                     
  169                             ; if here, the A:X value is positive
  170                     
  171  00:C8BA  85 03        sta <__temp
  172  00:C8BC  B1 00        lda [__stack], Y
  173  00:C8BE  30 BF        bmi cmp_false ; stack value is negative, so reply False
  174                     
  175  00:C8C0  A5 03        lda <__temp   ; stack value is also positive, so just go for the unsigned version
  176  00:C8C2  80 1B        bra ugt_y1   ; we spare one instruction, since we already have Y=1
  177                     
  178  00:C8C4            .gt_primary_minus:
  179                     
  180                             ; if here, the A:X value is negative
  181                     
  182  00:C8C4  85 03        sta <__temp
  183  00:C8C6  B1 00        lda [__stack], Y
  184  00:C8C8  30 11        bmi getA_ugt ; stack value is also negative, so restore A val from
  185                                             ; __temp and call ugt
  186                     
  187  00:C8CA            cmp_ok:
  188                        addw #2,<__stack     ; OK to kill A/X
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       00:C8CA  18                 clc
       00:C8CB  A5 00              lda    LOW_BYTE <__stack
       00:C8CD  69 02              adc    LOW_BYTE #2
       00:C8CF  85 00              sta    LOW_BYTE <__stack
       00:C8D1  A5 01              lda    HIGH_BYTE <__stack
       00:C8D3  69 00              adc    HIGH_BYTE #2
       00:C8D5  85 01              sta    HIGH_BYTE <__stack
                                  .endif
  189  00:C8D7  A9 FF        lda #$FF
  190  00:C8D9  82           clx
  191  00:C8DA  60           rts
  192                     
  193  00:C8DB            getA_ugt:       ; we grab back the value of A before entering the unsigned
  194                                     ; version of >
  195  00:C8DB  A5 03        lda <__temp
  196                     
  197  00:C8DD            ugt:    ; unsigned version of >
  198                     
  199  00:C8DD  A0 01        ldy #1
  200                     
  201  00:C8DF            ugt_y1: ; unsigned version of >, assuming Y = 1
  202                     
  203  00:C8DF  D1 00        cmp [__stack],Y
  204  00:C8E1  F0 05        beq .gt_must_test_lobyte
  205  00:C8E3  B0 09        bcs .gt_end ; hibyte of the reg var >= hibyte of the pushed var
  206  00:C8E5  C2           cly
  207  00:C8E6  80 06        bra .gt_end
  208                     
  209  00:C8E8            .gt_must_test_lobyte
  210  00:C8E8  22           sax
  211  00:C8E9  D2 00        cmp [__stack]
  212  00:C8EB  B0 01        bcs .gt_end       ; lobyte of the reg var >= lobyte of the pushed var
  213  00:C8ED  C2           cly
  214                     
  215  00:C8EE            .gt_end:
  216                        addw      #2,<__stack
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       00:C8EE  18                 clc
       00:C8EF  A5 00              lda    LOW_BYTE <__stack
       00:C8F1  69 02              adc    LOW_BYTE #2
       00:C8F3  85 00              sta    LOW_BYTE <__stack
       00:C8F5  A5 01              lda    HIGH_BYTE <__stack
       00:C8F7  69 00              adc    HIGH_BYTE #2
       00:C8F9  85 01              sta    HIGH_BYTE <__stack
                                  .endif
  217  00:C8FB  98           tya
  218  00:C8FC  3A           dec A
  219  00:C8FD  82           clx
  220  00:C8FE  60           rts
  221                     
  222                     
  223                     ; ----
  224                     ; zero page versions of lt/gt/ult/ugt:
  225                     ; ----
  226                     
  227  00:C8FF            ltzp:   ; signed, zero page
  228  00:C8FF  85 05             sta     <__temp+2
  229  00:C901  45 04             eor     <__temp+1
  230  00:C903  10 0C             bpl     .geta_ult
  231  00:C905  A5 05             lda     <__temp+2
  232  00:C907  10 04             bpl     .true
  233  00:C909  A9 00     .false: lda     #0
  234  00:C90B  82                clx
  235  00:C90C  60                rts
  236  00:C90D  A9 FF     .true:  lda     #$ff
  237  00:C90F  82                clx
  238  00:C910  60                rts
  239  00:C911            .geta_ult:
  240  00:C911  A5 05             lda     <__temp+2       ; and fall through to unsigned test
  241                     
  242  00:C913  C5 04     ultzp:  cmp     <__temp+1
  243  00:C915  F0 06             beq     .test_lo
  244  00:C917  90 0B             bcc     .false
  245  00:C919  A9 FF     .true:  lda     #$ff
  246  00:C91B  82                clx
  247  00:C91C  60                rts
  248  00:C91D            .test_lo:
  249  00:C91D  22                sax
  250  00:C91E  C5 03             cmp     <__temp
  251  00:C920  F0 02             beq     .false
  252  00:C922  B0 F5             bcs     .true
  253  00:C924  A9 00     .false: lda     #0
  254  00:C926  82                clx
  255  00:C927  60                rts
  256                     ; ----
  257  00:C928            gtzp:   ; signed, zero page
  258  00:C928  85 05             sta     <__temp+2
  259  00:C92A  45 04             eor     <__temp+1
  260  00:C92C  10 0C             bpl     .geta_ugt
  261  00:C92E  A5 05             lda     <__temp+2
  262  00:C930  10 04             bpl     .false
  263  00:C932  A9 FF     .true:  lda     #$ff
  264  00:C934  82                clx
  265  00:C935  60                rts
  266  00:C936  A9 00     .false: lda     #0
  267  00:C938  82                clx
  268  00:C939  60                rts
  269  00:C93A            .geta_ugt:
  270  00:C93A  A5 05             lda     <__temp+2       ; and fall through to unsigned test
  271                     
  272  00:C93C            ugtzp:
  273  00:C93C  C5 04             cmp     <__temp+1
  274  00:C93E  F0 06             beq     .test_lo
  275  00:C940  B0 0B             bcs     .false
  276  00:C942  A9 FF     .true:  lda     #$ff
  277  00:C944  82                clx
  278  00:C945  60                rts
  279  00:C946            .test_lo:
  280  00:C946  22                sax
  281  00:C947  C5 03             cmp     <__temp
  282  00:C949  F0 02             beq     .false
  283  00:C94B  90 F5             bcc     .true
  284  00:C94D  A9 00     .false: lda     #0
  285  00:C94F  82                clx
  286  00:C950  60                rts
  287                     
  288                     
  289                     ; ----
  290                     ; ge
  291                     ; ----
  292                     ; compare two signed words
  293                     ; ----
  294                     ; IN :  First word on the C stack
  295                     ;       Another word in A:X
  296                     ; ----
  297                     ; OUT : word A:X is non nul if pushed word is greater or egal to
  298                     ;       the word in A:X else nul
  299                     ; ----
  300                     
  301  00:C951            ge:     ; signed version of >
  302  00:C951  20 69 C8      jsr lt
  303  00:C954  1A            inc A   ; assuming that true is represented by A = 255
  304  00:C955  60            rts
  305                     
  306  00:C956  20 FF C8  gezp:   jsr     ltzp
  307  00:C959  49 FF             eor     #$ff
  308  00:C95B  60                rts
  309                     
  310                     ; ----
  311                     ; uge
  312                     ; ----
  313                     ; compare two unsigned signed words
  314                     ; ----
  315                     ; IN :  First word on the C stack
  316                     ;       Another word in A:X
  317                     ; ----
  318                     ; OUT : word A:X is non nul if pushed word is greater or egal to
  319                     ;       the word in A:X else nul
  320                     ; ----
  321                     
  322  00:C95C            uge:    ; unsigned version of >
  323  00:C95C  20 92 C8      jsr ult
  324  00:C95F  1A            inc A   ; assuming that true is represented by A = 255
  325  00:C960  60            rts
  326                     
  327  00:C961  20 13 C9  ugezp:  jsr     ultzp
  328  00:C964  49 FF             eor     #$ff
  329  00:C966  60                rts
  330                     
  331                     ; ----
  332                     ; ne
  333                     ; ----
  334                     ; compare two words
  335                     ; ----
  336                     ; IN :  First word on the C stack
  337                     ;       Another word in A:X
  338                     ; ----
  339                     ; OUT : word A:X is non null if pushed word is different from
  340                     ;       the word in A:X else null
  341                     ; ----
  342                     ; REMARK : signed compatible
  343                     ; ----
  344                     
  345                             ; previous version called 'eq' as subroutine and returned
  346                             ; opposite value; should be fully implemented for speed
  347                             ; since '!=' is such a common operand
  348                     
  349  00:C967            ne:
  350  00:C967  22           sax
  351  00:C968  D2 00        cmp [__stack]
  352  00:C96A  D0 18        bne .ne_endne
  353                     
  354  00:C96C  A0 01        ldy #1
  355  00:C96E  22           sax
  356  00:C96F  D1 00        cmp [__stack],Y
  357  00:C971  D0 11        bne .ne_endne
  358                     
  359  00:C973            .ne_endeq:
  360                        addw #2,<__stack   ; don't push A/X; they are thrown away
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       00:C973  18                 clc
       00:C974  A5 00              lda    LOW_BYTE <__stack
       00:C976  69 02              adc    LOW_BYTE #2
       00:C978  85 00              sta    LOW_BYTE <__stack
       00:C97A  A5 01              lda    HIGH_BYTE <__stack
       00:C97C  69 00              adc    HIGH_BYTE #2
       00:C97E  85 01              sta    HIGH_BYTE <__stack
                                  .endif
  361  00:C980  A9 00        lda  #0
  362  00:C982  82           clx
  363  00:C983  60           rts
  364                     
  365  00:C984            .ne_endne:
  366                        addw #2,<__stack
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       00:C984  18                 clc
       00:C985  A5 00              lda    LOW_BYTE <__stack
       00:C987  69 02              adc    LOW_BYTE #2
       00:C989  85 00              sta    LOW_BYTE <__stack
       00:C98B  A5 01              lda    HIGH_BYTE <__stack
       00:C98D  69 00              adc    HIGH_BYTE #2
       00:C98F  85 01              sta    HIGH_BYTE <__stack
                                  .endif
  367  00:C991  A9 FF        lda  #$ff
  368  00:C993  82           clx
  369  00:C994  60           rts
  370                     
  371                     ; streamlined version MACRO - uses zp ( <__temp ) instead of stack
  372                     ; returns A:X = 0 if false, FF00 if true
  373                     ; 15 bytes, best = 12 cycles; worst = 23
  374                     
  375  00:C995            nezp:
  376  00:C995  C5 04             cmp   <__temp+1
  377  00:C997  D0 09             bne   .x_ne
  378  00:C999  22                sax
  379  00:C99A  C5 03             cmp   <__temp
  380  00:C99C  D0 04             bne   .x_ne
  381  00:C99E  A9 00             lda   #0        ; ensure Z flag set
  382  00:C9A0  80 02             bra   .x1_eq
  383  00:C9A2            .x_ne:
  384  00:C9A2  A9 FF             lda   #$ff      ; ensure Z flag not set
  385  00:C9A4            .x1_eq:
  386  00:C9A4  82                clx
  387  00:C9A5  60                rts
  388                     
  389                     ; ----
  390                     ; le
  391                     ; ----
  392                     ; compare two signed words
  393                     ; ----
  394                     ; IN :  First word on the C stack
  395                     ;       Another word in A:X
  396                     ; ----
  397                     ; OUT : word A:X is non nul if pushed word is lower or egal to
  398                     ;       the word in A:X else nul
  399                     ; ----
  400                     
  401  00:C9A6            le:     ; signed version
  402  00:C9A6  20 B4 C8      jsr gt
  403  00:C9A9  1A            inc A       ; assuming that A=255 if true
  404  00:C9AA  60            rts
  405                     
  406  00:C9AB  20 28 C9  lezp:   jsr     gtzp
  407  00:C9AE  49 FF             eor     #$ff
  408  00:C9B0  60                rts
  409                     
  410                     ; ----
  411                     ; ule
  412                     ; ----
  413                     ; compare two unsigned words
  414                     ; ----
  415                     ; IN :  First word on the C stack
  416                     ;       Another word in A:X
  417                     ; ----
  418                     ; OUT : word A:X is non nul if pushed word is lower or egal to
  419                     ;       the word in A:X else nul
  420                     ; ----
  421                     
  422  00:C9B1            ule:    ; unsigned version
  423  00:C9B1  20 DD C8      jsr ugt
  424  00:C9B4  1A            inc A       ; assuming that A=255 if true
  425  00:C9B5  60            rts
  426                     
  427  00:C9B6  20 3C C9  ulezp:  jsr     ugtzp
  428  00:C9B9  49 FF             eor     #$ff
  429  00:C9BB  60                rts
  430                     
  431                     
  432                     ; ----
  433                     ; asl
  434                     ; ----
  435                     ; shift the pushed word left by the register word
  436                     ; ----
  437                     ; IN :  First word on the C stack
  438                     ;       Another word in A:X
  439                     ; ----
  440                     ; OUT : Register word egals the previous pushed value
  441                     ;       shifted left by A:X
  442                     ; ----
  443                     ; REMARK : only the lower byte of the right operand is taken in account
  444                     ;          signed compatible
  445                     ; ----
  446  00:C9BC            asl:
  447  00:C9BC  86 03        stx <__temp
  448                        __ldwp __stack
       00:C9BE  B2 00              lda    [__stack]
       00:C9C0  AA                 tax
       00:C9C1  A0 01              ldy    #1
       00:C9C3  B1 00              lda    [__stack],Y
  449  00:C9C5  A4 03        ldy <__temp
  450  00:C9C7  F0 0C        beq .asl_end
  451  00:C9C9  85 03        sta <__temp
  452  00:C9CB  22           sax
  453                     
  454  00:C9CC            .asl_begin
  455  00:C9CC  0A           asl a
  456  00:C9CD  26 03        rol <__temp
  457  00:C9CF  88           dey
  458  00:C9D0  D0 FA        bne .asl_begin
  459                     
  460  00:C9D2  22           sax
  461  00:C9D3  A5 03        lda <__temp
  462  00:C9D5            .asl_end
  463  00:C9D5  A8           tay
  464                        addw #2,<__stack
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       00:C9D6  18                 clc
       00:C9D7  A5 00              lda    LOW_BYTE <__stack
       00:C9D9  69 02              adc    LOW_BYTE #2
       00:C9DB  85 00              sta    LOW_BYTE <__stack
       00:C9DD  A5 01              lda    HIGH_BYTE <__stack
       00:C9DF  69 00              adc    HIGH_BYTE #2
       00:C9E1  85 01              sta    HIGH_BYTE <__stack
                                  .endif
  465  00:C9E3  98           tya
  466  00:C9E4  60           rts
  467                     
  468                     
  469                     ; ----
  470                     ; asr
  471                     ; ----
  472                     ; shift the pushed word right by the register word
  473                     ; ----
  474                     ; IN :  First word on the C stack
  475                     ;       Another word in A:X
  476                     ; ----
  477                     ; OUT : Register word egals the previous pushed value
  478                     ;       shifted right by A:X
  479                     ; ----
  480                     ; REMARK : only the lower byte of the right operand is taken in account
  481                     ;          signed compatible
  482                     ; ----
  483  00:C9E5            asr:
  484  00:C9E5  86 03        stx <__temp
  485                        __ldwp __stack
       00:C9E7  B2 00              lda    [__stack]
       00:C9E9  AA                 tax
       00:C9EA  A0 01              ldy    #1
       00:C9EC  B1 00              lda    [__stack],Y
  486  00:C9EE  A4 03        ldy <__temp
  487  00:C9F0  F0 0E        beq .asr_end
  488  00:C9F2  85 03        sta <__temp
  489  00:C9F4  22           sax
  490                     
  491  00:C9F5            .asr_begin
  492  00:C9F5  E0 80        cpx #$80
  493  00:C9F7  66 03        ror <__temp
  494  00:C9F9  6A           ror a
  495                     
  496  00:C9FA  88           dey
  497  00:C9FB  D0 F8        bne .asr_begin
  498                     
  499  00:C9FD  22           sax
  500  00:C9FE  A5 03        lda <__temp
  501  00:CA00            .asr_end
  502  00:CA00  A8           tay
  503                        addw #2,<__stack
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       00:CA01  18                 clc
       00:CA02  A5 00              lda    LOW_BYTE <__stack
       00:CA04  69 02              adc    LOW_BYTE #2
       00:CA06  85 00              sta    LOW_BYTE <__stack
       00:CA08  A5 01              lda    HIGH_BYTE <__stack
       00:CA0A  69 00              adc    HIGH_BYTE #2
       00:CA0C  85 01              sta    HIGH_BYTE <__stack
                                  .endif
  504  00:CA0E  98           tya
  505  00:CA0F  60           rts
  506                     
  507                     
  508                     ; ----
  509                     ; smul
  510                     ; ----
  511                     ; multiply two SIGNED words
  512                     ; ----
  513                     ; IN :  First word on the C stack
  514                     ;       Another word in A:X
  515                     ; ----
  516                     ; OUT : Register word egals the previous pushed value
  517                     ;       multiplied by A:X
  518                     ; ----
  519                     
  520  00:CA10            smul:
  521  00:CA10  64 16             stz <__sign      ; until we call umul, __sign keeps the sign parity
  522                                             ; of operand
  523  00:CA12  C9 80             cmp #$80
  524  00:CA14  90 0D             bcc smul_no_invert_primary
  525                     
  526                             __negw
       00:CA16  22                 sax
       00:CA17  49 FF              eor    #$FF
       00:CA19  18                 clc
       00:CA1A  69 01              adc    #1
       00:CA1C  22                 sax
       00:CA1D  49 FF              eor    #$FF
       00:CA1F  69 00              adc    #0
  527                     
  528  00:CA21  E6 16             inc <__sign      ; __sign ++
  529                     
  530  00:CA23            smul_no_invert_primary:
  531                     
  532  00:CA23  85 03             sta <__temp
  533  00:CA25  A0 01             ldy #1
  534  00:CA27  B1 00             lda [__stack],Y
  535  00:CA29  C9 80             cmp #$80
  536  00:CA2B  90 1B             bcc smul_no_invert_secondary
  537                     
  538  00:CA2D  E6 16             inc <__sign      ; this time, no optimisation possible, IMHO :)
  539                                             ; are you sure? :))
  540  00:CA2F  86 04             stx <__temp+1
  541                     
  542  00:CA31  B2 00             lda [__stack]
  543  00:CA33  AA                tax
  544  00:CA34  B1 00             lda [__stack],Y ; we assumed Y = 1 since we set it at the beginning of
  545                                             ; smul_no_invert_primary
  546                             __negw
       00:CA36  22                 sax
       00:CA37  49 FF              eor    #$FF
       00:CA39  18                 clc
       00:CA3A  69 01              adc    #1
       00:CA3C  22                 sax
       00:CA3D  49 FF              eor    #$FF
       00:CA3F  69 00              adc    #0
  547  00:CA41  91 00             sta [__stack],Y
  548  00:CA43  22                sax
  549  00:CA44  92 00             sta [__stack]
  550                     
  551  00:CA46  A6 04             ldx <__temp+1
  552                     
  553  00:CA48            smul_no_invert_secondary:
  554                     
  555  00:CA48  A5 16             lda <__sign
  556  00:CA4A  48                pha
  557  00:CA4B  A5 03             lda <__temp      ; saved at the beginning of smul_no_invert_primary
  558                                             ; where we're sure we passed
  559                     
  560  00:CA4D  20 65 CA          jsr umul
  561                     
  562  00:CA50  42                say
  563  00:CA51  68                pla
  564  00:CA52  29 01             and #$01
  565  00:CA54  F0 0D             beq smul_end
  566                     
  567  00:CA56  42                say
  568                             __negw
       00:CA57  22                 sax
       00:CA58  49 FF              eor    #$FF
       00:CA5A  18                 clc
       00:CA5B  69 01              adc    #1
       00:CA5D  22                 sax
       00:CA5E  49 FF              eor    #$FF
       00:CA60  69 00              adc    #0
  569  00:CA62  60                rts
  570                     
  571  00:CA63            smul_end:
  572  00:CA63  42                say
  573  00:CA64  60                rts
  574                     
  575                     
  576                     ; ----
  577                     ; umul
  578                     ; ----
  579                     ; multiply two UNSIGNED words
  580                     ; ----
  581                     ; IN :  First word on the C stack
  582                     ;       Another word in A:X
  583                     ; ----
  584                     ; OUT : Register word egals the previous pushed value
  585                     ;       multiplied by A:X
  586                     ; ----
  587                     
  588  00:CA65            umul:
  589                             __stw   <__temp+2 ; bx
       00:CA65  86 05              stx    <__temp+2
       00:CA67  85 06              sta    <__temp+2+1
  590                             __ldwp  __stack
       00:CA69  B2 00              lda    [__stack]
       00:CA6B  AA                 tax
       00:CA6C  A0 01              ldy    #1
       00:CA6E  B1 00              lda    [__stack],Y
  591                             __stw   <__temp   ; ax
       00:CA70  86 03              stx    <__temp
       00:CA72  85 04              sta    <__temp+1
  592  00:CA74  20 89 CA            jsr   umul16
  593                               addw  #2,<__stack
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       00:CA77  18                 clc
       00:CA78  A5 00              lda    LOW_BYTE <__stack
       00:CA7A  69 02              adc    LOW_BYTE #2
       00:CA7C  85 00              sta    LOW_BYTE <__stack
       00:CA7E  A5 01              lda    HIGH_BYTE <__stack
       00:CA80  69 00              adc    HIGH_BYTE #2
       00:CA82  85 01              sta    HIGH_BYTE <__stack
                                  .endif
  594                             __ldw   <__ptr
                0000              .if (1 = 2)
                                  .else
       00:CA84  A6 0B              ldx    <__ptr
       00:CA86  A5 0C              lda    <__ptr+1
                                  .endif
  595  00:CA88  60                  rts
  596  00:CA89            umul16:
  597  00:CA89  A5 06               lda   <__temp+3
  598  00:CA8B  05 04               ora   <__temp+1
  599  00:CA8D  F0 21               beq   umul8
  600                               stwz  <__ptr
       00:CA8F  64 0B              stz    LOW_BYTE <__ptr
       00:CA91  64 0C              stz    HIGH_BYTE <__ptr
  601  00:CA93  A0 10               ldy   #16
  602                     
  603                     .l1:      aslw  <__ptr
       00:CA95  06 0B              asl    <__ptr              ; word-sized value (at stated
       00:CA97  26 0C              rol    <__ptr+1            ; memory location)
  604                               aslw  <__temp+2
       00:CA99  06 05              asl    <__temp+2              ; word-sized value (at stated
       00:CA9B  26 06              rol    <__temp+2+1            ; memory location)
  605  00:CA9D  90 0D               bcc   .l2
  606                               addw  <__temp,<__ptr
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       00:CA9F  18                 clc
       00:CAA0  A5 0B              lda    LOW_BYTE <__ptr
       00:CAA2  65 03              adc    LOW_BYTE <__temp
       00:CAA4  85 0B              sta    LOW_BYTE <__ptr
       00:CAA6  A5 0C              lda    HIGH_BYTE <__ptr
       00:CAA8  65 04              adc    HIGH_BYTE <__temp
       00:CAAA  85 0C              sta    HIGH_BYTE <__ptr
                                  .endif
  607  00:CAAC  88        .l2:      dey
  608  00:CAAD  D0 E6               bne   .l1
  609  00:CAAF  60                  rts
  610  00:CAB0            umul8:
  611  00:CAB0  A5 05               lda   <__temp+2
  612  00:CAB2  85 0C               sta   <__ptr+1
  613  00:CAB4  62                  cla
  614  00:CAB5  A0 08               ldy   #8
  615                     
  616  00:CAB7  0A        .l1:      asl   A
  617  00:CAB8  26 0C               rol   <__ptr+1
  618  00:CABA  90 07               bcc   .l2
  619                               add   <__temp
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       00:CABC  18                 clc
       00:CABD  65 03              adc    <__temp
                                  .endif
  620  00:CABF  90 02               bcc   .l2
  621  00:CAC1  E6 0C               inc   <__ptr+1
  622  00:CAC3  88        .l2:      dey
  623  00:CAC4  D0 F1               bne   .l1
  624                     
  625  00:CAC6  85 0B               sta   <__ptr
  626  00:CAC8  60                  rts
  627                     
  628                     
  629                     ; ----
  630                     ; sdiv
  631                     ; ----
  632                     ; divide two SIGNED words
  633                     ; ----
  634                     ; IN :  First word on the C stack
  635                     ;       Another word in A:X
  636                     ; ----
  637                     ; OUT : Register word egals the previous pushed value
  638                     ;       divided by A:X
  639                     ; ----
  640                     
  641  00:CAC9            sdiv:
  642  00:CAC9  64 16             stz <__sign      ; until we call udiv, __sign keeps the sign parity
  643                                             ; of operand
  644  00:CACB  C9 80             cmp #$80
  645  00:CACD  90 0D             bcc sdiv_no_invert_primary
  646                     
  647                             __negw
       00:CACF  22                 sax
       00:CAD0  49 FF              eor    #$FF
       00:CAD2  18                 clc
       00:CAD3  69 01              adc    #1
       00:CAD5  22                 sax
       00:CAD6  49 FF              eor    #$FF
       00:CAD8  69 00              adc    #0
  648                     
  649  00:CADA  E6 16             inc <__sign      ; __sign ++
  650                     
  651  00:CADC            sdiv_no_invert_primary:
  652                     
  653  00:CADC  85 03             sta <__temp
  654  00:CADE  A0 01             ldy #1
  655  00:CAE0  B1 00             lda [__stack],Y
  656  00:CAE2  C9 80             cmp #$80
  657  00:CAE4  90 1B             bcc sdiv_no_invert_secondary
  658                     
  659  00:CAE6  E6 16             inc <__sign
  660                     
  661  00:CAE8  86 04             stx <__temp+1
  662                     
  663  00:CAEA  B2 00             lda [__stack]
  664  00:CAEC  AA                tax
  665  00:CAED  B1 00             lda [__stack],Y ; we assumed Y = 1 since we set it at the beginning of
  666                                             ; sdiv_no_invert_primary
  667                             __negw
       00:CAEF  22                 sax
       00:CAF0  49 FF              eor    #$FF
       00:CAF2  18                 clc
       00:CAF3  69 01              adc    #1
       00:CAF5  22                 sax
       00:CAF6  49 FF              eor    #$FF
       00:CAF8  69 00              adc    #0
  668  00:CAFA  91 00             sta [__stack],Y
  669  00:CAFC  22                sax
  670  00:CAFD  92 00             sta [__stack]
  671                     
  672  00:CAFF  A6 04             ldx <__temp+1
  673                     
  674  00:CB01            sdiv_no_invert_secondary:
  675                     
  676  00:CB01  A5 16             lda <__sign
  677  00:CB03  48                pha
  678  00:CB04  A5 03             lda <__temp      ; saved at the beginning of sdiv_no_invert_primary
  679                                             ; where we're sure we passed
  680  00:CB06  20 1E CB          jsr udiv
  681                     
  682  00:CB09  42                say
  683  00:CB0A  68                pla
  684  00:CB0B  29 01             and #$01
  685  00:CB0D  F0 0D             beq sdiv_end
  686                     
  687  00:CB0F  42                say
  688                             __negw
       00:CB10  22                 sax
       00:CB11  49 FF              eor    #$FF
       00:CB13  18                 clc
       00:CB14  69 01              adc    #1
       00:CB16  22                 sax
       00:CB17  49 FF              eor    #$FF
       00:CB19  69 00              adc    #0
  689  00:CB1B  60                rts
  690                     
  691  00:CB1C            sdiv_end:
  692  00:CB1C  42                say
  693  00:CB1D  60                rts
  694                     
  695                     
  696                     ; ----
  697                     ; udiv
  698                     ; ----
  699                     ; divide two UNSIGNED words
  700                     ; ----
  701                     ; IN :  First word on the C stack
  702                     ;       Another word in A:X
  703                     ; ----
  704                     ; OUT : Register word egals the previous pushed value
  705                     ;       divided by A:X
  706                     ; ----
  707                     
  708  00:CB1E            udiv:
  709                             __stw   <__ptr
       00:CB1E  86 0B              stx    <__ptr
       00:CB20  85 0C              sta    <__ptr+1
  710                             __ldwp  __stack
       00:CB22  B2 00              lda    [__stack]
       00:CB24  AA                 tax
       00:CB25  A0 01              ldy    #1
       00:CB27  B1 00              lda    [__stack],Y
  711                             __stw   <__temp
       00:CB29  86 03              stx    <__temp
       00:CB2B  85 04              sta    <__temp+1
  712                     
  713  00:CB2D  A9 00             lda     #0
  714  00:CB2F  85 17             sta     <__remain+1
  715  00:CB31  A0 10             ldy     #16
  716  00:CB33  06 03     .sdiv_begin:    asl     <__temp
  717  00:CB35  26 04             rol     <__temp+1
  718  00:CB37  2A                rol     a
  719  00:CB38  26 17             rol     <__remain+1
  720  00:CB3A  48                pha
  721  00:CB3B  C5 0B             cmp     <__ptr
  722  00:CB3D  A5 17             lda     <__remain+1
  723  00:CB3F  E5 0C             sbc     <__ptr+1
  724  00:CB41  90 08             bcc     .sdiv_end
  725  00:CB43  85 17             sta     <__remain+1
  726  00:CB45  68                pla
  727  00:CB46  E5 0B             sbc     <__ptr
  728  00:CB48  48                pha
  729  00:CB49  E6 03             inc     <__temp
  730  00:CB4B  68        .sdiv_end:      pla
  731  00:CB4C  88                dey
  732  00:CB4D  D0 E4             bne     .sdiv_begin
  733  00:CB4F  85 16             sta     <__remain
  734                     
  735                             addw  #2,<__stack
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       00:CB51  18                 clc
       00:CB52  A5 00              lda    LOW_BYTE <__stack
       00:CB54  69 02              adc    LOW_BYTE #2
       00:CB56  85 00              sta    LOW_BYTE <__stack
       00:CB58  A5 01              lda    HIGH_BYTE <__stack
       00:CB5A  69 00              adc    HIGH_BYTE #2
       00:CB5C  85 01              sta    HIGH_BYTE <__stack
                                  .endif
  736                             __ldw <__temp
                0000              .if (1 = 2)
                                  .else
       00:CB5E  A6 03              ldx    <__temp
       00:CB60  A5 04              lda    <__temp+1
                                  .endif
  737                     
  738  00:CB62  60                rts
  739                     
  740                     
  741                     ; ----
  742                     ; smod
  743                     ; ----
  744                     ; give the integer remainder of the two words
  745                     ; ----
  746                     ; IN :  First word on the C stack
  747                     ;       Another word in A:X
  748                     ; ----
  749                     ; OUT : Register word egals the remainder of the division of the
  750                     ;       pushed value by A:X
  751                     ; ----
  752                     ; REMARK : signed NON compatible
  753                     ; ----
  754                     
  755  00:CB63            smod:
  756  00:CB63            umod:
  757                             __stw   <__ptr
       00:CB63  86 0B              stx    <__ptr
       00:CB65  85 0C              sta    <__ptr+1
  758                             __ldwp  __stack
       00:CB67  B2 00              lda    [__stack]
       00:CB69  AA                 tax
       00:CB6A  A0 01              ldy    #1
       00:CB6C  B1 00              lda    [__stack],Y
  759                             __stw   <__temp
       00:CB6E  86 03              stx    <__temp
       00:CB70  85 04              sta    <__temp+1
  760                     
  761  00:CB72  A9 00             lda     #0
  762  00:CB74  85 17             sta     <__remain+1
  763  00:CB76  A0 10             ldy     #16
  764  00:CB78  06 03     .smod_begin:    asl     <__temp
  765  00:CB7A  26 04             rol     <__temp+1
  766  00:CB7C  2A                rol     a
  767  00:CB7D  26 17             rol     <__remain+1
  768  00:CB7F  48                pha
  769  00:CB80  C5 0B             cmp     <__ptr
  770  00:CB82  A5 17             lda     <__remain+1
  771  00:CB84  E5 0C             sbc     <__ptr+1
  772  00:CB86  90 08             bcc     .smod_end
  773  00:CB88  85 17             sta     <__remain+1
  774  00:CB8A  68                pla
  775  00:CB8B  E5 0B             sbc     <__ptr
  776  00:CB8D  48                pha
  777  00:CB8E  E6 03             inc     <__temp
  778  00:CB90  68        .smod_end:      pla
  779  00:CB91  88                dey
  780  00:CB92  D0 E4             bne     .smod_begin
  781  00:CB94  85 16             sta     <__remain
  782                     
  783                             addw  #2,<__stack
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       00:CB96  18                 clc
       00:CB97  A5 00              lda    LOW_BYTE <__stack
       00:CB99  69 02              adc    LOW_BYTE #2
       00:CB9B  85 00              sta    LOW_BYTE <__stack
       00:CB9D  A5 01              lda    HIGH_BYTE <__stack
       00:CB9F  69 00              adc    HIGH_BYTE #2
       00:CBA1  85 01              sta    HIGH_BYTE <__stack
                                  .endif
  784                             __ldw <__remain
                0000              .if (1 = 2)
                                  .else
       00:CBA3  A6 16              ldx    <__remain
       00:CBA5  A5 17              lda    <__remain+1
                                  .endif
  785                     
  786  00:CBA7  60                rts
  787                     
  788                     ; ----
  789                     ; ___case
  790                     ; ----
  791                     ; implement a switch instruction in C
  792                     ; ----
  793                     ; IN :  primary register (A:X) contain the discriminant value
  794                     ;       i.e. the one that will be checked against those indicated in the
  795                     ;       various case instructions
  796                     ;       On the stack, a pointer is passed
  797                     ;       This is a pointer toward an array
  798                     ;       Each item of this array is a 4 bytes long structure
  799                     ;       The structure is the following :
  800                     ;         WORD value_to_check
  801                     ;         WORD label_to_jump_to
  802                     ;       We have to parse the whole array in order to compare the primary
  803                     ;       register with all the 'value_to_check' field. If we ever find that
  804                     ;       the primary register is egal to such a value, we must jump to the
  805                     ;       corresponding 'label_to_jump_to'.
  806                     ;       The default value (which also means that we reached the end of the
  807                     ;       array) can be recognized with its 'label_to_jump_to' field set to 0.
  808                     ;       Then the 'value_to_check' field become the default label we have to
  809                     ;       use for the rest of the execution.
  810                     ; ----
  811                     ; OUT : The execution goes to another place
  812                     ; ----
  813                     ; REMARK : Also use __remain variable as a temporary value
  814                     ; ----
  815  00:CBA8            ___case:
  816                       __stw <__remain ; store the value to check to
       00:CBA8  86 16              stx    <__remain
       00:CBAA  85 17              sta    <__remain+1
  817                       __ldwp __stack
       00:CBAC  B2 00              lda    [__stack]
       00:CBAE  AA                 tax
       00:CBAF  A0 01              ldy    #1
       00:CBB1  B1 00              lda    [__stack],Y
  818                       __stw <__ptr ; __ptr contain the address of the array
       00:CBB3  86 0B              stx    <__ptr
       00:CBB5  85 0C              sta    <__ptr+1
  819                     
  820                       addw #2,<__stack
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       00:CBB7  18                 clc
       00:CBB8  A5 00              lda    LOW_BYTE <__stack
       00:CBBA  69 02              adc    LOW_BYTE #2
       00:CBBC  85 00              sta    LOW_BYTE <__stack
       00:CBBE  A5 01              lda    HIGH_BYTE <__stack
       00:CBC0  69 00              adc    HIGH_BYTE #2
       00:CBC2  85 01              sta    HIGH_BYTE <__stack
                                  .endif
  821                     
  822  00:CBC4            .begin_case:
  823                       addw #2,<__ptr
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       00:CBC4  18                 clc
       00:CBC5  A5 0B              lda    LOW_BYTE <__ptr
       00:CBC7  69 02              adc    LOW_BYTE #2
       00:CBC9  85 0B              sta    LOW_BYTE <__ptr
       00:CBCB  A5 0C              lda    HIGH_BYTE <__ptr
       00:CBCD  69 00              adc    HIGH_BYTE #2
       00:CBCF  85 0C              sta    HIGH_BYTE <__ptr
                                  .endif
  824                       __ldwp __ptr
       00:CBD1  B2 0B              lda    [__ptr]
       00:CBD3  AA                 tax
       00:CBD4  A0 01              ldy    #1
       00:CBD6  B1 0B              lda    [__ptr],Y
  825                       __tstw
                                   ; pha
       00:CBD8  86 03              stx    <__temp
       00:CBDA  05 03              ora    <__temp
                                   ; pla
  826                       __lbeq .end_case_default
       00:CBDC  D0 03              bne    .x00217
       00:CBDE  4C 44 CC           jmp    .end_case_default
       00:CBE1            .x00217
  827                     
  828                       addw  #-2,<__ptr
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       00:CBE1  18                 clc
       00:CBE2  A5 0B              lda    LOW_BYTE <__ptr
       00:CBE4  69 FE              adc    LOW_BYTE #-2
       00:CBE6  85 0B              sta    LOW_BYTE <__ptr
       00:CBE8  A5 0C              lda    HIGH_BYTE <__ptr
       00:CBEA  69 FF              adc    HIGH_BYTE #-2
       00:CBEC  85 0C              sta    HIGH_BYTE <__ptr
                                  .endif
  829                     
  830                       __ldwp __ptr
       00:CBEE  B2 0B              lda    [__ptr]
       00:CBF0  AA                 tax
       00:CBF1  A0 01              ldy    #1
       00:CBF3  B1 0B              lda    [__ptr],Y
  831                     
  832                       __addmi -2,__stack
       00:CBF5  48                 pha
       00:CBF6  18                 clc
       00:CBF7  A5 00              lda    <__stack
       00:CBF9  69 FE              adc    #low(-2)
       00:CBFB  85 00              sta    <__stack
       00:CBFD  A5 01              lda    <__stack+1
       00:CBFF  69 FF              adc    #high(-2)
       00:CC01  85 01              sta    <__stack+1
       00:CC03  68                 pla
  833                       __stwp __stack
       00:CC04  22                 sax
       00:CC05  92 00              sta    [__stack]
       00:CC07  22                 sax
       00:CC08  A0 01              ldy    #1
       00:CC0A  91 00              sta    [__stack],Y
  834                     
  835                       addw  #4,<__ptr
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       00:CC0C  18                 clc
       00:CC0D  A5 0B              lda    LOW_BYTE <__ptr
       00:CC0F  69 04              adc    LOW_BYTE #4
       00:CC11  85 0B              sta    LOW_BYTE <__ptr
       00:CC13  A5 0C              lda    HIGH_BYTE <__ptr
       00:CC15  69 00              adc    HIGH_BYTE #4
       00:CC17  85 0C              sta    HIGH_BYTE <__ptr
                                  .endif
  836                     
  837                       __ldw <__remain
                0000              .if (1 = 2)
                                  .else
       00:CC19  A6 16              ldx    <__remain
       00:CC1B  A5 17              lda    <__remain+1
                                  .endif
  838                     
  839  00:CC1D  20 2A C8    jsr eq
  840                       __tstw
                                   ; pha
       00:CC20  86 03              stx    <__temp
       00:CC22  05 03              ora    <__temp
                                   ; pla
  841                       __lbeq .begin_case
       00:CC24  D0 03              bne    .x00225
       00:CC26  4C C4 CB           jmp    .begin_case
       00:CC29            .x00225
  842                     
  843                       addw  #-2,<__ptr
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       00:CC29  18                 clc
       00:CC2A  A5 0B              lda    LOW_BYTE <__ptr
       00:CC2C  69 FE              adc    LOW_BYTE #-2
       00:CC2E  85 0B              sta    LOW_BYTE <__ptr
       00:CC30  A5 0C              lda    HIGH_BYTE <__ptr
       00:CC32  69 FF              adc    HIGH_BYTE #-2
       00:CC34  85 0C              sta    HIGH_BYTE <__ptr
                                  .endif
  844                       __ldwp __ptr
       00:CC36  B2 0B              lda    [__ptr]
       00:CC38  AA                 tax
       00:CC39  A0 01              ldy    #1
       00:CC3B  B1 0B              lda    [__ptr],Y
  845                       __stw <__temp
       00:CC3D  86 03              stx    <__temp
       00:CC3F  85 04              sta    <__temp+1
  846                     
  847  00:CC41  6C 03 20    jmp [__temp]
  848                     
  849  00:CC44            .end_case_default:      ; if we haven't found any corresponding value
  850                                             ; then we jump to the default supplied label
  851                     
  852                       addw   #-2,<__ptr
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       00:CC44  18                 clc
       00:CC45  A5 0B              lda    LOW_BYTE <__ptr
       00:CC47  69 FE              adc    LOW_BYTE #-2
       00:CC49  85 0B              sta    LOW_BYTE <__ptr
       00:CC4B  A5 0C              lda    HIGH_BYTE <__ptr
       00:CC4D  69 FF              adc    HIGH_BYTE #-2
       00:CC4F  85 0C              sta    HIGH_BYTE <__ptr
                                  .endif
  853                       __ldwp __ptr
       00:CC51  B2 0B              lda    [__ptr]
       00:CC53  AA                 tax
       00:CC54  A0 01              ldy    #1
       00:CC56  B1 0B              lda    [__ptr],Y
  854                       __stw <__temp
       00:CC58  86 03              stx    <__temp
       00:CC5A  85 04              sta    <__temp+1
  855                     
  856  00:CC5C  6C 03 20    jmp [__temp]
  857                     
  858                     
  859                     ; ----
  860                     ; hook
  861                     ; ----
  862                     ; indirect call to sub-routine
  863                     ; ----
  864                     ; IN :  sub-routine addr in __ptr
  865                     ; ----
  866                     
  867  00:CC5F            hook:
  868  00:CC5F  6C 0B 20          jmp     [__ptr]
  869                     
  870                     ; ----
  871                     ; setvdc
  872                     ; ----
  873                     ; set a vdc register
  874                     ; ----
  875                     ; IN : - reg index on the C stack
  876                     ;      - value in A:X
  877                     ; ----
  878                     
  879  00:CC62            setvdc:
  880  00:CC62  A8                tay
  881  00:CC63  B2 00             lda     [__sp]
  882  00:CC65  4A                lsr     A
  883                             ; --
  884  00:CC66  C9 09             cmp     #$09
  885  00:CC68  F0 2E             beq     .l3
  886  00:CC6A  C9 0A             cmp     #$0A
  887                             blo     .l1
       00:CC6C  90 04              bcc    .l1
  888  00:CC6E  C9 0F             cmp     #$0F
  889                             blo     .l2
       00:CC70  90 18              bcc    .l2
  890                             ; --
  891  00:CC72  85 F7     .l1:    sta     <vdc_reg
  892  00:CC74  8D 00 00          sta     video_reg
  893  00:CC77  8E 02 00          stx     video_data_l
  894  00:CC7A  8C 03 00          sty     video_data_h
  895                             ; --
  896  00:CC7D  C9 02             cmp     #$02
  897  00:CC7F  F0 09             beq     .l2
  898                             ; --
  899  00:CC81  0A                asl     A
  900  00:CC82  22                sax
  901  00:CC83  9D 7D 27          sta     _vdc,X
  902  00:CC86  98                tya
  903  00:CC87  9D 7E 27          sta     _vdc+1,X
  904                     .l2:    addw    #2,<__sp
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       00:CC8A  18                 clc
       00:CC8B  A5 00              lda    LOW_BYTE <__sp
       00:CC8D  69 02              adc    LOW_BYTE #2
       00:CC8F  85 00              sta    LOW_BYTE <__sp
       00:CC91  A5 01              lda    HIGH_BYTE <__sp
       00:CC93  69 00              adc    HIGH_BYTE #2
       00:CC95  85 01              sta    HIGH_BYTE <__sp
                                  .endif
  905  00:CC97  60                rts     
  906                             ; -- reg $09
  907  00:CC98  8A        .l3:    txa
  908  00:CC99  29 70             and     #$70
  909  00:CC9B  4A                lsr     A
  910  00:CC9C  4A                lsr     A
  911  00:CC9D  4A                lsr     A
  912  00:CC9E  4A                lsr     A
  913  00:CC9F  20 5C C5          jsr     set_bat_size
  914  00:CCA2  80 E6             bra     .l2
  915                     
  916                     ; ----
  917                     ; getvdc
  918                     ; ----
  919                     ; get vdc register content
  920                     ; ----
  921                     ; IN : reg index in A:X
  922                     ; ----
  923                     ; OUT: vdc register in A:X
  924                     ; ----
  925                     
  926  00:CCA4            getvdc:
  927  00:CCA4  E0 04             cpx     #4
  928  00:CCA6  F0 08             beq     .l1
  929                             ; --
  930  00:CCA8  02                sxy
  931  00:CCA9  BE 7D 27          ldx     _vdc,Y
  932  00:CCAC  B9 7E 27          lda     _vdc+1,Y
  933  00:CCAF  60                rts     
  934                             ; --
  935  00:CCB0  A9 02     .l1:    lda     #2
  936  00:CCB2  85 F7             sta     <vdc_reg
  937  00:CCB4  8D 00 00          sta     video_reg
  938  00:CCB7  AE 02 00          ldx     video_data_l
  939  00:CCBA  AD 03 00          lda     video_data_h
  940  00:CCBD  60                rts
  941                     
#[2]   startup.asm
#[3]   huc_gfx.asm
 1217                             .include "huc_gfx.asm"
    1                     ;
    2                     ; HUC_GFX.ASM  -  HuC Graphic Library
    3                     ;
    4                     
    5                     ; ----
    6                     ; local variables
    7                     
    8           2018                  .zp
    9  --:2018            __spr_ptr   .ds 2
   10  --:201A            __spr_max   .ds 1
   11  --:201B            __spr_flag  .ds 1
   12                     
   13           27A5                  .bss
   14  --:27A5            _font_base  .ds 2
   15  --:27A7            _font_color .ds 2
   16  --:27A9            _satb       .ds 512     ; the local SATB
   17                     
   18  --:29A9            _gfx_pal    .ds 1
   19                     
   20  --:29AA            _line_currx     .ds     2
   21  --:29AC            _line_curry     .ds     2
   22  --:29AE            _line_deltax    .ds     2
   23  --:29B0            _line_deltay    .ds     2
   24  --:29B2            _line_error     .ds     2
   25  --:29B4            _line_adjust    .ds     2
   26  --:29B6            _line_xdir      .ds     1
   27  --:29B7            _line_color     .ds     1
   28                     
   29                     
   30                     ; ----
   31                     ; library code
   32                     
   33           CCBE               .code
   34                     
   35                     ; cls(int val [dx])
   36                     ; ----
   37                     
   38  00:CCBE            _cls:
   39                               stw   _font_base,<_dx
       00:CCBE  AD A5 27           lda    LOW_BYTE _font_base
       00:CCC1  85 FE              sta    LOW_BYTE <_dx
       00:CCC3  AD A6 27           lda    HIGH_BYTE _font_base
       00:CCC6  85 FF              sta    HIGH_BYTE <_dx
   40  00:CCC8            _cls.1:
   41                               setvwaddr $0
                                   stw  #$0,<_di
       00:CCC8  A9 00              lda    LOW_BYTE #$0
       00:CCCA  85 F0              sta    LOW_BYTE <_di
       00:CCCC  A9 00              lda    HIGH_BYTE #$0
       00:CCCE  85 F1              sta    HIGH_BYTE <_di
       00:CCD0  20 36 C4           jsr  set_write
   42                               ; --
   43  00:CCD3  AC 0C 27            ldy   bat_height
   44  00:CCD6  AE 0A 27  .l2:      ldx   bat_width
   45                               ; --
   46                     .l3:      stw   <_dx,video_data
       00:CCD9  A5 FE              lda    LOW_BYTE <_dx
       00:CCDB  8D 02 00           sta    LOW_BYTE video_data
       00:CCDE  A5 FF              lda    HIGH_BYTE <_dx
       00:CCE0  8D 03 00           sta    HIGH_BYTE video_data
   47  00:CCE3  CA                  dex
   48  00:CCE4  D0 F3               bne   .l3
   49  00:CCE6  88                  dey
   50  00:CCE7  D0 ED               bne   .l2
   51  00:CCE9  60                  rts
   52                     
   53                     ; set_font_pal(int pal)
   54                     ; ----
   55                     
   56  00:CCEA            _set_font_pal:
   57  00:CCEA  8A                  txa
   58  00:CCEB  0A                  asl   A
   59  00:CCEC  0A                  asl   A
   60  00:CCED  0A                  asl   A
   61  00:CCEE  0A                  asl   A
   62  00:CCEF  85 03               sta   <__temp
   63  00:CCF1  AD A6 27            lda   _font_base+1
   64  00:CCF4  29 0F               and   #$0F
   65  00:CCF6  05 03               ora   <__temp
   66  00:CCF8  8D A6 27            sta   _font_base+1
   67  00:CCFB  60                  rts
   68                     
   69                     ; set_font_color(char color, char bg)
   70                     ; ----
   71                     
   72  00:CCFC            _set_font_color.2:
   73  00:CCFC  8A                  txa
   74  00:CCFD  29 0F               and   #$F
   75  00:CCFF  8D A8 27            sta   _font_color+1
   76  00:CD02  A5 F8               lda   <_al
   77  00:CD04  29 0F               and   #$F
   78  00:CD06  8D A7 27            sta   _font_color
   79  00:CD09  60                  rts
   80                     
   81                     ; set_font_addr(int addr)
   82                     ; ----
   83                     
   84  00:CD0A            _set_font_addr:
   85                               ; --
   86  00:CD0A  8E A5 27            stx   _font_base
   87  00:CD0D  4A                  lsr   A
   88  00:CD0E  6E A5 27            ror   _font_base
   89  00:CD11  4A                  lsr   A
   90  00:CD12  6E A5 27            ror   _font_base
   91  00:CD15  4A                  lsr   A
   92  00:CD16  6E A5 27            ror   _font_base
   93  00:CD19  4A                  lsr   A
   94  00:CD1A  6E A5 27            ror   _font_base
   95  00:CD1D  85 F8               sta   <_al
   96                               ; --
   97  00:CD1F  AD A6 27            lda   _font_base+1
   98  00:CD22  29 F0               and   #$F0
   99  00:CD24  05 F8               ora   <_al
  100  00:CD26  8D A6 27            sta   _font_base+1
  101  00:CD29  60                  rts
  102                     
  103                     ; get_font_pal()
  104                     ; ----
  105                     
  106  00:CD2A            _get_font_pal:
  107  00:CD2A  AD A6 27            lda   _font_base+1
  108  00:CD2D  4A                  lsr   A
  109  00:CD2E  4A                  lsr   A
  110  00:CD2F  4A                  lsr   A
  111  00:CD30  4A                  lsr   A
  112  00:CD31  82                  clx
  113  00:CD32  22                  sax
  114  00:CD33  60                  rts
  115                     
  116                     ; get_font_addr()
  117                     ; ----
  118                     
  119  00:CD34            _get_font_addr:
  120                               ; --
  121  00:CD34  AD A6 27            lda   _font_base+1
  122  00:CD37  85 F8               sta   <_al
  123  00:CD39  AD A5 27            lda   _font_base
  124  00:CD3C  0A                  asl   A
  125  00:CD3D  26 F8               rol   <_al
  126  00:CD3F  0A                  asl   A
  127  00:CD40  26 F8               rol   <_al
  128  00:CD42  0A                  asl   A
  129  00:CD43  26 F8               rol   <_al
  130  00:CD45  0A                  asl   A
  131  00:CD46  26 F8               rol   <_al
  132  00:CD48  A6 F8               ldx   <_al
  133  00:CD4A  22                  sax
  134  00:CD4B  60                  rts
  135                     
  136                     ; load_default_font(char num [dl], int addr [di])
  137                     ; ----
  138                     
  139  00:CD4C            _load_default_font:
  140                               ; --
  141  00:CD4C  64 FE               stz   <_dl
  142                     
  143  00:CD4E            _load_default_font.1:
  144                               ; --
  145  00:CD4E  A2 FF               ldx   #$FF
  146  00:CD50  A9 FF               lda   #$FF
  147  00:CD52  20 53 C4            jsr   calc_vram_addr
  148                               incw  <_di
       00:CD55  E6 F0              inc    <_di              ; value at stated memory
       00:CD57  D0 02              bne    .x_00239           ; location
       00:CD59  E6 F1              inc    <_di+1
       00:CD5B            .x_00239:
  149                     
  150  00:CD5B            _load_default_font.2:
  151                               ; --
  152  00:CD5B  A5 F0               lda   <_di
  153  00:CD5D  05 F1               ora   <_di+1
  154  00:CD5F  D0 09               bne   .l1
  155  00:CD61  20 34 CD            jsr   _get_font_addr
  156                             __stw   <_di
       00:CD64  86 F0              stx    <_di
       00:CD66  85 F1              sta    <_di+1
  157  00:CD68  80 07               bra   .l2
  158                               ; --
  159                     .l1:    __ldw   <_di
                0000              .if (1 = 2)
                                  .else
       00:CD6A  A6 F0              ldx    <_di
       00:CD6C  A5 F1              lda    <_di+1
                                  .endif
  160  00:CD6E  20 0A CD            jsr   _set_font_addr
  161                               ; --
  162                     .l2:      stb   #FONT_BANK+_bank_base,<_bl
       00:CD71  A9 81              lda    #FONT_BANK+_bank_base
       00:CD73  85 FA              sta    <_bl
  163                               stb   #96,<_cl
       00:CD75  A9 60              lda    #96
       00:CD77  85 FC              sta    <_cl
  164                               stb   _font_color+1,<_ah
       00:CD79  AD A8 27           lda    _font_color+1
       00:CD7C  85 F9              sta    <_ah
  165  00:CD7E  AD A7 27            lda   _font_color
  166  00:CD81  D0 01               bne   .l3
  167  00:CD83  1A                  inc   A
  168  00:CD84  85 F8     .l3:      sta   <_al
  169  00:CD86  A5 FE               lda   <_dl
  170  00:CD88  29 03               and   #$03
  171  00:CD8A  0A                  asl   A
  172  00:CD8B  AA                  tax
  173  00:CD8C  BD 48 C3            lda   font_table,X
  174  00:CD8F  85 EE               sta   <_si
  175  00:CD91  E8                  inx
  176  00:CD92  BD 48 C3            lda   font_table,X
  177  00:CD95  85 EF               sta   <_si+1
  178  00:CD97  4C DF C3            jmp   load_font
  179                     
  180                     ; load_font(farptr font [bl:si], char nb [cl], int addr [di])
  181                     ; ----
  182                     
  183  00:CD9A            _load_font.2:
  184                               ; --
  185  00:CD9A  A2 FF               ldx   #$FF
  186  00:CD9C  A9 FF               lda   #$FF
  187  00:CD9E  20 53 C4            jsr   calc_vram_addr
  188                               incw  <_di
       00:CDA1  E6 F0              inc    <_di              ; value at stated memory
       00:CDA3  D0 02              bne    .x_00245           ; location
       00:CDA5  E6 F1              inc    <_di+1
       00:CDA7            .x_00245:
  189                     
  190  00:CDA7            _load_font.3:
  191                               ; --
  192  00:CDA7  A5 F0               lda   <_di
  193  00:CDA9  05 F1               ora   <_di+1
  194  00:CDAB  D0 09               bne   .l1
  195  00:CDAD  20 34 CD            jsr   _get_font_addr
  196                             __stw   <_di
       00:CDB0  86 F0              stx    <_di
       00:CDB2  85 F1              sta    <_di+1
  197  00:CDB4  80 07               bra   .l2
  198                               ; --
  199                     .l1:    __ldw   <_di
                0000              .if (1 = 2)
                                  .else
       00:CDB6  A6 F0              ldx    <_di
       00:CDB8  A5 F1              lda    <_di+1
                                  .endif
  200  00:CDBA  20 0A CD            jsr   _set_font_addr
  201                               ; --
  202  00:CDBD  A5 FC     .l2:      lda   <_cl
  203  00:CDBF  64 FD               stz   <_ch
  204  00:CDC1  0A                  asl   A
  205  00:CDC2  26 FD               rol   <_ch
  206  00:CDC4  0A                  asl   A
  207  00:CDC5  26 FD               rol   <_ch
  208  00:CDC7  0A                  asl   A
  209  00:CDC8  26 FD               rol   <_ch
  210  00:CDCA  0A                  asl   A
  211  00:CDCB  26 FD               rol   <_ch
  212  00:CDCD  85 FC               sta   <_cl
  213  00:CDCF  4C F1 C3            jmp   load_vram
  214                     
  215                     ; put_digit(char digit, int offset)
  216                     ; put_digit(char digit, char x, char y)
  217                     ; ----
  218                     
  219  00:CDD2            _put_digit.3:
  220  00:CDD2  A4 02               ldy   <__arg_idx
  221                             __plb
                                   ; (bytes : 6/7, cycles : 11/12)
                          
                0000              .if (0 = 2)
                                  .else
       00:CDD4  88                 dey
       00:CDD5  B9 FF 31           lda    __arg,Y
                0000              .if (0)
                                  .endif
                                  .endif
  222  00:CDD8  20 FF CD            jsr   _put.xy
  223  00:CDDB  80 05               bra   _put_digit.main
  224  00:CDDD            _put_digit.2:
  225  00:CDDD  A4 02               ldy   <__arg_idx
  226  00:CDDF  20 06 CE            jsr   _put.vram
  227  00:CDE2            _put_digit.main:
  228                             __plb
                                   ; (bytes : 6/7, cycles : 11/12)
                          
                0000              .if (0 = 2)
                                  .else
       00:CDE2  88                 dey
       00:CDE3  B9 FF 31           lda    __arg,Y
                0000              .if (0)
                                  .endif
                                  .endif
  229  00:CDE6  84 02               sty   <__arg_idx
  230  00:CDE8            _put_digit.sub:
  231  00:CDE8  C9 0A               cmp   #10
  232                               blo   .l1
       00:CDEA  90 03              bcc    .l1
  233                               add   #$07
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       00:CDEC  18                 clc
       00:CDED  69 07              adc    #$07
                                  .endif
  234  00:CDEF  69 10     .l1:      adc   #$10
  235  00:CDF1  6D A5 27            adc   _font_base
  236  00:CDF4  8D 02 00            sta   video_data_l
  237  00:CDF7  62                  cla
  238  00:CDF8  6D A6 27            adc   _font_base+1
  239  00:CDFB  8D 03 00            sta   video_data_h
  240  00:CDFE  60                  rts
  241  00:CDFF            _put.xy:
  242  00:CDFF  22                  sax
  243  00:CE00  20 53 C4            jsr   calc_vram_addr
  244  00:CE03  4C 36 C4            jmp   set_write
  245  00:CE06            _put.vram:
  246  00:CE06  64 F7               stz   <vdc_reg
  247  00:CE08  9C 00 00            stz   video_reg
  248  00:CE0B  8E 02 00            stx   video_data_l
  249  00:CE0E  8D 03 00            sta   video_data_h
  250                               vreg  #$02
       00:CE11  A9 02              lda    #$02
       00:CE13  85 F7              sta    <vdc_reg
                0001               .if (2 = ARG_IMMED)
       00:CE15  03 02               st0   #$02
                                   .else
                                   .endif
  251  00:CE17  60                  rts
  252                     
  253                     ; put_char(char character, int offset)
  254                     ; put_char(char character, char x, char y)
  255                     ; ----
  256                     
  257  00:CE18            _put_char.3:
  258  00:CE18  A4 02               ldy   <__arg_idx
  259                             __plb
                                   ; (bytes : 6/7, cycles : 11/12)
                          
                0000              .if (0 = 2)
                                  .else
       00:CE1A  88                 dey
       00:CE1B  B9 FF 31           lda    __arg,Y
                0000              .if (0)
                                  .endif
                                  .endif
  260  00:CE1E  20 FF CD            jsr   _put.xy
  261  00:CE21  80 05               bra   _put_char.main
  262  00:CE23            _put_char.2:
  263  00:CE23  A4 02               ldy   <__arg_idx
  264  00:CE25  20 06 CE            jsr   _put.vram
  265  00:CE28            _put_char.main:
  266                             __plb
                                   ; (bytes : 6/7, cycles : 11/12)
                          
                0000              .if (0 = 2)
                                  .else
       00:CE28  88                 dey
       00:CE29  B9 FF 31           lda    __arg,Y
                0000              .if (0)
                                  .endif
                                  .endif
  267  00:CE2C  84 02               sty   <__arg_idx
  268                               ; --
  269  00:CE2E  C9 20               cmp   #32
  270                               bhs   .l1
       00:CE30  B0 03              bcs    .l1
  271  00:CE32  A9 20               lda   #32
  272  00:CE34  38                  sec
  273  00:CE35  E9 20     .l1:      sbc   #32
  274                               add   _font_base
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       00:CE37  18                 clc
       00:CE38  6D A5 27           adc    _font_base
                                  .endif
  275  00:CE3B  8D 02 00            sta   video_data_l
  276  00:CE3E  62                  cla
  277  00:CE3F  6D A6 27            adc   _font_base+1
  278  00:CE42  8D 03 00            sta   video_data_h
  279  00:CE45  60                  rts
  280                     
  281                     ; put_raw(int character, int offset)
  282                     ; put_raw(int character, char x, char y)
  283                     ; ----
  284                     
  285  00:CE46            _put_raw.3:
  286  00:CE46  A4 02               ldy   <__arg_idx
  287                             __plb
                                   ; (bytes : 6/7, cycles : 11/12)
                          
                0000              .if (0 = 2)
                                  .else
       00:CE48  88                 dey
       00:CE49  B9 FF 31           lda    __arg,Y
                0000              .if (0)
                                  .endif
                                  .endif
  288  00:CE4C  20 FF CD            jsr   _put.xy
  289  00:CE4F  80 05               bra   _put_raw.main
  290  00:CE51            _put_raw.2:
  291  00:CE51  A4 02               ldy   <__arg_idx
  292  00:CE53  20 06 CE            jsr   _put.vram
  293  00:CE56            _put_raw.main:
  294                             __plb
                                   ; (bytes : 6/7, cycles : 11/12)
                          
                0000              .if (0 = 2)
                                  .else
       00:CE56  88                 dey
       00:CE57  B9 FF 31           lda    __arg,Y
                0000              .if (0)
                                  .endif
                                  .endif
  295  00:CE5A  8D 02 00            sta   video_data_l
  296                             __plb
                                   ; (bytes : 6/7, cycles : 11/12)
                          
                0000              .if (0 = 2)
                                  .else
       00:CE5D  88                 dey
       00:CE5E  B9 FF 31           lda    __arg,Y
                0000              .if (0)
                                  .endif
                                  .endif
  297  00:CE61  8D 03 00            sta   video_data_h
  298  00:CE64  84 02               sty   <__arg_idx
  299  00:CE66  60                  rts
  300                     
  301                     ; put_number(int number, char n, int offset)
  302                     ; put_number(int number, char n, char x, char y)
  303                     ; ----
  304                     
  305                     
  306                     _put_number.3:  maplibfunc      lib2_put_number.3
       00:CE67  A8                 tay
       00:CE68  43 20              tma  #page(lib2_put_number.3)
       00:CE6A  48                 pha
       00:CE6B  A9 81              lda  #bank(lib2_put_number.3)
       00:CE6D  53 20              tam  #page(lib2_put_number.3)
       00:CE6F  98                 tya
       00:CE70  20 62 AB           jsr  lib2_put_number.3
       00:CE73  A8                 tay
       00:CE74  68                 pla
       00:CE75  53 20              tam  #page(lib2_put_number.3)
       00:CE77  98                 tya
  307  00:CE78  60                        rts
  308                     
  309                     _put_number.4:  maplibfunc      lib2_put_number.4
       00:CE79  A8                 tay
       00:CE7A  43 20              tma  #page(lib2_put_number.4)
       00:CE7C  48                 pha
       00:CE7D  A9 81              lda  #bank(lib2_put_number.4)
       00:CE7F  53 20              tam  #page(lib2_put_number.4)
       00:CE81  98                 tya
       00:CE82  20 57 AB           jsr  lib2_put_number.4
       00:CE85  A8                 tay
       00:CE86  68                 pla
       00:CE87  53 20              tam  #page(lib2_put_number.4)
       00:CE89  98                 tya
  310  00:CE8A  60                        rts
  311                     
  312                     
  313                     ; put_hex(int number, char n, int offset)
  314                     ; put_hex(int number, char n, char x, char y)
  315                     ; ----
  316                     
  317  00:CE8B            _put_hex.4:
  318  00:CE8B  A4 02               ldy   <__arg_idx
  319                             __plb
                                   ; (bytes : 6/7, cycles : 11/12)
                          
                0000              .if (0 = 2)
                                  .else
       00:CE8D  88                 dey
       00:CE8E  B9 FF 31           lda    __arg,Y
                0000              .if (0)
                                  .endif
                                  .endif
  320  00:CE91  20 FF CD            jsr   _put.xy
  321  00:CE94  80 05               bra   _put_hex.main
  322  00:CE96            _put_hex.3:
  323  00:CE96  A4 02               ldy   <__arg_idx
  324  00:CE98  20 06 CE            jsr   _put.vram
  325  00:CE9B            _put_hex.main:
  326                             __plb   <_cl,1
                                   ; (bytes : 6/7, cycles : 11/12)
                          
                0001              .if (2 = 2)
       00:CE9B  88                 dey
       00:CE9C  BE FF 31           ldx    __arg,Y
       00:CE9F  86 FC              stx    <_cl
                                  .else
                                  .endif
  327                             __plw   <_dx
                                   ; (bytes : 9/12, cycles : 16/22)
                          
       00:CEA1  88                 dey
       00:CEA2  B9 FF 31           lda    __arg,Y
                0001              .if (1)
       00:CEA5  85 FE              sta    <_dx
                                  .else
                                  .endif
       00:CEA7  88                 dey
       00:CEA8  B9 FF 31           lda    __arg,Y
                0001              .if (1)
       00:CEAB  85 FF              sta    <_dx+1
                                  .endif
  328  00:CEAD  84 02               sty   <__arg_idx
  329                               ; --
  330  00:CEAF  8A                  txa
  331  00:CEB0  F0 12               beq   .l3
  332  00:CEB2  E0 05     .l1:      cpx   #5
  333                               blo   .l2
       00:CEB4  90 07              bcc    .l2
  334  00:CEB6  62                  cla
  335  00:CEB7  20 E8 CD            jsr   _put_digit.sub
  336  00:CEBA  CA                  dex
  337  00:CEBB  80 F5               bra   .l1
  338                               ; --
  339  00:CEBD  8A        .l2:      txa
  340  00:CEBE  3A                  dec   A
  341  00:CEBF  0A                  asl   A
  342  00:CEC0  AA                  tax
  343  00:CEC1  7C C5 CE            jmp   [.tbl,X]
  344  00:CEC4  60        .l3:      rts
  345                               ; --
  346  00:CEC5  E6 CE     .tbl:    .dw    .h1,.h2,.h3,.h4
       00:CEC7  DD CE     
       00:CEC9  D6 CE     
       00:CECB  CD CE     
  347                               ; --
  348  00:CECD  A5 FF     .h4:      lda   <_dh
  349  00:CECF  4A                  lsr   A
  350  00:CED0  4A                  lsr   A
  351  00:CED1  4A                  lsr   A
  352  00:CED2  4A                  lsr   A
  353  00:CED3  20 E8 CD            jsr   _put_digit.sub
  354                               ; --
  355  00:CED6  A5 FF     .h3:      lda   <_dh
  356  00:CED8  29 0F               and   #$0F
  357  00:CEDA  20 E8 CD            jsr   _put_digit.sub
  358                               ; --
  359  00:CEDD  A5 FE     .h2:      lda   <_dl
  360  00:CEDF  4A                  lsr   A
  361  00:CEE0  4A                  lsr   A
  362  00:CEE1  4A                  lsr   A
  363  00:CEE2  4A                  lsr   A
  364  00:CEE3  20 E8 CD            jsr   _put_digit.sub
  365                               ; --
  366  00:CEE6  A5 FE     .h1:      lda   <_dl
  367  00:CEE8  29 0F               and   #$0F
  368  00:CEEA  4C E8 CD            jmp   _put_digit.sub
  369                     
  370                     ; put_string(char *string, int offset)
  371                     ; put_string(char *string, char x, char y)
  372                     ; ----
  373                     
  374  00:CEED            _put_string.3:
  375  00:CEED  A4 02               ldy   <__arg_idx
  376                             __plb
                                   ; (bytes : 6/7, cycles : 11/12)
                          
                0000              .if (0 = 2)
                                  .else
       00:CEEF  88                 dey
       00:CEF0  B9 FF 31           lda    __arg,Y
                0000              .if (0)
                                  .endif
                                  .endif
  377  00:CEF3  20 FF CD            jsr   _put.xy
  378  00:CEF6  80 05               bra   _put_string.main
  379  00:CEF8            _put_string.2:
  380  00:CEF8  A4 02               ldy   <__arg_idx
  381  00:CEFA  20 06 CE            jsr   _put.vram
  382  00:CEFD            _put_string.main:
  383                             __plw   <_si
                                   ; (bytes : 9/12, cycles : 16/22)
                          
       00:CEFD  88                 dey
       00:CEFE  B9 FF 31           lda    __arg,Y
                0001              .if (1)
       00:CF01  85 EE              sta    <_si
                                  .else
                                  .endif
       00:CF03  88                 dey
       00:CF04  B9 FF 31           lda    __arg,Y
                0001              .if (1)
       00:CF07  85 EF              sta    <_si+1
                                  .endif
  384  00:CF09  84 02               sty   <__arg_idx
  385  00:CF0B  80 1D               bra   .l3
  386                               ; --
  387  00:CF0D  C9 20     .l1:      cmp   #32
  388                               bhs   .l2
       00:CF0F  B0 03              bcs    .l2
  389  00:CF11  A9 20               lda   #32
  390  00:CF13  38                  sec
  391  00:CF14  E9 20     .l2:      sbc   #32
  392                               add   _font_base
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       00:CF16  18                 clc
       00:CF17  6D A5 27           adc    _font_base
                                  .endif
  393  00:CF1A  8D 02 00            sta   video_data_l
  394  00:CF1D  62                  cla
  395  00:CF1E  6D A6 27            adc   _font_base+1
  396  00:CF21  8D 03 00            sta   video_data_h
  397                               incw  <_si
       00:CF24  E6 EE              inc    <_si              ; value at stated memory
       00:CF26  D0 02              bne    .x_00270           ; location
       00:CF28  E6 EF              inc    <_si+1
       00:CF2A            .x_00270:
  398  00:CF2A  B2 EE     .l3:      lda   [_si]
  399  00:CF2C  D0 DF               bne   .l1
  400  00:CF2E  60                  rts
  401                     
  402                     ; vsync(char nb_frame)
  403                     ; ----
  404                     
  405  00:CF2F            _vsync:
  406  00:CF2F  8A                  txa
  407  00:CF30  C0 00               cpy   #0
  408  00:CF32  D0 01               bne   .l1
  409  00:CF34  62                  cla
  410  00:CF35  4C 42 DE  .l1:      jmp   wait_vsync
  411                     
  412                     ; vreg(char reg)
  413                     ; ----
  414                     
  415  00:CF38            _vreg:
  416  00:CF38  C0 02               cpy   #2
  417  00:CF3A  D0 03               bne   .l1
  418  00:CF3C  4C 62 CC            jmp   setvdc
  419  00:CF3F            .l1:
  420  00:CF3F  86 F7               stx   <vdc_reg
  421  00:CF41  8E 00 00            stx   video_reg
  422  00:CF44  60                  rts
  423                     
  424                     ; vram_addr(char x [al], char y)
  425                     ; ----
  426                     
  427  00:CF45            _vram_addr.2:
  428  00:CF45  A5 F8               lda   <_al
  429  00:CF47  22                  sax
  430  00:CF48  20 53 C4            jsr   calc_vram_addr
  431                             __ldw   <_di
                0000              .if (1 = 2)
                                  .else
       00:CF4B  A6 F0              ldx    <_di
       00:CF4D  A5 F1              lda    <_di+1
                                  .endif
  432  00:CF4F  60                  rts
  433                     
  434                     ; scan_map_table(int *tbl [si], int *x [ax], int *y [cx])
  435                     ; ----
  436                     ; tbl,
  437                     ; x,
  438                     ; y,
  439                     ; ----
  440                     
  441  00:CF50            _scan_map_table.3:
  442                     
  443  00:CF50  A0 01               ldy   #1
  444  00:CF52  B2 F8               lda   [_ax]
  445  00:CF54  85 FA               sta   <_bl
  446  00:CF56  B1 F8               lda   [_ax],Y
  447  00:CF58  85 FB               sta   <_bh
  448  00:CF5A  B2 FC               lda   [_cx]
  449  00:CF5C  85 FE               sta   <_dl
  450  00:CF5E  B1 FC               lda   [_cx],Y
  451  00:CF60  85 FF               sta   <_dh
  452                               ; --
  453                               addw  #4,<_si
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       00:CF62  18                 clc
       00:CF63  A5 EE              lda    LOW_BYTE <_si
       00:CF65  69 04              adc    LOW_BYTE #4
       00:CF67  85 EE              sta    LOW_BYTE <_si
       00:CF69  A5 EF              lda    HIGH_BYTE <_si
       00:CF6B  69 00              adc    HIGH_BYTE #4
       00:CF6D  85 EF              sta    HIGH_BYTE <_si
                                  .endif
  454                     
  455                         ; ----
  456                         ; check bounds
  457                         ;
  458                               ; -- bottom
  459  00:CF6F  A0 07     .l1:      ldy   #7
  460  00:CF71  B1 EE               lda   [_si],Y
  461  00:CF73  C5 FF               cmp   <_dh
  462                               blo   .x1
       00:CF75  90 3B              bcc    .x1
  463  00:CF77  D0 07               bne   .l2
  464  00:CF79  88                  dey
  465  00:CF7A  B1 EE               lda   [_si],Y
  466  00:CF7C  C5 FE               cmp   <_dl
  467                               blo   .x1
       00:CF7E  90 32              bcc    .x1
  468                               ; -- top
  469  00:CF80  A0 03     .l2:      ldy   #3
  470  00:CF82  A5 FF               lda   <_dh
  471  00:CF84  D1 EE               cmp   [_si],Y
  472                               blo   .x1
       00:CF86  90 2A              bcc    .x1
  473  00:CF88  D0 07               bne   .l3
  474  00:CF8A  88                  dey
  475  00:CF8B  A5 FE               lda   <_dl
  476  00:CF8D  D1 EE               cmp   [_si],Y
  477                               blo   .x1
       00:CF8F  90 21              bcc    .x1
  478                               ; -- right
  479  00:CF91  A0 05     .l3:      ldy   #5
  480  00:CF93  B1 EE               lda   [_si],Y
  481  00:CF95  C5 FB               cmp   <_bh
  482                               blo   .x1
       00:CF97  90 19              bcc    .x1
  483  00:CF99  D0 07               bne   .l4
  484  00:CF9B  88                  dey
  485  00:CF9C  B1 EE               lda   [_si],Y
  486  00:CF9E  C5 FA               cmp   <_bl
  487                               blo   .x1
       00:CFA0  90 10              bcc    .x1
  488                               ; -- left
  489  00:CFA2  A0 01     .l4:      ldy   #1
  490  00:CFA4  A5 FB               lda   <_bh
  491  00:CFA6  D1 EE               cmp   [_si],Y
  492                               blo   .x1
       00:CFA8  90 08              bcc    .x1
  493  00:CFAA  D0 20               bne   .x2
  494  00:CFAC  A5 FA               lda   <_bl
  495  00:CFAE  D2 EE               cmp   [_si]
  496                               bhs   .x2
       00:CFB0  B0 1A              bcs    .x2
  497                     
  498                         ; ----
  499                         ; next
  500                         ;
  501                     .x1:      addw  #12,<_si
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       00:CFB2  18                 clc
       00:CFB3  A5 EE              lda    LOW_BYTE <_si
       00:CFB5  69 0C              adc    LOW_BYTE #12
       00:CFB7  85 EE              sta    LOW_BYTE <_si
       00:CFB9  A5 EF              lda    HIGH_BYTE <_si
       00:CFBB  69 00              adc    HIGH_BYTE #12
       00:CFBD  85 EF              sta    HIGH_BYTE <_si
                                  .endif
  502  00:CFBF  A0 01               ldy   #1
  503  00:CFC1  B2 EE               lda   [_si]
  504  00:CFC3  31 EE               and   [_si],Y
  505  00:CFC5  C9 FF               cmp   #$FF
  506  00:CFC7  D0 A6               bne   .l1
  507                     
  508                         ; ----
  509                         ; didn't find map...
  510                         ;
  511  00:CFC9  82                  clx
  512  00:CFCA  62                  cla
  513  00:CFCB  60                  rts
  514                     
  515                         ; ----
  516                         ; found map!
  517                         ;
  518  00:CFCC  A0 01     .x2:      ldy   #1
  519  00:CFCE  A5 FA               lda   <_bl
  520                               sub   [_si]
                0000              .if (1 = 2)            ; from register A (handle
                                  .else
       00:CFD0  38                 sec
       00:CFD1  F2 EE              sbc    [_si]
                                  .endif
  521  00:CFD3  92 F8               sta   [_ax]
  522  00:CFD5  A5 FB               lda   <_bh
  523  00:CFD7  F1 EE               sbc   [_si],Y
  524  00:CFD9  91 F8               sta   [_ax],Y
  525                               ; --
  526  00:CFDB  C8                  iny
  527  00:CFDC  A5 FE               lda   <_dl
  528                               sub   [_si],Y
                0000              .if (1 = 2)            ; from register A (handle
                                  .else
       00:CFDE  38                 sec
       00:CFDF  F1 EE              sbc    [_si],Y
                                  .endif
  529  00:CFE1  92 FC               sta   [_cx]
  530  00:CFE3  C8                  iny
  531  00:CFE4  A5 FF               lda   <_dh
  532  00:CFE6  F1 EE               sbc   [_si],Y
  533  00:CFE8  A0 01               ldy   #1
  534  00:CFEA  91 FC               sta   [_cx],Y
  535                               ; --
  536                             __ldw   <_si
                0000              .if (1 = 2)
                                  .else
       00:CFEC  A6 EE              ldx    <_si
       00:CFEE  A5 EF              lda    <_si+1
                                  .endif
  537  00:CFF0  60                  rts
  538                     
  539                     ; set_map_data(int *ptr)
  540                     ; set_map_data(char *map [bl:si], int w [ax], int h)
  541                     ; set_map_data(char *map [bl:si], int w [ax], int h [dx], char wrap)
  542                     ; ----
  543                     ; map,  map base address
  544                     ; w,    map width
  545                     ; h,    map height
  546                     ; wrap, wrap flag (1 = wrap, 0 = do not wrap)
  547                     ; ----
  548                     
  549  00:CFF1            _set_map_data.1:
  550                             __stw   <_si
       00:CFF1  86 EE              stx    <_si
       00:CFF3  85 EF              sta    <_si+1
  551  00:CFF5  05 EE               ora   <_si
  552  00:CFF7  F0 54               beq   .l1
  553                               ; -- calculate width
  554  00:CFF9  A0 04 B1            lda   [_si].4
       00:CFFC  EE        
  555                               sub   [_si]
                0000              .if (1 = 2)            ; from register A (handle
                                  .else
       00:CFFD  38                 sec
       00:CFFE  F2 EE              sbc    [_si]
                                  .endif
  556  00:D000  8D EA 26            sta   mapwidth
  557  00:D003  A0 05 B1            lda   [_si].5
       00:D006  EE        
  558  00:D007  A0 01 F1            sbc   [_si].1
       00:D00A  EE        
  559  00:D00B  8D EB 26            sta   mapwidth+1
  560                               incw  mapwidth
       00:D00E  EE EA 26           inc    mapwidth              ; value at stated memory
       00:D011  D0 03              bne    .x_00287           ; location
       00:D013  EE EB 26           inc    mapwidth+1
       00:D016            .x_00287:
  561                               ; -- calculate height
  562  00:D016  A0 06 B1            lda   [_si].6
       00:D019  EE        
  563                               sub   [_si].2
                0000              .if (1 = 2)            ; from register A (handle
                                  .else
       00:D01A  38                 sec
       00:D01B  A0 02 F1           sbc    [_si].2
       00:D01E  EE        
                                  .endif
  564  00:D01F  8D EC 26            sta   mapheight
  565  00:D022  A0 07 B1            lda   [_si].7
       00:D025  EE        
  566  00:D026  A0 03 F1            sbc   [_si].3
       00:D029  EE        
  567  00:D02A  8D ED 26            sta   mapheight+1
  568                               incw  mapheight
       00:D02D  EE EC 26           inc    mapheight              ; value at stated memory
       00:D030  D0 03              bne    .x_00289           ; location
       00:D032  EE ED 26           inc    mapheight+1
       00:D035            .x_00289:
  569                               ; -- get map bank
  570  00:D035  A0 08 B1            lda   [_si].8
       00:D038  EE        
  571  00:D039  8D E7 26            sta   mapbank
  572                               ; -- get map addr
  573  00:D03C  A0 0A B1            lda   [_si].10
       00:D03F  EE        
  574  00:D040  8D E8 26            sta   mapaddr
  575  00:D043  C8                  iny
  576  00:D044  B2 EE               lda   [_si]
  577  00:D046  8D E9 26            sta   mapaddr+1
  578                               ; -- no wrap
  579  00:D049  9C F9 26            stz   mapwrap
  580  00:D04C  60                  rts
  581                               ; -- null pointer
  582                     .l1:      stwz  mapwidth
       00:D04D  9C EA 26           stz    LOW_BYTE mapwidth
       00:D050  9C EB 26           stz    HIGH_BYTE mapwidth
  583                               stwz  mapheight
       00:D053  9C EC 26           stz    LOW_BYTE mapheight
       00:D056  9C ED 26           stz    HIGH_BYTE mapheight
  584  00:D059  9C E7 26            stz   mapbank
  585                               stwz  mapaddr
       00:D05C  9C E8 26           stz    LOW_BYTE mapaddr
       00:D05F  9C E9 26           stz    HIGH_BYTE mapaddr
  586  00:D062  9C F9 26            stz   mapwrap
  587  00:D065  60                  rts
  588  00:D066            _set_map_data.4:
  589  00:D066  8E F9 26            stx   mapwrap
  590                             __ldw   <_dx
                0000              .if (1 = 2)
                                  .else
       00:D069  A6 FE              ldx    <_dx
       00:D06B  A5 FF              lda    <_dx+1
                                  .endif
  591  00:D06D  80 06               bra   _set_map_data.main
  592  00:D06F            _set_map_data.3:
  593  00:D06F  9C F9 26            stz   mapwrap
  594  00:D072  EE F9 26            inc   mapwrap
  595  00:D075            _set_map_data.main:
  596                             __stw   mapheight
       00:D075  8E EC 26           stx    mapheight
       00:D078  8D ED 26           sta    mapheight+1
  597                               stw   <_ax,mapwidth
       00:D07B  A5 F8              lda    LOW_BYTE <_ax
       00:D07D  8D EA 26           sta    LOW_BYTE mapwidth
       00:D080  A5 F9              lda    HIGH_BYTE <_ax
       00:D082  8D EB 26           sta    HIGH_BYTE mapwidth
  598                               stb   <_bl,mapbank
       00:D085  A5 FA              lda    <_bl
       00:D087  8D E7 26           sta    mapbank
  599                               stw   <_si,mapaddr
       00:D08A  A5 EE              lda    LOW_BYTE <_si
       00:D08C  8D E8 26           sta    LOW_BYTE mapaddr
       00:D08F  A5 EF              lda    HIGH_BYTE <_si
       00:D091  8D E9 26           sta    HIGH_BYTE mapaddr
  600  00:D094  60                  rts
  601                     
  602                     ; get_map_width()
  603                     ; ----
  604                     
  605  00:D095            _get_map_width:
  606                             __ldw   mapwidth
                0000              .if (1 = 2)
                                  .else
       00:D095  AE EA 26           ldx    mapwidth
       00:D098  AD EB 26           lda    mapwidth+1
                                  .endif
  607  00:D09B  60                  rts
  608                     
  609                     ; get_map_height()
  610                     ; ----
  611                     
  612  00:D09C            _get_map_height:
  613                             __ldw   mapheight
                0000              .if (1 = 2)
                                  .else
       00:D09C  AE EC 26           ldx    mapheight
       00:D09F  AD ED 26           lda    mapheight+1
                                  .endif
  614  00:D0A2  60                  rts
  615                     
  616                     ; set_tile_data(char *tile_ex [di])
  617                     ; set_tile_data(char *tile [bl:si], int nb_tile [cx], char *ptable [al:dx])
  618                     ; ----
  619                     ; tile,    tile base index
  620                     ; nb_tile, number of tile
  621                     ; ptable,  tile palette table address
  622                     ; ----
  623                     
  624  00:D0A3            _set_tile_data.1:
  625  00:D0A3  C2                  cly
  626  00:D0A4  B1 F0 C8            lda   [_di],Y++
  627  00:D0A7  8D F4 26            sta   mapnbtile
  628  00:D0AA  B1 F0 C8            lda   [_di],Y++
  629  00:D0AD  8D F5 26            sta   mapnbtile+1
  630  00:D0B0  B1 F0 C8            lda   [_di],Y++
  631  00:D0B3  8D EE 26            sta   maptiletype
  632  00:D0B6  C8                  iny
  633  00:D0B7  B1 F0 C8            lda   [_di],Y++
  634  00:D0BA  8D EF 26            sta   maptilebank
  635  00:D0BD  C8                  iny
  636  00:D0BE  B1 F0 C8            lda   [_di],Y++
  637  00:D0C1  8D F0 26            sta   maptileaddr
  638  00:D0C4  B1 F0 C8            lda   [_di],Y++
  639  00:D0C7  8D F1 26            sta   maptileaddr+1
  640  00:D0CA  A9 82               lda   #(CONST_BANK+_bank_base)
  641  00:D0CC  8D F6 26            sta   mapctablebank
  642  00:D0CF  B1 F0 C8            lda   [_di],Y++
  643  00:D0D2  8D F7 26            sta   mapctable
  644  00:D0D5  B1 F0               lda   [_di],Y
  645  00:D0D7  8D F8 26            sta   mapctable+1
  646  00:D0DA  60                  rts
  647  00:D0DB            _set_tile_data.3:
  648                               stb   <_bl,maptilebank
       00:D0DB  A5 FA              lda    <_bl
       00:D0DD  8D EF 26           sta    maptilebank
  649                               stw   <_si,maptileaddr
       00:D0E0  A5 EE              lda    LOW_BYTE <_si
       00:D0E2  8D F0 26           sta    LOW_BYTE maptileaddr
       00:D0E5  A5 EF              lda    HIGH_BYTE <_si
       00:D0E7  8D F1 26           sta    HIGH_BYTE maptileaddr
  650                               stw   <_cx,mapnbtile
       00:D0EA  A5 FC              lda    LOW_BYTE <_cx
       00:D0EC  8D F4 26           sta    LOW_BYTE mapnbtile
       00:D0EF  A5 FD              lda    HIGH_BYTE <_cx
       00:D0F1  8D F5 26           sta    HIGH_BYTE mapnbtile
  651                               stb   <_al,mapctablebank
       00:D0F4  A5 F8              lda    <_al
       00:D0F6  8D F6 26           sta    mapctablebank
  652                               stw   <_dx,mapctable
       00:D0F9  A5 FE              lda    LOW_BYTE <_dx
       00:D0FB  8D F7 26           sta    LOW_BYTE mapctable
       00:D0FE  A5 FF              lda    HIGH_BYTE <_dx
       00:D100  8D F8 26           sta    HIGH_BYTE mapctable
  653                               ; --
  654  00:D103  A4 FA               ldy   <_bl            ; get tile format (8x8 or 16x16)
  655  00:D105  A5 EF               lda   <_si+1
  656  00:D107  29 1F               and   #$1F
  657  00:D109  AA                  tax
  658  00:D10A  A5 EE               lda   <_si
  659  00:D10C  D0 08               bne   .l2
  660  00:D10E  E0 00               cpx   #$0
  661  00:D110  D0 03               bne   .l1
  662  00:D112  88                  dey
  663  00:D113  A2 20               ldx   #$20
  664  00:D115  CA        .l1:      dex
  665  00:D116  3A        .l2:      dec   A
  666  00:D117  8A                  txa
  667  00:D118  09 60               ora   #$60
  668  00:D11A  85 EF               sta   <_si+1
  669  00:D11C  98                  tya
  670  00:D11D  53 08               tam   #3
  671  00:D11F  B2 EE               lda   [_si]
  672  00:D121  8D EE 26            sta   maptiletype
  673  00:D124  60                  rts
  674                     
  675                     ; load_tile(int addr)
  676                     ; ----
  677                     
  678  00:D125            _load_tile:
  679                             __stw   <_di
       00:D125  86 F0              stx    <_di
       00:D127  85 F1              sta    <_di+1
  680  00:D129  86 F8               stx   <_al
  681  00:D12B  4A                  lsr   A
  682  00:D12C  66 F8               ror   <_al
  683  00:D12E  4A                  lsr   A
  684  00:D12F  66 F8               ror   <_al
  685  00:D131  4A                  lsr   A
  686  00:D132  66 F8               ror   <_al
  687  00:D134  4A                  lsr   A
  688  00:D135  66 F8               ror   <_al
  689  00:D137  8D F3 26            sta        maptilebase+1
  690                               stb   <_al,maptilebase
       00:D13A  A5 F8              lda    <_al
       00:D13C  8D F2 26           sta    maptilebase
  691                               ; --
  692                               stw   mapnbtile,<_cx
       00:D13F  AD F4 26           lda    LOW_BYTE mapnbtile
       00:D142  85 FC              sta    LOW_BYTE <_cx
       00:D144  AD F5 26           lda    HIGH_BYTE mapnbtile
       00:D147  85 FD              sta    HIGH_BYTE <_cx
  693  00:D149  A2 04               ldx   #4
  694  00:D14B  AD EE 26            lda   maptiletype
  695  00:D14E  C9 08               cmp   #8
  696  00:D150  F0 02               beq   .l1
  697  00:D152  A2 06               ldx   #6
  698  00:D154  06 FC     .l1:      asl   <_cl
  699  00:D156  26 FD               rol   <_ch
  700  00:D158  CA                  dex
  701  00:D159  D0 F9               bne   .l1
  702                               ; --
  703                               stb   maptilebank,<_bl
       00:D15B  AD EF 26           lda    maptilebank
       00:D15E  85 FA              sta    <_bl
  704                               stw   maptileaddr,<_si
       00:D160  AD F0 26           lda    LOW_BYTE maptileaddr
       00:D163  85 EE              sta    LOW_BYTE <_si
       00:D165  AD F1 26           lda    HIGH_BYTE maptileaddr
       00:D168  85 EF              sta    HIGH_BYTE <_si
  705  00:D16A  4C F1 C3            jmp   load_vram
  706                     
  707                     ; load_map(char x [al], char y [ah], int mx, int my, char w [dl], char h [dh])
  708                     ; ----
  709                     
  710  00:D16D            _load_map.6:
  711                     
  712                               tstw  mapwidth
       00:D16D  AD EA 26           lda   mapwidth               ; value at stated memory
       00:D170  0D EB 26           ora   mapwidth+1             ; location is zero
  713                               lbeq  .l6
       00:D173  D0 03              bne    .x_00311
       00:D175  4C 0F D2           jmp    .l6
       00:D178            .x_00311
  714                               tstw  mapheight
       00:D178  AD EC 26           lda   mapheight               ; value at stated memory
       00:D17B  0D ED 26           ora   mapheight+1             ; location is zero
  715                               lbeq  .l6
       00:D17E  D0 03              bne    .x_00313
       00:D180  4C 0F D2           jmp    .l6
       00:D183            .x_00313
  716                     
  717                         ; ----
  718                         ; adjust map y coordinate
  719                         ;
  720  00:D183  A4 02               ldy   <__arg_idx
  721                             __plw   <_bx
                                   ; (bytes : 9/12, cycles : 16/22)
                          
       00:D185  88                 dey
       00:D186  B9 FF 31           lda    __arg,Y
                0001              .if (1)
       00:D189  85 FA              sta    <_bx
                                  .else
                                  .endif
       00:D18B  88                 dey
       00:D18C  B9 FF 31           lda    __arg,Y
                0001              .if (1)
       00:D18F  85 FB              sta    <_bx+1
                                  .endif
  722  00:D191  30 1F               bmi   .l2
  723                     .l1:      cmpw  mapheight,<_bx
       00:D193  A5 FB              lda    HIGH_BYTE <_bx
       00:D195  CD ED 26           cmp    HIGH_BYTE mapheight
       00:D198  D0 05              bne    .x_00315
       00:D19A  A5 FA              lda    LOW_BYTE <_bx
       00:D19C  CD EC 26           cmp    LOW_BYTE mapheight
       00:D19F            .x_00315:
  724                               blo   .l3
       00:D19F  90 26              bcc    .l3
  725                               subw  mapheight,<_bx
       00:D1A1  38                 sec
       00:D1A2  A5 FA              lda    LOW_BYTE <_bx
       00:D1A4  ED EC 26           sbc    LOW_BYTE mapheight
       00:D1A7  85 FA              sta    LOW_BYTE <_bx
       00:D1A9  A5 FB              lda    HIGH_BYTE <_bx
       00:D1AB  ED ED 26           sbc    HIGH_BYTE mapheight
       00:D1AE  85 FB              sta    HIGH_BYTE <_bx
  726  00:D1B0  80 E1               bra   .l1
  727                               ; --
  728  00:D1B2  A5 FB     .l2:      lda   <_bh
  729  00:D1B4  10 11               bpl   .l3
  730                               addw  mapheight,<_bx
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       00:D1B6  18                 clc
       00:D1B7  A5 FA              lda    LOW_BYTE <_bx
       00:D1B9  6D EC 26           adc    LOW_BYTE mapheight
       00:D1BC  85 FA              sta    LOW_BYTE <_bx
       00:D1BE  A5 FB              lda    HIGH_BYTE <_bx
       00:D1C0  6D ED 26           adc    HIGH_BYTE mapheight
       00:D1C3  85 FB              sta    HIGH_BYTE <_bx
                                  .endif
  731  00:D1C5  80 EB               bra   .l2
  732                               
  733                         ; ----
  734                         ; adjust map x coordinate
  735                         ;
  736                     .l3:      stb   <_bl,<_ch
       00:D1C7  A5 FA              lda    <_bl
       00:D1C9  85 FD              sta    <_ch
  737                             __plw   <_bx
                                   ; (bytes : 9/12, cycles : 16/22)
                          
       00:D1CB  88                 dey
       00:D1CC  B9 FF 31           lda    __arg,Y
                0001              .if (1)
       00:D1CF  85 FA              sta    <_bx
                                  .else
                                  .endif
       00:D1D1  88                 dey
       00:D1D2  B9 FF 31           lda    __arg,Y
                0001              .if (1)
       00:D1D5  85 FB              sta    <_bx+1
                                  .endif
  738  00:D1D7  84 02               sty   <__arg_idx
  739  00:D1D9  30 1F               bmi   .l5
  740                     .l4:      cmpw  mapwidth,<_bx
       00:D1DB  A5 FB              lda    HIGH_BYTE <_bx
       00:D1DD  CD EB 26           cmp    HIGH_BYTE mapwidth
       00:D1E0  D0 05              bne    .x_00321
       00:D1E2  A5 FA              lda    LOW_BYTE <_bx
       00:D1E4  CD EA 26           cmp    LOW_BYTE mapwidth
       00:D1E7            .x_00321:
  741                               blo   .l7
       00:D1E7  90 2E              bcc    .l7
  742                               subw  mapwidth,<_bx
       00:D1E9  38                 sec
       00:D1EA  A5 FA              lda    LOW_BYTE <_bx
       00:D1EC  ED EA 26           sbc    LOW_BYTE mapwidth
       00:D1EF  85 FA              sta    LOW_BYTE <_bx
       00:D1F1  A5 FB              lda    HIGH_BYTE <_bx
       00:D1F3  ED EB 26           sbc    HIGH_BYTE mapwidth
       00:D1F6  85 FB              sta    HIGH_BYTE <_bx
  743  00:D1F8  80 E1               bra   .l4
  744                               ; --
  745  00:D1FA  A5 FB     .l5:      lda   <_bh
  746  00:D1FC  10 19               bpl   .l7
  747                               addw  mapwidth,<_bx
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       00:D1FE  18                 clc
       00:D1FF  A5 FA              lda    LOW_BYTE <_bx
       00:D201  6D EA 26           adc    LOW_BYTE mapwidth
       00:D204  85 FA              sta    LOW_BYTE <_bx
       00:D206  A5 FB              lda    HIGH_BYTE <_bx
       00:D208  6D EB 26           adc    HIGH_BYTE mapwidth
       00:D20B  85 FB              sta    HIGH_BYTE <_bx
                                  .endif
  748  00:D20D  80 EB               bra   .l5
  749                     
  750                         ; ----
  751                         ; exit
  752                         ;
  753                     .l6:      sub   #4,<__arg_idx
                0001              .if (2 = 2)            ; from register A (handle
       00:D20F  A5 02              lda    <__arg_idx              ; carry flag)
       00:D211  38                 sec
       00:D212  E9 04              sbc    #4
       00:D214  85 02              sta    <__arg_idx
                                  .else
                                  .endif
  754  00:D216  60                  rts
  755                     
  756                         ; ----
  757                         ; ok
  758                         ;
  759                     .l7:      stb   <_bl,<_cl
       00:D217  A5 FA              lda    <_bl
       00:D219  85 FC              sta    <_cl
  760  00:D21B  4C B4 C3            jmp   load_map
  761                     
  762                     ; spr_set(char num)
  763                     ; ----
  764                     ; load SI with the offset of the sprite to change
  765                     ; SI = satb + 8 * sprite_number
  766                     ; ----
  767                     
  768  00:D21E            _spr_set:
  769  00:D21E  E0 40               cpx   #64
  770                               bhs   .l2
       00:D220  B0 19              bcs    .l2
  771  00:D222  8A                  txa
  772  00:D223  E8                  inx
  773  00:D224  E4 1A               cpx   <__spr_max
  774                               blo   .l1
       00:D226  90 02              bcc    .l1
  775  00:D228  86 1A               stx   <__spr_max
  776                               ; --
  777  00:D22A  64 19     .l1:      stz   <__spr_ptr+1
  778  00:D22C  0A                  asl   A
  779  00:D22D  0A                  asl   A
  780  00:D22E  0A                  asl   A
  781  00:D22F  26 19               rol   <__spr_ptr+1
  782  00:D231  69 A9               adc   #low(_satb)
  783  00:D233  85 18               sta   <__spr_ptr
  784  00:D235  A5 19               lda   <__spr_ptr+1
  785  00:D237  69 27               adc   #high(_satb)
  786  00:D239  85 19               sta   <__spr_ptr+1
  787  00:D23B  60        .l2:      rts
  788                     
  789                     ; spr_hide(char num)
  790                     ; ----
  791                     
  792  00:D23C            _spr_hide:
  793  00:D23C  C0 00               cpy   #0
  794  00:D23E  F0 0E               beq   .l2
  795                               ; -- hide sprite number #
  796  00:D240  E0 40               cpx   #64
  797                               bhs   .l1
       00:D242  B0 09              bcs    .l1
  798  00:D244  20 57 D2            jsr   _spr_hide.sub
  799  00:D247  B1 0B               lda   [__ptr],Y
  800  00:D249  09 02               ora   #$02
  801  00:D24B  91 0B               sta   [__ptr],Y
  802  00:D24D  60        .l1:      rts
  803                               ; -- hide current sprite
  804  00:D24E  A0 01     .l2:      ldy   #1
  805  00:D250  B1 18               lda   [__spr_ptr],Y
  806  00:D252  09 02               ora   #$02
  807  00:D254  91 18               sta   [__spr_ptr],Y
  808  00:D256  60                  rts
  809                               ; -- calc satb ptr
  810  00:D257            _spr_hide.sub:
  811  00:D257  8A                  txa
  812  00:D258  64 0C               stz   <__ptr+1
  813  00:D25A  0A                  asl   A
  814  00:D25B  0A                  asl   A
  815  00:D25C  0A                  asl   A
  816  00:D25D  26 0C               rol   <__ptr+1
  817  00:D25F  69 A9               adc   #low(_satb)
  818  00:D261  85 0B               sta   <__ptr
  819  00:D263  A5 0C               lda   <__ptr+1
  820  00:D265  69 27               adc   #high(_satb)
  821  00:D267  85 0C               sta   <__ptr+1
  822  00:D269  A0 01               ldy   #1
  823  00:D26B  60                  rts
  824                     
  825                     ; spr_show(char num)
  826                     ; ----
  827                     
  828  00:D26C            _spr_show:
  829  00:D26C  C0 00               cpy   #0
  830  00:D26E  F0 0E               beq   .l2
  831                               ; -- hide sprite number #
  832  00:D270  E0 40               cpx   #64
  833                               bhs   .l1
       00:D272  B0 09              bcs    .l1
  834  00:D274  20 57 D2            jsr   _spr_hide.sub
  835  00:D277  B1 0B               lda   [__ptr],Y
  836  00:D279  29 01               and   #$01
  837  00:D27B  91 0B               sta   [__ptr],Y
  838  00:D27D  60        .l1:      rts
  839                               ; -- hide current sprite
  840  00:D27E  A0 01     .l2:      ldy   #1
  841  00:D280  B1 18               lda   [__spr_ptr],Y
  842  00:D282  29 01               and   #$01
  843  00:D284  91 18               sta   [__spr_ptr],Y
  844  00:D286  60                  rts
  845                     
  846                     ; spr_x(int value)
  847                     ; ----
  848                     
  849  00:D287            _spr_x:
  850  00:D287  A0 02               ldy   #2
  851  00:D289  22                  sax
  852                               add   #32
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       00:D28A  18                 clc
       00:D28B  69 20              adc    #32
                                  .endif
  853  00:D28D  91 18               sta   [__spr_ptr],Y
  854  00:D28F  22                  sax
  855  00:D290  69 00               adc   #0
  856  00:D292  C8                  iny
  857  00:D293  91 18               sta   [__spr_ptr],Y
  858  00:D295  60                  rts
  859                     
  860  00:D296            _spr_get_x:
  861  00:D296  A0 02               ldy   #2
  862  00:D298  B1 18               lda   [__spr_ptr],Y
  863                               sub   #32
                0000              .if (1 = 2)            ; from register A (handle
                                  .else
       00:D29A  38                 sec
       00:D29B  E9 20              sbc    #32
                                  .endif
  864  00:D29D  AA                  tax
  865  00:D29E  C8                  iny
  866  00:D29F  B1 18               lda   [__spr_ptr],Y
  867  00:D2A1  E9 00               sbc   #0
  868  00:D2A3  60                  rts
  869                     
  870                     ; spr_y(int value)
  871                     ; ----
  872                     
  873  00:D2A4            _spr_y:
  874  00:D2A4  22                  sax
  875                               add   #64
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       00:D2A5  18                 clc
       00:D2A6  69 40              adc    #64
                                  .endif
  876  00:D2A8  92 18               sta   [__spr_ptr]
  877  00:D2AA  22                  sax
  878  00:D2AB  69 00               adc   #0
  879  00:D2AD  29 01               and   #$01
  880  00:D2AF  A0 01               ldy   #1
  881  00:D2B1  91 18               sta   [__spr_ptr],Y
  882  00:D2B3  60                  rts
  883                     
  884  00:D2B4            _spr_get_y:
  885  00:D2B4  B2 18               lda   [__spr_ptr]
  886                               sub   #64
                0000              .if (1 = 2)            ; from register A (handle
                                  .else
       00:D2B6  38                 sec
       00:D2B7  E9 40              sbc    #64
                                  .endif
  887  00:D2B9  AA                  tax
  888  00:D2BA  A0 01               ldy   #1
  889  00:D2BC  B1 18               lda   [__spr_ptr],Y
  890  00:D2BE  E9 00               sbc   #0
  891  00:D2C0  60                  rts
  892                     
  893                     ; spr_pattern(int vaddr)
  894                     ; ----
  895                     
  896  00:D2C1            _spr_pattern:
  897  00:D2C1  85 03               sta   <__temp
  898  00:D2C3  8A                  txa
  899  00:D2C4  0A                  asl   A
  900  00:D2C5  26 03               rol   <__temp
  901  00:D2C7  2A                  rol   A
  902  00:D2C8  26 03               rol   <__temp
  903  00:D2CA  2A                  rol   A
  904  00:D2CB  26 03               rol   <__temp
  905  00:D2CD  2A                  rol   A
  906  00:D2CE  29 07               and   #$7
  907  00:D2D0  A0 05               ldy   #5
  908  00:D2D2  91 18               sta   [__spr_ptr],Y
  909  00:D2D4  A5 03               lda   <__temp
  910  00:D2D6  88                  dey
  911  00:D2D7  91 18               sta   [__spr_ptr],Y
  912  00:D2D9  60                  rts
  913                     
  914  00:D2DA            _spr_get_pattern:
  915  00:D2DA  A0 04               ldy   #4
  916  00:D2DC  B1 18               lda   [__spr_ptr],Y
  917  00:D2DE  85 03               sta   <__temp
  918  00:D2E0  C8                  iny
  919  00:D2E1  B1 18               lda   [__spr_ptr],Y
  920  00:D2E3  4A                  lsr   A
  921  00:D2E4  66 03               ror   <__temp
  922  00:D2E6  6A                  ror   A
  923  00:D2E7  66 03               ror   <__temp
  924  00:D2E9  6A                  ror   A
  925  00:D2EA  66 03               ror   <__temp
  926  00:D2EC  6A                  ror   A
  927  00:D2ED  29 E0               and   #$E0
  928  00:D2EF  AA                  tax
  929  00:D2F0  A5 03               lda   <__temp
  930  00:D2F2  60                  rts
  931                     
  932                     ; spr_ctrl(char mask [al], char value)
  933                     ; ----
  934                     
  935  00:D2F3            _spr_ctrl.2:
  936  00:D2F3  8A                  txa
  937  00:D2F4  25 F8               and   <_al
  938  00:D2F6  85 03               sta   <__temp
  939  00:D2F8  A5 F8               lda   <_al
  940  00:D2FA  49 FF               eor   #$FF
  941  00:D2FC  A0 07               ldy   #7
  942  00:D2FE  31 18               and   [__spr_ptr],Y
  943  00:D300  05 03               ora   <__temp
  944  00:D302  91 18               sta   [__spr_ptr],Y
  945  00:D304  60                  rts
  946                     
  947                     ; spr_pal(char pal)
  948                     ; ----
  949                     
  950  00:D305            _spr_pal:
  951  00:D305  8A                  txa
  952  00:D306  29 0F               and   #$0F
  953  00:D308  85 03               sta   <__temp
  954  00:D30A  A0 06               ldy   #6
  955  00:D30C  B1 18               lda   [__spr_ptr],Y
  956  00:D30E  29 F0               and   #$F0
  957  00:D310  05 03               ora   <__temp
  958  00:D312  91 18               sta   [__spr_ptr],Y
  959  00:D314  60                  rts
  960                     
  961  00:D315            _spr_get_pal:
  962  00:D315  A0 06               ldy   #6
  963  00:D317  B1 18               lda   [__spr_ptr],Y
  964  00:D319  29 0F               and   #$0F
  965  00:D31B  AA                  tax
  966  00:D31C  62                  cla
  967  00:D31D  60                  rts
  968                     
  969                     ; spr_pri(char pri)
  970                     ; ----
  971                     
  972  00:D31E            _spr_pri:
  973  00:D31E  A0 06               ldy   #6
  974  00:D320  B1 18               lda   [__spr_ptr],Y
  975  00:D322  29 7F               and   #$7F
  976  00:D324  E0 00               cpx   #$00
  977  00:D326  F0 02               beq   .l1
  978  00:D328  09 80               ora   #$80
  979  00:D32A            .l1:
  980  00:D32A  91 18               sta   [__spr_ptr],Y
  981  00:D32C  60                  rts
  982                     
  983                     ; satb_update()
  984                     ; ----
  985                     
  986  00:D32D            _satb_update:
  987  00:D32D  A5 1B               lda   <__spr_flag
  988  00:D32F  F0 06               beq   .l1
  989  00:D331  64 1B               stz   <__spr_flag
  990  00:D333  A2 40               ldx   #64
  991  00:D335  80 0A               bra   .l3
  992                               ; --
  993  00:D337  C0 01     .l1:      cpy   #1
  994  00:D339  F0 02               beq   .l2
  995  00:D33B  A6 1A               ldx   <__spr_max
  996  00:D33D  E0 00     .l2:      cpx   #0
  997  00:D33F  F0 50               beq   .l4
  998                               ; --
  999  00:D341  86 F8     .l3:      stx   <_al    ; number of sprites
 1000  00:D343  8A                  txa
 1001  00:D344  3A                  dec   A       ; round up to the next group of 4 sprites
 1002  00:D345  4A                  lsr   A
 1003  00:D346  4A                  lsr   A
 1004  00:D347  1A                  inc   A
 1005  00:D348  85 FC               sta   <_cl
 1006                     
 1007                     ; Use TIA, but BLiT 16 words at a time (32 bytes)
 1008                     ; Because interrupt must not deferred too much
 1009                     ;
 1010                               stw   #32, _ram_hdwr_tia_size
       00:D34A  A9 20              lda    LOW_BYTE #32
       00:D34C  8D 07 27           sta    LOW_BYTE _ram_hdwr_tia_size
       00:D34F  A9 00              lda    HIGH_BYTE #32
       00:D351  8D 08 27           sta    HIGH_BYTE _ram_hdwr_tia_size
 1011                               stw   #video_data, _ram_hdwr_tia_dest
       00:D354  A9 02              lda    LOW_BYTE #video_data
       00:D356  8D 05 27           sta    LOW_BYTE _ram_hdwr_tia_dest
       00:D359  A9 00              lda    HIGH_BYTE #video_data
       00:D35B  8D 06 27           sta    HIGH_BYTE _ram_hdwr_tia_dest
 1012                               stw   #_satb, <_si
       00:D35E  A9 A9              lda    LOW_BYTE #_satb
       00:D360  85 EE              sta    LOW_BYTE <_si
       00:D362  A9 27              lda    HIGH_BYTE #_satb
       00:D364  85 EF              sta    HIGH_BYTE <_si
 1013                     
 1014                               stw   #$7F00, <_di
       00:D366  A9 00              lda    LOW_BYTE #$7F00
       00:D368  85 F0              sta    LOW_BYTE <_di
       00:D36A  A9 7F              lda    HIGH_BYTE #$7F00
       00:D36C  85 F1              sta    HIGH_BYTE <_di
 1015  00:D36E  20 36 C4            jsr   set_write
 1016                     
 1017                     .l3a:     stw   <_si, _ram_hdwr_tia_src
       00:D371  A5 EE              lda    LOW_BYTE <_si
       00:D373  8D 03 27           sta    LOW_BYTE _ram_hdwr_tia_src
       00:D376  A5 EF              lda    HIGH_BYTE <_si
       00:D378  8D 04 27           sta    HIGH_BYTE _ram_hdwr_tia_src
 1018  00:D37B  20 02 27            jsr   _ram_hdwr_tia
 1019                               addw  #32,<_si
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       00:D37E  18                 clc
       00:D37F  A5 EE              lda    LOW_BYTE <_si
       00:D381  69 20              adc    LOW_BYTE #32
       00:D383  85 EE              sta    LOW_BYTE <_si
       00:D385  A5 EF              lda    HIGH_BYTE <_si
       00:D387  69 00              adc    HIGH_BYTE #32
       00:D389  85 EF              sta    HIGH_BYTE <_si
                                  .endif
 1020  00:D38B  C6 FC               dec   <_cl
 1021  00:D38D  D0 E2               bne   .l3a
 1022                               
 1023                     ;.l3:     stx   <_al
 1024                     ;         stw   #_satb,<_si
 1025                     ;         stb   #BANK(_satb),<_bl
 1026                     ;         stw   #$7F00,<_di
 1027                     ;         txa
 1028                     ;         stz   <_ch
 1029                     ;         asl   A
 1030                     ;         asl   A
 1031                     ;         rol   <_ch
 1032                     ;         sta   <_cl
 1033                     ;         jsr   load_vram
 1034                     
 1035                               ; --
 1036  00:D38F  A6 F8               ldx   <_al
 1037  00:D391  62        .l4:      cla
 1038  00:D392  60                  rts
 1039                     
 1040                     
 1041                     ; init_satb()
 1042                     ; reset_satb()
 1043                     ; ----
 1044                     
 1045  00:D393            _reset_satb:
 1046  00:D393            _init_satb:
 1047  00:D393  82                  clx
 1048  00:D394  62                  cla
 1049  00:D395  9E A9 27  .l1:      stz   _satb,X
 1050  00:D398  9E A9 28            stz   _satb+256,X
 1051  00:D39B  E8                  inx
 1052  00:D39C  D0 F7               bne   .l1
 1053                               ; --
 1054  00:D39E  A0 01               ldy   #1
 1055  00:D3A0  84 1B               sty   <__spr_flag
 1056  00:D3A2  64 1A               stz   <__spr_max
 1057  00:D3A4  60                  rts
 1058                     
 1059                     ; get_color(int index [color_reg])
 1060                     ; ----
 1061                     ; index: index in the palette (0-511)
 1062                     ; ----
 1063                     
 1064  00:D3A5            _get_color.1:
 1065  00:D3A5  AE 04 04            ldx   color_data_l
 1066  00:D3A8  AD 05 04            lda   color_data_h
 1067  00:D3AB  29 01               and   #$01
 1068  00:D3AD  60                  rts
 1069                     
 1070                     ; set_color(int index [color_reg], int color [color_data])
 1071                     ; ----
 1072                     ; set one palette entry to the specified color
 1073                     ; ----
 1074                     ; index: index in the palette (0-511)
 1075                     ; color: color value,  GREEN: bit 6-8
 1076                     ;                      RED:   bit 3-5
 1077                     ;                      BLUE:  bit 0-2
 1078                     ; ----
 1079                     ; NOTE : inlined
 1080                     ; ----
 1081                     
 1082                     ; fade_color(int color [ax], char level)
 1083                     ; fade_color(int index [color_reg], int color [ax], char level)
 1084                     ; ----
 1085                     ; set one palette entry to the specified color
 1086                     ; ----
 1087                     ; index: index in the palette (0-511)
 1088                     ; color: color value,  GREEN: bit 6-8
 1089                     ;                      RED:   bit 3-5
 1090                     ;                      BLUE:  bit 0-2
 1091                     ; level: level of fading (0 = black, 8 = full)
 1092                     ; ----
 1093                     
 1094  00:D3AE            _fade_color.2:
 1095  00:D3AE            _fade_color.3:
 1096  00:D3AE  E0 00               cpx   #0
 1097  00:D3B0  F0 38               beq   .l4
 1098  00:D3B2  E0 08               cpx   #8
 1099                               bhs   .l5
       00:D3B4  B0 37              bcs    .l5
 1100                               ; -- fading
 1101  00:D3B6  A0 03               ldy   #3
 1102  00:D3B8  86 FA               stx   <_bl
 1103                               stwz  <_dx
       00:D3BA  64 FE              stz    LOW_BYTE <_dx
       00:D3BC  64 FF              stz    HIGH_BYTE <_dx
 1104  00:D3BE  46 FA     .l1:      lsr   <_bl
 1105  00:D3C0  90 0D               bcc   .l2
 1106                               addw  <_ax,<_dx
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       00:D3C2  18                 clc
       00:D3C3  A5 FE              lda    LOW_BYTE <_dx
       00:D3C5  65 F8              adc    LOW_BYTE <_ax
       00:D3C7  85 FE              sta    LOW_BYTE <_dx
       00:D3C9  A5 FF              lda    HIGH_BYTE <_dx
       00:D3CB  65 F9              adc    HIGH_BYTE <_ax
       00:D3CD  85 FF              sta    HIGH_BYTE <_dx
                                  .endif
 1107                     .l2:      aslw  <_ax
       00:D3CF  06 F8              asl    <_ax              ; word-sized value (at stated
       00:D3D1  26 F9              rol    <_ax+1            ; memory location)
 1108  00:D3D3  88                  dey
 1109  00:D3D4  D0 E8               bne   .l1
 1110  00:D3D6  A5 FF               lda   <_dh
 1111  00:D3D8  4A                  lsr   A
 1112  00:D3D9  66 FE               ror   <_dl
 1113  00:D3DB  4A                  lsr   A
 1114  00:D3DC  66 FE               ror   <_dl
 1115  00:D3DE  4A                  lsr   A
 1116  00:D3DF  66 FE               ror   <_dl
 1117                               ; -- set color
 1118  00:D3E1  A6 FE               ldx   <_dl
 1119  00:D3E3  8E 04 04  .l3:      stx   color_data_l
 1120  00:D3E6  8D 05 04            sta   color_data_h
 1121  00:D3E9  60                  rts
 1122                               ; -- black
 1123  00:D3EA  62        .l4:      cla
 1124  00:D3EB  80 F6               bra   .l3
 1125                               ; -- full
 1126  00:D3ED  A6 F8     .l5:      ldx   <_al
 1127  00:D3EF  A5 F9               lda   <_ah
 1128  00:D3F1  80 F0               bra   .l3
 1129                     
 1130                     ; set_color_rgb(int index [color_reg], char r [al], char g [ah], char b)
 1131                     ; ----
 1132                     ; set one palette entry to the specified color
 1133                     ; ----
 1134                     ; index: index in the palette (0-511)
 1135                     ; r:     red              RED:   bit 3-5
 1136                     ; g:     green            GREEN: bit 6-8
 1137                     ; b:     blue             BLUE:  bit 0-2
 1138                     ; ----
 1139                     
 1140  00:D3F3            _set_color_rgb.4:
 1141  00:D3F3  8A                  txa
 1142  00:D3F4  29 07               and   #$7
 1143  00:D3F6  85 03               sta   <__temp
 1144  00:D3F8  A5 F8               lda   <_al
 1145  00:D3FA  0A                  asl   A
 1146  00:D3FB  0A                  asl   A
 1147  00:D3FC  0A                  asl   A
 1148  00:D3FD  05 03               ora   <__temp
 1149  00:D3FF  0A                  asl   A
 1150  00:D400  0A                  asl   A
 1151  00:D401  85 03               sta   <__temp
 1152  00:D403  A5 F9               lda   <_ah
 1153  00:D405  4A                  lsr   A
 1154  00:D406  66 03               ror   <__temp
 1155  00:D408  4A                  lsr   A
 1156  00:D409  66 03               ror   <__temp
 1157  00:D40B  A6 03               ldx   <__temp
 1158  00:D40D  8E 04 04            stx   color_data_l
 1159  00:D410  8D 05 04            sta   color_data_h
 1160  00:D413  60                  rts
 1161                     
 1162                     ; put_tile(int tile_num [dx], int position)
 1163                     ; put_tile(int tile_num [dx], char x [al], char y)
 1164                     ; ----
 1165                     ; draw a single 8x8 or 16x16 tile at a given position
 1166                     ; ----
 1167                     ; pattern:  vram address of the tile pattern
 1168                     ; position: position on screen where to put the tile
 1169                     ; ----
 1170                     
 1171  00:D414            _put_tile.3:
 1172  00:D414  A5 F8               lda   <_al
 1173  00:D416  AC EE 26            ldy   maptiletype
 1174  00:D419  C0 08               cpy   #8
 1175  00:D41B  F0 08               beq   .l1
 1176                               ; --
 1177  00:D41D  0A                  asl   A
 1178  00:D41E  22                  sax
 1179  00:D41F  0A                  asl   A
 1180  00:D420  20 53 C4            jsr   calc_vram_addr
 1181  00:D423  80 33               bra   _put_tile_16
 1182                               ; --
 1183  00:D425  22        .l1:      sax
 1184  00:D426  20 53 C4            jsr   calc_vram_addr
 1185  00:D429  80 0B               bra   _put_tile_8
 1186  00:D42B            _put_tile.2:
 1187                             __stw   <_di
       00:D42B  86 F0              stx    <_di
       00:D42D  85 F1              sta    <_di+1
 1188  00:D42F  AC EE 26            ldy   maptiletype
 1189  00:D432  C0 08               cpy   #8
 1190  00:D434  D0 22               bne   _put_tile_16
 1191  00:D436            _put_tile_8:
 1192  00:D436  20 36 C4            jsr   set_write
 1193                               ; -- calculate tile vram address
 1194                               stw   mapctable,<_bx
       00:D439  AD F7 26           lda    LOW_BYTE mapctable
       00:D43C  85 FA              sta    LOW_BYTE <_bx
       00:D43E  AD F8 26           lda    HIGH_BYTE mapctable
       00:D441  85 FB              sta    HIGH_BYTE <_bx
 1195  00:D443  A5 FE               lda   <_dl
 1196  00:D445  A8                  tay
 1197                               add   maptilebase
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       00:D446  18                 clc
       00:D447  6D F2 26           adc    maptilebase
                                  .endif
 1198  00:D44A  AA                  tax
 1199  00:D44B  62                  cla
 1200  00:D44C  6D F3 26            adc   maptilebase+1
 1201  00:D44F  71 FA               adc   [_bx],Y
 1202                               ; -- copy tile
 1203  00:D451  8E 02 00            stx   video_data_l
 1204  00:D454  8D 03 00            sta   video_data_h
 1205  00:D457  60                  rts
 1206  00:D458            _put_tile_16:
 1207  00:D458  20 36 C4            jsr   set_write
 1208                               ; -- calculate tile vram address
 1209                               stw   mapctable,<_bx
       00:D45B  AD F7 26           lda    LOW_BYTE mapctable
       00:D45E  85 FA              sta    LOW_BYTE <_bx
       00:D460  AD F8 26           lda    HIGH_BYTE mapctable
       00:D463  85 FB              sta    HIGH_BYTE <_bx
 1210  00:D465  64 FF               stz   <_dh
 1211  00:D467  A5 FE               lda   <_dl
 1212  00:D469  A8                  tay
 1213  00:D46A  0A                  asl   A
 1214  00:D46B  26 FF               rol   <_dh
 1215  00:D46D  0A                  asl   A
 1216  00:D46E  26 FF               rol   <_dh
 1217                               add   maptilebase
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       00:D470  18                 clc
       00:D471  6D F2 26           adc    maptilebase
                                  .endif
 1218  00:D474  85 FE               sta   <_dl
 1219  00:D476  A5 FF               lda   <_dh
 1220  00:D478  6D F3 26            adc   maptilebase+1
 1221  00:D47B  71 FA               adc   [_bx],Y
 1222  00:D47D  85 FF               sta   <_dh
 1223                               ; -- copy tile
 1224                               stw   <_dx,video_data
       00:D47F  A5 FE              lda    LOW_BYTE <_dx
       00:D481  8D 02 00           sta    LOW_BYTE video_data
       00:D484  A5 FF              lda    HIGH_BYTE <_dx
       00:D486  8D 03 00           sta    HIGH_BYTE video_data
 1225                               incw  <_dx
       00:D489  E6 FE              inc    <_dx              ; value at stated memory
       00:D48B  D0 02              bne    .x_00351           ; location
       00:D48D  E6 FF              inc    <_dx+1
       00:D48F            .x_00351:
 1226                               stw   <_dx,video_data
       00:D48F  A5 FE              lda    LOW_BYTE <_dx
       00:D491  8D 02 00           sta    LOW_BYTE video_data
       00:D494  A5 FF              lda    HIGH_BYTE <_dx
       00:D496  8D 03 00           sta    HIGH_BYTE video_data
 1227                               incw  <_dx
       00:D499  E6 FE              inc    <_dx              ; value at stated memory
       00:D49B  D0 02              bne    .x_00353           ; location
       00:D49D  E6 FF              inc    <_dx+1
       00:D49F            .x_00353:
 1228                               vreg  #0
       00:D49F  A9 00              lda    #0
       00:D4A1  85 F7              sta    <vdc_reg
                0001               .if (2 = ARG_IMMED)
       00:D4A3  03 00               st0   #0
                                   .else
                                   .endif
 1229                               addw  bat_width,<_di,video_data
                0001              .if     (3 = 3)
                                   ; 3-arg mode
                                   ;
       00:D4A5  18                 clc
       00:D4A6  A5 F0              lda    LOW_BYTE <_di
       00:D4A8  6D 0A 27           adc    LOW_BYTE bat_width
       00:D4AB  8D 02 00           sta    LOW_BYTE video_data
       00:D4AE  A5 F1              lda    HIGH_BYTE <_di
       00:D4B0  6D 0B 27           adc    HIGH_BYTE bat_width
       00:D4B3  8D 03 00           sta    HIGH_BYTE video_data
                                  .else
                                  .endif
 1230                               vreg  #2
       00:D4B6  A9 02              lda    #2
       00:D4B8  85 F7              sta    <vdc_reg
                0001               .if (2 = ARG_IMMED)
       00:D4BA  03 02               st0   #2
                                   .else
                                   .endif
 1231                               stw   <_dx,video_data
       00:D4BC  A5 FE              lda    LOW_BYTE <_dx
       00:D4BE  8D 02 00           sta    LOW_BYTE video_data
       00:D4C1  A5 FF              lda    HIGH_BYTE <_dx
       00:D4C3  8D 03 00           sta    HIGH_BYTE video_data
 1232                               incw  <_dx
       00:D4C6  E6 FE              inc    <_dx              ; value at stated memory
       00:D4C8  D0 02              bne    .x_00358           ; location
       00:D4CA  E6 FF              inc    <_dx+1
       00:D4CC            .x_00358:
 1233                               stw   <_dx,video_data
       00:D4CC  A5 FE              lda    LOW_BYTE <_dx
       00:D4CE  8D 02 00           sta    LOW_BYTE video_data
       00:D4D1  A5 FF              lda    HIGH_BYTE <_dx
       00:D4D3  8D 03 00           sta    HIGH_BYTE video_data
 1234  00:D4D6  60                  rts
 1235                     
 1236                     ; map_get_tile(char x [dl], char y)
 1237                     ; map_put_tile(char x [dl], char y [dh], char tile)
 1238                     ; ----
 1239                     
 1240  00:D4D7            _map_get_tile.2:
 1241  00:D4D7  86 FF               stx   <_dh
 1242  00:D4D9  20 E9 D4            jsr   _map_calc_tile_addr
 1243                               ; --
 1244  00:D4DC  B2 FC               lda   [_cx]
 1245  00:D4DE  AA                  tax
 1246  00:D4DF  62                  cla
 1247  00:D4E0  60                  rts
 1248                     
 1249  00:D4E1            _map_put_tile.3:
 1250  00:D4E1  DA                  phx
 1251  00:D4E2  20 E9 D4            jsr   _map_calc_tile_addr
 1252  00:D4E5  68                  pla
 1253  00:D4E6  92 FC               sta   [_cx]
 1254  00:D4E8  60                  rts
 1255                     
 1256                     ; map_calc_tile_addr(char x [dl], char y [dh])
 1257                     ; ----
 1258  00:D4E9            _map_calc_tile_addr:
 1259  00:D4E9  A6 FF               ldx   <_dh
 1260  00:D4EB  AD EB 26            lda   mapwidth+1
 1261  00:D4EE  F0 08               beq   .l1
 1262  00:D4F0  86 FD               stx   <_ch
 1263  00:D4F2  A5 FE               lda   <_dl
 1264  00:D4F4  85 FC               sta   <_cl
 1265  00:D4F6  80 13               bra   .l2
 1266                               ; --
 1267  00:D4F8  86 F8     .l1:      stx   <_al
 1268  00:D4FA  AD EA 26            lda   mapwidth
 1269  00:D4FD  85 FA               sta   <_bl
 1270  00:D4FF  20 BD E0            jsr   mulu8
 1271                               ; --
 1272  00:D502  A5 FC               lda   <_cl
 1273                               add   <_dl
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       00:D504  18                 clc
       00:D505  65 FE              adc    <_dl
                                  .endif
 1274  00:D507  90 02               bcc   .l2
 1275  00:D509  E6 FD               inc   <_ch
 1276                               ; --
 1277                     .l2:      add   mapaddr
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       00:D50B  18                 clc
       00:D50C  6D E8 26           adc    mapaddr
                                  .endif
 1278  00:D50F  85 FC               sta   <_cl
 1279  00:D511  AD E9 26            lda   mapaddr+1
 1280  00:D514  29 1F               and   #$1F
 1281  00:D516  65 FD               adc   <_ch
 1282  00:D518  AA                  tax
 1283                               ; --
 1284                     ;         rol   A
 1285                     ;         rol   A
 1286                     ;         rol   A
 1287                     ;         rol   A
 1288  00:D519  4A                  lsr   A
 1289  00:D51A  4A                  lsr   A
 1290  00:D51B  4A                  lsr   A
 1291  00:D51C  4A                  lsr   A
 1292  00:D51D  4A                  lsr   A
 1293  00:D51E  29 0F               and   #$0F
 1294                               add   mapbank
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       00:D520  18                 clc
       00:D521  6D E7 26           adc    mapbank
                                  .endif
 1295  00:D524  53 08               tam   #3
 1296                               ; --
 1297  00:D526  8A                  txa
 1298  00:D527  29 1F               and   #$1F
 1299  00:D529  09 60               ora   #$60
 1300  00:D52B  85 FD               sta   <_ch
 1301  00:D52D  A6 FC               ldx   <_cl
 1302  00:D52F  60                  rts
 1303                     
 1304                     ; scroll(char num, int x, int y, char top, char bottom, char disp)
 1305                     ; ----
 1306                     ; set screen scrolling
 1307                     ; ----
 1308                     
 1309  00:D530            _scroll:
 1310  00:D530  A0 08               ldy   #8
 1311  00:D532  B1 00               lda   [__sp],Y
 1312  00:D534  29 03               and   #$03
 1313                               ; --
 1314  00:D536  22                  sax
 1315  00:D537  29 C0               and   #$C0
 1316  00:D539  09 01               ora   #$01
 1317  00:D53B  9D 2E 27            sta   scroll_cr,X
 1318  00:D53E  B2 00               lda   [__sp]
 1319  00:D540  1A                  inc   A
 1320  00:D541  9D 2A 27            sta   scroll_bottom,X
 1321  00:D544  A0 02               ldy   #2
 1322  00:D546  B1 00               lda   [__sp],Y
 1323  00:D548  9D 26 27            sta   scroll_top,X
 1324  00:D54B  A0 04               ldy   #4
 1325  00:D54D  B1 00               lda   [__sp],Y
 1326  00:D54F  9D 1E 27            sta   scroll_yl,X
 1327  00:D552  C8                  iny
 1328  00:D553  B1 00               lda   [__sp],Y
 1329  00:D555  9D 22 27            sta   scroll_yh,X
 1330  00:D558  C8                  iny
 1331  00:D559  B1 00               lda   [__sp],Y
 1332  00:D55B  9D 16 27            sta   scroll_xl,X
 1333  00:D55E  C8                  iny
 1334  00:D55F  B1 00               lda   [__sp],Y
 1335  00:D561  9D 1A 27            sta   scroll_xh,X
 1336                               addw  #10,<__sp
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       00:D564  18                 clc
       00:D565  A5 00              lda    LOW_BYTE <__sp
       00:D567  69 0A              adc    LOW_BYTE #10
       00:D569  85 00              sta    LOW_BYTE <__sp
       00:D56B  A5 01              lda    HIGH_BYTE <__sp
       00:D56D  69 00              adc    HIGH_BYTE #10
       00:D56F  85 01              sta    HIGH_BYTE <__sp
                                  .endif
 1337  00:D571  60                  rts
 1338                     
 1339                     ; scroll_disable(char num)
 1340                     ; ----
 1341                     ; disable screen scrolling for a scroll region
 1342                     ; ----
 1343                     
 1344  00:D572            _scroll_disable:
 1345  00:D572  BD 2E 27            lda   scroll_cr,X
 1346  00:D575  29 FE               and   #$fe
 1347  00:D577  9D 2E 27            sta   scroll_cr,X
 1348  00:D57A  60                  rts
 1349                     
 1350                     ; set_screen_size(char size)
 1351                     ; ----
 1352                     ; set screen virtual size
 1353                     ; ----
 1354                     
 1355  00:D57B            _set_screen_size:
 1356  00:D57B  8A                  txa
 1357  00:D57C  4C 5C C5            jmp   set_bat_size
 1358                     
 1359                     ; set_xres(int xres)
 1360                     ; ----
 1361                     ; set horizontal display resolution
 1362                     ; ----
 1363                     
 1364  00:D57F            _set_xres.1:
 1365  00:D57F  A9 04               lda   #XRES_SOFT
 1366  00:D581  85 FC               sta   <_cl
 1367  00:D583            _set_xres.2:
 1368  00:D583  20 4A C5            jsr   set_xres
 1369  00:D586  A6 F8               ldx   <_al
 1370  00:D588  A5 F9               lda   <_ah
 1371  00:D58A  60                  rts
 1372                     
 1373                     
 1374                     ; ------------------------
 1375                     ; Graphics functions
 1376                     ; ------------------------
 1377                     
 1378                     ; readvram
 1379                     ; ----
 1380                     ; leftover from asm library
 1381                     ; needed for 'a = vram[n]'
 1382                     ; semantic
 1383                     ; ----
 1384  00:D58B            readvram:
 1385  00:D58B  A0 01               ldy   #1
 1386  00:D58D  84 F7               sty   <vdc_reg
 1387  00:D58F  8C 00 00            sty   video_reg
 1388  00:D592  8E 02 00            stx   video_data_l
 1389  00:D595  8D 03 00            sta   video_data_h
 1390                               vreg  #$02
       00:D598  A9 02              lda    #$02
       00:D59A  85 F7              sta    <vdc_reg
                0001               .if (2 = ARG_IMMED)
       00:D59C  03 02               st0   #$02
                                   .else
                                   .endif
 1391  00:D59E  AE 02 00            ldx   video_data_l
 1392  00:D5A1  AD 03 00            lda   video_data_h
 1393  00:D5A4  60                  rts
 1394                     
 1395                     
 1396                     ; writevram
 1397                     ; ----
 1398                     ; leftover from asm library
 1399                     ; needed for 'vram[n] = a'
 1400                     ; semantic
 1401                     ; ----
 1402  00:D5A5            writevram:
 1403  00:D5A5  A8                  tay
 1404  00:D5A6  64 F7               stz   <vdc_reg
 1405  00:D5A8  9C 00 00            stz   video_reg
 1406  00:D5AB  B2 00               lda   [__sp]
 1407  00:D5AD  8D 02 00            sta   video_data_l
 1408                               incw  <__sp
       00:D5B0  E6 00              inc    <__sp              ; value at stated memory
       00:D5B2  D0 02              bne    .x_00365           ; location
       00:D5B4  E6 01              inc    <__sp+1
       00:D5B6            .x_00365:
 1409  00:D5B6  B2 00               lda   [__sp]
 1410  00:D5B8  8D 03 00            sta   video_data_h
 1411                               incw  <__sp
       00:D5BB  E6 00              inc    <__sp              ; value at stated memory
       00:D5BD  D0 02              bne    .x_00366           ; location
       00:D5BF  E6 01              inc    <__sp+1
       00:D5C1            .x_00366:
 1412                               vreg  #2
       00:D5C1  A9 02              lda    #2
       00:D5C3  85 F7              sta    <vdc_reg
                0001               .if (2 = ARG_IMMED)
       00:D5C5  03 02               st0   #2
                                   .else
                                   .endif
 1413  00:D5C7  8E 02 00            stx   video_data_l
 1414  00:D5CA  8C 03 00            sty   video_data_h
 1415  00:D5CD  60                  rts
 1416                     
 1417                     
 1418                     ; gfx_setbgpal(char pal)
 1419                     ; ----
 1420                     ; set default major palette for gfx_* func's
 1421                     ; ----
 1422                     
 1423  00:D5CE            _gfx_setbgpal:
 1424  00:D5CE  8A                  txa
 1425  00:D5CF  0A                  asl   A
 1426  00:D5D0  0A                  asl   A
 1427  00:D5D1  0A                  asl   A
 1428  00:D5D2  0A                  asl   A
 1429  00:D5D3  8D A9 29            sta   _gfx_pal
 1430  00:D5D6  60                  rts
 1431                     
 1432                     
 1433                     ; gfx_init(int start_vram_addr)
 1434                     ; ----
 1435                     ; initialize graphics mode
 1436                     ;  - points graphics map to tiles at start_vram_addr
 1437                     ; ----
 1438                     
 1439  00:D5D7            _gfx_init:
 1440                             __stw   <_dx    ; vram addr
       00:D5D7  86 FE              stx    <_dx
       00:D5D9  85 FF              sta    <_dx+1
 1441                     
 1442                               lsrw  <_dx    ; shift address to make char pattern
       00:D5DB  46 FF              lsr    <_dx+1            ; value (at stated memory
       00:D5DD  66 FE              ror    <_dx              ; location)
 1443                               lsrw  <_dx
       00:D5DF  46 FF              lsr    <_dx+1            ; value (at stated memory
       00:D5E1  66 FE              ror    <_dx              ; location)
 1444                               lsrw  <_dx
       00:D5E3  46 FF              lsr    <_dx+1            ; value (at stated memory
       00:D5E5  66 FE              ror    <_dx              ; location)
 1445                               lsrw  <_dx
       00:D5E7  46 FF              lsr    <_dx+1            ; value (at stated memory
       00:D5E9  66 FE              ror    <_dx              ; location)
 1446  00:D5EB  A5 FF               lda   <_dx+1
 1447  00:D5ED  29 0F               and   #$0f
 1448  00:D5EF  0D A9 29            ora   _gfx_pal        ; and add major palette info
 1449  00:D5F2  85 FF               sta   <_dx+1
 1450                     
 1451                               setvwaddr $0
                                   stw  #$0,<_di
       00:D5F4  A9 00              lda    LOW_BYTE #$0
       00:D5F6  85 F0              sta    LOW_BYTE <_di
       00:D5F8  A9 00              lda    HIGH_BYTE #$0
       00:D5FA  85 F1              sta    HIGH_BYTE <_di
       00:D5FC  20 36 C4           jsr  set_write
 1452                               ; --
 1453  00:D5FF  AC 0C 27            ldy   bat_height
 1454  00:D602  AE 0A 27  .l2:      ldx   bat_width
 1455                               ; --
 1456                     .l3:      stw   <_dx,video_data
       00:D605  A5 FE              lda    LOW_BYTE <_dx
       00:D607  8D 02 00           sta    LOW_BYTE video_data
       00:D60A  A5 FF              lda    HIGH_BYTE <_dx
       00:D60C  8D 03 00           sta    HIGH_BYTE video_data
 1457                               incw  <_dx
       00:D60F  E6 FE              inc    <_dx              ; value at stated memory
       00:D611  D0 02              bne    .x_00376           ; location
       00:D613  E6 FF              inc    <_dx+1
       00:D615            .x_00376:
 1458  00:D615  CA                  dex
 1459  00:D616  D0 ED               bne   .l3
 1460  00:D618  88                  dey
 1461  00:D619  D0 E7               bne   .l2
 1462  00:D61B  60                  rts
 1463                     
 1464                     
 1465                     ; gfx_clear(int start_vram_addr)
 1466                     ; ----
 1467                     ; Clear the values in the graphics tiles
 1468                     ; - places zeroes in graphics tiles at start_vram_addr
 1469                     ; ----
 1470                     
 1471  00:D61C            _gfx_clear:
 1472                             __stw   <_di            ; start_vram_addr
       00:D61C  86 F0              stx    <_di
       00:D61E  85 F1              sta    <_di+1
 1473  00:D620  20 36 C4            jsr   set_write       ; setup VRAM addr for writing
 1474                     
 1475  00:D623  AD 0C 27            lda   bat_height
 1476  00:D626  85 FA               sta   <_bl            ; loop for all lines
 1477  00:D628  AE 0A 27  .l2:      ldx   bat_width       ; loop for all characters
 1478  00:D62B  A0 08     .l3:      ldy   #8              ; loop for 16 words
 1479                     .l4:      stw   #0,video_data   ; unrolled a bit (8 iterations
       00:D62D  A9 00              lda    LOW_BYTE #0
       00:D62F  8D 02 00           sta    LOW_BYTE video_data
       00:D632  A9 00              lda    HIGH_BYTE #0
       00:D634  8D 03 00           sta    HIGH_BYTE video_data
 1480                               stw   #0,video_data   ; @ 2 words each iteration)
       00:D637  A9 00              lda    LOW_BYTE #0
       00:D639  8D 02 00           sta    LOW_BYTE video_data
       00:D63C  A9 00              lda    HIGH_BYTE #0
       00:D63E  8D 03 00           sta    HIGH_BYTE video_data
 1481  00:D641  88                  dey
 1482  00:D642  D0 E9               bne   .l4 
 1483  00:D644  CA                  dex
 1484  00:D645  D0 E4               bne   .l3
 1485  00:D647  C6 FA               dec   <_bl
 1486  00:D649  D0 DD               bne   .l2
 1487  00:D64B  60                  rts
 1488                     
 1489                     
 1490                     ; gfx_plot(int x [bx] int y [cx] char color [reg acc])
 1491                     ; ----
 1492                     ; Plot a point at location (x,y) in color
 1493                     ; ----
 1494                     
 1495  00:D64C            _gfx_plot.3:
 1496                               maplibfunc    lib2_gfx_plot.3
       00:D64C  A8                 tay
       00:D64D  43 20              tma  #page(lib2_gfx_plot.3)
       00:D64F  48                 pha
       00:D650  A9 81              lda  #bank(lib2_gfx_plot.3)
       00:D652  53 20              tam  #page(lib2_gfx_plot.3)
       00:D654  98                 tya
       00:D655  20 52 AE           jsr  lib2_gfx_plot.3
       00:D658  A8                 tay
       00:D659  68                 pla
       00:D65A  53 20              tam  #page(lib2_gfx_plot.3)
       00:D65C  98                 tya
 1497  00:D65D  60                  rts
 1498                     
 1499                     
 1500                     ; gfx_point(int x [bx], int y [cx])
 1501                     ; ----
 1502                     ; Returns color of point at location (x,y)
 1503                     ; ----
 1504                     
 1505  00:D65E            _gfx_point.2:
 1506                               maplibfunc    lib2_gfx_point.2
       00:D65E  A8                 tay
       00:D65F  43 20              tma  #page(lib2_gfx_point.2)
       00:D661  48                 pha
       00:D662  A9 81              lda  #bank(lib2_gfx_point.2)
       00:D664  53 20              tam  #page(lib2_gfx_point.2)
       00:D666  98                 tya
       00:D667  20 0D AF           jsr  lib2_gfx_point.2
       00:D66A  A8                 tay
       00:D66B  68                 pla
       00:D66C  53 20              tam  #page(lib2_gfx_point.2)
       00:D66E  98                 tya
 1507  00:D66F  60                  rts
 1508                     
 1509                     
 1510                     ; gfx_line(int x1 [bx], int y1 [cx], int x2 [si], int y2 [bp], char color [reg acc])
 1511                     ; ----
 1512                     ; Plot a line from location (x1,y1) to location (x2,y2) in color
 1513                     ; ----
 1514                     
 1515  00:D670            _gfx_line.5:
 1516                               maplibfunc    lib2_gfx_line.5
       00:D670  A8                 tay
       00:D671  43 20              tma  #page(lib2_gfx_line.5)
       00:D673  48                 pha
       00:D674  A9 81              lda  #bank(lib2_gfx_line.5)
       00:D676  53 20              tam  #page(lib2_gfx_line.5)
       00:D678  98                 tya
       00:D679  20 C8 AB           jsr  lib2_gfx_line.5
       00:D67C  A8                 tay
       00:D67D  68                 pla
       00:D67E  53 20              tam  #page(lib2_gfx_line.5)
       00:D680  98                 tya
 1517  00:D681  60                  rts
 1518                     
 1519                     ;---------------------------------
 1520                     
 1521                     ;
 1522                     ; Change to context LIB2_BANK for these functions
 1523                     ; because they are larger than LIB1_BANK functions
 1524                     ; should be
 1525                     ;
 1526                     
 1527           0001               .bank  LIB2_BANK
 1528                     
 1529                     ; put_number(int number, char n, int offset)
 1530                     ; put_number(int number, char n, char x, char y)
 1531                     ; ----
 1532                     
 1533  01:AB57            lib2_put_number.4:
 1534  01:AB57  A4 02               ldy   <__arg_idx
 1535                             __plb
                                   ; (bytes : 6/7, cycles : 11/12)
                          
                0000              .if (0 = 2)
                                  .else
       01:AB59  88                 dey
       01:AB5A  B9 FF 31           lda    __arg,Y
                0000              .if (0)
                                  .endif
                                  .endif
 1536  01:AB5D  20 FF CD            jsr   _put.xy
 1537  01:AB60  80 05               bra   putnum.main
 1538  01:AB62            lib2_put_number.3:
 1539  01:AB62  A4 02               ldy   <__arg_idx
 1540  01:AB64  20 06 CE            jsr   _put.vram
 1541  01:AB67            putnum.main:
 1542                             __plb   <_cl,1
                                   ; (bytes : 6/7, cycles : 11/12)
                          
                0001              .if (2 = 2)
       01:AB67  88                 dey
       01:AB68  BE FF 31           ldx    __arg,Y
       01:AB6B  86 FC              stx    <_cl
                                  .else
                                  .endif
 1543                             __plw   <_dx
                                   ; (bytes : 9/12, cycles : 16/22)
                          
       01:AB6D  88                 dey
       01:AB6E  B9 FF 31           lda    __arg,Y
                0001              .if (1)
       01:AB71  85 FE              sta    <_dx
                                  .else
                                  .endif
       01:AB73  88                 dey
       01:AB74  B9 FF 31           lda    __arg,Y
                0001              .if (1)
       01:AB77  85 FF              sta    <_dx+1
                                  .endif
 1544  01:AB79  84 02               sty   <__arg_idx
 1545                               ; --
 1546  01:AB7B  64 F8               stz   <_al ; sign flag
 1547  01:AB7D  CA                  dex
 1548  01:AB7E  E0 10               cpx   #16
 1549                               bhs   .l5
       01:AB80  B0 45              bcs    .l5
 1550                               ; --
 1551  01:AB82  A5 FF               lda   <_dh ; check sign
 1552  01:AB84  10 0F               bpl   .l1
 1553                               negw  <_dx ; negate
       01:AB86  62                 cla                    ; (at stated memory location)
                                   sub    <_dx              ; 2's complement
                0000              .if (1 = 2)            ; from register A (handle
                                  .else
       01:AB87  38                 sec
       01:AB88  E5 FE              sbc    <_dx
                                  .endif
       01:AB8A  85 FE              sta    <_dx
       01:AB8C  62                 cla
       01:AB8D  E5 FF              sbc    <_dx+1
       01:AB8F  85 FF              sta    <_dx+1
 1554  01:AB91  A9 01               lda   #1
 1555  01:AB93  85 F8               sta   <_al
 1556                               ; --
 1557  01:AB95  20 14 C7  .l1:      jsr   divu10
 1558  01:AB98  09 10               ora   #$10
 1559  01:AB9A  48                  pha
 1560  01:AB9B  CA                  dex
 1561  01:AB9C  30 15               bmi   .l3
 1562                               tstw  <_dx
       01:AB9E  A5 FE              lda   <_dx               ; value at stated memory
       01:ABA0  05 FF              ora   <_dx+1             ; location is zero
 1563  01:ABA2  D0 F1               bne   .l1
 1564                               ; --
 1565  01:ABA4  A5 F8               lda   <_al
 1566  01:ABA6  F0 07               beq   .l2
 1567  01:ABA8  A9 0D               lda   #$0D
 1568  01:ABAA  48                  pha
 1569  01:ABAB  CA                  dex
 1570  01:ABAC  30 05               bmi   .l3
 1571                               ; --
 1572  01:ABAE  62                  cla
 1573  01:ABAF  48        .l2:      pha
 1574  01:ABB0  CA                  dex
 1575  01:ABB1  10 FC               bpl   .l2
 1576                               ; --
 1577  01:ABB3  A6 FC     .l3:      ldx   <_cl
 1578  01:ABB5  68        .l4:      pla
 1579                               add   _font_base
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       01:ABB6  18                 clc
       01:ABB7  6D A5 27           adc    _font_base
                                  .endif
 1580  01:ABBA  8D 02 00            sta   video_data_l
 1581  01:ABBD  62                  cla
 1582  01:ABBE  6D A6 27            adc   _font_base+1
 1583  01:ABC1  8D 03 00            sta   video_data_h
 1584  01:ABC4  CA                  dex
 1585  01:ABC5  D0 EE               bne   .l4
 1586  01:ABC7  60        .l5:      rts
 1587                     
 1588                     
 1589                     ; gfx_line(int x1 [bx], int y1 [cx], int x2 [si], int y2 [bp], char color [reg acc])
 1590                     ; ----
 1591                     ; Plot a line from location (x1,y1) to locations (x2,y2) in color
 1592                     ; ----
 1593  01:ABC8            lib2_gfx_line.5:                ; Bresenham line drawing algorithm
 1594  01:ABC8  8E B7 29            stx   _line_color
 1595                     
 1596                               cmpw  <_cx,<_bp       ; make y always ascending by swapping
       01:ABCB  A5 ED              lda    HIGH_BYTE <_bp
       01:ABCD  C5 FD              cmp    HIGH_BYTE <_cx
       01:ABCF  D0 04              bne    .x_00391
       01:ABD1  A5 EC              lda    LOW_BYTE <_bp
       01:ABD3  C5 FC              cmp    LOW_BYTE <_cx
       01:ABD5            .x_00391:
 1597                               bhs   .l1             ; co-ordinates
       01:ABD5  B0 26              bcs    .l1
 1598                                                     ; jump over swap if _bp > _cx
 1599                     
 1600                               stw   <_bp,_line_curry        ; swap coordinates
       01:ABD7  A5 EC              lda    LOW_BYTE <_bp
       01:ABD9  8D AC 29           sta    LOW_BYTE _line_curry
       01:ABDC  A5 ED              lda    HIGH_BYTE <_bp
       01:ABDE  8D AD 29           sta    HIGH_BYTE _line_curry
 1601                               stw   <_cx,<_bp
       01:ABE1  A5 FC              lda    LOW_BYTE <_cx
       01:ABE3  85 EC              sta    LOW_BYTE <_bp
       01:ABE5  A5 FD              lda    HIGH_BYTE <_cx
       01:ABE7  85 ED              sta    HIGH_BYTE <_bp
 1602                               stw   <_si,_line_currx
       01:ABE9  A5 EE              lda    LOW_BYTE <_si
       01:ABEB  8D AA 29           sta    LOW_BYTE _line_currx
       01:ABEE  A5 EF              lda    HIGH_BYTE <_si
       01:ABF0  8D AB 29           sta    HIGH_BYTE _line_currx
 1603                               stw   <_bx,<_si
       01:ABF3  A5 FA              lda    LOW_BYTE <_bx
       01:ABF5  85 EE              sta    LOW_BYTE <_si
       01:ABF7  A5 FB              lda    HIGH_BYTE <_bx
       01:ABF9  85 EF              sta    HIGH_BYTE <_si
 1604                     
 1605  01:ABFB  80 14               bra   .l2
 1606                     
 1607                     .l1:      stw   <_bx,_line_currx
       01:ABFD  A5 FA              lda    LOW_BYTE <_bx
       01:ABFF  8D AA 29           sta    LOW_BYTE _line_currx
       01:AC02  A5 FB              lda    HIGH_BYTE <_bx
       01:AC04  8D AB 29           sta    HIGH_BYTE _line_currx
 1608                               stw   <_cx,_line_curry
       01:AC07  A5 FC              lda    LOW_BYTE <_cx
       01:AC09  8D AC 29           sta    LOW_BYTE _line_curry
       01:AC0C  A5 FD              lda    HIGH_BYTE <_cx
       01:AC0E  8D AD 29           sta    HIGH_BYTE _line_curry
 1609                     
 1610                     ; now:
 1611                     ;  line_currx and line_curry are start point
 1612                     ;  <_si and <_bp are end point
 1613                     ;  <_bx and <_cx are 'dont care'
 1614                     
 1615  01:AC11            .l2:
 1616  01:AC11  A5 EC               lda   LOW_BYTE  <_bp
 1617                               sub   LOW_BYTE  _line_curry
                0000              .if (1 = 2)            ; from register A (handle
                                  .else
       01:AC13  38                 sec
       01:AC14  ED AC 29           sbc    LOW_BYTE  _line_curry
                                  .endif
 1618  01:AC17  8D B0 29            sta   LOW_BYTE  _line_deltay
 1619  01:AC1A  A5 ED               lda   HIGH_BYTE <_bp
 1620  01:AC1C  ED AD 29            sbc   HIGH_BYTE _line_curry
 1621  01:AC1F  8D B1 29            sta   HIGH_BYTE _line_deltay
 1622                     
 1623  01:AC22  A5 EE               lda   LOW_BYTE  <_si
 1624                               sub   LOW_BYTE  _line_currx
                0000              .if (1 = 2)            ; from register A (handle
                                  .else
       01:AC24  38                 sec
       01:AC25  ED AA 29           sbc    LOW_BYTE  _line_currx
                                  .endif
 1625  01:AC28  8D AE 29            sta   LOW_BYTE  _line_deltax
 1626  01:AC2B  A5 EF               lda   HIGH_BYTE <_si
 1627  01:AC2D  ED AB 29            sbc   HIGH_BYTE _line_currx
 1628  01:AC30  8D AF 29            sta   HIGH_BYTE _line_deltax
 1629                     
 1630  01:AC33  9C B6 29            stz   _line_xdir      ; 0 = positive
 1631                     
 1632  01:AC36  AD AF 29            lda   HIGH_BYTE _line_deltax
 1633  01:AC39  10 14               bpl   .l3
 1634                     
 1635  01:AC3B  A9 01               lda   #1
 1636  01:AC3D  8D B6 29            sta   _line_xdir      ; 1 = negative
 1637                               negw  _line_deltax
       01:AC40  62                 cla                    ; (at stated memory location)
                                   sub    _line_deltax              ; 2's complement
                0000              .if (1 = 2)            ; from register A (handle
                                  .else
       01:AC41  38                 sec
       01:AC42  ED AE 29           sbc    _line_deltax
                                  .endif
       01:AC45  8D AE 29           sta    _line_deltax
       01:AC48  62                 cla
       01:AC49  ED AF 29           sbc    _line_deltax+1
       01:AC4C  8D AF 29           sta    _line_deltax+1
 1638                     
 1639                     ; now:
 1640                     ;  line_deltay is difference from end to start (positive)
 1641                     ;  line_deltax is difference from end to start (positive)
 1642                     ;  line_xdir shows whether to apply deltax positive or negative
 1643                     
 1644                     
 1645  01:AC4F            .l3:
 1646                               cmpw  _line_deltax,_line_deltay
       01:AC4F  AD B1 29           lda    HIGH_BYTE _line_deltay
       01:AC52  CD AF 29           cmp    HIGH_BYTE _line_deltax
       01:AC55  D0 06              bne    .x_00403
       01:AC57  AD B0 29           lda    LOW_BYTE _line_deltay
       01:AC5A  CD AE 29           cmp    LOW_BYTE _line_deltax
       01:AC5D            .x_00403:
 1647                               lbhs  .ybiglp         ; jump if deltay > |deltax|
       01:AC5D  90 03              bcc    .x_00404
       01:AC5F  4C 5B AD           jmp    .ybiglp
       01:AC62            .x_00404
 1648                     
 1649  01:AC62            .xbiglp:
 1650                             __ldw   _line_deltay
                0000              .if (1 = 2)
                                  .else
       01:AC62  AE B0 29           ldx    _line_deltay
       01:AC65  AD B1 29           lda    _line_deltay+1
                                  .endif
 1651                             __aslw
       01:AC68  22                 sax
       01:AC69  0A                 asl    A
       01:AC6A  22                 sax
       01:AC6B  2A                 rol    A
 1652                             __stw   _line_adjust
       01:AC6C  8E B4 29           stx    _line_adjust
       01:AC6F  8D B5 29           sta    _line_adjust+1
 1653                             __stw   _line_error
       01:AC72  8E B2 29           stx    _line_error
       01:AC75  8D B3 29           sta    _line_error+1
 1654                     
 1655                               subw  _line_deltax,_line_adjust
       01:AC78  38                 sec
       01:AC79  AD B4 29           lda    LOW_BYTE _line_adjust
       01:AC7C  ED AE 29           sbc    LOW_BYTE _line_deltax
       01:AC7F  8D B4 29           sta    LOW_BYTE _line_adjust
       01:AC82  AD B5 29           lda    HIGH_BYTE _line_adjust
       01:AC85  ED AF 29           sbc    HIGH_BYTE _line_deltax
       01:AC88  8D B5 29           sta    HIGH_BYTE _line_adjust
 1656                               subw  _line_deltax,_line_adjust
       01:AC8B  38                 sec
       01:AC8C  AD B4 29           lda    LOW_BYTE _line_adjust
       01:AC8F  ED AE 29           sbc    LOW_BYTE _line_deltax
       01:AC92  8D B4 29           sta    LOW_BYTE _line_adjust
       01:AC95  AD B5 29           lda    HIGH_BYTE _line_adjust
       01:AC98  ED AF 29           sbc    HIGH_BYTE _line_deltax
       01:AC9B  8D B5 29           sta    HIGH_BYTE _line_adjust
 1657                     
 1658                               subw  _line_deltax,_line_error
       01:AC9E  38                 sec
       01:AC9F  AD B2 29           lda    LOW_BYTE _line_error
       01:ACA2  ED AE 29           sbc    LOW_BYTE _line_deltax
       01:ACA5  8D B2 29           sta    LOW_BYTE _line_error
       01:ACA8  AD B3 29           lda    HIGH_BYTE _line_error
       01:ACAB  ED AF 29           sbc    HIGH_BYTE _line_deltax
       01:ACAE  8D B3 29           sta    HIGH_BYTE _line_error
 1659                     
 1660                               incw  _line_deltax            ; used as counter - get both endpoints
       01:ACB1  EE AE 29           inc    _line_deltax              ; value at stated memory
       01:ACB4  D0 03              bne    .x_00412           ; location
       01:ACB6  EE AF 29           inc    _line_deltax+1
       01:ACB9            .x_00412:
 1661                     
 1662  01:ACB9            .xlp1:
 1663                               stw   _line_currx,<_bx        ; draw pixel
       01:ACB9  AD AA 29           lda    LOW_BYTE _line_currx
       01:ACBC  85 FA              sta    LOW_BYTE <_bx
       01:ACBE  AD AB 29           lda    HIGH_BYTE _line_currx
       01:ACC1  85 FB              sta    HIGH_BYTE <_bx
 1664                               stw   _line_curry,<_cx
       01:ACC3  AD AC 29           lda    LOW_BYTE _line_curry
       01:ACC6  85 FC              sta    LOW_BYTE <_cx
       01:ACC8  AD AD 29           lda    HIGH_BYTE _line_curry
       01:ACCB  85 FD              sta    HIGH_BYTE <_cx
 1665  01:ACCD  AE B7 29            ldx   _line_color
 1666  01:ACD0  62                  cla
 1667  01:ACD1  20 52 AE            jsr   lib2_gfx_plot.3
 1668                     
 1669                               decw  _line_deltax            ; dec counter
       01:ACD4  38                 sec                    ; value at stated memory
       01:ACD5  AD AE 29           lda    _line_deltax              ; location
       01:ACD8  E9 01              sbc    #1
       01:ACDA  8D AE 29           sta    _line_deltax
       01:ACDD  AD AF 29           lda    _line_deltax+1
       01:ACE0  E9 00              sbc    #0
       01:ACE2  8D AF 29           sta    _line_deltax+1
 1670                               tstw  _line_deltax
       01:ACE5  AD AE 29           lda   _line_deltax               ; value at stated memory
       01:ACE8  0D AF 29           ora   _line_deltax+1             ; location is zero
 1671                               lbeq  .out
       01:ACEB  D0 03              bne    .x_00417
       01:ACED  4C 51 AE           jmp    .out
       01:ACF0            .x_00417
 1672                     
 1673  01:ACF0  AD B6 29            lda   _line_xdir              ; adjust currx
 1674  01:ACF3  F0 13               beq   .xlppos
 1675                     
 1676                               decw  _line_currx
       01:ACF5  38                 sec                    ; value at stated memory
       01:ACF6  AD AA 29           lda    _line_currx              ; location
       01:ACF9  E9 01              sbc    #1
       01:ACFB  8D AA 29           sta    _line_currx
       01:ACFE  AD AB 29           lda    _line_currx+1
       01:AD01  E9 00              sbc    #0
       01:AD03  8D AB 29           sta    _line_currx+1
 1677  01:AD06  80 08               bra   .xlp2
 1678                     
 1679                     .xlppos:  incw  _line_currx
       01:AD08  EE AA 29           inc    _line_currx              ; value at stated memory
       01:AD0B  D0 03              bne    .x_00419           ; location
       01:AD0D  EE AB 29           inc    _line_currx+1
       01:AD10            .x_00419:
 1680                     
 1681  01:AD10            .xlp2:
 1682  01:AD10  AD B3 29            lda   HIGH_BYTE _line_error
 1683  01:AD13  30 1D               bmi   .xlp3
 1684                     
 1685                               addw  _line_adjust,_line_error
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       01:AD15  18                 clc
       01:AD16  AD B2 29           lda    LOW_BYTE _line_error
       01:AD19  6D B4 29           adc    LOW_BYTE _line_adjust
       01:AD1C  8D B2 29           sta    LOW_BYTE _line_error
       01:AD1F  AD B3 29           lda    HIGH_BYTE _line_error
       01:AD22  6D B5 29           adc    HIGH_BYTE _line_adjust
       01:AD25  8D B3 29           sta    HIGH_BYTE _line_error
                                  .endif
 1686                               incw  _line_curry
       01:AD28  EE AC 29           inc    _line_curry              ; value at stated memory
       01:AD2B  D0 03              bne    .x_00421           ; location
       01:AD2D  EE AD 29           inc    _line_curry+1
       01:AD30            .x_00421:
 1687  01:AD30  80 87               bra   .xlp1
 1688  01:AD32            .xlp3:
 1689                               addw  _line_deltay,_line_error
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       01:AD32  18                 clc
       01:AD33  AD B2 29           lda    LOW_BYTE _line_error
       01:AD36  6D B0 29           adc    LOW_BYTE _line_deltay
       01:AD39  8D B2 29           sta    LOW_BYTE _line_error
       01:AD3C  AD B3 29           lda    HIGH_BYTE _line_error
       01:AD3F  6D B1 29           adc    HIGH_BYTE _line_deltay
       01:AD42  8D B3 29           sta    HIGH_BYTE _line_error
                                  .endif
 1690                               addw  _line_deltay,_line_error
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       01:AD45  18                 clc
       01:AD46  AD B2 29           lda    LOW_BYTE _line_error
       01:AD49  6D B0 29           adc    LOW_BYTE _line_deltay
       01:AD4C  8D B2 29           sta    LOW_BYTE _line_error
       01:AD4F  AD B3 29           lda    HIGH_BYTE _line_error
       01:AD52  6D B1 29           adc    HIGH_BYTE _line_deltay
       01:AD55  8D B3 29           sta    HIGH_BYTE _line_error
                                  .endif
 1691  01:AD58  4C B9 AC            jmp   .xlp1
 1692                     
 1693  01:AD5B            .ybiglp:
 1694                             __ldw   _line_deltax
                0000              .if (1 = 2)
                                  .else
       01:AD5B  AE AE 29           ldx    _line_deltax
       01:AD5E  AD AF 29           lda    _line_deltax+1
                                  .endif
 1695                             __aslw
       01:AD61  22                 sax
       01:AD62  0A                 asl    A
       01:AD63  22                 sax
       01:AD64  2A                 rol    A
 1696                             __stw   _line_adjust
       01:AD65  8E B4 29           stx    _line_adjust
       01:AD68  8D B5 29           sta    _line_adjust+1
 1697                             __stw   _line_error
       01:AD6B  8E B2 29           stx    _line_error
       01:AD6E  8D B3 29           sta    _line_error+1
 1698                     
 1699                               subw  _line_deltay,_line_adjust
       01:AD71  38                 sec
       01:AD72  AD B4 29           lda    LOW_BYTE _line_adjust
       01:AD75  ED B0 29           sbc    LOW_BYTE _line_deltay
       01:AD78  8D B4 29           sta    LOW_BYTE _line_adjust
       01:AD7B  AD B5 29           lda    HIGH_BYTE _line_adjust
       01:AD7E  ED B1 29           sbc    HIGH_BYTE _line_deltay
       01:AD81  8D B5 29           sta    HIGH_BYTE _line_adjust
 1700                               subw  _line_deltay,_line_adjust
       01:AD84  38                 sec
       01:AD85  AD B4 29           lda    LOW_BYTE _line_adjust
       01:AD88  ED B0 29           sbc    LOW_BYTE _line_deltay
       01:AD8B  8D B4 29           sta    LOW_BYTE _line_adjust
       01:AD8E  AD B5 29           lda    HIGH_BYTE _line_adjust
       01:AD91  ED B1 29           sbc    HIGH_BYTE _line_deltay
       01:AD94  8D B5 29           sta    HIGH_BYTE _line_adjust
 1701                             
 1702                               subw  _line_deltay,_line_error
       01:AD97  38                 sec
       01:AD98  AD B2 29           lda    LOW_BYTE _line_error
       01:AD9B  ED B0 29           sbc    LOW_BYTE _line_deltay
       01:AD9E  8D B2 29           sta    LOW_BYTE _line_error
       01:ADA1  AD B3 29           lda    HIGH_BYTE _line_error
       01:ADA4  ED B1 29           sbc    HIGH_BYTE _line_deltay
       01:ADA7  8D B3 29           sta    HIGH_BYTE _line_error
 1703                     
 1704                               incw  _line_deltay            ; used as counter - get both endpoints
       01:ADAA  EE B0 29           inc    _line_deltay              ; value at stated memory
       01:ADAD  D0 03              bne    .x_00431           ; location
       01:ADAF  EE B1 29           inc    _line_deltay+1
       01:ADB2            .x_00431:
 1705                     
 1706  01:ADB2            .ylp1:
 1707                               stw   _line_currx,<_bx        ; draw pixel
       01:ADB2  AD AA 29           lda    LOW_BYTE _line_currx
       01:ADB5  85 FA              sta    LOW_BYTE <_bx
       01:ADB7  AD AB 29           lda    HIGH_BYTE _line_currx
       01:ADBA  85 FB              sta    HIGH_BYTE <_bx
 1708                               stw   _line_curry,<_cx
       01:ADBC  AD AC 29           lda    LOW_BYTE _line_curry
       01:ADBF  85 FC              sta    LOW_BYTE <_cx
       01:ADC1  AD AD 29           lda    HIGH_BYTE _line_curry
       01:ADC4  85 FD              sta    HIGH_BYTE <_cx
 1709  01:ADC6  AE B7 29            ldx   _line_color
 1710  01:ADC9  62                  cla
 1711  01:ADCA  20 52 AE            jsr   lib2_gfx_plot.3
 1712                     
 1713                               decw  _line_deltay            ; dec counter
       01:ADCD  38                 sec                    ; value at stated memory
       01:ADCE  AD B0 29           lda    _line_deltay              ; location
       01:ADD1  E9 01              sbc    #1
       01:ADD3  8D B0 29           sta    _line_deltay
       01:ADD6  AD B1 29           lda    _line_deltay+1
       01:ADD9  E9 00              sbc    #0
       01:ADDB  8D B1 29           sta    _line_deltay+1
 1714                               tstw  _line_deltay
       01:ADDE  AD B0 29           lda   _line_deltay               ; value at stated memory
       01:ADE1  0D B1 29           ora   _line_deltay+1             ; location is zero
 1715  01:ADE4  F0 6B               beq   .out
 1716                     
 1717                               incw  _line_curry
       01:ADE6  EE AC 29           inc    _line_curry              ; value at stated memory
       01:ADE9  D0 03              bne    .x_00436           ; location
       01:ADEB  EE AD 29           inc    _line_curry+1
       01:ADEE            .x_00436:
 1718                     
 1719  01:ADEE  AD B3 29            lda   HIGH_BYTE _line_error
 1720  01:ADF1  30 35               bmi   .ylp2
 1721                     
 1722                               addw  _line_adjust,_line_error
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       01:ADF3  18                 clc
       01:ADF4  AD B2 29           lda    LOW_BYTE _line_error
       01:ADF7  6D B4 29           adc    LOW_BYTE _line_adjust
       01:ADFA  8D B2 29           sta    LOW_BYTE _line_error
       01:ADFD  AD B3 29           lda    HIGH_BYTE _line_error
       01:AE00  6D B5 29           adc    HIGH_BYTE _line_adjust
       01:AE03  8D B3 29           sta    HIGH_BYTE _line_error
                                  .endif
 1723  01:AE06  AD B6 29            lda   _line_xdir
 1724  01:AE09  F0 13               beq   .ylppos
 1725                     
 1726                               decw  _line_currx
       01:AE0B  38                 sec                    ; value at stated memory
       01:AE0C  AD AA 29           lda    _line_currx              ; location
       01:AE0F  E9 01              sbc    #1
       01:AE11  8D AA 29           sta    _line_currx
       01:AE14  AD AB 29           lda    _line_currx+1
       01:AE17  E9 00              sbc    #0
       01:AE19  8D AB 29           sta    _line_currx+1
 1727  01:AE1C  80 94               bra   .ylp1
 1728                     
 1729                     .ylppos:  incw  _line_currx
       01:AE1E  EE AA 29           inc    _line_currx              ; value at stated memory
       01:AE21  D0 03              bne    .x_00439           ; location
       01:AE23  EE AB 29           inc    _line_currx+1
       01:AE26            .x_00439:
 1730  01:AE26  80 8A               bra   .ylp1
 1731                     
 1732  01:AE28            .ylp2:
 1733                               addw  _line_deltax,_line_error
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       01:AE28  18                 clc
       01:AE29  AD B2 29           lda    LOW_BYTE _line_error
       01:AE2C  6D AE 29           adc    LOW_BYTE _line_deltax
       01:AE2F  8D B2 29           sta    LOW_BYTE _line_error
       01:AE32  AD B3 29           lda    HIGH_BYTE _line_error
       01:AE35  6D AF 29           adc    HIGH_BYTE _line_deltax
       01:AE38  8D B3 29           sta    HIGH_BYTE _line_error
                                  .endif
 1734                               addw  _line_deltax,_line_error
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       01:AE3B  18                 clc
       01:AE3C  AD B2 29           lda    LOW_BYTE _line_error
       01:AE3F  6D AE 29           adc    LOW_BYTE _line_deltax
       01:AE42  8D B2 29           sta    LOW_BYTE _line_error
       01:AE45  AD B3 29           lda    HIGH_BYTE _line_error
       01:AE48  6D AF 29           adc    HIGH_BYTE _line_deltax
       01:AE4B  8D B3 29           sta    HIGH_BYTE _line_error
                                  .endif
 1735  01:AE4E  4C B2 AD            jmp   .ylp1
 1736                     
 1737  01:AE51            .out:
 1738  01:AE51  60                  rts
 1739                     
 1740                     
 1741                     ; gfx_plot(int x [bx], int y [cx], char color [reg acc])
 1742                     ; ----
 1743                     ; Plot a point at location (x,y) in color
 1744                     ; ----
 1745                     
 1746  01:AE52            lib2_gfx_plot.3:
 1747  01:AE52  86 FE               stx   <_dl            ; color
 1748  01:AE54  20 63 AF            jsr   gfx_getaddr
 1749                     
 1750                             ; same as vm_rawread - save 21 cycles by inlining
 1751                             ;
 1752                               vreg  #1              ; video read register
       01:AE57  A9 01              lda    #1
       01:AE59  85 F7              sta    <vdc_reg
                0001               .if (2 = ARG_IMMED)
       01:AE5B  03 01               st0   #1
                                   .else
                                   .endif
 1753                               stw   <_cx,video_data ; VRAM address
       01:AE5D  A5 FC              lda    LOW_BYTE <_cx
       01:AE5F  8D 02 00           sta    LOW_BYTE video_data
       01:AE62  A5 FD              lda    HIGH_BYTE <_cx
       01:AE64  8D 03 00           sta    HIGH_BYTE video_data
 1754                               vreg  #2              ; set R/W memory mode
       01:AE67  A9 02              lda    #2
       01:AE69  85 F7              sta    <vdc_reg
                0001               .if (2 = ARG_IMMED)
       01:AE6B  03 02               st0   #2
                                   .else
                                   .endif
 1755                             __ldw   video_data
                0000              .if (1 = 2)
                                  .else
       01:AE6D  AE 02 00           ldx    video_data
       01:AE70  AD 03 00           lda    video_data+1
                                  .endif
 1756                             ;
 1757                             ; end inline
 1758                     
 1759  01:AE73  A4 F8               ldy   <_al            ; bit offset
 1760  01:AE75  1F FE 05            bbr1  <_dl,.l1
 1761  01:AE78  19 53 AF            ora   gfx_bittbl,Y    ; set bit
 1762  01:AE7B  80 03               bra   .l1a
 1763  01:AE7D  39 5B AF  .l1:      and   gfx_bittbl2,Y   ; else mask bit
 1764  01:AE80            .l1a:
 1765  01:AE80  22                  sax
 1766  01:AE81  0F FE 05            bbr0  <_dl,.l2
 1767  01:AE84  19 53 AF            ora   gfx_bittbl,Y    ; set bit
 1768  01:AE87  80 03               bra   .l2a
 1769  01:AE89  39 5B AF  .l2:      and   gfx_bittbl2,Y   ; else mask bit
 1770  01:AE8C            .l2a:
 1771                             ; same as vm_rawwrite - save >14 cycles by inlining
 1772                             ;
 1773  01:AE8C  DA                  phx
 1774  01:AE8D  AA                  tax
 1775                               vreg  #0              ; video write register
       01:AE8E  A9 00              lda    #0
       01:AE90  85 F7              sta    <vdc_reg
                0001               .if (2 = ARG_IMMED)
       01:AE92  03 00               st0   #0
                                   .else
                                   .endif
 1776                               stw   <_cx,video_data ; VRAM address
       01:AE94  A5 FC              lda    LOW_BYTE <_cx
       01:AE96  8D 02 00           sta    LOW_BYTE video_data
       01:AE99  A5 FD              lda    HIGH_BYTE <_cx
       01:AE9B  8D 03 00           sta    HIGH_BYTE video_data
 1777                               vreg  #2              ; set R/W memory mode
       01:AE9E  A9 02              lda    #2
       01:AEA0  85 F7              sta    <vdc_reg
                0001               .if (2 = ARG_IMMED)
       01:AEA2  03 02               st0   #2
                                   .else
                                   .endif
 1778  01:AEA4  68                  pla
 1779                             __stw   video_data      ; write
       01:AEA5  8E 02 00           stx    video_data
       01:AEA8  8D 03 00           sta    video_data+1
 1780                             ;
 1781                             ; end inline
 1782                     
 1783                               addw  #8,<_cx         ; other half of pixel
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       01:AEAB  18                 clc
       01:AEAC  A5 FC              lda    LOW_BYTE <_cx
       01:AEAE  69 08              adc    LOW_BYTE #8
       01:AEB0  85 FC              sta    LOW_BYTE <_cx
       01:AEB2  A5 FD              lda    HIGH_BYTE <_cx
       01:AEB4  69 00              adc    HIGH_BYTE #8
       01:AEB6  85 FD              sta    HIGH_BYTE <_cx
                                  .endif
 1784                     
 1785                             ; same as vm_rawread - save 21 cycles by inlining
 1786                             ;
 1787                               vreg  #1              ; video read register
       01:AEB8  A9 01              lda    #1
       01:AEBA  85 F7              sta    <vdc_reg
                0001               .if (2 = ARG_IMMED)
       01:AEBC  03 01               st0   #1
                                   .else
                                   .endif
 1788                               stw   <_cx,video_data ; VRAM address
       01:AEBE  A5 FC              lda    LOW_BYTE <_cx
       01:AEC0  8D 02 00           sta    LOW_BYTE video_data
       01:AEC3  A5 FD              lda    HIGH_BYTE <_cx
       01:AEC5  8D 03 00           sta    HIGH_BYTE video_data
 1789                               vreg  #2              ; set R/W memory mode
       01:AEC8  A9 02              lda    #2
       01:AECA  85 F7              sta    <vdc_reg
                0001               .if (2 = ARG_IMMED)
       01:AECC  03 02               st0   #2
                                   .else
                                   .endif
 1790                             __ldw   video_data
                0000              .if (1 = 2)
                                  .else
       01:AECE  AE 02 00           ldx    video_data
       01:AED1  AD 03 00           lda    video_data+1
                                  .endif
 1791                             ;
 1792                             ; end inline
 1793                     
 1794  01:AED4  A4 F8               ldy   <_al            ; bit offset
 1795  01:AED6  3F FE 05            bbr3  <_dl,.l3
 1796  01:AED9  19 53 AF            ora   gfx_bittbl,Y    ; set bit
 1797  01:AEDC  80 03               bra   .l3a
 1798  01:AEDE  39 5B AF  .l3:      and   gfx_bittbl2,Y   ; else mask bit
 1799  01:AEE1            .l3a:
 1800  01:AEE1  22                  sax
 1801  01:AEE2  2F FE 05            bbr2  <_dl,.l4
 1802  01:AEE5  19 53 AF            ora   gfx_bittbl,Y    ; set bit
 1803  01:AEE8  80 03               bra   .l4a
 1804  01:AEEA  39 5B AF  .l4:      and   gfx_bittbl2,Y   ; mask bit
 1805  01:AEED            .l4a:
 1806                             ; same as vm_rawwrite - save >14 cycles by inlining
 1807                             ;
 1808  01:AEED  DA                  phx
 1809  01:AEEE  AA                  tax
 1810                               vreg  #0              ; video write register
       01:AEEF  A9 00              lda    #0
       01:AEF1  85 F7              sta    <vdc_reg
                0001               .if (2 = ARG_IMMED)
       01:AEF3  03 00               st0   #0
                                   .else
                                   .endif
 1811                               stw   <_cx,video_data ; VRAM address
       01:AEF5  A5 FC              lda    LOW_BYTE <_cx
       01:AEF7  8D 02 00           sta    LOW_BYTE video_data
       01:AEFA  A5 FD              lda    HIGH_BYTE <_cx
       01:AEFC  8D 03 00           sta    HIGH_BYTE video_data
 1812                               vreg  #2              ; set R/W memory mode
       01:AEFF  A9 02              lda    #2
       01:AF01  85 F7              sta    <vdc_reg
                0001               .if (2 = ARG_IMMED)
       01:AF03  03 02               st0   #2
                                   .else
                                   .endif
 1813  01:AF05  68                  pla
 1814                             __stw   video_data      ; write
       01:AF06  8E 02 00           stx    video_data
       01:AF09  8D 03 00           sta    video_data+1
 1815                             ;
 1816                             ; end inline
 1817                     
 1818  01:AF0C  60                  rts
 1819                     
 1820                     
 1821                     ; gfx_point(int x [bx], int y [cx])
 1822                     ; ----
 1823                     ; Returns color of point at location (x,y)
 1824                     ; ----
 1825                     
 1826  01:AF0D            lib2_gfx_point.2:
 1827  01:AF0D  20 63 AF            jsr   gfx_getaddr
 1828  01:AF10  64 F9               stz   <_ah            ; will be color
 1829                             __ldw   <_cx            ; VRAM address
                0000              .if (1 = 2)
                                  .else
       01:AF12  A6 FC              ldx    <_cx
       01:AF14  A5 FD              lda    <_cx+1
                                  .endif
 1830  01:AF16  20 8B D5            jsr   readvram
 1831                     
 1832  01:AF19  A4 F8               ldy   <_al            ; bit offset
 1833  01:AF1B  39 53 AF            and   gfx_bittbl,Y
 1834  01:AF1E  F0 02               beq   .l1
 1835  01:AF20  97 F9               smb1  <_ah
 1836  01:AF22  8A        .l1:      txa
 1837  01:AF23  39 53 AF            and   gfx_bittbl,Y
 1838  01:AF26  F0 02               beq   .l2
 1839  01:AF28  87 F9               smb0  <_ah
 1840  01:AF2A            .l2:
 1841                               addw  #8,<_cx
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       01:AF2A  18                 clc
       01:AF2B  A5 FC              lda    LOW_BYTE <_cx
       01:AF2D  69 08              adc    LOW_BYTE #8
       01:AF2F  85 FC              sta    LOW_BYTE <_cx
       01:AF31  A5 FD              lda    HIGH_BYTE <_cx
       01:AF33  69 00              adc    HIGH_BYTE #8
       01:AF35  85 FD              sta    HIGH_BYTE <_cx
                                  .endif
 1842                             __ldw   <_cx            ; VRAM address part 2
                0000              .if (1 = 2)
                                  .else
       01:AF37  A6 FC              ldx    <_cx
       01:AF39  A5 FD              lda    <_cx+1
                                  .endif
 1843  01:AF3B  20 8B D5            jsr   readvram
 1844                     
 1845  01:AF3E  A4 F8               ldy   <_al
 1846  01:AF40  39 53 AF            and   gfx_bittbl,Y
 1847  01:AF43  F0 02               beq   .l3
 1848  01:AF45  B7 F9               smb3  <_ah
 1849  01:AF47  8A        .l3:      txa
 1850  01:AF48  39 53 AF            and   gfx_bittbl,Y
 1851  01:AF4B  F0 02               beq   .l4
 1852  01:AF4D  A7 F9               smb2  <_ah
 1853  01:AF4F            .l4:
 1854  01:AF4F  A6 F9               ldx   <_ah
 1855  01:AF51  62                  cla
 1856  01:AF52  60                  rts
 1857                     
 1858                     
 1859  01:AF53            gfx_bittbl:
 1860  01:AF53  80 40 20            .db   $80,$40,$20,$10,$08,$04,$02,$01
       01:AF56  10 08 04  
       01:AF59  02 01     
 1861  01:AF5B            gfx_bittbl2:
 1862  01:AF5B  7F BF DF            .db   $7f,$bf,$df,$ef,$f7,$fb,$fd,$fe
       01:AF5E  EF F7 FB  
       01:AF61  FD FE     
 1863                     
 1864                     
 1865                     ; gfx_getaddr
 1866                     ; ----
 1867                     ; Utility routine to switch x/y pixel
 1868                     ; co-ordinates into VRAM addr and bit #
 1869                     ; ----
 1870                     
 1871  01:AF63            gfx_getaddr:
 1872  01:AF63  A5 FC               lda   <_cl
 1873  01:AF65  29 07               and   #7
 1874  01:AF67  85 F8               sta   <_al    ; al = lines from tile base
 1875                     
 1876  01:AF69  A5 FA               lda   <_bl
 1877  01:AF6B  29 07               and   #7
 1878  01:AF6D  48                  pha           ; = bit offset
 1879                     
 1880                             __ldw   <_bx
                0000              .if (1 = 2)
                                  .else
       01:AF6E  A6 FA              ldx    <_bx
       01:AF70  A5 FB              lda    <_bx+1
                                  .endif
 1881                             __lsrw          ; should be only 2 bits in MSB are possible
       01:AF72  4A                lsr     A
       01:AF73  22                sax
       01:AF74  6A                ror     A
       01:AF75  22                sax
 1882                             __lsrw          ; but we'll shift 3 times anyway
       01:AF76  4A                lsr     A
       01:AF77  22                sax
       01:AF78  6A                ror     A
       01:AF79  22                sax
 1883                             __lsrw
       01:AF7A  4A                lsr     A
       01:AF7B  22                sax
       01:AF7C  6A                ror     A
       01:AF7D  22                sax
 1884  01:AF7E  DA                  phx           ; X = character column
 1885                     
 1886                             __ldw   <_cx
                0000              .if (1 = 2)
                                  .else
       01:AF7F  A6 FC              ldx    <_cx
       01:AF81  A5 FD              lda    <_cx+1
                                  .endif
 1887                             __lsrw          ; should be only 2 bits in MSB are possible
       01:AF83  4A                lsr     A
       01:AF84  22                sax
       01:AF85  6A                ror     A
       01:AF86  22                sax
 1888                             __lsrw          ; but we'll shift 3 times anyway
       01:AF87  4A                lsr     A
       01:AF88  22                sax
       01:AF89  6A                ror     A
       01:AF8A  22                sax
 1889                             __lsrw
       01:AF8B  4A                lsr     A
       01:AF8C  22                sax
       01:AF8D  6A                ror     A
       01:AF8E  22                sax
 1890  01:AF8F  8A                  txa           ; A = character row
 1891                     
 1892  01:AF90  FA                  plx
 1893  01:AF91  20 53 C4            jsr   calc_vram_addr
 1894                     
 1895                             __ldw   <_di            ; to get BAT addr
                0000              .if (1 = 2)
                                  .else
       01:AF94  A6 F0              ldx    <_di
       01:AF96  A5 F1              lda    <_di+1
                                  .endif
 1896  01:AF98  20 8B D5            jsr   readvram        ; read BAT value
 1897                             __aslw                  ; change into VRAM tile addr
       01:AF9B  22                 sax
       01:AF9C  0A                 asl    A
       01:AF9D  22                 sax
       01:AF9E  2A                 rol    A
 1898                             __aslw
       01:AF9F  22                 sax
       01:AFA0  0A                 asl    A
       01:AFA1  22                 sax
       01:AFA2  2A                 rol    A
 1899                             __aslw
       01:AFA3  22                 sax
       01:AFA4  0A                 asl    A
       01:AFA5  22                 sax
       01:AFA6  2A                 rol    A
 1900                             __aslw                  ; cx = VRAM addr start of tile
       01:AFA7  22                 sax
       01:AFA8  0A                 asl    A
       01:AFA9  22                 sax
       01:AFAA  2A                 rol    A
 1901                     
 1902  01:AFAB  22                  sax
 1903  01:AFAC  18                  clc                   ; add row within tile
 1904  01:AFAD  65 F8               adc   <_al
 1905  01:AFAF  22                  sax
 1906  01:AFB0  69 00               adc   #0
 1907                             __stw   <_cx
       01:AFB2  86 FC              stx    <_cx
       01:AFB4  85 FD              sta    <_cx+1
 1908                     
 1909  01:AFB6  68                  pla
 1910  01:AFB7  85 F8               sta   <_al            ; al = bit offset
 1911                     
 1912  01:AFB9  60                  rts
 1913                     
 1914                     ; Change back to original LIB1_BANK context
 1915                     
 1916           0000               .bank  LIB1_BANK
 1917                     
 1918                     
 1919                     
#[2]   startup.asm
#[3]   huc_math.asm
 1218                             .include "huc_math.asm"
    1                     ;
    2                     ; HUC_MATH.ASM  -  HuC Math Library
    3                     ;
    4                     
    5                     ; abs(int val)
    6                     ; ---
    7                     
    8  00:D682            _abs:
    9  00:D682  A8                tay
   10  00:D683  10 0B             bpl     .l1
   11  00:D685  22                sax
   12  00:D686  49 FF             eor     #$FF
   13                             add     #1
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       00:D688  18                 clc
       00:D689  69 01              adc    #1
                                  .endif
   14  00:D68B  22                sax
   15  00:D68C  49 FF             eor     #$FF
   16  00:D68E  69 00             adc     #0
   17  00:D690            .l1:
   18  00:D690  60                rts
   19                     
   20                     ; mov32(void *dst [di], void *src)
   21                     ; ----
   22                     
   23  00:D691            _mov32.2:
   24                             __stw   <_si
       00:D691  86 EE              stx    <_si
       00:D693  85 EF              sta    <_si+1
   25  00:D695            _mov32.sub:
   26  00:D695  A0 03               ldy   #3
   27  00:D697  B1 EE     .l1:      lda   [_si],Y
   28  00:D699  91 F0               sta   [_di],Y
   29  00:D69B  88                  dey
   30  00:D69C  10 F9               bpl   .l1
   31  00:D69E  60                  rts
   32                     
   33                     ; add32(void *dst [di], void *src) /* ax|bx */
   34                     ; ----
   35                     
   36  00:D69F            _add32.2:
   37                             __stw   <_si
       00:D69F  86 EE              stx    <_si
       00:D6A1  85 EF              sta    <_si+1
   38  00:D6A3  18                  clc
   39  00:D6A4  C2                  cly
   40  00:D6A5  A2 04               ldx   #4
   41  00:D6A7  B1 F0     .l1:      lda   [_di],Y
   42  00:D6A9  71 EE               adc   [_si],Y
   43  00:D6AB  91 F0               sta   [_di],Y
   44  00:D6AD  C8                  iny
   45  00:D6AE  CA                  dex
   46  00:D6AF  D0 F6               bne   .l1
   47  00:D6B1  60                  rts
   48                     
   49                     ; sub32(void *dst [di], void *src)
   50                     ; ----
   51                     
   52  00:D6B2            _sub32.2:
   53                             __stw   <_si
       00:D6B2  86 EE              stx    <_si
       00:D6B4  85 EF              sta    <_si+1
   54  00:D6B6  38                  sec
   55  00:D6B7  C2                  cly
   56  00:D6B8  A2 04               ldx   #4
   57  00:D6BA  B1 F0     .l1:      lda   [_di],Y
   58  00:D6BC  F1 EE               sbc   [_si],Y
   59  00:D6BE  91 F0               sta   [_di],Y
   60  00:D6C0  C8                  iny
   61  00:D6C1  CA                  dex
   62  00:D6C2  D0 F6               bne   .l1
   63  00:D6C4  60                  rts
   64                     
   65                     ; mul32(void *dst [bp], void *src)
   66                     ; ----
   67                     
   68  00:D6C5            _mul32.2:
   69                             __stw   <_si
       00:D6C5  86 EE              stx    <_si
       00:D6C7  85 EF              sta    <_si+1
   70                               stw   #_ax,<_di
       00:D6C9  A9 F8              lda    LOW_BYTE #_ax
       00:D6CB  85 F0              sta    LOW_BYTE <_di
       00:D6CD  A9 20              lda    HIGH_BYTE #_ax
       00:D6CF  85 F1              sta    HIGH_BYTE <_di
   71  00:D6D1  20 95 D6            jsr   _mov32.sub
   72                               stw   <_bp,<_si
       00:D6D4  A5 EC              lda    LOW_BYTE <_bp
       00:D6D6  85 EE              sta    LOW_BYTE <_si
       00:D6D8  A5 ED              lda    HIGH_BYTE <_bp
       00:D6DA  85 EF              sta    HIGH_BYTE <_si
   73                               stw   #_cx,<_di
       00:D6DC  A9 FC              lda    LOW_BYTE #_cx
       00:D6DE  85 F0              sta    LOW_BYTE <_di
       00:D6E0  A9 20              lda    HIGH_BYTE #_cx
       00:D6E2  85 F1              sta    HIGH_BYTE <_di
   74  00:D6E4  20 95 D6            jsr   _mov32.sub
   75  00:D6E7  20 2A C7            jsr    mulu32
   76                               stw   <_bp,<_di
       00:D6EA  A5 EC              lda    LOW_BYTE <_bp
       00:D6EC  85 F0              sta    LOW_BYTE <_di
       00:D6EE  A5 ED              lda    HIGH_BYTE <_bp
       00:D6F0  85 F1              sta    HIGH_BYTE <_di
   77                               stw   #_cx,<_si
       00:D6F2  A9 FC              lda    LOW_BYTE #_cx
       00:D6F4  85 EE              sta    LOW_BYTE <_si
       00:D6F6  A9 20              lda    HIGH_BYTE #_cx
       00:D6F8  85 EF              sta    HIGH_BYTE <_si
   78  00:D6FA  4C 95 D6            jmp   _mov32.sub
   79                     
   80                     ; div32(void *dst [di], void *src)
   81                     ; ----
   82                     
   83  00:D6FD            _div32.2:
   84  00:D6FD  60                  rts
   85                     
   86                     ; com32(void *dst)
   87                     ; ----
   88                     
   89  00:D6FE            _com32.1:
   90                             __stw   <_di
       00:D6FE  86 F0              stx    <_di
       00:D700  85 F1              sta    <_di+1
   91  00:D702  A0 03               ldy   #3
   92  00:D704  B1 F0     .l1:      lda   [_di],Y
   93  00:D706  49 FF               eor   #$FF
   94  00:D708  91 F0               sta   [_di],Y
   95  00:D70A  88                  dey
   96  00:D70B  10 F7               bpl   .l1
   97  00:D70D  60                  rts
   98                             
   99                     ; cmp32(void *dst [di], void *src)
  100                     ; ----
  101                     
  102  00:D70E            _cmp32.2:
  103                             __stw   <_si
       00:D70E  86 EE              stx    <_si
       00:D710  85 EF              sta    <_si+1
  104  00:D712  A0 03               ldy   #3
  105  00:D714  B1 F0     .l1:      lda   [_di],Y
  106  00:D716  D1 EE               cmp   [_si],Y
  107  00:D718  D0 06               bne   .l2
  108  00:D71A  88                  dey
  109  00:D71B  10 F7               bpl   .l1
  110                               ; --
  111  00:D71D  82                  clx
  112  00:D71E  62                  cla
  113  00:D71F  60                  rts
  114                               ; --
  115                     .l2:      blo   .l3
       00:D720  90 04              bcc    .l3
  116  00:D722  A2 01               ldx   #$01
  117  00:D724  62                  cla
  118  00:D725  60                  rts
  119                               ; --
  120  00:D726  A2 FF     .l3:      ldx   #$FF
  121  00:D728  8A                  txa
  122  00:D729  60                  rts
  123                     
  124                     ; bcd_init(char *dst [bx], char digits)
  125                     ; ----
  126                     
  127  00:D72A            _bcd_init.2:
  128                               ; -- check digit number (max. 16)
  129  00:D72A  8A                  txa
  130  00:D72B  C9 10               cmp   #16
  131                               blo   .l1
       00:D72D  90 02              bcc    .l1
  132  00:D72F  A9 10               lda   #16
  133  00:D731  1A        .l1:      inc   A
  134  00:D732  4A                  lsr   A
  135  00:D733  09 80               ora   #$80
  136  00:D735  92 FA               sta   [_bx]
  137  00:D737            _bcd_init.clear:
  138                               ; -- clear bcd number
  139  00:D737  B2 FA               lda   [_bx]
  140  00:D739  29 1F               and   #$1F
  141  00:D73B  A8                  tay
  142  00:D73C  62                  cla
  143  00:D73D  91 FA     .l2:      sta   [_bx],Y
  144  00:D73F  88                  dey
  145  00:D740  D0 FB               bne   .l2
  146  00:D742  60                  rts
  147                     
  148                     ; bcd_set(char *dst [bx], char *src)
  149                     ; bcd_mov(char *dst [bx], char *src)
  150                     ; ----
  151                     
  152  00:D743            _bcd_set.2:
  153  00:D743            _bcd_mov.2:
  154                             __stw   <_si
       00:D743  86 EE              stx    <_si
       00:D745  85 EF              sta    <_si+1
  155  00:D747  05 EE               ora   <_si
  156  00:D749  F0 EC               beq   _bcd_init.clear
  157                               ; -- check dst
  158  00:D74B  B2 FA               lda   [_bx]
  159  00:D74D  10 0B               bpl   .x1
  160  00:D74F  29 1F               and   #$1F
  161  00:D751  F0 07               beq   .x1
  162  00:D753  AA                  tax
  163                               ; -- check src type
  164  00:D754  B2 EE               lda   [_si]
  165  00:D756  10 03               bpl   _bcd_set.ascii
  166  00:D758  80 33               bra   _bcd_set.bcd
  167  00:D75A  60        .x1:      rts
  168                         ; ----
  169                         ; ... from an ascii string (ie. "100")
  170                         ;
  171  00:D75B            _bcd_set.ascii:
  172                               ; -- get string length
  173  00:D75B  C2                  cly
  174  00:D75C  B1 EE     .l1:      lda   [_si],Y
  175  00:D75E  C9 30               cmp   #48
  176                               blo   .l2
       00:D760  90 07              bcc    .l2
  177  00:D762  C9 3A               cmp   #58
  178                               bhs   .l2
       00:D764  B0 03              bcs    .l2
  179  00:D766  C8                  iny
  180  00:D767  80 F3               bra   .l1
  181                               ; -- check if the string is empty 
  182  00:D769  98        .l2:      tya
  183  00:D76A  F0 CB               beq   _bcd_init.clear
  184                               ; -- copy number
  185  00:D76C  62        .l3:      cla
  186  00:D76D  88                  dey
  187  00:D76E  30 15               bmi   .l4
  188  00:D770  B1 EE               lda   [_si],Y
  189                               sub   #48
                0000              .if (1 = 2)            ; from register A (handle
                                  .else
       00:D772  38                 sec
       00:D773  E9 30              sbc    #48
                                  .endif
  190  00:D775  85 FE               sta   <_dl
  191  00:D777  88                  dey
  192  00:D778  30 0B               bmi   .l4
  193  00:D77A  B1 EE               lda   [_si],Y
  194                               sub   #48
                0000              .if (1 = 2)            ; from register A (handle
                                  .else
       00:D77C  38                 sec
       00:D77D  E9 30              sbc    #48
                                  .endif
  195  00:D77F  0A                  asl   A
  196  00:D780  0A                  asl   A
  197  00:D781  0A                  asl   A
  198  00:D782  0A                  asl   A
  199  00:D783  05 FE               ora   <_dl
  200  00:D785  02        .l4:      sxy
  201  00:D786  91 FA               sta   [_bx],Y
  202  00:D788  02                  sxy
  203  00:D789  CA                  dex
  204  00:D78A  D0 E0               bne   .l3
  205  00:D78C  60                  rts
  206                     
  207                         ; ----
  208                         ; ... from another bcd number
  209                         ;
  210  00:D78D            _bcd_set.bcd:
  211                               ; -- get src size
  212  00:D78D  B2 EE               lda   [_si]
  213  00:D78F  10 18               bpl   .x1
  214  00:D791  29 1F               and   #$1F
  215  00:D793  F0 14               beq   .x1
  216  00:D795  A8                  tay
  217                               ; -- copy number
  218  00:D796  B1 EE     .l1:      lda   [_si],Y
  219  00:D798  02                  sxy
  220  00:D799  91 FA               sta   [_bx],Y
  221  00:D79B  88                  dey
  222  00:D79C  F0 0B               beq   .x1
  223  00:D79E  02                  sxy
  224  00:D79F  88                  dey
  225  00:D7A0  D0 F4               bne   .l1
  226                               ; -- adjust number
  227  00:D7A2  02                  sxy
  228  00:D7A3  62                  cla
  229  00:D7A4  91 FA     .l2:      sta   [_bx],Y
  230  00:D7A6  88                  dey
  231  00:D7A7  D0 FB               bne   .l2
  232  00:D7A9  60        .x1:      rts
  233                     
  234                     ; bcd_add(char *dst [di], char *src)
  235                     ; ----
  236                     
  237  00:D7AA            _bcd_add.2:
  238                             __stw   <_si
       00:D7AA  86 EE              stx    <_si
       00:D7AC  85 EF              sta    <_si+1
  239  00:D7AE  05 EE               ora   <_si
  240  00:D7B0  F0 3D               beq   .x1
  241                               ; -- check dst
  242  00:D7B2  B2 F0               lda   [_di]
  243  00:D7B4  10 39               bpl   .x1
  244  00:D7B6  29 1F               and   #$1F
  245  00:D7B8  F0 35               beq   .x1
  246  00:D7BA  AA                  tax
  247  00:D7BB  86 FC               stx   <_cl
  248                               ; -- check src
  249  00:D7BD  B2 EE               lda   [_si]
  250  00:D7BF  30 19               bmi   .l1
  251                               ; -- convert ascii string
  252                               stw   #__temp,<_bx
       00:D7C1  A9 03              lda    LOW_BYTE #__temp
       00:D7C3  85 FA              sta    LOW_BYTE <_bx
       00:D7C5  A9 20              lda    HIGH_BYTE #__temp
       00:D7C7  85 FB              sta    HIGH_BYTE <_bx
  253  00:D7C9  20 5B D7            jsr   _bcd_set.ascii
  254                               stw   #__temp,<_si
       00:D7CC  A9 03              lda    LOW_BYTE #__temp
       00:D7CE  85 EE              sta    LOW_BYTE <_si
       00:D7D0  A9 20              lda    HIGH_BYTE #__temp
       00:D7D2  85 EF              sta    HIGH_BYTE <_si
  255  00:D7D4  A6 FC               ldx   <_cl
  256  00:D7D6  A4 FC               ldy   <_cl
  257  00:D7D8  80 07               bra   .l2
  258                               ; -- get src size
  259  00:D7DA  29 1F     .l1:      and   #$1F
  260  00:D7DC  F0 11               beq   .x1
  261  00:D7DE  A8                  tay
  262                               ; -- add numbers
  263  00:D7DF  18                  clc
  264  00:D7E0  F8                  sed
  265  00:D7E1  B1 F0     .l2:      lda   [_di],Y
  266  00:D7E3  02                  sxy
  267  00:D7E4  71 F0               adc   [_di],Y
  268  00:D7E6  91 F0               sta   [_di],Y
  269  00:D7E8  CA                  dex
  270  00:D7E9  F0 0C               beq   .l4
  271  00:D7EB  02                  sxy
  272  00:D7EC  CA                  dex
  273  00:D7ED  D0 F2               bne   .l2
  274                               ; --
  275  00:D7EF  D8        .x1:      cld
  276  00:D7F0  60                  rts
  277                               ; -- carry
  278  00:D7F1  B1 F0     .l3:      lda   [_di],Y
  279  00:D7F3  69 00               adc   #0
  280  00:D7F5  91 F0               sta   [_di],Y
  281  00:D7F7  90 F6     .l4:      bcc   .x1
  282  00:D7F9  88                  dey
  283  00:D7FA  D0 F5               bne   .l3
  284  00:D7FC  D8                  cld
  285  00:D7FD  60                  rts
  286                     
#[2]   startup.asm
#[3]   huc_bram.asm
 1219                             .include "huc_bram.asm"
    1                     ;
    2                     ; HUC_BRAM.ASM  -  HuC Backup RAM Library
    3                     ;
    4                     
    5           29B8                      .bss
    6  --:29B8            _bm_mpr4:       .ds 1
    7  --:29B9            _bm_error:      .ds 1
    8           D7FE                      .code
    9                     
   10                     ; NOTE: the BRAM format is as follows:
   11                     ;
   12                     ; BRAM bank header (0x10 bytes):
   13                     ; ------------------------------
   14                     ; - Header tag (4 bytes) = 'HUBM'
   15                     ;
   16                     ; - Pointer to 1st byte after BRAM (2 byte int)
   17                     ;   Note: relative to 0x8000 segment, hex example: 00 88 ($8800)
   18                     ;
   19                     ; - Pointer to next available BRAM slot (2 byte int)
   20                     ;   Note: relative to 0x8000 segment, hex example: 22 80 ($8022)
   21                     ;
   22                     ; - Zeroes (8 bytes)
   23                     ;
   24                     ; BRAM Entry Header (0x10 bytes):
   25                     ; -------------------------------
   26                     ; - Size of entry (2 bytes), hex example: 12 00 ($0012)
   27                     ;   This size includes the 0x10 bytes used by this header information
   28                     ;
   29                     ; - Checksum (2 bytes)
   30                     ;   This number added to the data should total to 0
   31                     ;
   32                     ; - Name (12 bytes)
   33                     ;   This subdivides into:
   34                     ;   - Unique ID (2 bytes); I have only ever seen 00 00 in this entry
   35                     ;     However, it appears to be an integral part of the name
   36                     ;   - ASCII Name (10 bytes)
   37                     ;     This should be padded with spaces
   38                     ;
   39                     ; BRAM Entry:
   40                     ; -----------
   41                     ; - Miscellaneous data, size described by header parameters
   42                     ;
   43                     ; BRAM Entry Trailer (0x02 bytes):
   44                     ; --------------------------------
   45                     ; - Zeores (2 bytes)
   46                     ;   Technically, this trailer is "not used", but rather a terminator
   47                     ;   to the linked list.  The BRAM bank header points at it by the
   48                     ;   'next available slot' pointer
   49                     ;
   50                     
   51                     
   52                     ; bm_check()
   53                     ; ---
   54                     ; Determine whether BRAM exists on this system
   55                     ; without damaging contents on BRAM
   56                     ;
   57                     
   58  00:D7FE            _bm_check:
   59  00:D7FE  20 2F DA            jsr   _bm_unlock
   60                     
   61                               stw   #$8000,<_di     ; test area at $8000
       00:D801  A9 00              lda    LOW_BYTE #$8000
       00:D803  85 F0              sta    LOW_BYTE <_di
       00:D805  A9 80              lda    HIGH_BYTE #$8000
       00:D807  85 F1              sta    HIGH_BYTE <_di
   62  00:D809  20 1F D8            jsr   _bm_testram
   63                     
   64                               ; -- result
   65  00:D80C  20 1D DA            jsr   _bm_disable
   66  00:D80F  E0 00               cpx   #0
   67  00:D811  D0 08               bne   .err
   68                               ; -- ok
   69  00:D813  9C B9 29            stz   _bm_error
   70  00:D816  A2 01               ldx   #1
   71  00:D818  62                  cla
   72  00:D819  18                  clc
   73  00:D81A  60                  rts
   74                               ; -- no bram
   75  00:D81B  82        .err:     clx
   76  00:D81C  62                  cla
   77  00:D81D  38                  sec
   78  00:D81E  60                  rts
   79                     
   80                     
   81                     ; bm_testram
   82                     ; ---
   83                     ; internal function to test whether BRAM exists at a location
   84                     ; input  = _di (pointer to memory area to test)
   85                     ; output = register x (# errors)
   86                     ;
   87                     
   88  00:D81F            _bm_testram:
   89                               ; -- swap bits
   90  00:D81F  A0 07               ldy   #7
   91  00:D821  B1 F0     .l1:      lda   [_di],Y
   92  00:D823  49 FF               eor   #$FF
   93  00:D825  99 F8 20            sta   _ax,Y
   94  00:D828  91 F0               sta   [_di],Y
   95  00:D82A  88                  dey
   96  00:D82B  10 F4               bpl   .l1
   97                               ; -- cmp
   98  00:D82D  82                  clx
   99  00:D82E  A0 07               ldy   #7
  100  00:D830  B9 F8 20  .l2:      lda   _ax,Y
  101  00:D833  D1 F0               cmp   [_di],Y
  102  00:D835  F0 01               beq   .l3
  103  00:D837  E8                  inx
  104  00:D838  49 FF     .l3:      eor   #$FF
  105  00:D83A  91 F0               sta   [_di],Y
  106  00:D83C  88                  dey
  107  00:D83D  10 F1               bpl   .l2
  108                     
  109  00:D83F  60                  rts
  110                     
  111                     
  112                     ; bm_format()
  113                     ; ---
  114                     ; If BRAM is already formatted (*_PROPERLY_*), return OK
  115                     ; Otherwise, set header info, and set limit of BRAM to
  116                     ; maximum amount of memory available on this hardware
  117                     ;
  118                     
  119  00:D840            _bm_format:
  120  00:D840  20 0B DA            jsr   _bm_enable
  121  00:D843  90 30               bcc   .ok
  122                               ; -- format
  123  00:D845  A2 07               ldx   #7
  124  00:D847  BD 97 D9  .l1:      lda   _bm_id,X
  125  00:D84A  9D 00 80            sta   $8000,X
  126  00:D84D  CA                  dex
  127  00:D84E  10 F7               bpl   .l1
  128  00:D850  9C 10 80            stz   $8010
  129  00:D853  9C 11 80            stz   $8011
  130                     
  131                               stw   #$8000,<_di     ; test area at $8000
       00:D856  A9 00              lda    LOW_BYTE #$8000
       00:D858  85 F0              sta    LOW_BYTE <_di
       00:D85A  A9 80              lda    HIGH_BYTE #$8000
       00:D85C  85 F1              sta    HIGH_BYTE <_di
  132  00:D85E  20 1F D8  .l2:      jsr   _bm_testram
  133  00:D861  E0 00               cpx   #0
  134  00:D863  D0 0B               bne   .setsz
  135  00:D865  A5 F1               lda   <_di+1
  136  00:D867  C9 A0               cmp   #$A0            ; and keep going until either
  137  00:D869  F0 05               beq   .setsz          ; (a) bad memory, or
  138  00:D86B  1A                  inc   A               ; (b) next bank
  139  00:D86C  85 F1               sta   <_di+1
  140  00:D86E  80 EE               bra   .l2
  141                     
  142  00:D870  A5 F1     .setsz:   lda   <_di+1
  143  00:D872  8D 05 80            sta   $8005
  144                     
  145                               ; -- ok
  146  00:D875  20 1D DA  .ok:      jsr   _bm_disable
  147  00:D878  9C B9 29            stz   _bm_error
  148  00:D87B  82                  clx
  149  00:D87C  62                  cla
  150  00:D87D  18                  clc
  151  00:D87E  60                  rts
  152                     
  153                     
  154                     ; bm_free()
  155                     ; ---
  156                     ; Returns (int) number of user bytes available in BRAM
  157                     ; BRAM header entry and trailer overhead is already deducted
  158                     ;
  159                     
  160  00:D87F            _bm_free:
  161  00:D87F  20 0B DA            jsr   _bm_enable
  162  00:D882  B0 3A               bcs   .err
  163                               ; -- calculate free space
  164                               stw   $8004,<_cx
       00:D884  AD 04 80           lda    LOW_BYTE $8004
       00:D887  85 FC              sta    LOW_BYTE <_cx
       00:D889  AD 05 80           lda    HIGH_BYTE $8004
       00:D88C  85 FD              sta    HIGH_BYTE <_cx
  165                               subw  $8006,<_cx
       00:D88E  38                 sec
       00:D88F  A5 FC              lda    LOW_BYTE <_cx
       00:D891  ED 06 80           sbc    LOW_BYTE $8006
       00:D894  85 FC              sta    LOW_BYTE <_cx
       00:D896  A5 FD              lda    HIGH_BYTE <_cx
       00:D898  ED 07 80           sbc    HIGH_BYTE $8006
       00:D89B  85 FD              sta    HIGH_BYTE <_cx
  166                               subw  #$12,<_cx
       00:D89D  38                 sec
       00:D89E  A5 FC              lda    LOW_BYTE <_cx
       00:D8A0  E9 12              sbc    LOW_BYTE #$12
       00:D8A2  85 FC              sta    LOW_BYTE <_cx
       00:D8A4  A5 FD              lda    HIGH_BYTE <_cx
       00:D8A6  E9 00              sbc    HIGH_BYTE #$12
       00:D8A8  85 FD              sta    HIGH_BYTE <_cx
  167  00:D8AA  A5 FD               lda   <_ch
  168  00:D8AC  10 04               bpl   .ok
  169                               stwz  <_cx
       00:D8AE  64 FC              stz    LOW_BYTE <_cx
       00:D8B0  64 FD              stz    HIGH_BYTE <_cx
  170                               ; -- ok
  171  00:D8B2  20 1D DA  .ok:      jsr   _bm_disable
  172  00:D8B5  9C B9 29            stz   _bm_error
  173                             __ldw   <_cx
                0000              .if (1 = 2)
                                  .else
       00:D8B8  A6 FC              ldx    <_cx
       00:D8BA  A5 FD              lda    <_cx+1
                                  .endif
  174  00:D8BC  18                  clc
  175  00:D8BD  60                  rts
  176                               ; -- error, bram not formated
  177  00:D8BE  8D B9 29  .err:     sta   _bm_error
  178  00:D8C1  20 1D DA            jsr   _bm_disable
  179  00:D8C4  A9 FF               lda   #$FF
  180  00:D8C6  AA                  tax
  181  00:D8C7  38                  sec
  182  00:D8C8  60                  rts
  183                     
  184                     
  185                     ; bm_size()
  186                     ; ---
  187                     ; Returns (int) number of bytes in BRAM - should normally
  188                     ; be 2K, but can be as large as 8KB
  189                     
  190  00:D8C9            _bm_size:
  191  00:D8C9  20 0B DA            jsr   _bm_enable
  192  00:D8CC  B0 33               bcs   .err
  193                               ; -- calculate free space
  194                               stw   $8004,<_cx
       00:D8CE  AD 04 80           lda    LOW_BYTE $8004
       00:D8D1  85 FC              sta    LOW_BYTE <_cx
       00:D8D3  AD 05 80           lda    HIGH_BYTE $8004
       00:D8D6  85 FD              sta    HIGH_BYTE <_cx
  195                               subw  #$8000,<_cx
       00:D8D8  38                 sec
       00:D8D9  A5 FC              lda    LOW_BYTE <_cx
       00:D8DB  E9 00              sbc    LOW_BYTE #$8000
       00:D8DD  85 FC              sta    LOW_BYTE <_cx
       00:D8DF  A5 FD              lda    HIGH_BYTE <_cx
       00:D8E1  E9 80              sbc    HIGH_BYTE #$8000
       00:D8E3  85 FD              sta    HIGH_BYTE <_cx
  196  00:D8E5  A5 FD               lda   <_ch
  197  00:D8E7  C9 21               cmp   #$21
  198  00:D8E9  B0 14               bcs   .err1
  199  00:D8EB  A5 FD               lda   <_ch
  200  00:D8ED  10 04               bpl   .ok
  201                               stwz  <_cx
       00:D8EF  64 FC              stz    LOW_BYTE <_cx
       00:D8F1  64 FD              stz    HIGH_BYTE <_cx
  202                               ; -- ok
  203  00:D8F3  20 1D DA  .ok:      jsr   _bm_disable
  204  00:D8F6  9C B9 29            stz   _bm_error
  205                             __ldw   <_cx
                0000              .if (1 = 2)
                                  .else
       00:D8F9  A6 FC              ldx    <_cx
       00:D8FB  A5 FD              lda    <_cx+1
                                  .endif
  206  00:D8FD  18                  clc
  207  00:D8FE  60                  rts
  208                               ; -- error, bram not formated
  209  00:D8FF  A9 FF     .err1:    lda   #$ff
  210  00:D901  8D B9 29  .err:     sta   _bm_error
  211  00:D904  20 1D DA            jsr   _bm_disable
  212  00:D907  A9 FF               lda   #$FF
  213  00:D909  AA                  tax
  214  00:D90A  38                  sec
  215  00:D90B  60                  rts
  216                     
  217                     
  218                     ; bm_rawread(int location)
  219                     ; ---
  220                     ; Similar to peek(), but for BRAM
  221                     ; Automatically handles mapping of memory ; and address range
  222                     ;
  223  00:D90C            _bm_rawread:
  224                             __stw   <_bx
       00:D90C  86 FA              stx    <_bx
       00:D90E  85 FB              sta    <_bx+1
  225  00:D910  A5 FB               lda   <_bh
  226  00:D912  29 1F               and   #$1F
  227  00:D914  09 80               ora   #$80
  228  00:D916  85 FB               sta   <_bh
  229  00:D918  20 0B DA            jsr   _bm_enable
  230  00:D91B  B0 0C               bcs   .err
  231  00:D91D  B2 FA               lda   [_bx]
  232  00:D91F  22                  sax
  233  00:D920  9C B9 29            stz   _bm_error
  234  00:D923  20 1D DA            jsr   _bm_disable
  235  00:D926  62                  cla
  236  00:D927  18                  clc
  237  00:D928  60                  rts
  238  00:D929  8D B9 29  .err:     sta   _bm_error
  239  00:D92C  20 1D DA            jsr   _bm_disable
  240  00:D92F  38                  sec
  241  00:D930  60                  rts
  242                     
  243                     
  244                     ; bm_rawwrite(int location [bx], char val [reg acc])
  245                     ; ---
  246                     ; Similar to peek(), but for BRAM
  247                     ; Automatically handles mapping of memory ; and address range
  248                     ;
  249  00:D931            _bm_rawwrite.2:
  250                             __stw   <_ax
       00:D931  86 F8              stx    <_ax
       00:D933  85 F9              sta    <_ax+1
  251  00:D935  A5 FB               lda   <_bh
  252  00:D937  29 1F               and   #$1F
  253  00:D939  09 80               ora   #$80
  254  00:D93B  85 FB               sta   <_bh
  255  00:D93D  20 0B DA            jsr   _bm_enable
  256  00:D940  B0 0E               bcs   .err
  257  00:D942  A5 F8               lda   <_al
  258  00:D944  92 FA               sta   [_bx]
  259  00:D946  9C B9 29            stz   _bm_error
  260  00:D949  20 1D DA            jsr   _bm_disable
  261  00:D94C  62                  cla
  262  00:D94D  82                  clx
  263  00:D94E  18                  clc
  264  00:D94F  60                  rts
  265  00:D950  8D B9 29  .err:     sta   _bm_error
  266  00:D953  20 1D DA            jsr   _bm_disable
  267  00:D956  38                  sec
  268  00:D957  60                  rts
  269                     
  270                     
  271                     ; bm_exist(char *name)
  272                     ; ---
  273                     ; Check for existence of BRAM file with a matching name
  274                     ; Note: name is 12 bytes; first 2 bytes are a uniqueness value
  275                     ;       (should be zeroes), and the next10 bytes are ASCII name
  276                     ;       with trailing spaces as padding
  277                     ;
  278                     
  279  00:D958            _bm_exist:
  280                             __stw   <_bx
       00:D958  86 FA              stx    <_bx
       00:D95A  85 FB              sta    <_bx+1
  281  00:D95C  20 F9 D9            jsr   _bm_open
  282  00:D95F  B0 0A               bcs   .l1
  283  00:D961  20 1D DA            jsr   _bm_disable
  284  00:D964  A2 01               ldx   #1
  285  00:D966  AD B9 29            lda   _bm_error
  286  00:D969  F0 02               beq   .noerr
  287  00:D96B  82        .l1:      clx
  288  00:D96C  62                  cla
  289  00:D96D  60        .noerr:   rts
  290                     
  291                     
  292                     ; bm_sizeof(char *name)
  293                     ; ---
  294                     ; Return the size of the user data in a RAM file with the given name
  295                     ; Note: name is 12 bytes; first 2 bytes are a uniqueness value
  296                     ;       (should be zeroes), and the next10 bytes are ASCII name
  297                     ;       with trailing spaces as padding
  298                     ;
  299                     
  300  00:D96E            _bm_sizeof:
  301                             __stw   <_bx
       00:D96E  86 FA              stx    <_bx
       00:D970  85 FB              sta    <_bx+1
  302  00:D972  20 F9 D9            jsr   _bm_open
  303  00:D975  B0 18               bcs   .l1
  304                               subw  #$10,<_cx
       00:D977  38                 sec
       00:D978  A5 FC              lda    LOW_BYTE <_cx
       00:D97A  E9 10              sbc    LOW_BYTE #$10
       00:D97C  85 FC              sta    LOW_BYTE <_cx
       00:D97E  A5 FD              lda    HIGH_BYTE <_cx
       00:D980  E9 00              sbc    HIGH_BYTE #$10
       00:D982  85 FD              sta    HIGH_BYTE <_cx
  305  00:D984  20 1D DA            jsr   _bm_disable
  306  00:D987  9C B9 29            stz   _bm_error
  307  00:D98A  A6 FC               ldx   <_cl
  308  00:D98C  A5 FD               lda   <_ch
  309  00:D98E  60                  rts
  310  00:D98F  82        .l1:      clx
  311  00:D990  62                  cla
  312  00:D991  60                  rts
  313                     
  314                     
  315                     ; bm_errno()
  316                     ; ---
  317                     ; Return error type
  318                     ;
  319                     
  320  00:D992            _bm_errno:
  321  00:D992  AE B9 29            ldx   _bm_error
  322  00:D995  62                  cla
  323  00:D996  60                  rts
  324                     
  325                     
  326  00:D997            _bm_id:
  327  00:D997  48 55 42            .db   $48,$55,$42,$4D
       00:D99A  4D        
  328  00:D99B  00 88 10            .db   $00,$88,$10,$80
       00:D99E  80        
  329                     
  330                     
  331                     ; ------------------------
  332                     
  333                     ; bm_getptr(int ptr [bp], char *namebuf [reg acc])
  334                     ; ---
  335                     ; Given a pointer with the BRAM, obtain the name of the entry
  336                     ; and the pointer to the next entry
  337                     ; Use BRAM_START for first entry
  338                     ;
  339                     
  340  00:D99F            _bm_getptr.2:
  341                               maplibfunc    lib2_bm_getptr.2
       00:D99F  A8                 tay
       00:D9A0  43 20              tma  #page(lib2_bm_getptr.2)
       00:D9A2  48                 pha
       00:D9A3  A9 81              lda  #bank(lib2_bm_getptr.2)
       00:D9A5  53 20              tam  #page(lib2_bm_getptr.2)
       00:D9A7  98                 tya
       00:D9A8  20 BA AF           jsr  lib2_bm_getptr.2
       00:D9AB  A8                 tay
       00:D9AC  68                 pla
       00:D9AD  53 20              tam  #page(lib2_bm_getptr.2)
       00:D9AF  98                 tya
  342  00:D9B0  60                  rts
  343                     
  344                     
  345                     ; bm_delete(char *namebuf)
  346                     ; ---
  347                     ; Delete the entry specified by the name provided
  348                     ;
  349                     
  350  00:D9B1            _bm_delete:
  351                               maplibfunc    lib2_bm_delete
       00:D9B1  A8                 tay
       00:D9B2  43 20              tma  #page(lib2_bm_delete)
       00:D9B4  48                 pha
       00:D9B5  A9 81              lda  #bank(lib2_bm_delete)
       00:D9B7  53 20              tam  #page(lib2_bm_delete)
       00:D9B9  98                 tya
       00:D9BA  20 10 B0           jsr  lib2_bm_delete
       00:D9BD  A8                 tay
       00:D9BE  68                 pla
       00:D9BF  53 20              tam  #page(lib2_bm_delete)
       00:D9C1  98                 tya
  352  00:D9C2  60                  rts
  353                     
  354                     
  355                     ; bm_read(char *buf [di], char *name [bx], int offset [bp], int nb)
  356                     ; ---
  357                     ; Given a name of a file, grab some info from the file
  358                     ;
  359                     
  360  00:D9C3            _bm_read.4:
  361                               maplibfunc    lib2_bm_read.4
       00:D9C3  A8                 tay
       00:D9C4  43 20              tma  #page(lib2_bm_read.4)
       00:D9C6  48                 pha
       00:D9C7  A9 81              lda  #bank(lib2_bm_read.4)
       00:D9C9  53 20              tam  #page(lib2_bm_read.4)
       00:D9CB  98                 tya
       00:D9CC  20 6F B0           jsr  lib2_bm_read.4
       00:D9CF  A8                 tay
       00:D9D0  68                 pla
       00:D9D1  53 20              tam  #page(lib2_bm_read.4)
       00:D9D3  98                 tya
  362  00:D9D4  60                  rts
  363                     
  364                     
  365                     ; bm_write(char *buf [di], char *name [bx], int offset [bp], int nb)
  366                     ; ---
  367                     ; Given the name of a BRAM file, update some info inside of it
  368                     ;
  369                     
  370  00:D9D5            _bm_write.4:
  371                               maplibfunc    lib2_bm_write.4
       00:D9D5  A8                 tay
       00:D9D6  43 20              tma  #page(lib2_bm_write.4)
       00:D9D8  48                 pha
       00:D9D9  A9 81              lda  #bank(lib2_bm_write.4)
       00:D9DB  53 20              tam  #page(lib2_bm_write.4)
       00:D9DD  98                 tya
       00:D9DE  20 BE B0           jsr  lib2_bm_write.4
       00:D9E1  A8                 tay
       00:D9E2  68                 pla
       00:D9E3  53 20              tam  #page(lib2_bm_write.4)
       00:D9E5  98                 tya
  372  00:D9E6  60                  rts
  373                     
  374                     
  375                     ; bm_create(char *name [bx], int size)
  376                     ; ---
  377                     ; Create a new BRAM file, given the name and size
  378                     
  379  00:D9E7            _bm_create.2:
  380                               maplibfunc    lib2_bm_create.2
       00:D9E7  A8                 tay
       00:D9E8  43 20              tma  #page(lib2_bm_create.2)
       00:D9EA  48                 pha
       00:D9EB  A9 81              lda  #bank(lib2_bm_create.2)
       00:D9ED  53 20              tam  #page(lib2_bm_create.2)
       00:D9EF  98                 tya
       00:D9F0  20 FD B0           jsr  lib2_bm_create.2
       00:D9F3  A8                 tay
       00:D9F4  68                 pla
       00:D9F5  53 20              tam  #page(lib2_bm_create.2)
       00:D9F7  98                 tya
  381  00:D9F8  60                  rts
  382                     
  383                     
  384                     ; bm_open(char *name [bx])
  385                     ; ---
  386                     ; Internal function to obtain access to a named file
  387                     
  388  00:D9F9            _bm_open:
  389                               maplibfunc    lib2_bm_open
       00:D9F9  A8                 tay
       00:D9FA  43 20              tma  #page(lib2_bm_open)
       00:D9FC  48                 pha
       00:D9FD  A9 81              lda  #bank(lib2_bm_open)
       00:D9FF  53 20              tam  #page(lib2_bm_open)
       00:DA01  98                 tya
       00:DA02  20 BD B1           jsr  lib2_bm_open
       00:DA05  A8                 tay
       00:DA06  68                 pla
       00:DA07  53 20              tam  #page(lib2_bm_open)
       00:DA09  98                 tya
  390  00:DA0A  60                  rts
  391                     
  392                     
  393                     ; bm_enable()
  394                     ; ---
  395                     ; Internal function to enable the BRAM area and do a quick check
  396                     
  397  00:DA0B            _bm_enable:
  398                               maplibfunc    lib2_bm_enable
       00:DA0B  A8                 tay
       00:DA0C  43 20              tma  #page(lib2_bm_enable)
       00:DA0E  48                 pha
       00:DA0F  A9 81              lda  #bank(lib2_bm_enable)
       00:DA11  53 20              tam  #page(lib2_bm_enable)
       00:DA13  98                 tya
       00:DA14  20 40 B2           jsr  lib2_bm_enable
       00:DA17  A8                 tay
       00:DA18  68                 pla
       00:DA19  53 20              tam  #page(lib2_bm_enable)
       00:DA1B  98                 tya
  399  00:DA1C  60                  rts
  400                     
  401                     
  402                     ; bm_disable()
  403                     ; ---
  404                     ; This internal function handles the fixup of BRAM segment/locking
  405                     
  406  00:DA1D            _bm_disable:
  407                               maplibfunc    lib2_bm_disable
       00:DA1D  A8                 tay
       00:DA1E  43 20              tma  #page(lib2_bm_disable)
       00:DA20  48                 pha
       00:DA21  A9 81              lda  #bank(lib2_bm_disable)
       00:DA23  53 20              tam  #page(lib2_bm_disable)
       00:DA25  98                 tya
       00:DA26  20 68 B2           jsr  lib2_bm_disable
       00:DA29  A8                 tay
       00:DA2A  68                 pla
       00:DA2B  53 20              tam  #page(lib2_bm_disable)
       00:DA2D  98                 tya
  408  00:DA2E  60                  rts
  409                     
  410                     
  411                     ; bm_unlock()
  412                     ; ---
  413                     ; This internal function handles only the map/unlock of the BRAM area
  414                     
  415  00:DA2F            _bm_unlock:
  416                               maplibfunc    lib2_bm_unlock
       00:DA2F  A8                 tay
       00:DA30  43 20              tma  #page(lib2_bm_unlock)
       00:DA32  48                 pha
       00:DA33  A9 81              lda  #bank(lib2_bm_unlock)
       00:DA35  53 20              tam  #page(lib2_bm_unlock)
       00:DA37  98                 tya
       00:DA38  20 57 B2           jsr  lib2_bm_unlock
       00:DA3B  A8                 tay
       00:DA3C  68                 pla
       00:DA3D  53 20              tam  #page(lib2_bm_unlock)
       00:DA3F  98                 tya
  417  00:DA40  60                  rts
  418                     
  419                     
  420                     ; ---------------
  421                     
  422                     ;
  423                     ; From here, we have the implementation of various
  424                     ; BRAM routines in LIB2_BANK rather than LIB1_BANK
  425                     ; for reasons of speed and size
  426                     ;
  427                     ; Their external linkages will have specified above
  428                     ; and be begin with an underscore.  The private
  429                     ; definitions will not have an underscore
  430                     ;
  431                     
  432           0001              .bank   LIB2_BANK
  433                     
  434                     ; bm_getptr(int ptr [bp], char *namebuf [reg acc])
  435                     ; ---
  436                     ; Given a pointer with the BRAM, obtain the name of the entry
  437                     ; and the pointer to the next entry
  438                     ; Use BRAM_START for first entry
  439                     ;
  440                     
  441  01:AFBA            lib2_bm_getptr.2:
  442                             __stw   <_di            ; namebuf is destination of a copy
       01:AFBA  86 F0              stx    <_di
       01:AFBC  85 F1              sta    <_di+1
  443  01:AFBE  20 40 B2            jsr   lib2_bm_enable
  444  01:AFC1  B0 43               bcs   .x2
  445                     
  446                               tstw  <_bp            ; error - 0 input
       01:AFC3  A5 EC              lda   <_bp               ; value at stated memory
       01:AFC5  05 ED              ora   <_bp+1             ; location is zero
  447  01:AFC7  F0 3D               beq   .x2
  448  01:AFC9  B2 EC               lda   [_bp]
  449  01:AFCB  85 FC               sta   <_cl
  450  01:AFCD  A0 01               ldy   #1
  451  01:AFCF  B1 EC               lda   [_bp],Y
  452  01:AFD1  85 FD               sta   <_ch            ; <_cx is length of entry
  453                               tstw  <_cx
       01:AFD3  A5 FC              lda   <_cx               ; value at stated memory
       01:AFD5  05 FD              ora   <_cx+1             ; location is zero
  454  01:AFD7  F0 2C               beq   .empty
  455                     
  456                               addw  #4,<_bp,<_si    ; <_si is now ptr to name of current entry
                0001              .if     (3 = 3)
                                   ; 3-arg mode
                                   ;
       01:AFD9  18                 clc
       01:AFDA  A5 EC              lda    LOW_BYTE <_bp
       01:AFDC  69 04              adc    LOW_BYTE #4
       01:AFDE  85 EE              sta    LOW_BYTE <_si
       01:AFE0  A5 ED              lda    HIGH_BYTE <_bp
       01:AFE2  69 00              adc    HIGH_BYTE #4
       01:AFE4  85 EF              sta    HIGH_BYTE <_si
                                  .else
                                  .endif
  457  01:AFE6  62                  cla
  458  01:AFE7  A2 0C               ldx   #12
  459  01:AFE9  20 42 C6            jsr   _memcpy.3       ; copy 12 bytes of name to namebuf
  460                               addw  <_cx,<_bp,<_ax  ; next pointer
                0001              .if     (3 = 3)
                                   ; 3-arg mode
                                   ;
       01:AFEC  18                 clc
       01:AFED  A5 EC              lda    LOW_BYTE <_bp
       01:AFEF  65 FC              adc    LOW_BYTE <_cx
       01:AFF1  85 F8              sta    LOW_BYTE <_ax
       01:AFF3  A5 ED              lda    HIGH_BYTE <_bp
       01:AFF5  65 FD              adc    HIGH_BYTE <_cx
       01:AFF7  85 F9              sta    HIGH_BYTE <_ax
                                  .else
                                  .endif
  461  01:AFF9  20 68 B2            jsr   lib2_bm_disable
  462  01:AFFC  9C B9 29            stz   _bm_error
  463  01:AFFF  A5 F9               lda   <_ah
  464  01:B001  A6 F8               ldx   <_al
  465  01:B003  18                  clc
  466  01:B004  60                  rts
  467                     
  468  01:B005  62        .empty:   cla
  469                               
  470                               ; -- error, bram not formatted
  471  01:B006  8D B9 29  .x2:      sta   _bm_error
  472  01:B009  20 68 B2            jsr   lib2_bm_disable
  473  01:B00C  62                  cla
  474  01:B00D  82                  clx
  475  01:B00E  38                  sec
  476  01:B00F  60                  rts
  477                     
  478                     
  479                     ; bm_delete(char *namebuf)
  480                     ; ---
  481                     ; Delete the entry specified by the name provided
  482                     ;
  483                     
  484  01:B010            lib2_bm_delete:
  485                             __stw   <_ax
       01:B010  86 F8              stx    <_ax
       01:B012  85 F9              sta    <_ax+1
  486  01:B014  20 BD B1            jsr   lib2_bm_open
  487  01:B017  B0 55               bcs   .out
  488                               stw   $8006,<_bx      ; ptr to end
       01:B019  AD 06 80           lda    LOW_BYTE $8006
       01:B01C  85 FA              sta    LOW_BYTE <_bx
       01:B01E  AD 07 80           lda    HIGH_BYTE $8006
       01:B021  85 FB              sta    HIGH_BYTE <_bx
  489                               stw   <_si,<_di       ; setup currptr as dest
       01:B023  A5 EE              lda    LOW_BYTE <_si
       01:B025  85 F0              sta    LOW_BYTE <_di
       01:B027  A5 EF              lda    HIGH_BYTE <_si
       01:B029  85 F1              sta    HIGH_BYTE <_di
  490                               stw   <_dx,<_si       ; setup nextptr as src
       01:B02B  A5 FE              lda    LOW_BYTE <_dx
       01:B02D  85 EE              sta    LOW_BYTE <_si
       01:B02F  A5 FF              lda    HIGH_BYTE <_dx
       01:B031  85 EF              sta    HIGH_BYTE <_si
  491                               subw  <_dx,<_bx       ; #bytes = end-next + 2
       01:B033  38                 sec
       01:B034  A5 FA              lda    LOW_BYTE <_bx
       01:B036  E5 FE              sbc    LOW_BYTE <_dx
       01:B038  85 FA              sta    LOW_BYTE <_bx
       01:B03A  A5 FB              lda    HIGH_BYTE <_bx
       01:B03C  E5 FF              sbc    HIGH_BYTE <_dx
       01:B03E  85 FB              sta    HIGH_BYTE <_bx
  492                               addw  #2,<_bx
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       01:B040  18                 clc
       01:B041  A5 FA              lda    LOW_BYTE <_bx
       01:B043  69 02              adc    LOW_BYTE #2
       01:B045  85 FA              sta    LOW_BYTE <_bx
       01:B047  A5 FB              lda    HIGH_BYTE <_bx
       01:B049  69 00              adc    HIGH_BYTE #2
       01:B04B  85 FB              sta    HIGH_BYTE <_bx
                                  .endif
  493                               subw  <_cx,$8006      ; adjust ptr to end
       01:B04D  38                 sec
       01:B04E  AD 06 80           lda    LOW_BYTE $8006
       01:B051  E5 FC              sbc    LOW_BYTE <_cx
       01:B053  8D 06 80           sta    LOW_BYTE $8006
       01:B056  AD 07 80           lda    HIGH_BYTE $8006
       01:B059  E5 FD              sbc    HIGH_BYTE <_cx
       01:B05B  8D 07 80           sta    HIGH_BYTE $8006
  494  01:B05E  A5 FB               lda   <_bh
  495  01:B060  A6 FA               ldx   <_bl
  496  01:B062  20 42 C6            jsr   _memcpy.3
  497  01:B065  20 68 B2            jsr   lib2_bm_disable
  498  01:B068  9C B9 29            stz   _bm_error
  499  01:B06B  82                  clx
  500  01:B06C  62                  cla
  501  01:B06D  18                  clc
  502  01:B06E  60        .out:     rts
  503                     
  504                     
  505                     ; bm_read(char *buf [di], char *name [bx], int offset [bp], int nb)
  506                     ; ---
  507                     ; Given a name of a file, grab some info from the file
  508                     ;
  509                     
  510  01:B06F            lib2_bm_read.4:
  511                             __stw   <_ax
       01:B06F  86 F8              stx    <_ax
       01:B071  85 F9              sta    <_ax+1
  512                               ; -- open file
  513  01:B073  20 BD B1            jsr   lib2_bm_open
  514  01:B076  B0 45               bcs   .x2
  515                               ; -- checksum test
  516  01:B078  20 73 B2            jsr   lib2_bm_checksum
  517  01:B07B  A0 02               ldy   #2
  518  01:B07D  B1 EE               lda   [_si],Y
  519                               add   <_dl
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       01:B07F  18                 clc
       01:B080  65 FE              adc    <_dl
                                  .endif
  520  01:B082  85 FE               sta   <_dl
  521  01:B084  C8                  iny
  522  01:B085  B1 EE               lda   [_si],Y
  523  01:B087  65 FF               adc   <_dh
  524  01:B089  05 FE               ora   <_dl
  525  01:B08B  D0 25               bne   .x1
  526                               ; -- setup ptr
  527  01:B08D  20 A9 B2            jsr   lib2_bm_setup_ptr
  528  01:B090  B0 14               bcs   .ok
  529                               ; -- read
  530  01:B092  C2                  cly
  531  01:B093  B1 FE     .l1:      lda   [_dx],Y
  532  01:B095  91 F0               sta   [_di],Y
  533  01:B097  C8                  iny
  534  01:B098  D0 04               bne   .l2
  535  01:B09A  E6 FF               inc   <_dx+1
  536  01:B09C  E6 F1               inc   <_di+1
  537  01:B09E  C6 FC     .l2:      dec   <_cl
  538  01:B0A0  D0 F1               bne   .l1
  539  01:B0A2  C6 FD               dec   <_ch
  540  01:B0A4  10 ED               bpl   .l1
  541                               ; -- ok
  542  01:B0A6  20 68 B2  .ok:      jsr   lib2_bm_disable
  543  01:B0A9  9C B9 29            stz   _bm_error
  544                             __ldw   <_ax
                0000              .if (1 = 2)
                                  .else
       01:B0AC  A6 F8              ldx    <_ax
       01:B0AE  A5 F9              lda    <_ax+1
                                  .endif
  545  01:B0B0  18                  clc
  546  01:B0B1  60                  rts
  547                               ; -- error, bad file checksum
  548  01:B0B2  A9 02     .x1:      lda   #2
  549  01:B0B4  8D B9 29            sta   _bm_error
  550  01:B0B7  20 68 B2            jsr   lib2_bm_disable
  551  01:B0BA  82                  clx
  552  01:B0BB  62                  cla
  553  01:B0BC  38                  sec
  554  01:B0BD  60        .x2:      rts
  555                     
  556                     
  557                     ; bm_write(char *buf [di], char *name [bx], int offset [bp], int nb)
  558                     ; ---
  559                     ; Given the name of a BRAM file, update some info inside of it
  560                     ;
  561                     
  562  01:B0BE            lib2_bm_write.4:
  563                             __stw   <_ax
       01:B0BE  86 F8              stx    <_ax
       01:B0C0  85 F9              sta    <_ax+1
  564                               ; -- open file
  565  01:B0C2  20 BD B1            jsr   lib2_bm_open
  566  01:B0C5  B0 35               bcs   .x1
  567                               ; -- setup ptr
  568  01:B0C7  20 A9 B2            jsr   lib2_bm_setup_ptr
  569  01:B0CA  B0 25               bcs   .ok
  570                               ; -- write data
  571  01:B0CC  C2                  cly
  572  01:B0CD  B1 F0     .l1:      lda   [_di],Y
  573  01:B0CF  91 FE               sta   [_dx],Y
  574  01:B0D1  C8                  iny
  575  01:B0D2  D0 04               bne   .l2
  576  01:B0D4  E6 FF               inc   <_dx+1
  577  01:B0D6  E6 F1               inc   <_di+1
  578  01:B0D8  C6 FC     .l2:      dec   <_cl
  579  01:B0DA  D0 F1               bne   .l1
  580  01:B0DC  C6 FD               dec   <_ch
  581  01:B0DE  10 ED               bpl   .l1
  582                               ; -- update checksum
  583  01:B0E0  20 73 B2            jsr   lib2_bm_checksum
  584  01:B0E3  A0 02               ldy   #2
  585  01:B0E5  62                  cla
  586                               sub   <_dl
                0000              .if (1 = 2)            ; from register A (handle
                                  .else
       01:B0E6  38                 sec
       01:B0E7  E5 FE              sbc    <_dl
                                  .endif
  587  01:B0E9  91 EE               sta   [_si],Y
  588  01:B0EB  C8                  iny
  589  01:B0EC  62                  cla
  590  01:B0ED  E5 FF               sbc   <_dh
  591  01:B0EF  91 EE               sta   [_si],Y
  592                               ; -- ok
  593  01:B0F1  20 68 B2  .ok:      jsr   lib2_bm_disable
  594  01:B0F4  9C B9 29            stz   _bm_error
  595                             __ldw   <_ax
                0000              .if (1 = 2)
                                  .else
       01:B0F7  A6 F8              ldx    <_ax
       01:B0F9  A5 F9              lda    <_ax+1
                                  .endif
  596  01:B0FB  18                  clc
  597  01:B0FC  60        .x1:      rts
  598                     
  599                     
  600                     ; bm_create(char *name [bx], int size)
  601                     ; ---
  602                     ; Create a new BRAM file, given the name and size
  603                     
  604  01:B0FD            lib2_bm_create.2:
  605                             __stw   <_ax
       01:B0FD  86 F8              stx    <_ax
       01:B0FF  85 F9              sta    <_ax+1
  606  01:B101  20 40 B2            jsr   lib2_bm_enable
  607  01:B104  90 10               bcc   .go
  608  01:B106  80 02               bra   .x2
  609                               ; -- error, not enough ram
  610  01:B108  A9 05     .x1:      lda   #5
  611                               ; -- error, bram not formated
  612  01:B10A  8D B9 29  .x2:      sta   _bm_error
  613  01:B10D  20 68 B2            jsr   lib2_bm_disable
  614  01:B110  AE B9 29            ldx   _bm_error
  615  01:B113  62                  cla
  616  01:B114  38                  sec
  617  01:B115  60                  rts
  618                               ; -- check free space
  619                     .go:      addw  #$12,$8006,<_dx
                0001              .if     (3 = 3)
                                   ; 3-arg mode
                                   ;
       01:B116  18                 clc
       01:B117  AD 06 80           lda    LOW_BYTE $8006
       01:B11A  69 12              adc    LOW_BYTE #$12
       01:B11C  85 FE              sta    LOW_BYTE <_dx
       01:B11E  AD 07 80           lda    HIGH_BYTE $8006
       01:B121  69 00              adc    HIGH_BYTE #$12
       01:B123  85 FF              sta    HIGH_BYTE <_dx
                                  .else
                                  .endif
  620                               addw  <_ax,<_dx
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       01:B125  18                 clc
       01:B126  A5 FE              lda    LOW_BYTE <_dx
       01:B128  65 F8              adc    LOW_BYTE <_ax
       01:B12A  85 FE              sta    LOW_BYTE <_dx
       01:B12C  A5 FF              lda    HIGH_BYTE <_dx
       01:B12E  65 F9              adc    HIGH_BYTE <_ax
       01:B130  85 FF              sta    HIGH_BYTE <_dx
                                  .endif
  621                               cmpw  <_dx,$8004
       01:B132  AD 05 80           lda    HIGH_BYTE $8004
       01:B135  C5 FF              cmp    HIGH_BYTE <_dx
       01:B137  D0 05              bne    .x_00544
       01:B139  AD 04 80           lda    LOW_BYTE $8004
       01:B13C  C5 FE              cmp    LOW_BYTE <_dx
       01:B13E            .x_00544:
  622                               blo   .x1
       01:B13E  90 C8              bcc    .x1
  623                               ; -- create file
  624                               stw   $8006,<_si
       01:B140  AD 06 80           lda    LOW_BYTE $8006
       01:B143  85 EE              sta    LOW_BYTE <_si
       01:B145  AD 07 80           lda    HIGH_BYTE $8006
       01:B148  85 EF              sta    HIGH_BYTE <_si
  625  01:B14A  A0 01               ldy   #1
  626  01:B14C  A5 F8               lda   <_al
  627                               add   #$10
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       01:B14E  18                 clc
       01:B14F  69 10              adc    #$10
                                  .endif
  628  01:B151  92 EE               sta   [_si]
  629  01:B153  A5 F9               lda   <_ah
  630  01:B155  69 00               adc   #$00
  631  01:B157  91 EE               sta   [_si],Y
  632                               ; --
  633  01:B159  AD 06 80            lda   $8006
  634                               add   [_si]
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       01:B15C  18                 clc
       01:B15D  72 EE              adc    [_si]
                                  .endif
  635  01:B15F  85 FE               sta   <_dl
  636  01:B161  8D 06 80            sta   $8006
  637  01:B164  AD 07 80            lda   $8007
  638  01:B167  71 EE               adc   [_si],Y
  639  01:B169  85 FF               sta   <_dh
  640  01:B16B  8D 07 80            sta   $8007
  641  01:B16E  62                  cla
  642  01:B16F  92 FE               sta   [_dx]
  643  01:B171  91 FE               sta   [_dx],Y
  644                               ; -- copy name
  645  01:B173  82                  clx
  646  01:B174  A0 04               ldy   #4
  647  01:B176  02        .l1:      sxy
  648  01:B177  B1 FA               lda   [_bx],Y
  649  01:B179  02                  sxy
  650  01:B17A  91 EE               sta   [_si],Y
  651  01:B17C  C8                  iny
  652  01:B17D  E8                  inx
  653  01:B17E  E0 0C               cpx   #12
  654  01:B180  D0 F4               bne   .l1
  655                               ; -- clear file
  656  01:B182  A5 F8               lda   <_al
  657  01:B184  05 F9               ora   <_ah
  658  01:B186  F0 1A               beq   .sum
  659                               stw   <_si,<_bx
       01:B188  A5 EE              lda    LOW_BYTE <_si
       01:B18A  85 FA              sta    LOW_BYTE <_bx
       01:B18C  A5 EF              lda    HIGH_BYTE <_si
       01:B18E  85 FB              sta    HIGH_BYTE <_bx
  660  01:B190  A0 10               ldy   #16
  661  01:B192  62                  cla
  662  01:B193  91 FA     .l2:      sta   [_bx],Y
  663  01:B195  C8                  iny
  664  01:B196  D0 02               bne   .l3
  665  01:B198  E6 FB               inc   <_bh
  666  01:B19A  C6 F8     .l3:      dec   <_al
  667  01:B19C  D0 F5               bne   .l2
  668  01:B19E  C6 F9               dec   <_ah
  669  01:B1A0  10 F1               bpl   .l2
  670                               ; -- update checksum
  671  01:B1A2  20 73 B2  .sum:     jsr   lib2_bm_checksum
  672  01:B1A5  A0 02               ldy   #2
  673  01:B1A7  62                  cla
  674                               sub   <_dl
                0000              .if (1 = 2)            ; from register A (handle
                                  .else
       01:B1A8  38                 sec
       01:B1A9  E5 FE              sbc    <_dl
                                  .endif
  675  01:B1AB  91 EE               sta   [_si],Y
  676  01:B1AD  C8                  iny
  677  01:B1AE  62                  cla
  678  01:B1AF  E5 FF               sbc   <_dh
  679  01:B1B1  91 EE               sta   [_si],Y
  680                               ; -- ok
  681  01:B1B3  20 68 B2  .ok:      jsr   lib2_bm_disable
  682  01:B1B6  9C B9 29            stz   _bm_error
  683  01:B1B9  82                  clx
  684  01:B1BA  62                  cla
  685  01:B1BB  18                  clc
  686  01:B1BC  60                  rts
  687                     
  688                     
  689                     ; bm_open(char *name [bx])
  690                     ; ---
  691                     ; Internal function to obtain access to a named file
  692                     
  693  01:B1BD            lib2_bm_open:
  694  01:B1BD  20 40 B2            jsr   lib2_bm_enable
  695  01:B1C0  B0 6E               bcs   .x2
  696                               ; -- get dir entry
  697                               stw   #$8010,<_si
       01:B1C2  A9 10              lda    LOW_BYTE #$8010
       01:B1C4  85 EE              sta    LOW_BYTE <_si
       01:B1C6  A9 80              lda    HIGH_BYTE #$8010
       01:B1C8  85 EF              sta    HIGH_BYTE <_si
  698  01:B1CA  B2 EE     .l1:      lda   [_si]
  699  01:B1CC  85 FC               sta   <_cl
  700  01:B1CE  A0 01               ldy   #1
  701  01:B1D0  B1 EE               lda   [_si],Y
  702  01:B1D2  85 FD               sta   <_ch
  703  01:B1D4  05 FC               ora   <_cl
  704  01:B1D6  F0 56               beq   .x1
  705                               addw  <_cx,<_si,<_dx
                0001              .if     (3 = 3)
                                   ; 3-arg mode
                                   ;
       01:B1D8  18                 clc
       01:B1D9  A5 EE              lda    LOW_BYTE <_si
       01:B1DB  65 FC              adc    LOW_BYTE <_cx
       01:B1DD  85 FE              sta    LOW_BYTE <_dx
       01:B1DF  A5 EF              lda    HIGH_BYTE <_si
       01:B1E1  65 FD              adc    HIGH_BYTE <_cx
       01:B1E3  85 FF              sta    HIGH_BYTE <_dx
                                  .else
                                  .endif
  706                               cmpw  <_dx,$8004
       01:B1E5  AD 05 80           lda    HIGH_BYTE $8004
       01:B1E8  C5 FF              cmp    HIGH_BYTE <_dx
       01:B1EA  D0 05              bne    .x_00553
       01:B1EC  AD 04 80           lda    LOW_BYTE $8004
       01:B1EF  C5 FE              cmp    LOW_BYTE <_dx
       01:B1F1            .x_00553:
  707                               blo   .x3
       01:B1F1  90 45              bcc    .x3
  708                               cmpw  #16,<_cx
       01:B1F3  A5 FD              lda    HIGH_BYTE <_cx
       01:B1F5  C9 00              cmp    HIGH_BYTE #16
       01:B1F7  D0 04              bne    .x_00555
       01:B1F9  A5 FC              lda    LOW_BYTE <_cx
       01:B1FB  C9 10              cmp    LOW_BYTE #16
       01:B1FD            .x_00555:
  709                               blo   .x3
       01:B1FD  90 39              bcc    .x3
  710                               ; -- compare names
  711  01:B1FF  C2                  cly
  712  01:B200  A2 04               ldx   #4
  713  01:B202  B1 FA     .l2:      lda   [_bx],Y
  714  01:B204  02                  sxy
  715  01:B205  D1 EE               cmp   [_si],Y
  716  01:B207  D0 16               bne   .next
  717  01:B209  02                  sxy
  718  01:B20A  E8                  inx
  719  01:B20B  C8                  iny
  720  01:B20C  C0 0C               cpy   #12
  721                               blo   .l2
       01:B20E  90 F2              bcc    .l2
  722                               ; -- check file size
  723  01:B210  A5 FD               lda   <_ch
  724  01:B212  D0 06               bne   .ok
  725  01:B214  A5 FC               lda   <_cl
  726  01:B216  C9 10               cmp   #16
  727  01:B218  F0 22               beq   .x4
  728                               ; -- ok
  729  01:B21A  9C B9 29  .ok:      stz   _bm_error
  730  01:B21D  18                  clc
  731  01:B21E  60                  rts
  732                               ; -- next entry
  733                     .next:    addw  <_cx,<_si
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       01:B21F  18                 clc
       01:B220  A5 EE              lda    LOW_BYTE <_si
       01:B222  65 FC              adc    LOW_BYTE <_cx
       01:B224  85 EE              sta    LOW_BYTE <_si
       01:B226  A5 EF              lda    HIGH_BYTE <_si
       01:B228  65 FD              adc    HIGH_BYTE <_cx
       01:B22A  85 EF              sta    HIGH_BYTE <_si
                                  .endif
  734  01:B22C  80 9C               bra   .l1
  735                               ; -- error, file not found
  736  01:B22E  A9 01     .x1:      lda   #1
  737                               ; -- error, bram not formated
  738  01:B230  8D B9 29  .x2:      sta   _bm_error
  739  01:B233  20 68 B2            jsr   lib2_bm_disable
  740  01:B236  38                  sec
  741  01:B237  60                  rts
  742                               ; -- error, directory corrupted
  743  01:B238  A9 03     .x3:      lda   #3
  744  01:B23A  80 F4               bra   .x2
  745                               ; -- error, empty file
  746  01:B23C  A9 04     .x4:      lda   #4
  747  01:B23E  80 F0               bra   .x2
  748                     
  749                     
  750                     ; bm_enable()
  751                     ; ---
  752                     ; Internal function to enable the BRAM area and do a quick check
  753                     
  754  01:B240            lib2_bm_enable:
  755  01:B240  20 57 B2            jsr   lib2_bm_unlock
  756                               ; -- check if formated
  757  01:B243  A2 03               ldx   #3
  758  01:B245  BD 00 80  .l1:      lda   $8000,X
  759  01:B248  DD 97 D9            cmp   _bm_id,X
  760  01:B24B  D0 06               bne   .x1
  761  01:B24D  CA                  dex
  762  01:B24E  10 F5               bpl   .l1
  763                               ; -- ok
  764  01:B250  62                  cla
  765  01:B251  18                  clc
  766  01:B252  60                  rts
  767                               ; -- error, not formated!
  768  01:B253  A9 FF     .x1:      lda   #$FF
  769  01:B255  38                  sec
  770  01:B256  60                  rts
  771                     
  772                     
  773                     ; bm_unlock()
  774                     ; ---
  775                     ; This internal function handles only the map/unlock of the BRAM area
  776                     
  777  01:B257            lib2_bm_unlock:
  778  01:B257  78                  sei
  779  01:B258  43 10               tma   #4
  780  01:B25A  8D B8 29            sta   _bm_mpr4
  781  01:B25D  A9 F7               lda   #$F7
  782  01:B25F  53 10               tam   #4
  783  01:B261  54                  csl
  784  01:B262  A9 80               lda   #$80
  785  01:B264  8D 07 18            sta   bram_unlock
  786  01:B267  60                  rts
  787                     
  788                             
  789                     ; bm_disable()
  790                     ; ---
  791                     ; This internal function handles the fixup of BRAM segment/locking
  792                     
  793  01:B268            lib2_bm_disable:
  794  01:B268  AD B8 29            lda   _bm_mpr4
  795  01:B26B  53 10               tam   #4
  796  01:B26D  AD 03 18            lda   bram_lock
  797  01:B270  D4                  csh
  798  01:B271  58                  cli
  799  01:B272  60                  rts
  800                     
  801                     
  802                     ; bm_checksum(char *fcb [si])
  803                     ; ---
  804                     ; Internal function to generate checksum
  805                     ;
  806                     
  807  01:B273            lib2_bm_checksum:
  808                               stwz  <_dx
       01:B273  64 FE              stz    LOW_BYTE <_dx
       01:B275  64 FF              stz    HIGH_BYTE <_dx
  809                               ; -- get file size
  810  01:B277  B2 EE               lda   [_si]
  811                               sub   #4
                0000              .if (1 = 2)            ; from register A (handle
                                  .else
       01:B279  38                 sec
       01:B27A  E9 04              sbc    #4
                                  .endif
  812  01:B27C  85 FC               sta   <_cl
  813  01:B27E  A0 01               ldy   #1
  814  01:B280  B1 EE               lda   [_si],Y
  815  01:B282  E9 00               sbc   #0
  816  01:B284  85 FD               sta   <_ch
  817                               stw   <_si,<_bx
       01:B286  A5 EE              lda    LOW_BYTE <_si
       01:B288  85 FA              sta    LOW_BYTE <_bx
       01:B28A  A5 EF              lda    HIGH_BYTE <_si
       01:B28C  85 FB              sta    HIGH_BYTE <_bx
  818                               ; -- calc checksum
  819  01:B28E  A0 04               ldy   #4
  820  01:B290  B1 FA     .l1:      lda   [_bx],Y
  821                               add   <_dl
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       01:B292  18                 clc
       01:B293  65 FE              adc    <_dl
                                  .endif
  822  01:B295  85 FE               sta   <_dl
  823  01:B297  90 02               bcc   .l2
  824  01:B299  E6 FF               inc   <_dh
  825  01:B29B  C8        .l2:      iny
  826  01:B29C  D0 02               bne   .l3
  827  01:B29E  E6 FB               inc   <_bh
  828  01:B2A0  C6 FC     .l3:      dec   <_cl
  829  01:B2A2  D0 EC               bne   .l1
  830  01:B2A4  C6 FD               dec   <_ch
  831  01:B2A6  10 E8               bpl   .l1
  832  01:B2A8  60                  rts
  833                     
  834                     
  835                     ; bm_setup_ptr(char *fcb [si], char *buf [di], int offset [bp], int nb [ax])
  836                     ; ---
  837                     
  838  01:B2A9            lib2_bm_setup_ptr:
  839                               ; -- check length
  840                               tstw  <_ax
       01:B2A9  A5 F8              lda   <_ax               ; value at stated memory
       01:B2AB  05 F9              ora   <_ax+1             ; location is zero
  841  01:B2AD  F0 21               beq   .x1
  842                               ; -- check ptr
  843                               tstw  <_di
       01:B2AF  A5 F0              lda   <_di               ; value at stated memory
       01:B2B1  05 F1              ora   <_di+1             ; location is zero
  844  01:B2B3  F0 1B               beq   .x1
  845                               ; -- check offset
  846                               addw  #16,<_bp,<_bx
                0001              .if     (3 = 3)
                                   ; 3-arg mode
                                   ;
       01:B2B5  18                 clc
       01:B2B6  A5 EC              lda    LOW_BYTE <_bp
       01:B2B8  69 10              adc    LOW_BYTE #16
       01:B2BA  85 FA              sta    LOW_BYTE <_bx
       01:B2BC  A5 ED              lda    HIGH_BYTE <_bp
       01:B2BE  69 00              adc    HIGH_BYTE #16
       01:B2C0  85 FB              sta    HIGH_BYTE <_bx
                                  .else
                                  .endif
  847  01:B2C2  A0 01               ldy   #1
  848  01:B2C4  A5 FB               lda   <_bh
  849  01:B2C6  D1 EE               cmp   [_si],Y
  850  01:B2C8  D0 04               bne   .l1
  851  01:B2CA  A5 FA               lda   <_bl
  852  01:B2CC  D2 EE               cmp   [_si]
  853                     .l1:      blo   .l2
       01:B2CE  90 06              bcc    .l2
  854                               ; -- eof
  855                     .x1:      stwz  <_ax
       01:B2D0  64 F8              stz    LOW_BYTE <_ax
       01:B2D2  64 F9              stz    HIGH_BYTE <_ax
  856  01:B2D4  38                  sec
  857  01:B2D5  60                  rts
  858                               ; -- set base ptr
  859                     .l2:      addw  <_bx,<_si,<_dx
                0001              .if     (3 = 3)
                                   ; 3-arg mode
                                   ;
       01:B2D6  18                 clc
       01:B2D7  A5 EE              lda    LOW_BYTE <_si
       01:B2D9  65 FA              adc    LOW_BYTE <_bx
       01:B2DB  85 FE              sta    LOW_BYTE <_dx
       01:B2DD  A5 EF              lda    HIGH_BYTE <_si
       01:B2DF  65 FB              adc    HIGH_BYTE <_bx
       01:B2E1  85 FF              sta    HIGH_BYTE <_dx
                                  .else
                                  .endif
  860                               ; -- check length
  861                               addw  <_ax,<_bx
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       01:B2E3  18                 clc
       01:B2E4  A5 FA              lda    LOW_BYTE <_bx
       01:B2E6  65 F8              adc    LOW_BYTE <_ax
       01:B2E8  85 FA              sta    LOW_BYTE <_bx
       01:B2EA  A5 FB              lda    HIGH_BYTE <_bx
       01:B2EC  65 F9              adc    HIGH_BYTE <_ax
       01:B2EE  85 FB              sta    HIGH_BYTE <_bx
                                  .endif
  862  01:B2F0  B2 EE               lda   [_si]
  863                               sub   <_bl
                0000              .if (1 = 2)            ; from register A (handle
                                  .else
       01:B2F2  38                 sec
       01:B2F3  E5 FA              sbc    <_bl
                                  .endif
  864  01:B2F5  85 FA               sta   <_bl
  865  01:B2F7  B1 EE               lda   [_si],Y
  866  01:B2F9  E5 FB               sbc   <_bh
  867  01:B2FB  85 FB               sta   <_bh
  868  01:B2FD  10 0D               bpl   .ok
  869                               ; -- adjust size
  870                               addw  <_bx,<_ax
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       01:B2FF  18                 clc
       01:B300  A5 F8              lda    LOW_BYTE <_ax
       01:B302  65 FA              adc    LOW_BYTE <_bx
       01:B304  85 F8              sta    LOW_BYTE <_ax
       01:B306  A5 F9              lda    HIGH_BYTE <_ax
       01:B308  65 FB              adc    HIGH_BYTE <_bx
       01:B30A  85 F9              sta    HIGH_BYTE <_ax
                                  .endif
  871                     .ok:      stw   <_ax,<_cx
       01:B30C  A5 F8              lda    LOW_BYTE <_ax
       01:B30E  85 FC              sta    LOW_BYTE <_cx
       01:B310  A5 F9              lda    HIGH_BYTE <_ax
       01:B312  85 FD              sta    HIGH_BYTE <_cx
  872  01:B314  18                  clc
  873  01:B315  60                  rts
  874                     
  875                     ;
  876                     ; restore the context of the library routines
  877                     ; in LIB1_BANK
  878                     ;
  879           0000              .bank   LIB1_BANK
  880                     
#[2]   startup.asm
#[3]   huc_misc.asm
 1220                             .include "huc_misc.asm"
    1                     ;
    2                     ; HUC_MISC.ASM  -  HuC Misc Library
    3                     ;
    4                     
    5                     
    6                     ; joy(char number)
    7                     ; ----
    8                     
    9  00:DA41            _joy:
   10  00:DA41  02                  sxy
   11  00:DA42  BE 28 22            ldx   joy,Y
   12  00:DA45  B9 93 26            lda   joy6,Y
   13  00:DA48  60                  rts
   14                     
   15                     ; joytrg(char number)
   16                     ; ----
   17                     
   18  00:DA49            _joytrg:
   19  00:DA49  02                  sxy
   20  00:DA4A  BE 2D 22            ldx   joytrg,Y
   21  00:DA4D  B9 98 26            lda   joytrg6,Y
   22  00:DA50  60                  rts
   23                     
   24                     ; joyold(char number)
   25                     ; ----
   26                     
   27  00:DA51            _joyold:
   28  00:DA51  02                  sxy
   29  00:DA52  BE 32 22            ldx   joyold,Y
   30  00:DA55  B9 9D 26            lda   joyold6,Y
   31  00:DA58  60                  rts
   32                     
   33                     ; joybuf(char number)
   34                     ; ----
   35                     
   36  00:DA59            _joybuf:
   37  00:DA59  02                  sxy
   38  00:DA5A  BE 81 26            ldx   joybuf,Y
   39  00:DA5D  B9 A2 26            lda   joybuf6,Y
   40  00:DA60  60                  rts
   41                     
   42                     
   43                     ; mouse functions
   44                     ; only available if '#define SUPPORT_MOUSE 1' is used
   45                     ; ----
   46                     
   47           0001              .ifdef SUPPORT_MOUSE
   48                     
   49                     ; mouse_exists() - returns true/false (true = 1)
   50                     ; ----
   51                     
   52  00:DA61            _mouse_exists:
   53  00:DA61  AE BA 29            ldx   msflag
   54  00:DA64  62                  cla
   55  00:DA65  60                  rts
   56                     
   57                     ; mouse_disable() - turns off mouse support
   58                     ; ----
   59                     
   60  00:DA66            _mouse_disable:
   61  00:DA66  62                  cla
   62  00:DA67  82                  clx
   63  00:DA68  8D BA 29            sta   msflag
   64  00:DA6B  60                  rts
   65                     
   66                     ; mouse_enable() - turns on mouse support, if mouse detected
   67                     ;                - return true/false (true=1) if mouse exists
   68                     ; ----
   69                     
   70  00:DA6C            _mouse_enable:
   71  00:DA6C  20 8B DB            jsr   mousinit
   72  00:DA6F  22                  sax
   73  00:DA70  62                  cla
   74  00:DA71  60                  rts
   75                     
   76                     ; mouse_x() - returns x/y delta (int)
   77                     ; ----
   78                     
   79  00:DA72            _mouse_x:
   80  00:DA72  AE BC 29            ldx   mshorz
   81  00:DA75  10 08               bpl   mouspos
   82  00:DA77  A9 FF     mousneg:  lda   #$ff
   83  00:DA79  60                  rts
   84                     
   85                     ; mouse_y() - returns y delta (int)
   86                     ; ----
   87                     
   88  00:DA7A            _mouse_y:
   89  00:DA7A  AE BB 29            ldx   msvert
   90  00:DA7D  30 F8               bmi   mousneg
   91  00:DA7F  62        mouspos:  cla
   92  00:DA80  60                  rts
   93                     
   94                             .endif          ; SUPPORT_MOUSE
   95                     
   96                     
   97                     ; set_joy_callback(char num [dl], char mask [al], char keys [ah], int proc [bl:si])
   98                     ; ----
   99                     
  100  00:DA81            _set_joy_callback.4:
  101  00:DA81  9C 88 26            stz   joycallback
  102  00:DA84  A5 FA               lda   <_bl
  103  00:DA86  8D 8B 26            sta   joycallback+3
  104                             __ldw   <_si
                0000              .if (1 = 2)
                                  .else
       00:DA89  A6 EE              ldx    <_si
       00:DA8B  A5 EF              lda    <_si+1
                                  .endif
  105                             __stw   joycallback+4
       00:DA8D  8E 8C 26           stx    joycallback+4
       00:DA90  8D 8D 26           sta    joycallback+4+1
  106  00:DA93  05 EE               ora   <_si
  107  00:DA95  F0 0F               beq   .l1
  108  00:DA97  A5 F9               lda   <_ah
  109  00:DA99  8D 8A 26            sta   joycallback+2
  110  00:DA9C  A5 F8               lda   <_al
  111  00:DA9E  8D 89 26            sta   joycallback+1
  112  00:DAA1  A9 80               lda   #$80
  113  00:DAA3  8D 88 26            sta   joycallback
  114  00:DAA6  60        .l1:      rts
  115                     
  116                     ; get_joy_events(char num, int rst)
  117                     ; ----
  118                     ; return all the collected joypad events
  119                     ; ----
  120                     
  121  00:DAA7            _get_joy_events.2:
  122  00:DAA7  A4 F8               ldy   <_al
  123  00:DAA9  E0 00               cpx   #0
  124  00:DAAB  D0 06               bne   _get_joy_events.sub
  125  00:DAAD  BE 81 26            ldx   joybuf,Y
  126  00:DAB0  62                  cla
  127  00:DAB1  60                  rts
  128  00:DAB2            _get_joy_events.1:
  129  00:DAB2  02                  sxy
  130  00:DAB3            _get_joy_events.sub:
  131  00:DAB3  BE 81 26            ldx   joybuf,Y
  132  00:DAB6  62                  cla
  133  00:DAB7  99 81 26            sta   joybuf,Y
  134  00:DABA  60                  rts
  135                     
  136                     ; clear_joy_events(char mask)
  137                     ; ----
  138                     
  139  00:DABB            _clear_joy_events:
  140  00:DABB  86 F8               stx   <_al
  141  00:DABD  C2                  cly
  142  00:DABE  78                  sei
  143  00:DABF  46 F8     .l1:      lsr   <_al
  144  00:DAC1  90 15               bcc   .l2
  145  00:DAC3  62                  cla
  146  00:DAC4  99 81 26            sta   joybuf,Y
  147  00:DAC7  99 A2 26            sta   joybuf6,Y
  148  00:DACA  99 2D 22            sta   joytrg,Y
  149  00:DACD  99 98 26            sta   joytrg6,Y
  150  00:DAD0  A9 FF               lda   #$FF
  151  00:DAD2  99 32 22            sta   joyold,Y
  152  00:DAD5  99 9D 26            sta   joyold6,Y
  153  00:DAD8  C8        .l2:      iny
  154  00:DAD9  C0 05               cpy   #5
  155                               blo   .l1
       00:DADB  90 E2              bcc    .l1
  156  00:DADD  58                  cli
  157  00:DADE  60                  rts
  158                     
  159                     
  160                     ; clock_hh()
  161                     ; ----
  162  00:DADF            _clock_hh:
  163  00:DADF  62                  cla
  164  00:DAE0  AE 8F 26            ldx   clock_hh
  165  00:DAE3  60                  rts
  166                     
  167                     ; clock_mm()
  168                     ; ----
  169  00:DAE4            _clock_mm:
  170  00:DAE4  62                  cla
  171  00:DAE5  AE 90 26            ldx   clock_mm
  172  00:DAE8  60                  rts
  173                     
  174                     ; clock_ss()
  175                     ; ----
  176  00:DAE9            _clock_ss:
  177  00:DAE9  62                  cla
  178  00:DAEA  AE 91 26            ldx   clock_ss
  179  00:DAED  60                  rts
  180                     
  181                     ; clock_tt()
  182                     ; ----
  183  00:DAEE            _clock_tt:
  184  00:DAEE  62                  cla
  185  00:DAEF  AE 92 26            ldx   clock_tt
  186  00:DAF2  60                  rts
  187                     
  188                     ; clock_reset()
  189                     ; ----
  190  00:DAF3            _clock_reset:
  191  00:DAF3  9C 8F 26            stz   clock_hh
  192  00:DAF6  9C 90 26            stz   clock_mm
  193  00:DAF9  9C 91 26            stz   clock_ss
  194  00:DAFC  9C 92 26            stz   clock_tt
  195  00:DAFF  60                  rts
  196                     
  197                     
  198                     ; poke(int offset bx, char val)
  199                     ; ----
  200                     
  201  00:DB00            _poke.2:
  202  00:DB00  8A                  txa
  203  00:DB01  92 FA               sta   [_bx]
  204  00:DB03  60                  rts
  205                     
  206                     ; poke/pokew(int offset bx, int val)
  207                     ; ----
  208                     
  209  00:DB04            _pokew.2:
  210  00:DB04  22                  sax
  211  00:DB05  92 FA               sta   [_bx]
  212  00:DB07  A0 01               ldy   #1
  213  00:DB09  22                  sax
  214  00:DB0A  91 FA               sta   [_bx],Y
  215  00:DB0C  60                  rts
  216                     
  217                     ; peek(int offset)
  218                     ; ----
  219                     
  220  00:DB0D            _peek:
  221                             __stw   <__ptr
       00:DB0D  86 0B              stx    <__ptr
       00:DB0F  85 0C              sta    <__ptr+1
  222  00:DB11  B2 0B               lda   [__ptr]
  223  00:DB13  AA                  tax
  224  00:DB14  62                  cla
  225  00:DB15  60                  rts
  226                     
  227                     ; peekw(int offset)
  228                     ; ----
  229                     
  230  00:DB16            _peekw:
  231                             __stw   <__ptr
       00:DB16  86 0B              stx    <__ptr
       00:DB18  85 0C              sta    <__ptr+1
  232  00:DB1A  B2 0B               lda   [__ptr]
  233  00:DB1C  AA                  tax
  234  00:DB1D  A0 01               ldy   #1
  235  00:DB1F  B1 0B               lda   [__ptr],Y
  236  00:DB21  60                  rts
  237                     
  238                     ; farpeekb(far void *base)
  239                     ; ----
  240                     
  241  00:DB22            _farpeekb.1:
  242  00:DB22  A5 0D               lda   <__fbank
  243  00:DB24  53 08               tam   #3
  244  00:DB26  A5 0F               lda   <__fptr+1
  245  00:DB28  29 1F               and   #$1F
  246  00:DB2A  09 60               ora   #$60
  247  00:DB2C  85 0F               sta   <__fptr+1
  248  00:DB2E  B2 0E               lda   [__fptr]
  249  00:DB30  AA                  tax
  250  00:DB31  62                  cla
  251  00:DB32  60                  rts
  252                     
  253                     ; farpeekw(far void *base)
  254                     ; ----
  255                     
  256  00:DB33            _farpeekw.1:
  257  00:DB33  A5 0D               lda   <__fbank
  258  00:DB35  53 08               tam   #3
  259  00:DB37  A5 0F               lda   <__fptr+1
  260  00:DB39  29 1F               and   #$1F
  261  00:DB3B  09 60               ora   #$60
  262  00:DB3D  85 0F               sta   <__fptr+1
  263  00:DB3F  80 09               bra   _farpeekw.sub
  264  00:DB41            _farpeekw.fast:
  265  00:DB41  53 08               tam   #3
  266  00:DB43  8A                  txa
  267  00:DB44  29 1F               and   #$1F
  268  00:DB46  09 60               ora   #$60
  269  00:DB48  85 0F               sta   <__fptr+1
  270  00:DB4A            _farpeekw.sub:
  271  00:DB4A  B2 0E               lda   [__fptr]
  272  00:DB4C  AA                  tax
  273  00:DB4D  E6 0E               inc   <__fptr
  274  00:DB4F  90 08               bcc   .l1
  275  00:DB51  E6 0F               inc   <__fptr+1
  276  00:DB53  10 04               bpl   .l1
  277  00:DB55  A9 60               lda   #$60
  278  00:DB57  85 0F               sta   <__fptr+1
  279  00:DB59            .l1:
  280  00:DB59  B2 0E               lda   [__fptr]
  281  00:DB5B  60                  rts
  282                     
  283                     ; farmemget(void *dst, far void *base, int len)
  284                     ; ----
  285                     
  286  00:DB5C            _farmemget.3:
  287                               maplibfunc    lib2_farmemget.3
       00:DB5C  A8                 tay
       00:DB5D  43 20              tma  #page(lib2_farmemget.3)
       00:DB5F  48                 pha
       00:DB60  A9 81              lda  #bank(lib2_farmemget.3)
       00:DB62  53 20              tam  #page(lib2_farmemget.3)
       00:DB64  98                 tya
       00:DB65  20 16 B3           jsr  lib2_farmemget.3
       00:DB68  A8                 tay
       00:DB69  68                 pla
       00:DB6A  53 20              tam  #page(lib2_farmemget.3)
       00:DB6C  98                 tya
  288  00:DB6D  60                  rts
  289                     
  290                     ; The following function was too large to stay
  291                     ; in LIB1_BANK, so it is placed in LIB2_BANK
  292                     ; and must be mapped in and out when used.
  293                     
  294                     ; Code after this routine should be back in LIB1_BANK
  295                     
  296           0001               .bank  LIB2_BANK
  297                     
  298  01:B316            lib2_farmemget.3:
  299                     
  300                             __stw   <_cx
       01:B316  86 FC              stx    <_cx
       01:B318  85 FD              sta    <_cx+1
  301  01:B31A  A5 0D               lda   <__fbank
  302  01:B31C  53 08               tam   #3
  303                     
  304                         ; ----
  305                         ; split transfer if needed
  306                         ;
  307                               ; -- clip length (max. 8KB)
  308                               cmpw  #$2000,<_cx
       01:B31E  A5 FD              lda    HIGH_BYTE <_cx
       01:B320  C9 20              cmp    HIGH_BYTE #$2000
       01:B322  D0 04              bne    .x_00580
       01:B324  A5 FC              lda    LOW_BYTE <_cx
       01:B326  C9 00              cmp    LOW_BYTE #$2000
       01:B328            .x_00580:
  309                               blo   .t1
       01:B328  90 08              bcc    .t1
  310                               stw   #$2000,<_cx
       01:B32A  A9 00              lda    LOW_BYTE #$2000
       01:B32C  85 FC              sta    LOW_BYTE <_cx
       01:B32E  A9 20              lda    HIGH_BYTE #$2000
       01:B330  85 FD              sta    HIGH_BYTE <_cx
  311                               ; -- check length
  312  01:B332  A5 0E     .t1:      lda   <__fptr
  313                               add   <_cl
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       01:B334  18                 clc
       01:B335  65 FC              adc    <_cl
                                  .endif
  314  01:B337  85 F8               sta   <_al
  315  01:B339  A5 0F               lda   <__fptr+1
  316  01:B33B  29 1F               and   #$1F
  317  01:B33D  65 FD               adc   <_ch
  318  01:B33F  85 F9               sta   <_ah
  319  01:B341  C9 20               cmp   #$20
  320                               blo   .t2
       01:B343  90 15              bcc    .t2
  321                               ; -- calculate second-half size
  322  01:B345  29 1F               and   #$1F
  323  01:B347  85 FF               sta   <_dh
  324  01:B349  A5 F8               lda   <_al
  325  01:B34B  85 FE               sta   <_dl
  326                               subw  <_dx,<_cx
       01:B34D  38                 sec
       01:B34E  A5 FC              lda    LOW_BYTE <_cx
       01:B350  E5 FE              sbc    LOW_BYTE <_dx
       01:B352  85 FC              sta    LOW_BYTE <_cx
       01:B354  A5 FD              lda    HIGH_BYTE <_cx
       01:B356  E5 FF              sbc    HIGH_BYTE <_dx
       01:B358  85 FD              sta    HIGH_BYTE <_cx
  327                               ; -- remap src ptr
  328  01:B35A  A5 0F     .t2:      lda   <__fptr+1
  329  01:B35C  29 1F               and   #$1F
  330  01:B35E  09 60               ora   #$60
  331  01:B360  85 0F               sta   <__fptr+1
  332                     
  333                         ; ----
  334                         ; copy a block
  335                         ;
  336  01:B362  82                  clx
  337  01:B363  C2                  cly
  338  01:B364  C6 FD               dec   <_ch
  339  01:B366  30 1C               bmi   .l4
  340                               ; -- main loop
  341  01:B368  B1 0E     .l1:      lda   [__fptr],Y
  342  01:B36A  91 FA               sta   [_bx],Y
  343  01:B36C  C8                  iny
  344  01:B36D  CA                  dex
  345  01:B36E  D0 F8               bne   .l1
  346                               ; -- inc dst ptr
  347  01:B370  C0 00               cpy   #0
  348  01:B372  F0 08               beq   .l2
  349  01:B374  98                  tya
  350                               add   <_bl
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       01:B375  18                 clc
       01:B376  65 FA              adc    <_bl
                                  .endif
  351  01:B378  85 FA               sta   <_bl
  352  01:B37A  90 02               bcc   .l3
  353  01:B37C  E6 FB     .l2:      inc   <_bh
  354                               ; -- inc src ptr
  355  01:B37E  E6 0F     .l3:      inc   <__fptr+1
  356                               ; -- next chunk
  357  01:B380  C6 FD               dec   <_ch
  358  01:B382  10 E4               bpl   .l1
  359  01:B384  A6 FC     .l4:      ldx   <_cl
  360  01:B386  64 FC               stz   <_cl
  361  01:B388  D0 DE               bne   .l1
  362                     
  363                         ; ----
  364                         ; second half
  365                         ;
  366                               tstw  <_dx
       01:B38A  A5 FE              lda   <_dx               ; value at stated memory
       01:B38C  05 FF              ora   <_dx+1             ; location is zero
  367  01:B38E  F0 17               beq   .l5
  368                               ; -- reload dst and cnt
  369                               stw   <_dx,<_cx
       01:B390  A5 FE              lda    LOW_BYTE <_dx
       01:B392  85 FC              sta    LOW_BYTE <_cx
       01:B394  A5 FF              lda    HIGH_BYTE <_dx
       01:B396  85 FD              sta    HIGH_BYTE <_cx
  370                               stw   #$6000,<__fptr
       01:B398  A9 00              lda    LOW_BYTE #$6000
       01:B39A  85 0E              sta    LOW_BYTE <__fptr
       01:B39C  A9 60              lda    HIGH_BYTE #$6000
       01:B39E  85 0F              sta    HIGH_BYTE <__fptr
  371                               ; -- inc bank
  372  01:B3A0  43 08               tma   #3
  373  01:B3A2  1A                  inc   A
  374  01:B3A3  53 08               tam   #3
  375  01:B3A5  80 C1               bra   .l1
  376                     
  377                         ; ----
  378                         ; exit
  379                         ;
  380  01:B3A7  60        .l5:      rts
  381                     
  382                     ; The preceding function was too large to stay
  383                     ; in LIB1_BANK, so it is placed in LIB2_BANK
  384                     ; and must be mapped in and out when used.
  385                     
  386                     ; Code after this routine should be back in LIB1_BANK
  387                     
  388           0000               .bank  LIB1_BANK
  389                     
  390                     
  391                     ; srand(int seed)
  392                     ; srand32.2(int seed1 [dx], int seed2 [cx])
  393                     ; ---------------
  394                     ; set the seed number for the psuedo-random number generator
  395                     
  396  00:DB6E            _srand:
  397                             __stw   <_dx
       00:DB6E  86 FE              stx    <_dx
       00:DB70  85 FF              sta    <_dx+1
  398                             __stw   <_cx
       00:DB72  86 FC              stx    <_cx
       00:DB74  85 FD              sta    <_cx+1
  399                     
  400  00:DB76            _srand32.2:
  401  00:DB76  20 73 C7            jsr   srand
  402  00:DB79  60                  rts
  403                     
  404                     ; rand()
  405                     ; ----
  406                     ; get a 16-bit random number
  407                     
  408  00:DB7A            _rand:
  409  00:DB7A  20 99 C7            jsr   rand
  410                             __ldw   <_dx
                0000              .if (1 = 2)
                                  .else
       00:DB7D  A6 FE              ldx    <_dx
       00:DB7F  A5 FF              lda    <_dx+1
                                  .endif
  411  00:DB81  60                  rts
  412                     
  413                     
  414                     ; random(char limit)
  415                     ; --- 
  416                     ; get a random number where 0 <= n < limit
  417                     ; (and limit < 128)
  418                     
  419  00:DB82            _random:
  420  00:DB82  22                  sax
  421  00:DB83  29 7F               and   #$7f
  422  00:DB85  20 10 C8            jsr   random
  423  00:DB88  22                  sax
  424  00:DB89  62                  cla
  425  00:DB8A  60                  rts
  426                     
#[2]   startup.asm
 1221                            .endif   ; HUC
 1222                     
 1223           0001             .ifdef SUPPORT_MOUSE
#[3]   mouse.asm
 1224                             .include "mouse.asm"
    1                     ;- The mouse is read 4 successive times, in order to assemble the mouse data
    2                     ;(horiz most-significant-nybble/horiz LSN/vert MSN/vert LSN).
    3                     ;- values are deltas, and reading the mouse every VSYNC is normal
    4                     ;- For vertical movement, up is positive, down is negative
    5                     ;- For horizontal movement, left is positive, right is negative
    6                     ;- I was not able to yield a delta value greater than 0x25 (hexadecimal)
    7                     ;during a 1-VSYNC interval  (I didn't try all *that* hard though).  This
    8                     ;should give you an idea of the sensitivity.
    9                     
   10                     ;
   11                     ;  PCE mouse driver source
   12                     ;
   13                     
   14           29BA              .bss
   15  --:29BA            msflag: .ds 1
   16  --:29BB            msvert: .ds 1
   17  --:29BC            mshorz: .ds 1
   18                     
   19           DB8B              .code
   20                     
   21                     ;
   22                     ; These stub interfaces are available from LIB1_BANK
   23                     ; But the real guts are in LIB2_BANK
   24                     ;
   25  00:DB8B            mousinit:
   26                             maplibfunc      lib2_mousinit
       00:DB8B  A8                 tay
       00:DB8C  43 20              tma  #page(lib2_mousinit)
       00:DB8E  48                 pha
       00:DB8F  A9 81              lda  #bank(lib2_mousinit)
       00:DB91  53 20              tam  #page(lib2_mousinit)
       00:DB93  98                 tya
       00:DB94  20 A8 B3           jsr  lib2_mousinit
       00:DB97  A8                 tay
       00:DB98  68                 pla
       00:DB99  53 20              tam  #page(lib2_mousinit)
       00:DB9B  98                 tya
   27  00:DB9C  60                rts
   28                     
   29  00:DB9D            mousread:
   30                             maplibfunc      lib2_mousread
       00:DB9D  A8                 tay
       00:DB9E  43 20              tma  #page(lib2_mousread)
       00:DBA0  48                 pha
       00:DBA1  A9 81              lda  #bank(lib2_mousread)
       00:DBA3  53 20              tam  #page(lib2_mousread)
       00:DBA5  98                 tya
       00:DBA6  20 37 B4           jsr  lib2_mousread
       00:DBA9  A8                 tay
       00:DBAA  68                 pla
       00:DBAB  53 20              tam  #page(lib2_mousread)
       00:DBAD  98                 tya
   31  00:DBAE  60                rts
   32                     
   33                     
   34                     ;
   35                     ; These functions are available in bank 2 of the
   36                     ; library:
   37                     ;
   38           0001              .bank   LIB2_BANK
   39                     
   40                     ;
   41                     ; detect and initialize the mouse
   42                     ;
   43  01:B3A8            lib2_mousinit:
   44  01:B3A8  A9 20             lda   #$20      ; reset resource-usage flag
   45  01:B3AA  04 F5             tsb   <irq_m    ; to skip joystick read portion of vsync
   46                     
   47  01:B3AC  9C 28 22          stz   joy       ; clear joypad memory area
   48  01:B3AF  73 28 22          tii   joy, joy+1, $4
       01:B3B2  29 22 04  
       01:B3B5  00        
   49                     
   50  01:B3B6  9C 2D 22          stz   joytrg    ; clear joypad memory area
   51  01:B3B9  73 2D 22          tii   joytrg, joytrg+1, $4
       01:B3BC  2E 22 04  
       01:B3BF  00        
   52                     
   53  01:B3C0  9C 32 22          stz   joyold    ; clear joypad memory area
   54  01:B3C3  73 32 22          tii   joyold, joyold+1, $4
       01:B3C6  33 22 04  
       01:B3C9  00        
   55                     
   56  01:B3CA  9C 81 26          stz   joybuf    ; clear joypad memory area
   57  01:B3CD  73 81 26          tii   joybuf, joybuf+1, $4
       01:B3D0  82 26 04  
       01:B3D3  00        
   58                     
   59  01:B3D4  9C 93 26          stz   joy6      ; clear joypad memory area
   60  01:B3D7  73 93 26          tii   joy6, joy6+1, $4
       01:B3DA  94 26 04  
       01:B3DD  00        
   61                     
   62  01:B3DE  9C 98 26          stz   joytrg6   ; clear joypad memory area
   63  01:B3E1  73 98 26          tii   joytrg6, joytrg6+1, $4
       01:B3E4  99 26 04  
       01:B3E7  00        
   64                     
   65  01:B3E8  9C 9D 26          stz   joyold6   ; clear joypad memory area
   66  01:B3EB  73 9D 26          tii   joyold6, joyold6+1, $4
       01:B3EE  9E 26 04  
       01:B3F1  00        
   67                     
   68  01:B3F2  9C A2 26          stz   joybuf6   ; clear joypad memory area
   69  01:B3F5  73 A2 26          tii   joybuf6, joybuf6+1, $4
       01:B3F8  A3 26 04  
       01:B3FB  00        
   70                     
   71  01:B3FC  9C BB 29          stz   msvert
   72  01:B3FF  9C BC 29          stz   mshorz
   73  01:B402  9C BA 29          stz   msflag
   74                     
   75  01:B405  62                cla             ; counter of 'good' reads (where vertical == 0)
   76  01:B406  A2 0A             ldx   #$0A      ; try 10 iterations
   77  01:B408  48        .loop1: pha
   78  01:B409  DA                phx
   79  01:B40A  A9 01             lda   #1
   80                     ;       jsr   wait_vsync        ; wait for 1 vsync frame
   81  01:B40C  20 37 B4          jsr   lib2_mousread     ; read mouse
   82  01:B40F  FA                plx
   83  01:B410  68                pla
   84  01:B411  AC BB 29          ldy   msvert    ; read mouse vertical axis movement
   85  01:B414  D0 01             bne   .l1       ; if (val == 0), inc counter
   86  01:B416  1A                inc   a
   87  01:B417  CA        .l1:    dex
   88  01:B418  D0 EE             bne   .loop1    ; next iteration
   89                     
   90  01:B41A  C9 00             cmp   #$00      ; if #$00 value found even once (out of 10 times)
   91  01:B41C  D0 0F             bne   .mous     ; then return(1)
   92                     
   93  01:B41E  A9 20             lda   #$20      ; reset #$20 bit of $F5
   94  01:B420  14 F5             trb   <irq_m
   95  01:B422  62                cla             ; bad return code
   96  01:B423  8D BA 29          sta   msflag
   97  01:B426  9C BB 29          stz   msvert
   98  01:B429  9C BC 29          stz   mshorz
   99  01:B42C  60                rts
  100                     
  101  01:B42D            .mous:
  102  01:B42D  A9 20             lda   #$20      ; reset #$20 bit of $F5
  103  01:B42F  14 F5             trb   <irq_m
  104  01:B431  A9 01             lda   #$01      ; good return code
  105  01:B433  8D BA 29          sta   msflag
  106  01:B436  60                rts
  107                     
  108                     ;
  109                     ; actual mechanics of reading mouse
  110                     ;
  111  01:B437            lib2_mousread:
  112  01:B437  A2 04             ldx   #$04      ; # iterations (actually 5)
  113  01:B439  BD 28 22  .loop1: lda   joy,X     ; copy 'current' value to 'previous' value
  114  01:B43C  9D 32 22          sta   joyold,X
  115  01:B43F  CA                dex
  116  01:B440  10 F7             bpl  .loop1
  117                     
  118  01:B442  9C 28 22          stz   joy       ; initialize joypad #1's value
  119                     
  120  01:B445  A9 01             lda   #$01      ; reset joypad port# to joystick #1
  121  01:B447  8D 00 10          sta   joyport
  122  01:B44A  A9 03             lda   #$03
  123  01:B44C  8D 00 10          sta   joyport
  124  01:B44F  A9 01             lda   #$01
  125  01:B451  8D 00 10          sta   joyport
  126                     
  127  01:B454  20 CC B4          jsr   delay240  ; delay 240 CPU cycles
  128                     
  129  01:B457  AD 00 10          lda   joyport   ; read joystick port
  130  01:B45A  0A                asl   a ; upper nybble of 8-bit value - shift it
  131  01:B45B  0A                asl   a
  132  01:B45C  0A                asl   a
  133  01:B45D  0A                asl   a
  134  01:B45E  8D BC 29          sta   mshorz    ; store it
  135  01:B461  20 D9 B4          jsr   msbutt    ; read buttons (toggle port/read other nybble)
  136                     
  137  01:B464  A9 01             lda   #$01      ; reset joystick port again (to stick #1)
  138  01:B466  8D 00 10          sta   joyport
  139  01:B469  A9 03             lda   #$03
  140  01:B46B  8D 00 10          sta   joyport
  141  01:B46E  A9 01             lda   #$01
  142  01:B470  8D 00 10          sta   joyport
  143                     
  144  01:B473  20 D8 B4          jsr   delay14   ; wait 14 cycles to settle (reference code says 9)
  145                     
  146  01:B476  AD 00 10          lda   joyport   ; read port
  147  01:B479  29 0F             and   #$0F      ; lower nybble of 8-bit value
  148  01:B47B  0C BC 29          tsb   mshorz    ; 'or' it into memory
  149  01:B47E  44 59             bsr   msbutt    ; read buttons (toggle port/read other nybble)
  150                     
  151  01:B480  A9 01             lda   #$01      ; reset joystick port again
  152  01:B482  8D 00 10          sta   joyport
  153  01:B485  A9 03             lda   #$03
  154  01:B487  8D 00 10          sta   joyport
  155  01:B48A  A9 01             lda   #$01
  156  01:B48C  8D 00 10          sta   joyport
  157                     
  158  01:B48F  20 D8 B4          jsr   delay14   ; wait 14 cycles to settle (reference code says 9)
  159                     
  160  01:B492  AD 00 10          lda   joyport   ; read port
  161  01:B495  0A                asl   a ; upper nybble of 8-bit value - shift it
  162  01:B496  0A                asl   a
  163  01:B497  0A                asl   a
  164  01:B498  0A                asl   a
  165  01:B499  8D BB 29          sta   msvert
  166  01:B49C  44 3B             bsr   msbutt    ; read buttons (toggle port/read other nybble)
  167                     
  168  01:B49E  A9 01             lda   #$01      ; reset joystick port again
  169  01:B4A0  8D 00 10          sta   joyport
  170  01:B4A3  A9 03             lda   #$03
  171  01:B4A5  8D 00 10          sta   joyport
  172  01:B4A8  A9 01             lda   #$01
  173  01:B4AA  8D 00 10          sta   joyport
  174                     
  175  01:B4AD  20 D8 B4          jsr   delay14   ; wait 14 cycles to settle (reference code says 9)
  176                     
  177  01:B4B0  AD 00 10          lda   joyport   ; read port
  178  01:B4B3  29 0F             and   #$0F      ; lower nybble of 8-bit value
  179  01:B4B5  0C BB 29          tsb   msvert    ; 'or' it into value
  180  01:B4B8  44 1F             bsr   msbutt    ; read buttons (toggle port/read other nybble)
  181                     
  182  01:B4BA  AD 2D 22          lda   joytrg    ; check joystick buttons
  183  01:B4BD  C9 04             cmp   #$04      ; is 'select' newly-pressed ?
  184  01:B4BF  D0 0A             bne  .exit
  185  01:B4C1  AD 28 22          lda   joy       ; if so, are both run & select pressed ?
  186  01:B4C4  C9 0C             cmp   #$0C
  187  01:B4C6  D0 03             bne  .exit
  188  01:B4C8  6C 84 22          jmp   [soft_reset]      ; if yes, reboot
  189  01:B4CB  60        .exit:  rts             ; else return
  190                     
  191  01:B4CC            delay240:
  192  01:B4CC  48                pha             ; delay loop for 240 processor cycles
  193  01:B4CD  DA                phx             ; (including call/return overhead)
  194  01:B4CE  62                cla
  195  01:B4CF  EA                nop
  196  01:B4D0  EA        .lp:    nop
  197  01:B4D1  1A                inc     a
  198  01:B4D2  C9 15             cmp     #21
  199  01:B4D4  90 FA             bcc     .lp
  200  01:B4D6  FA                plx
  201  01:B4D7  68                pla
  202  01:B4D8            delay14:
  203  01:B4D8  60                rts
  204                     
  205  01:B4D9            msbutt:
  206  01:B4D9  9C 00 10          stz   joyport   ; toggle joystick port to read buttons
  207                     
  208  01:B4DC  20 D8 B4          jsr   delay14   ; wait 14 cycles to settle (reference code says 9)
  209                     
  210  01:B4DF  AD 00 10          lda   joyport   ; read value
  211  01:B4E2  49 FF             eor   #$FF      ; change low-active to high-active
  212  01:B4E4  29 0F             and   #$0F      ; only 4 bits
  213  01:B4E6  0C 28 22          tsb   joy       ; 'or' it into value
  214                     
  215  01:B4E9  0D 32 22          ora   joyold    ; determine 'newly-pressed' buttons
  216  01:B4EC  4D 32 22          eor   joyold
  217  01:B4EF  8D 2D 22          sta   joytrg    ; put them into 'delta'
  218  01:B4F2  60                rts
  219                     
  220           0000              .bank   LIB1_BANK       ; restore bank-context
  221                     
  222                     
#[2]   startup.asm
 1225                            .endif   ; SUPPORT_MOUSE
 1226                     
 1227           0001             .if (CDROM)
#[3]   cdrom.asm
 1228                             .include "cdrom.asm"
    1                     ;
    2                     ;  PCE CDROM access routines' sources
    3                     ;
    4                     
#[4]   cdrom.inc
    5                             .include "cdrom.inc"
    1                     ;
    2                     ; CDROM.INC  -  MagicKit CDROM Equates
    3                     ;
    4                     
    5                     ;
    6                     ; Standard parameters for  CDROM system functions
    7                     ;
    8                     
    9                     ; These attributes are used for CD_PLAY:
   10                     
   11           0000      CD_SECTOR =     %00000000
   12           0040      CD_MSF =        %01000000
   13           0080      CD_TRACK =      %10000000
   14           00C0      CD_CURRPOS =    %11000000
   15           00C0      CD_LEADOUT =    %11000000
   16           003F      CD_PLAYMODE =   %00111111
   17                     
   18           0000      CDPLAY_MUTE =   0
   19           0001      CDPLAY_REPEAT = 1
   20           0002      CDPLAY_NORMAL = 2
   21           0000      CDPLAY_ENDOFDISC = 0
   22                     
   23           0000      CDFADE_CANCEL = 0
   24           0008      CDFADE_PCM6 =    8
   25           000A      CDFADE_ADPCM6 =  10
   26           000C      CDFADE_PCM2 =    12
   27           000E      CDFADE_ADPCM2 =  14
   28                     
   29           0000      CDTRK_AUDIO =   0
   30           0004      CDTRK_DATA =    4
   31                     
   32           0001      GRP_FILL = 1
   33           0000      GRP_NOFILL = 0
#[3]   cdrom.asm
    6                     
    7           29BD              .bss
    8                     
    9  --:29BD            cdplay_end_ctl  .ds  1 ; saved 'cd_play end' information - type
   10  --:29BE            cdplay_end_h    .ds  1 ; high byte of address
   11  --:29BF            cdplay_end_m    .ds  1 ; mid byte
   12  --:29C0            cdplay_end_l    .ds  1 ; low byte
   13  --:29C1            cd_buf          .ds  4 ; Return buffer from some BIOS commands
   14                     
   15           DBAF              .code
   16                     
   17                     ;
   18                     ; cd_reset(void)
   19                     ; ----
   20                     ; Reset CDROM
   21                     ; ----
   22                     ;
   23  00:DBAF  20 03 E0  _cd_reset:      jsr     cd_reset
   24  00:DBB2  60                        rts
   25                     
   26                     ;
   27                     ; cd_pause(void)
   28                     ; ----
   29                     ; Pause CDROM drive
   30                     ; ----
   31                     ;
   32  00:DBB3  20 18 E0  _cd_pause:      jsr     cd_pause
   33  00:DBB6  AA                        tax
   34  00:DBB7  62                        cla
   35  00:DBB8  60                        rts
   36                     
   37                     
   38                     ;
   39                     ; cd_unpause(void)
   40                     ; ----
   41                     ; Continue playing CDROM audio after pause
   42                     ; ----
   43                     ;
   44  00:DBB9  AD BD 29  _cd_unpause:    lda     cdplay_end_ctl
   45  00:DBBC  85 FF                     sta     <_dh
   46  00:DBBE  AD BE 29                  lda     cdplay_end_h
   47  00:DBC1  85 FC                     sta     <_cl
   48  00:DBC3  AD BF 29                  lda     cdplay_end_m
   49  00:DBC6  85 FD                     sta     <_ch
   50  00:DBC8  AD C0 29                  lda     cdplay_end_l
   51  00:DBCB  85 FE                     sta     <_dl
   52  00:DBCD  A9 C0                     lda     #CD_CURRPOS
   53  00:DBCF  85 FB                     sta     <_bh
   54  00:DBD1  20 12 E0                  jsr     cd_play
   55  00:DBD4  AA                        tax
   56  00:DBD5  62                        cla
   57  00:DBD6  60                        rts
   58                     
   59                     ;
   60                     ; cd_fade(char type)
   61                     ;
   62                     ;   type = $00 -> cancel fade
   63                     ;          $08 -> PCM fadeout 6 seconds
   64                     ;          $0A -> ADPCM fadeout 6 seconds
   65                     ;          $0C -> PCM fadeout 2.5 seconds
   66                     ;          $0E -> ADPCM fadeout 2.5 seconds
   67                     ; ----
   68                     ; Fade-out PCM/ADPCM audio
   69                     ; ----
   70                     ;
   71  00:DBD7  8A        _cd_fade:       txa
   72  00:DBD8  20 2D E0                  jsr     cd_fade
   73  00:DBDB  AA                        tax
   74  00:DBDC  62                        cla
   75  00:DBDD  60                        rts
   76                     
   77                     
   78                     ;
   79                     ; cd_playtrk(int start_track [bx], int end_track [cx], int mode [acc])
   80                     ;   mode = CDPLAY_MUTE / CDPLAY_REPEAT / CDPLAY_NORMAL
   81                     ; ----
   82                     ; Play CDROM audio track
   83                     ; ----
   84                     ;
   85  00:DBDE  8A        _cd_playtrk.3:  txa
   86  00:DBDF  29 3F                     and     #CD_PLAYMODE
   87  00:DBE1  09 80                     ora     #CD_TRACK
   88  00:DBE3  85 FF                     sta     <_dh            ; end type + play mode
   89  00:DBE5  8D BD 29                  sta     cdplay_end_ctl
   90  00:DBE8  A9 80                     lda     #CD_TRACK
   91  00:DBEA  85 FB                     sta     <_bh            ; start type
   92                                     
   93  00:DBEC  A5 FC                     lda     <_cl
   94  00:DBEE  D0 0B                     bne     .endtrk
   95                     
   96  00:DBF0  A5 FF     .endofdisc:     lda     <_dh            ; repeat to end of disc
   97  00:DBF2  09 C0                     ora     #CD_LEADOUT
   98  00:DBF4  85 FF                     sta     <_dh
   99  00:DBF6  8D BD 29                  sta     cdplay_end_ctl
  100  00:DBF9  80 12                     bra     .starttrk
  101                     
  102  00:DBFB  20 B4 E0  .endtrk:        jsr     ex_binbcd
  103  00:DBFE  85 FC                     sta     <_cl            ; end track
  104  00:DC00  8D BE 29                  sta     cdplay_end_h
  105  00:DC03  64 FD                     stz     <_ch
  106  00:DC05  9C BF 29                  stz     cdplay_end_m
  107  00:DC08  64 FE                     stz     <_dl
  108  00:DC0A  9C C0 29                  stz     cdplay_end_l
  109                     
  110  00:DC0D  A5 FA     .starttrk:      lda     <_bl            ; track #
  111  00:DC0F  20 B4 E0                  jsr     ex_binbcd
  112  00:DC12  85 F8                     sta     <_al            ; from track
  113  00:DC14  64 F9                     stz     <_ah
  114  00:DC16  64 FA                     stz     <_bl
  115  00:DC18  20 12 E0                  jsr     cd_play
  116  00:DC1B  AA                        tax
  117  00:DC1C  62                        cla
  118  00:DC1D  60                        rts
  119                     
  120                     
  121                     ;
  122                     ; cd_playmsf(int start_minute [al], int start_second [ah], int start_frame [bl],
  123                     ;            int end_minute [cl], int end_second [ch], int end_frame [dl], int mode [acc])
  124                     ;   mode = CDPLAY_MUTE / CDPLAY_REPEAT / CDPLAY_NORMAL
  125                     ; ----
  126                     ; Play CDROM from/to 'minute/second/frame'
  127                     ; ----
  128                     ;
  129  00:DC1E  8A        _cd_playmsf.7:  txa
  130  00:DC1F  29 3F                     and     #CD_PLAYMODE
  131  00:DC21  09 40                     ora     #CD_MSF
  132  00:DC23  85 FF                     sta     <_dh            ; end type + play mode
  133  00:DC25  8D BD 29                  sta     cdplay_end_ctl
  134  00:DC28  A9 40                     lda     #CD_MSF
  135  00:DC2A  85 FB                     sta     <_bh            ; start type
  136                                     
  137  00:DC2C  A5 FE     .endmsf:        lda     <_dl            ; end frame
  138  00:DC2E  20 B4 E0                  jsr     ex_binbcd
  139  00:DC31  85 FE                     sta     <_dl
  140  00:DC33  8D C0 29                  sta     cdplay_end_l
  141                     
  142  00:DC36  A5 FD                     lda     <_ch            ; end second
  143  00:DC38  20 B4 E0                  jsr     ex_binbcd
  144  00:DC3B  85 FD                     sta     <_ch
  145  00:DC3D  8D BF 29                  sta     cdplay_end_m
  146                     
  147  00:DC40  A5 FC                     lda     <_cl            ; end minute
  148  00:DC42  20 B4 E0                  jsr     ex_binbcd
  149  00:DC45  85 FC                     sta     <_cl
  150  00:DC47  8D BE 29                  sta     cdplay_end_h
  151                     
  152  00:DC4A            .startmsf:
  153  00:DC4A  A5 FA                     lda     <_bl            ; start frame
  154  00:DC4C  20 B4 E0                  jsr     ex_binbcd
  155  00:DC4F  85 FA                     sta     <_bl
  156                     
  157  00:DC51  A5 F9                     lda     <_ah            ; start second
  158  00:DC53  20 B4 E0                  jsr     ex_binbcd
  159  00:DC56  85 F9                     sta     <_ah
  160                     
  161  00:DC58  A5 F8                     lda     <_al            ; start minute
  162  00:DC5A  20 B4 E0                  jsr     ex_binbcd
  163  00:DC5D  85 F8                     sta     <_al
  164                     
  165  00:DC5F  20 12 E0                  jsr     cd_play
  166  00:DC62  AA                        tax
  167  00:DC63  62                        cla
  168  00:DC64  60                        rts
  169                     
  170                     ;
  171                     ; char cd_numtrk(void)
  172                     ; ----
  173                     ; return number of tracks on CDROM
  174                     ; ----
  175                     ;
  176                     _cd_numtrk:     stw     #cd_buf,<_bx
       00:DC65  A9 C1              lda    LOW_BYTE #cd_buf
       00:DC67  85 FA              sta    LOW_BYTE <_bx
       00:DC69  A9 29              lda    HIGH_BYTE #cd_buf
       00:DC6B  85 FB              sta    HIGH_BYTE <_bx
  177  00:DC6D  64 F8                     stz     <_al            ; request type 0
  178  00:DC6F  20 21 E0                  jsr     cd_dinfo
  179  00:DC72  C9 00                     cmp     #$00
  180  00:DC74  D0 09                     bne     .err
  181  00:DC76  AD C2 29                  lda     cd_buf+1
  182  00:DC79  20 B7 E0                  jsr     ex_bcdbin
  183  00:DC7C  82                        clx
  184  00:DC7D  22                        sax
  185  00:DC7E  60                        rts
  186  00:DC7F  A9 FF     .err:           lda     #$ff
  187  00:DC81  AA                        tax
  188  00:DC82  60                        rts
  189                     
  190                     ;
  191                     ; char cd_trkinfo(char track [ax], char *min [cx], char *sec [dx], char *frm [bp])
  192                     ; ----
  193                     ; Return information about track
  194                     ; ----
  195                     ;
  196  00:DC83            _cd_trkinfo.4:
  197                                   __ldw     <_ax
                0000              .if (1 = 2)
                                  .else
       00:DC83  A6 F8              ldx    <_ax
       00:DC85  A5 F9              lda    <_ax+1
                                  .endif
  198  00:DC87  20 A5 DC                  jsr     _cd_trktype
  199  00:DC8A  DA                        phx
  200  00:DC8B  AD C1 29                  lda     cd_buf
  201  00:DC8E  20 B7 E0                  jsr     ex_bcdbin
  202  00:DC91  92 FC                     sta     [_cx]
  203                     
  204  00:DC93  AD C2 29                  lda     cd_buf+1
  205  00:DC96  20 B7 E0                  jsr     ex_bcdbin
  206  00:DC99  92 FE                     sta     [_dx]
  207                     
  208  00:DC9B  AD C3 29                  lda     cd_buf+2
  209  00:DC9E  20 B7 E0                  jsr     ex_bcdbin
  210  00:DCA1  92 EC                     sta     [_bp]
  211                     
  212  00:DCA3  FA                        plx
  213  00:DCA4  60                        rts
  214                     
  215                     ;
  216                     ; char cd_trktype(char track)
  217                     ; ----
  218                     ; Return type of track (data/audio)
  219                     ; ----
  220                     ;
  221  00:DCA5  22        _cd_trktype:    sax
  222  00:DCA6  20 B4 E0                  jsr     ex_binbcd
  223  00:DCA9  85 F9                     sta     <_ah            ; track #
  224                                     stw     #cd_buf,<_bx
       00:DCAB  A9 C1              lda    LOW_BYTE #cd_buf
       00:DCAD  85 FA              sta    LOW_BYTE <_bx
       00:DCAF  A9 29              lda    HIGH_BYTE #cd_buf
       00:DCB1  85 FB              sta    HIGH_BYTE <_bx
  225  00:DCB3  C9 00                     cmp     #0
  226  00:DCB5  F0 04                     beq     .discnottrk
  227  00:DCB7  A9 02                     lda     #2
  228  00:DCB9  80 02                     bra     .go
  229  00:DCBB  A9 01     .discnottrk     lda     #1
  230  00:DCBD  85 F8     .go:            sta     <_al            ; request type 2
  231  00:DCBF  20 21 E0                  jsr     cd_dinfo
  232  00:DCC2  C9 00                     cmp     #$00
  233  00:DCC4  D0 05                     bne     .err
  234  00:DCC6  AE C4 29                  ldx     cd_buf+3        ; track type
  235  00:DCC9  62                        cla
  236  00:DCCA  60                        rts
  237  00:DCCB  A9 FF     .err:           lda     #$ff
  238  00:DCCD  AA                        tax
  239  00:DCCE  60                        rts
  240                     
  241                     ;
  242                     ; char cd_execoverlay(int ovl_index)
  243                     ; ----
  244                     ; Execute program overlay from disc
  245                     ; ----
  246                     ;
  247  00:DCCF            _cd_execoverlay:
  248  00:DCCF  20 E3 DC                  jsr     cd_overlay
  249  00:DCD2  C9 00                     cmp     #0
  250  00:DCD4  D0 03                     bne     .error
  251  00:DCD6  4C 00 C0                  jmp     $C000           ; loaded fine... now run it
  252  00:DCD9  48        .error:         pha
  253  00:DCDA  AE B1 26                  ldx     ovl_running     ; failed; reload old segment for error recovery
  254  00:DCDD  20 E3 DC                  jsr     cd_overlay
  255  00:DCE0  FA                        plx                     ; return error
  256  00:DCE1  62                        cla
  257  00:DCE2  60                        rts
  258                     
  259  00:DCE3            cd_overlay:
  260  00:DCE3  20 CB DD                  jsr     prep_rdsect
  261  00:DCE6  64 FC                     stz     <_cl    ; sector (offset from base of track)
  262  00:DCE8  85 FD                     sta     <_ch
  263  00:DCEA  86 FE                     stx     <_dl
  264  00:DCEC  C8                        iny
  265  00:DCED  B9 00 60                  lda     ovlarray,Y
  266  00:DCF0  85 F8                     sta     <_al    ; # sectors
  267  00:DCF2  43 40                     tma     #6
  268  00:DCF4  85 FA                     sta     <_bl    ; Bank #
  269  00:DCF6  A9 03                     lda     #3
  270  00:DCF8  85 FF                     sta     <_dh    ; MPR #
  271  00:DCFA  20 09 E0                  jsr     cd_read
  272  00:DCFD  60                        rts
  273                     
  274                     ;
  275                     ; char cd_loadvram(int ovl_index [di], int sect_offset [si], int vramaddr [bx], int bytes [acc])
  276                     ; ----
  277                     ; Load CDROM data directly into VRAM
  278                     ; ----
  279                     ;
  280  00:DCFE            _cd_loadvram.4:
  281                                   __stw     <_ax
       00:DCFE  86 F8              stx    <_ax
       00:DD00  85 F9              sta    <_ax+1
  282                                   __ldw     <_di
                0000              .if (1 = 2)
                                  .else
       00:DD02  A6 F0              ldx    <_di
       00:DD04  A5 F1              lda    <_di+1
                                  .endif
  283  00:DD06  20 CB DD                  jsr     prep_rdsect
  284                                   __addw    <_si
       00:DD09  18                 clc
       00:DD0A  22                 sax
       00:DD0B  65 EE              adc    <_si
       00:DD0D  22                 sax
       00:DD0E  65 EF              adc    <_si+1
  285  00:DD10  64 FC                     stz     <_cl
  286  00:DD12  85 FD                     sta     <_ch
  287  00:DD14  86 FE                     stx     <_dl
  288  00:DD16  A9 FE                     lda     #$FE
  289  00:DD18  85 FF                     sta     <_dh
  290  00:DD1A  20 09 E0                  jsr     cd_read
  291  00:DD1D  AA                        tax
  292  00:DD1E  62                        cla
  293  00:DD1F  60                        rts
  294                     ;
  295                     ; char cd_loaddata(int ovl_index [di], int sect_offset [si], farptr array [bl:bp], int bytes [acc])
  296                     ; ----
  297                     ; Load CDROM data directly into data area, replacing predefined data
  298                     ; ----
  299                     ;
  300           29C5              .bss
  301  --:29C5            cdtemp_l        .ds     1
  302  --:29C6            cdtemp_m        .ds     1
  303  --:29C7            cdtemp_bank     .ds     1
  304  --:29C8            cdtemp_savbnk60 .ds     1
  305  --:29C9            cdtemp_savbnk80 .ds     1
  306  --:29CA            cdtemp_addr     .ds     2
  307  --:29CC            cdtemp_bytes    .ds     2
  308           DD20              .code
  309                     
  310  00:DD20            _cd_loaddata.4:
  311                                   __stw     cdtemp_bytes
       00:DD20  8E CC 29           stx    cdtemp_bytes
       00:DD23  8D CD 29           sta    cdtemp_bytes+1
  312                                   __ldw     <_di
                0000              .if (1 = 2)
                                  .else
       00:DD26  A6 F0              ldx    <_di
       00:DD28  A5 F1              lda    <_di+1
                                  .endif
  313  00:DD2A  20 CB DD                  jsr     prep_rdsect
  314                                   __addw    <_si
       00:DD2D  18                 clc
       00:DD2E  22                 sax
       00:DD2F  65 EE              adc    <_si
       00:DD31  22                 sax
       00:DD32  65 EF              adc    <_si+1
  315  00:DD34  8E C5 29                  stx     cdtemp_l        ; calculate sector adddress
  316  00:DD37  8D C6 29                  sta     cdtemp_m
  317                     
  318  00:DD3A  43 08                     tma     #3              ; save entry banks
  319  00:DD3C  8D C8 29                  sta     cdtemp_savbnk60
  320  00:DD3F  43 10                     tma     #4
  321  00:DD41  8D C9 29                  sta     cdtemp_savbnk80
  322                     
  323  00:DD44  A5 FA                     lda     <_bl
  324  00:DD46  8D C7 29                  sta     cdtemp_bank     ; load addr (bank/address)
  325                                   __ldw     <_bp
                0000              .if (1 = 2)
                                  .else
       00:DD49  A6 EC              ldx    <_bp
       00:DD4B  A5 ED              lda    <_bp+1
                                  .endif
  326  00:DD4D  29 1F                     and     #$1f            ; correct to a $6000-relative addr.
  327  00:DD4F  09 60                     ora     #$60
  328                                   __stw     cdtemp_addr
       00:DD51  8E CA 29           stx    cdtemp_addr
       00:DD54  8D CB 29           sta    cdtemp_addr+1
  329                     
  330  00:DD57            .loop:
  331  00:DD57  AD C7 29                  lda     cdtemp_bank     ; get 2 adjacent banks just in case
  332  00:DD5A  53 08                     tam     #3
  333  00:DD5C  1A                        inc     A
  334  00:DD5D  53 10                     tam     #4
  335                     
  336                                   __ldw     cdtemp_addr     ; load address
                0000              .if (1 = 2)
                                  .else
       00:DD5F  AE CA 29           ldx    cdtemp_addr
       00:DD62  AD CB 29           lda    cdtemp_addr+1
                                  .endif
  337                                   __stw     <_bx
       00:DD65  86 FA              stx    <_bx
       00:DD67  85 FB              sta    <_bx+1
  338                     
  339  00:DD69  64 FC                     stz     <_cl            ; sector address
  340  00:DD6B  AD C6 29                  lda     cdtemp_m
  341  00:DD6E  85 FD                     sta     <_ch
  342  00:DD70  AD C5 29                  lda     cdtemp_l
  343  00:DD73  85 FE                     sta     <_dl
  344  00:DD75  64 FF                     stz     <_dh            ; address type (local, # bytes)
  345                     
  346                                   __ldw     cdtemp_bytes
                0000              .if (1 = 2)
                                  .else
       00:DD77  AE CC 29           ldx    cdtemp_bytes
       00:DD7A  AD CD 29           lda    cdtemp_bytes+1
                                  .endif
  347                                     sub     #$20
                0000              .if (1 = 2)            ; from register A (handle
                                  .else
       00:DD7D  38                 sec
       00:DD7E  E9 20              sbc    #$20
                                  .endif
  348  00:DD80  30 0C                     bmi     .less2000
  349                                   __stw     cdtemp_bytes
       00:DD82  8E CC 29           stx    cdtemp_bytes
       00:DD85  8D CD 29           sta    cdtemp_bytes+1
  350                                   __ldwi    $2000
       00:DD88  A2 00              ldx    #low($2000)
       00:DD8A  A9 20              lda    #high($2000)
  351  00:DD8C  80 09                     bra     .read
  352                     
  353                     .less2000:      add     #$20
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       00:DD8E  18                 clc
       00:DD8F  69 20              adc    #$20
                                  .endif
  354                                     stwz    cdtemp_bytes
       00:DD91  9C CC 29           stz    LOW_BYTE cdtemp_bytes
       00:DD94  9C CD 29           stz    HIGH_BYTE cdtemp_bytes
  355                     .read:        __stw     <_ax
       00:DD97  86 F8              stx    <_ax
       00:DD99  85 F9              sta    <_ax+1
  356                             
  357  00:DD9B  20 09 E0                  jsr     cd_read
  358  00:DD9E  C9 00                     cmp     #0
  359  00:DDA0  D0 1C                     bne     .error
  360                     
  361                                   __tstw    cdtemp_bytes    ; if still some bytes to read
                                   ; pha
       00:DDA2  86 03              stx    <__temp
       00:DDA4  05 03              ora    <__temp
                                   ; pla
  362  00:DDA6  F0 16                     beq     .error          ; but A = 0 so no error
  363                     
  364                                     addw    #4,cdtemp_l     ; add 4 sectors (with 16-bit carry)
                0000              .if     (2 = 3)
                                  .else
                                   ; 2-arg mode
                                   ;
       00:DDA8  18                 clc
       00:DDA9  AD C5 29           lda    LOW_BYTE cdtemp_l
       00:DDAC  69 04              adc    LOW_BYTE #4
       00:DDAE  8D C5 29           sta    LOW_BYTE cdtemp_l
       00:DDB1  AD C6 29           lda    HIGH_BYTE cdtemp_l
       00:DDB4  69 00              adc    HIGH_BYTE #4
       00:DDB6  8D C6 29           sta    HIGH_BYTE cdtemp_l
                                  .endif
  365  00:DDB9  EE C7 29                  inc     cdtemp_bank     ; go back for next bank
  366  00:DDBC  80 99                     bra     .loop
  367                     
  368  00:DDBE  AA        .error:         tax
  369  00:DDBF  AD C8 29                  lda     cdtemp_savbnk60
  370  00:DDC2  53 08                     tam     #3
  371  00:DDC4  AD C9 29                  lda     cdtemp_savbnk80
  372  00:DDC7  53 10                     tam     #4
  373  00:DDC9  62                        cla
  374  00:DDCA  60                        rts
  375                     
  376                     ;
  377                     ; prepare the sector address
  378                     ;
  379  00:DDCB  8A        prep_rdsect:    txa
  380  00:DDCC  0A                        asl     A
  381  00:DDCD  0A                        asl     A
  382  00:DDCE  A8                        tay
  383                                     map     ovlarray        ; in DATA_BANK
       00:DDCF  A9 83              lda   #bank(ovlarray)        ; addressable memory
       00:DDD1  53 08              tam   #page(ovlarray)
  384  00:DDD3  BE 00 60                  ldx     ovlarray,Y
  385  00:DDD6  C8                        iny
  386  00:DDD7  B9 00 60                  lda     ovlarray,Y
  387  00:DDDA  60                        rts
  388                     
  389                     ;--------------------
  390                     ; NOT IMPLEMENTED YET
  391                     ;--------------------
  392                     ;
  393                     ;
  394                     ; cd_status()
  395                     ; ----
  396                     ; Get CDROM status
  397                     ;
  398                     ;   input $00     (= busy check)  -> return $00 if not busy, else busy
  399                     ;         (other) (= ready check) -> return $00 if ready, else sub error code
  400                     ; ----
  401                     ;
  402  00:DDDB            _cd_status:
  403  00:DDDB  8A                        txa
  404  00:DDDC  20 1B E0                  jsr     cd_stat
  405  00:DDDF  AA                        tax
  406  00:DDE0  62                        cla
  407  00:DDE1  60                        rts
  408                     
  409                     
  410                     ;--------------------
  411                     
  412                     
  413                     ;
  414                     ; int cd_getver()
  415                     ; ----
  416                     ; get CDROM system card version number
  417                     ; MSB = major number
  418                     ; LSB = minor number
  419                     ; ----
  420                     ;
  421  00:DDE2            _cd_getver:
  422  00:DDE2  20 5A E0                  jsr     ex_getver
  423  00:DDE5  98                        tya
  424  00:DDE6  22                        sax
  425  00:DDE7  60                        rts
  426                     
  427                     
  428                     ;
  429                     ; int ac_exists(void)
  430                     ; ----
  431                     ; Detect Arcade Card (return 1 if true)
  432                     ; ----
  433                     ;
  434  00:DDE8  AD FF 1A  _ac_exists:     lda     ac_identflag
  435  00:DDEB  A2 01                     ldx     #1
  436  00:DDED  C9 51                     cmp     #AC_IDENT
  437  00:DDEF  F0 01                     beq     .true
  438  00:DDF1  82                        clx
  439  00:DDF2  62        .true:          cla
  440  00:DDF3  60                        rts
  441                     
  442                     ;
  443                     ; ad_reset(void)
  444                     ; ----
  445                     ; Reset ADPCM device
  446                     ; ----
  447                     ;
  448  00:DDF4  20 30 E0  _ad_reset:      jsr     ad_reset
  449  00:DDF7  60                        rts
  450                     
  451                     ;
  452                     ; ad_stop(void)
  453                     ; ----
  454                     ; stop ADPCM playing
  455                     ; ----
  456                     ;
  457  00:DDF8  20 42 E0  _ad_stop:       jsr     ad_stop
  458  00:DDFB  60                        rts
  459                     
  460                     ;
  461                     ; char ad_stat(void)
  462                     ; ----
  463                     ; Get ADPCM status
  464                     ; ----
  465                     ;
  466  00:DDFC  20 45 E0  _ad_stat:       jsr     ad_stat
  467  00:DDFF  AA                        tax
  468  00:DE00  62                        cla
  469  00:DE01  60                        rts
  470                     
  471                     ;
  472                     ; char ad_trans(int ovl_index [di], int sect_offset [si], char nb_sectors [al], int ad_addr [bx])
  473                     ; ----
  474                     ; Load CDROM data directly into ADPCM RAM
  475                     ; ----
  476                     ;
  477  00:DE02            _ad_trans.4:
  478                                   __ldw     <_di
                0000              .if (1 = 2)
                                  .else
       00:DE02  A6 F0              ldx    <_di
       00:DE04  A5 F1              lda    <_di+1
                                  .endif
  479  00:DE06  20 CB DD                  jsr     prep_rdsect
  480                                   __addw    <_si
       00:DE09  18                 clc
       00:DE0A  22                 sax
       00:DE0B  65 EE              adc    <_si
       00:DE0D  22                 sax
       00:DE0E  65 EF              adc    <_si+1
  481  00:DE10  64 FC                     stz     <_cl
  482  00:DE12  85 FD                     sta     <_ch
  483  00:DE14  86 FE                     stx     <_dl
  484  00:DE16  64 FF                     stz     <_dh
  485  00:DE18  20 33 E0                  jsr     ad_trans
  486  00:DE1B  AA                        tax
  487  00:DE1C  62                        cla
  488  00:DE1D  60                        rts
  489                     
  490                     ;
  491                     ; char ad_read(int ad_addr [cx], char mode [dh], int buf [bx], int bytes [ax])
  492                     ; ----
  493                     ; copy data from ADPCM RAM directly to RAM or VRAM
  494                     ; ----
  495                     ;
  496  00:DE1E            _ad_read.4:
  497  00:DE1E  20 36 E0                  jsr     ad_read
  498  00:DE21  AA                        tax
  499  00:DE22  62                        cla
  500  00:DE23  60                        rts
  501                     
  502                     ;
  503                     ; char ad_write(int ad_addr [cx], char mode [dh], int buf [bx], int bytes [ax])
  504                     ; ----
  505                     ; copy data from RAM or VRAM directly to ADPCM VRAM
  506                     ; ----
  507                     ;
  508  00:DE24            _ad_write.4:
  509  00:DE24  20 39 E0                  jsr     ad_write
  510  00:DE27  AA                        tax
  511  00:DE28  62                        cla
  512  00:DE29  60                        rts
  513                     
  514                     ;
  515                     ; char ad_play(int ad_addr [bx], int bytes [ax], char freq [dh], char mode [dl])
  516                     ; ----
  517                     ; play ADPCM sample
  518                     ; ----
  519                     ;
  520  00:DE2A            _ad_play.4:
  521  00:DE2A  20 3C E0                  jsr     ad_play
  522  00:DE2D  AA                        tax
  523  00:DE2E  62                        cla
  524  00:DE2F  60                        rts
#[2]   startup.asm
 1229                            .else
 1231                            .endif   ; CDROM
 1232                     
 1233                     ; ----
 1234                     ; disp_on
 1235                     ; ----
 1236                     ; enable display
 1237                     ; ----
 1238                     
 1239           0001             .ifdef HUC
 1240  00:DE30            _disp_on:
 1241  00:DE30  AE 8E 26          ldx   disp_cr
 1242  00:DE33  A9 01             lda   #1
 1243  00:DE35  8D 8E 26          sta   disp_cr
 1244  00:DE38  62                cla
 1245  00:DE39  60                rts
 1246                            .else
 1251                            .endif   ; HUC
 1252                     
 1253                     ; ----
 1254                     ; disp_off
 1255                     ; ----
 1256                     ; disable display
 1257                     ; ----
 1258                     
 1259           0001             .ifdef HUC
 1260  00:DE3A            _disp_off:
 1261  00:DE3A  AE 8E 26          ldx   disp_cr
 1262  00:DE3D  9C 8E 26          stz   disp_cr
 1263  00:DE40  62                cla
 1264  00:DE41  60                rts
 1265                            .else
 1269                            .endif   ; HUC
 1270                     
 1271                     ; ----
 1272                     ; set_intvec
 1273                     ; ----
 1274                     ; set interrupt vector
 1275                     ; ----
 1276                     ; IN : A = vector number
 1277                     ;           0 IRQ2
 1278                     ;           1 IRQ1 (VDC)
 1279                     ;           2 TIMER
 1280                     ;           3 NMI
 1281                     ;           4 VSYNC
 1282                     ;           5 HSYNC
 1283                     ;           6 SOFT RESET (RUN + SELECT)
 1284                     ;      X = vector address low byte
 1285                     ;      Y =   "      "    high byte
 1286                     ; ----
 1287                     
 1288           0000             .if  !(CDROM)
 1312                            .endif   ; !(CDROM)
 1313                     
 1314                     ; ----
 1315                     ; wait_vsync
 1316                     ; ----
 1317                     ; wait the next vsync
 1318                     ; ----
 1319                     ; IN :  A = number of frames to be sync'ed on
 1320                     ; ----
 1321                     ; OUT:  A = number of elapsed frames since last call
 1322                     ; ----
 1323                     
 1324  00:DE42            wait_vsync:
 1325  00:DE42  1F F5 03          bbr1 <irq_m,.l1
 1326  00:DE45  62                cla                     ; return immediately if IRQ1 is redirected
 1327           0001             .ifdef HUC
 1328  00:DE46  82                clx
 1329                            .endif
 1330  00:DE47  60                rts
 1331                     
 1332  00:DE48  78        .l1:    sei                     ; disable interrupts
 1333  00:DE49  CD 41 22          cmp   irq_cnt           ; calculate how many frames to wait
 1334  00:DE4C  F0 05             beq  .l2
 1335                             bhs  .l3
       00:DE4E  B0 04              bcs    .l3
 1336  00:DE50  AD 41 22          lda   irq_cnt
 1337  00:DE53  1A        .l2:    inc   A
 1338                     .l3:    sub   irq_cnt
                0000              .if (1 = 2)            ; from register A (handle
                                  .else
       00:DE54  38                 sec
       00:DE55  ED 41 22           sbc    irq_cnt
                                  .endif
 1339  00:DE58  8D 80 26          sta   vsync_cnt
 1340  00:DE5B  58                cli                     ; re-enable interrupts
 1341                     
 1342  00:DE5C  AD 41 22  .l4:    lda   irq_cnt           ; wait loop
 1343                     .l5:    incw  _rndseed
       00:DE5F  EE 79 27           inc    _rndseed              ; value at stated memory
       00:DE62  D0 03              bne    .x_00622           ; location
       00:DE64  EE 7A 27           inc    _rndseed+1
       00:DE67            .x_00622:
 1344  00:DE67  CD 41 22          cmp   irq_cnt
 1345  00:DE6A  F0 F3             beq  .l5
 1346  00:DE6C  CE 80 26          dec   vsync_cnt
 1347  00:DE6F  D0 EB             bne  .l4
 1348                     
 1349  00:DE71  9C 41 22          stz   irq_cnt           ; reset system interrupt counter
 1350  00:DE74  1A                inc   A                 ; return number of elapsed frames
 1351                     
 1352           0000             .ifndef HUC
 1354                            .else
 1355                     
 1356                         ; ----
 1357                         ; callback support
 1358                     
 1359  00:DE75  48                pha
 1360  00:DE76  AD 88 26          lda   joycallback       ; callback valid?
 1361  00:DE79  10 34             bpl  .t3
 1362  00:DE7B  89 01             bit   #$01
 1363  00:DE7D  D0 30             bne  .t3
 1364                     
 1365  00:DE7F  AD 89 26          lda   joycallback+1     ; get events for all the 
 1366  00:DE82  F0 2B             beq  .t3                ; selected joypads
 1367  00:DE84  85 F8             sta  <_al
 1368  00:DE86  C2                cly
 1369  00:DE87  62                cla
 1370  00:DE88  46 F8     .t1:    lsr  <_al
 1371  00:DE8A  90 03             bcc  .t2
 1372  00:DE8C  19 81 26          ora   joybuf,Y
 1373  00:DE8F  C8        .t2:    iny
 1374  00:DE90  C0 05             cpy   #5
 1375                             blo  .t1
       00:DE92  90 F4              bcc    .t1
 1376                     
 1377  00:DE94  2D 8A 26          and   joycallback+2     ; compare with requested state
 1378  00:DE97  F0 16             beq  .t3
 1379                     
 1380  00:DE99  EE 88 26          inc   joycallback       ; lock callback feature
 1381  00:DE9C  AA                tax                     ; call user routine
 1382  00:DE9D  43 20             tma   #5
 1383  00:DE9F  48                pha
 1384  00:DEA0  AD 8B 26          lda   joycallback+3
 1385  00:DEA3  53 20             tam   #5
 1386  00:DEA5  62                cla
 1387  00:DEA6  20 B2 DE          jsr  .callback
 1388  00:DEA9  68                pla
 1389  00:DEAA  53 20             tam   #5
 1390  00:DEAC  CE 88 26          dec   joycallback       ; unlock
 1391                             ; --
 1392  00:DEAF  FA        .t3:    plx
 1393  00:DEB0  62                cla
 1394  00:DEB1  60                rts
 1395                     
 1396                         ; ----
 1397                         ; user routine callback
 1398                         ;
 1399  00:DEB2            .callback:
 1400  00:DEB2  6C 8C 26          jmp   [joycallback+4]
 1401                            .endif   ; ndef HUC
 1402                     
#[3]   joypad.asm
 1403                            .include  "joypad.asm"   ; read joypad values
    1                     ; ----
    2                     ; read_joypad
    3                     ; ----
    4                     ; poll joypads
    5                     ;
    6                     ; 'joyport' (location $1000) is a control read/write port which only reads
    7                     ; 4 bits at a time; the program uses joyport to toggle the multiplex line
    8                     ;
    9                     ; real logic values are read into the port - the joypad's keys are default
   10                     ; high, and 'pulled' low when pressed.  Therefore, these values must be
   11                     ; inverted/complemented to yield values where '1' means 'pressed'
   12                     ;
   13                     ; bit values for joypad bytes: (MSB = #7; LSB = #0)
   14                     ; -------------------------------------------------
   15                     ; bit 0 (ie $01) = I
   16                     ; bit 1 (ie $02) = II
   17                     ; bit 2 (ie $04) = 'select'
   18                     ; bit 3 (ie $08) = 'run'
   19                     ; bit 4 (ie $10) = UP
   20                     ; bit 5 (ie $20) = RIGHT
   21                     ; bit 6 (ie $40) = DOWN
   22                     ; bit 7 (ie $80) = LEFT
   23                     ; ----
   24                     ; bit values for joypad 6-button bytes: (MSB = #7; LSB = #0)
   25                     ; ----------------------------------------------------------
   26                     ; bit 0   (ie $01) = III
   27                     ; bit 1   (ie $02) = IV
   28                     ; bit 2   (ie $04) = V
   29                     ; bit 3   (ie $08) = VI
   30                     ; bit 4-7 (ie $F0) = exists (all on or all off)
   31                     ; ----
   32                     
   33                     ; Note: Read twice for 6-button joysticks.
   34                     ; First read should be for 'joy' and second for
   35                     ; 'joy6'; need to hide values temporarily while
   36                     ; scanning twice.
   37                     
   38  00:DEB5            read_joypad:
   39                             maplibfunc  lib2_readjoy
       00:DEB5  A8                 tay
       00:DEB6  43 20              tma  #page(lib2_readjoy)
       00:DEB8  48                 pha
       00:DEB9  A9 81              lda  #bank(lib2_readjoy)
       00:DEBB  53 20              tam  #page(lib2_readjoy)
       00:DEBD  98                 tya
       00:DEBE  20 F3 B4           jsr  lib2_readjoy
       00:DEC1  A8                 tay
       00:DEC2  68                 pla
       00:DEC3  53 20              tam  #page(lib2_readjoy)
       00:DEC5  98                 tya
   40  00:DEC6  60                rts
   41                     
   42           0001              .bank   LIB2_BANK
   43                     
   44  01:B4F3            lib2_readjoy:
   45  01:B4F3  AD 27 22          lda   joyena            ; suppress reset during individual read
   46  01:B4F6  48                pha
   47  01:B4F7  9C 27 22          stz   joyena
   48                     
   49           0001             .if (CDROM)
   50  01:B4FA  20 63 E0          jsr   ex_joysns
   51                            .else
   53                            .endif
   54                     
   55  01:B4FD  73 28 22          tii   joy, joy6, 5      ; move to 6-button area
       01:B500  93 26 05  
       01:B503  00        
   56                     
   57           0001             .if (CDROM)
   58  01:B504  20 63 E0          jsr   ex_joysns
   59                            .else
   61                            .endif
   62                     
   63  01:B507  68                pla
   64  01:B508  8D 27 22          sta   joyena
   65                     
   66  01:B50B  73 A7 26          tii   joytmp, joyold, 5         ; restore past info from stash
       01:B50E  32 22 05  
       01:B511  00        
   67  01:B512  73 AC 26          tii   joytmp6, joyold6, 5
       01:B515  9D 26 05  
       01:B518  00        
   68                     
   69                             ;
   70                             ; the '.l2' loop determines if first or
   71                             ; second scans imply a 6-button joystick,
   72                             ; and rearrange bytes if out of order,
   73                             ; and zero the joy6 area if necessary
   74                             ;
   75  01:B519  C2                cly
   76  01:B51A  B9 28 22  .l2:    lda   joy,Y             ; check if 6-button joypad, and
   77  01:B51D  AA                tax
   78  01:B51E  29 50             and   #JOY_TYPE6        ; scans became backwards somehow
   79  01:B520  C9 50             cmp   #JOY_TYPE6
   80  01:B522  D0 0A             bne  .notswap
   81  01:B524  B9 93 26          lda   joy6,Y            ; then swap them if they need it
   82  01:B527  99 28 22          sta   joy,Y
   83  01:B52A  22                sax
   84  01:B52B  99 93 26          sta   joy6,Y
   85                     
   86  01:B52E            .notswap:
   87  01:B52E  B9 93 26          lda   joy6,Y            ; verify whether a 6-button exists
   88  01:B531  29 50             and   #JOY_TYPE6
   89  01:B533  C9 50             cmp   #JOY_TYPE6
   90  01:B535  F0 04             beq  .type6
   91  01:B537  62                cla
   92  01:B538  99 93 26          sta   joy6,Y            ; not 6-button, so clear extra entry
   93                     
   94  01:B53B            .type6:
   95  01:B53B  B9 93 26          lda   joy6,Y            ; strip off unused bits
   96  01:B53E  29 5F             and   #(JOY_III | JOY_IV | JOY_V | JOY_VI | JOY_TYPE6)
   97  01:B540  99 93 26          sta   joy6,Y            ; clear unnecessary bits
   98                     
   99                     
  100                             ;
  101                             ; The '.l2a' area sets appropriate values
  102                             ; for all of the joytrg and joybuf areas
  103                             ;
  104                     
  105  01:B543  B9 28 22  .l2a:   lda   joy,Y
  106  01:B546  59 32 22          eor   joyold,Y          ; check against previous value
  107  01:B549  39 28 22          and   joy,Y
  108  01:B54C  99 2D 22          sta   joytrg,Y          ; 'new key pressed' key values
  109                     
  110                         ; ----
  111                         ; buffered 'new key pressed'
  112                         ; see joy_events();
  113                         ;
  114  01:B54F  19 81 26          ora   joybuf,Y          ; collect 'new key pressed'
  115  01:B552  99 81 26          sta   joybuf,Y
  116                     
  117                         ; ----
  118                         ; repeat the joyold/joytrg/joybuf stuff
  119                         ; for 6-button values
  120                         ;
  121  01:B555  B9 93 26          lda   joy6,Y
  122  01:B558  59 9D 26          eor   joyold6,Y
  123  01:B55B  39 93 26          and   joy6,Y
  124  01:B55E  99 98 26          sta   joytrg6,Y
  125  01:B561  19 A2 26          ora   joybuf6,Y
  126  01:B564  99 A2 26          sta   joybuf6,Y
  127                     
  128                         ; ----
  129                         ; next joypad
  130                         ;
  131  01:B567  C8                iny
  132  01:B568  C0 05             cpy   #$05              ; cycle for next of 5 joypads
  133  01:B56A  90 AE             bcc  .l2
  134                     
  135                         ; ----
  136                         ; soft reset check
  137                         ;
  138  01:B56C  C2                cly                     ; start cycle of 5 joypads
  139  01:B56D  AD 27 22  .l3:    lda   joyena            ; find mask of 'important' joysticks
  140  01:B570  39 A5 B5          and  .bitmsk,Y
  141  01:B573  F0 11             beq  .l4                ; not important enough to check
  142  01:B575  B9 2D 22          lda   joytrg,Y
  143  01:B578  C9 04             cmp   #$04              ; 'select' key newly-pressed ?
  144  01:B57A  D0 0A             bne  .l4
  145  01:B57C  B9 28 22          lda   joy,Y
  146  01:B57F  C9 0C             cmp   #$0C              ; 'run+select' currently pressed ?
  147  01:B581  D0 03             bne  .l4
  148                     
  149           0000             .if (DEVELO)
  151                            .else
  152  01:B583  6C 84 22          jmp   [soft_reset]      ; run+select 'soft reset' vector
  153                            .endif   ; (DEVELO)
  154                     
  155  01:B586  C8        .l4:    iny                     ; try next joypad
  156  01:B587  C0 05             cpy   #$05
  157  01:B589  90 E2             bcc  .l3
  158                     
  159                         ; ----
  160                         ; joyread hook
  161                         ;
  162           0001             .ifdef HUC
  163                             tstw  joyhook
       01:B58B  AD 86 26           lda   joyhook               ; value at stated memory
       01:B58E  0D 87 26           ora   joyhook+1             ; location is zero
  164  01:B591  F0 03             beq  .l5
  165  01:B593  20 AA B5          jsr  .hook
  166  01:B596            .l5:
  167                            .endif   ; HUC
  168                     
  169                     
  170                         ; ----
  171                         ; return
  172                         ;
  173  01:B596  73 28 22          tii   joy, joytmp, 5    ; stash values for next read because CDROM
       01:B599  A7 26 05  
       01:B59C  00        
  174  01:B59D  73 93 26          tii   joy6, joytmp6, 5  ; may force another read between VSYNC's
       01:B5A0  AC 26 05  
       01:B5A3  00        
  175                     
  176  01:B5A4  60                rts
  177                     
  178                     
  179           0000             .if !(CDROM)
  225                            .endif   ; !(CDROM)
  226                     
  227  01:B5A5            .bitmsk:
  228  01:B5A5  01 02 04          .db $01,$02,$04,$08,$10 ; bit-masks for check-reset
       01:B5A8  08 10     
  229                     
  230                         ; ----
  231                         ; user routine
  232                         ;
  233           0001             .ifdef HUC
  234  01:B5AA            .hook:
  235  01:B5AA  6C 86 26          jmp   [joyhook]
  236                            .endif   ; HUC
  237                     
  238                     ; At end of all this lib2_bank stuff, we need to return
  239                     ; to the base context of lib1_bank:
  240                     
  241           0000              .bank  LIB1_BANK
  242                     
#[2]   startup.asm
 1404                     
 1405                     
 1406                     ;[ USER PROGRAM ]
 1407                     
 1408                     ;       .nomlist
 1409                     ;       .list
 1410                     
 1411                             ;...
 1412                     
 1413                     ;       .endif
 1414                     
#[1]   seek2.s
   13           60C8              .data
   14           0003              .bank DATA_BANK
   15                     
   16           DEC7              .code
   17                     
   18                     ; cd_read_sector(void) - references char rec_h, char rec_m, char rec_l, char * target_data
   19  00:DEC7            _cd_read_sector:
   20  00:DEC7  AD CE 29      lda _rec_h       ; disc sector address (LBA address)
   21  00:DECA  85 FC         sta <_cl
   22  00:DECC  AD CF 29      lda _rec_m
   23  00:DECF  85 FD         sta <_ch
   24  00:DED1  AD D0 29      lda _rec_l
   25  00:DED4  85 FE         sta <_dl
   26  00:DED6  A9 01         lda #1           ; data read address type (LOCAL)
   27  00:DED8  85 FF         sta <_dh
   28  00:DEDA  A9 29         lda #HIGH(_target_data)    ; memory address
   29  00:DEDC  85 FB         sta <_bh
   30  00:DEDE  A9 D1         lda #LOW(_target_data)
   31  00:DEE0  85 FA         sta <_bl
   32  00:DEE2  A9 01         lda #1           ; number of units
   33  00:DEE4  85 F8         sta <_al         ; record length - in sectors for this read type
   34  00:DEE6  20 09 E0      call cd_read
   35  00:DEE9  60            rts
   36  04:4000                    .proc _add_3digit
   37                             __pushw
                                 __submi  2,__stack
       04:A000  48                 pha
       04:A001  38                 sec
       04:A002  A5 00              lda    <__stack
       04:A004  E9 02              sbc    #low(2)
       04:A006  85 00              sta    <__stack
       04:A008  A5 01              lda    <__stack+1
       04:A00A  E9 00              sbc    #high(2)
       04:A00C  85 01              sta    <__stack+1
       04:A00E  68                 pla
       04:A00F  22                 sax
       04:A010  92 00              sta    [__stack]
       04:A012  22                 sax
       04:A013  A0 01              ldy    #1
       04:A015  91 00              sta    [__stack],Y
   38                             __addmi -8,__stack
       04:A017  48                 pha
       04:A018  18                 clc
       04:A019  A5 00              lda    <__stack
       04:A01B  69 F8              adc    #low(-8)
       04:A01D  85 00              sta    <__stack
       04:A01F  A5 01              lda    <__stack+1
       04:A021  69 FF              adc    #high(-8)
       04:A023  85 01              sta    <__stack+1
       04:A025  68                 pla
   39                             __ldw_s 10
                0001              .if (10 < 255)
                                   ; short index (bytes :  7/8, cycles : 18/20)
                0000               .if (10 = 0)
                                   .else
       04:A026  A0 0A               ldy   #10
       04:A028  B1 00               lda   [__sp],Y
       04:A02A  AA                  tax
       04:A02B  C8                  iny
       04:A02C  B1 00               lda   [__sp],Y
                                   .endif
                                  .else
                                  .endif
   40                             __addwi 2
       04:A02E  18                 clc
       04:A02F  22                 sax
       04:A030  69 02              adc    #low(2)
       04:A032  22                 sax
       04:A033  69 00              adc    #high(2)
   41                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:A035  86 0B              stx    <__ptr
       04:A037  85 0C              sta    <__ptr+1
       04:A039  B2 0B              lda    [__ptr]
       04:A03B  AA                 tax
       04:A03C  62                 cla
                          ;        bpl    .x_00631   ; signed
                          ;        dec    A
                          ;.x_00631:
   42                             __andwi 255
       04:A03D  22                 sax
       04:A03E  29 FF              and    #low(255)
       04:A040  22                 sax
       04:A041  29 00              and    #high(255)
   43                             __stw_s 6
                0001              .if (6 < 255)
                                   ; short index (bytes :  9, cycles : 22)
                          
       04:A043  22                 sax
       04:A044  A0 06              ldy    #6
       04:A046  91 00              sta    [__sp],Y
       04:A048  22                 sax
       04:A049  C8                 iny
       04:A04A  91 00              sta    [__sp],Y
                                  .else
                                  .endif
   44                             __ldw_s 8
                0001              .if (8 < 255)
                                   ; short index (bytes :  7/8, cycles : 18/20)
                0000               .if (8 = 0)
                                   .else
       04:A04C  A0 08               ldy   #8
       04:A04E  B1 00               lda   [__sp],Y
       04:A050  AA                  tax
       04:A051  C8                  iny
       04:A052  B1 00               lda   [__sp],Y
                                   .endif
                                  .else
                                  .endif
   45                             __addwi 2
       04:A054  18                 clc
       04:A055  22                 sax
       04:A056  69 02              adc    #low(2)
       04:A058  22                 sax
       04:A059  69 00              adc    #high(2)
   46                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:A05B  86 0B              stx    <__ptr
       04:A05D  85 0C              sta    <__ptr+1
       04:A05F  B2 0B              lda    [__ptr]
       04:A061  AA                 tax
       04:A062  62                 cla
                          ;        bpl    .x_00636   ; signed
                          ;        dec    A
                          ;.x_00636:
   47                             __andwi 255
       04:A063  22                 sax
       04:A064  29 FF              and    #low(255)
       04:A066  22                 sax
       04:A067  29 00              and    #high(255)
   48                             __stw_s 4
                0001              .if (4 < 255)
                                   ; short index (bytes :  9, cycles : 22)
                          
       04:A069  22                 sax
       04:A06A  A0 04              ldy    #4
       04:A06C  91 00              sta    [__sp],Y
       04:A06E  22                 sax
       04:A06F  C8                 iny
       04:A070  91 00              sta    [__sp],Y
                                  .else
                                  .endif
   49                             __ldw_s 6
                0001              .if (6 < 255)
                                   ; short index (bytes :  7/8, cycles : 18/20)
                0000               .if (6 = 0)
                                   .else
       04:A072  A0 06               ldy   #6
       04:A074  B1 00               lda   [__sp],Y
       04:A076  AA                  tax
       04:A077  C8                  iny
       04:A078  B1 00               lda   [__sp],Y
                                   .endif
                                  .else
                                  .endif
   50                             __addw_s        4
                0001              .if (4 < 255)
                                   ; short index (bytes : 10, cycles : 24)
                          
       04:A07A  A0 04              ldy    #4
       04:A07C  18                 clc
       04:A07D  22                 sax
       04:A07E  71 00              adc    [__sp],Y
       04:A080  22                 sax
       04:A081  C8                 iny
       04:A082  71 00              adc    [__sp],Y
                                  .else
                                  .endif
   51                             __stw_s 2
                0001              .if (2 < 255)
                                   ; short index (bytes :  9, cycles : 22)
                          
       04:A084  22                 sax
       04:A085  A0 02              ldy    #2
       04:A087  91 00              sta    [__sp],Y
       04:A089  22                 sax
       04:A08A  C8                 iny
       04:A08B  91 00              sta    [__sp],Y
                                  .else
                                  .endif
   52                             __pushw
                                 __submi  2,__stack
       04:A08D  48                 pha
       04:A08E  38                 sec
       04:A08F  A5 00              lda    <__stack
       04:A091  E9 02              sbc    #low(2)
       04:A093  85 00              sta    <__stack
       04:A095  A5 01              lda    <__stack+1
       04:A097  E9 00              sbc    #high(2)
       04:A099  85 01              sta    <__stack+1
       04:A09B  68                 pla
       04:A09C  22                 sax
       04:A09D  92 00              sta    [__stack]
       04:A09F  22                 sax
       04:A0A0  A0 01              ldy    #1
       04:A0A2  91 00              sta    [__stack],Y
   53                             __ldwi  8
       04:A0A4  A2 08              ldx    #low(8)
       04:A0A6  A9 00              lda    #high(8)
   54  04:A0A8  20 E5 C9            jsr   asr
   55                             __stw_s 0
                0001              .if (0 < 255)
                                   ; short index (bytes :  9, cycles : 22)
                          
       04:A0AB  22                 sax
       04:A0AC  A0 00              ldy    #0
       04:A0AE  91 00              sta    [__sp],Y
       04:A0B0  22                 sax
       04:A0B1  C8                 iny
       04:A0B2  91 00              sta    [__sp],Y
                                  .else
                                  .endif
   56                             __ldwi  _result
       04:A0B4  A2 DE              ldx    #low(_result)
       04:A0B6  A9 31              lda    #high(_result)
   57                             __addwi 2
       04:A0B8  18                 clc
       04:A0B9  22                 sax
       04:A0BA  69 02              adc    #low(2)
       04:A0BC  22                 sax
       04:A0BD  69 00              adc    #high(2)
   58                             __pushw
                                 __submi  2,__stack
       04:A0BF  48                 pha
       04:A0C0  38                 sec
       04:A0C1  A5 00              lda    <__stack
       04:A0C3  E9 02              sbc    #low(2)
       04:A0C5  85 00              sta    <__stack
       04:A0C7  A5 01              lda    <__stack+1
       04:A0C9  E9 00              sbc    #high(2)
       04:A0CB  85 01              sta    <__stack+1
       04:A0CD  68                 pla
       04:A0CE  22                 sax
       04:A0CF  92 00              sta    [__stack]
       04:A0D1  22                 sax
       04:A0D2  A0 01              ldy    #1
       04:A0D4  91 00              sta    [__stack],Y
   59                             __ldw_s 4
                0001              .if (4 < 255)
                                   ; short index (bytes :  7/8, cycles : 18/20)
                0000               .if (4 = 0)
                                   .else
       04:A0D6  A0 04               ldy   #4
       04:A0D8  B1 00               lda   [__sp],Y
       04:A0DA  AA                  tax
       04:A0DB  C8                  iny
       04:A0DC  B1 00               lda   [__sp],Y
                                   .endif
                                  .else
                                  .endif
   60                             __andwi 255
       04:A0DE  22                 sax
       04:A0DF  29 FF              and    #low(255)
       04:A0E1  22                 sax
       04:A0E2  29 00              and    #high(255)
   61                             __stbps
                                 __stw    <__temp
       04:A0E4  86 03              stx    <__temp
       04:A0E6  85 04              sta    <__temp+1
                                 __ldwp    __stack
       04:A0E8  B2 00              lda    [__stack]
       04:A0EA  AA                 tax
       04:A0EB  A0 01              ldy    #1
       04:A0ED  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       04:A0EF  86 0B              stx    <__ptr
       04:A0F1  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       04:A0F3  A6 03              ldx    <__temp
       04:A0F5  A5 04              lda    <__temp+1
                                  .endif
       04:A0F7  22                 sax
       04:A0F8  92 0B              sta    [__ptr]
       04:A0FA  22                 sax
                                 __addmi  2,__stack
       04:A0FB  48                 pha
       04:A0FC  18                 clc
       04:A0FD  A5 00              lda    <__stack
       04:A0FF  69 02              adc    #low(2)
       04:A101  85 00              sta    <__stack
       04:A103  A5 01              lda    <__stack+1
       04:A105  69 00              adc    #high(2)
       04:A107  85 01              sta    <__stack+1
       04:A109  68                 pla
   62                             __ldw_s 10
                0001              .if (10 < 255)
                                   ; short index (bytes :  7/8, cycles : 18/20)
                0000               .if (10 = 0)
                                   .else
       04:A10A  A0 0A               ldy   #10
       04:A10C  B1 00               lda   [__sp],Y
       04:A10E  AA                  tax
       04:A10F  C8                  iny
       04:A110  B1 00               lda   [__sp],Y
                                   .endif
                                  .else
                                  .endif
   63                             __addwi 1
       04:A112  18                 clc
       04:A113  22                 sax
       04:A114  69 01              adc    #low(1)
       04:A116  22                 sax
       04:A117  69 00              adc    #high(1)
   64                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:A119  86 0B              stx    <__ptr
       04:A11B  85 0C              sta    <__ptr+1
       04:A11D  B2 0B              lda    [__ptr]
       04:A11F  AA                 tax
       04:A120  62                 cla
                          ;        bpl    .x_00660   ; signed
                          ;        dec    A
                          ;.x_00660:
   65                             __andwi 255
       04:A121  22                 sax
       04:A122  29 FF              and    #low(255)
       04:A124  22                 sax
       04:A125  29 00              and    #high(255)
   66                             __stw_s 6
                0001              .if (6 < 255)
                                   ; short index (bytes :  9, cycles : 22)
                          
       04:A127  22                 sax
       04:A128  A0 06              ldy    #6
       04:A12A  91 00              sta    [__sp],Y
       04:A12C  22                 sax
       04:A12D  C8                 iny
       04:A12E  91 00              sta    [__sp],Y
                                  .else
                                  .endif
   67                             __ldw_s 8
                0001              .if (8 < 255)
                                   ; short index (bytes :  7/8, cycles : 18/20)
                0000               .if (8 = 0)
                                   .else
       04:A130  A0 08               ldy   #8
       04:A132  B1 00               lda   [__sp],Y
       04:A134  AA                  tax
       04:A135  C8                  iny
       04:A136  B1 00               lda   [__sp],Y
                                   .endif
                                  .else
                                  .endif
   68                             __addwi 1
       04:A138  18                 clc
       04:A139  22                 sax
       04:A13A  69 01              adc    #low(1)
       04:A13C  22                 sax
       04:A13D  69 00              adc    #high(1)
   69                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:A13F  86 0B              stx    <__ptr
       04:A141  85 0C              sta    <__ptr+1
       04:A143  B2 0B              lda    [__ptr]
       04:A145  AA                 tax
       04:A146  62                 cla
                          ;        bpl    .x_00665   ; signed
                          ;        dec    A
                          ;.x_00665:
   70                             __andwi 255
       04:A147  22                 sax
       04:A148  29 FF              and    #low(255)
       04:A14A  22                 sax
       04:A14B  29 00              and    #high(255)
   71                             __stw_s 4
                0001              .if (4 < 255)
                                   ; short index (bytes :  9, cycles : 22)
                          
       04:A14D  22                 sax
       04:A14E  A0 04              ldy    #4
       04:A150  91 00              sta    [__sp],Y
       04:A152  22                 sax
       04:A153  C8                 iny
       04:A154  91 00              sta    [__sp],Y
                                  .else
                                  .endif
   72                             __ldw_s 6
                0001              .if (6 < 255)
                                   ; short index (bytes :  7/8, cycles : 18/20)
                0000               .if (6 = 0)
                                   .else
       04:A156  A0 06               ldy   #6
       04:A158  B1 00               lda   [__sp],Y
       04:A15A  AA                  tax
       04:A15B  C8                  iny
       04:A15C  B1 00               lda   [__sp],Y
                                   .endif
                                  .else
                                  .endif
   73                             __addw_s        4
                0001              .if (4 < 255)
                                   ; short index (bytes : 10, cycles : 24)
                          
       04:A15E  A0 04              ldy    #4
       04:A160  18                 clc
       04:A161  22                 sax
       04:A162  71 00              adc    [__sp],Y
       04:A164  22                 sax
       04:A165  C8                 iny
       04:A166  71 00              adc    [__sp],Y
                                  .else
                                  .endif
   74                             __addw_s        0
                0001              .if (0 < 255)
                                   ; short index (bytes : 10, cycles : 24)
                          
       04:A168  A0 00              ldy    #0
       04:A16A  18                 clc
       04:A16B  22                 sax
       04:A16C  71 00              adc    [__sp],Y
       04:A16E  22                 sax
       04:A16F  C8                 iny
       04:A170  71 00              adc    [__sp],Y
                                  .else
                                  .endif
   75                             __stw_s 2
                0001              .if (2 < 255)
                                   ; short index (bytes :  9, cycles : 22)
                          
       04:A172  22                 sax
       04:A173  A0 02              ldy    #2
       04:A175  91 00              sta    [__sp],Y
       04:A177  22                 sax
       04:A178  C8                 iny
       04:A179  91 00              sta    [__sp],Y
                                  .else
                                  .endif
   76                             __pushw
                                 __submi  2,__stack
       04:A17B  48                 pha
       04:A17C  38                 sec
       04:A17D  A5 00              lda    <__stack
       04:A17F  E9 02              sbc    #low(2)
       04:A181  85 00              sta    <__stack
       04:A183  A5 01              lda    <__stack+1
       04:A185  E9 00              sbc    #high(2)
       04:A187  85 01              sta    <__stack+1
       04:A189  68                 pla
       04:A18A  22                 sax
       04:A18B  92 00              sta    [__stack]
       04:A18D  22                 sax
       04:A18E  A0 01              ldy    #1
       04:A190  91 00              sta    [__stack],Y
   77                             __ldwi  8
       04:A192  A2 08              ldx    #low(8)
       04:A194  A9 00              lda    #high(8)
   78  04:A196  20 E5 C9            jsr   asr
   79                             __stw_s 0
                0001              .if (0 < 255)
                                   ; short index (bytes :  9, cycles : 22)
                          
       04:A199  22                 sax
       04:A19A  A0 00              ldy    #0
       04:A19C  91 00              sta    [__sp],Y
       04:A19E  22                 sax
       04:A19F  C8                 iny
       04:A1A0  91 00              sta    [__sp],Y
                                  .else
                                  .endif
   80                             __ldwi  _result
       04:A1A2  A2 DE              ldx    #low(_result)
       04:A1A4  A9 31              lda    #high(_result)
   81                             __addwi 1
       04:A1A6  18                 clc
       04:A1A7  22                 sax
       04:A1A8  69 01              adc    #low(1)
       04:A1AA  22                 sax
       04:A1AB  69 00              adc    #high(1)
   82                             __pushw
                                 __submi  2,__stack
       04:A1AD  48                 pha
       04:A1AE  38                 sec
       04:A1AF  A5 00              lda    <__stack
       04:A1B1  E9 02              sbc    #low(2)
       04:A1B3  85 00              sta    <__stack
       04:A1B5  A5 01              lda    <__stack+1
       04:A1B7  E9 00              sbc    #high(2)
       04:A1B9  85 01              sta    <__stack+1
       04:A1BB  68                 pla
       04:A1BC  22                 sax
       04:A1BD  92 00              sta    [__stack]
       04:A1BF  22                 sax
       04:A1C0  A0 01              ldy    #1
       04:A1C2  91 00              sta    [__stack],Y
   83                             __ldw_s 4
                0001              .if (4 < 255)
                                   ; short index (bytes :  7/8, cycles : 18/20)
                0000               .if (4 = 0)
                                   .else
       04:A1C4  A0 04               ldy   #4
       04:A1C6  B1 00               lda   [__sp],Y
       04:A1C8  AA                  tax
       04:A1C9  C8                  iny
       04:A1CA  B1 00               lda   [__sp],Y
                                   .endif
                                  .else
                                  .endif
   84                             __andwi 255
       04:A1CC  22                 sax
       04:A1CD  29 FF              and    #low(255)
       04:A1CF  22                 sax
       04:A1D0  29 00              and    #high(255)
   85                             __stbps
                                 __stw    <__temp
       04:A1D2  86 03              stx    <__temp
       04:A1D4  85 04              sta    <__temp+1
                                 __ldwp    __stack
       04:A1D6  B2 00              lda    [__stack]
       04:A1D8  AA                 tax
       04:A1D9  A0 01              ldy    #1
       04:A1DB  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       04:A1DD  86 0B              stx    <__ptr
       04:A1DF  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       04:A1E1  A6 03              ldx    <__temp
       04:A1E3  A5 04              lda    <__temp+1
                                  .endif
       04:A1E5  22                 sax
       04:A1E6  92 0B              sta    [__ptr]
       04:A1E8  22                 sax
                                 __addmi  2,__stack
       04:A1E9  48                 pha
       04:A1EA  18                 clc
       04:A1EB  A5 00              lda    <__stack
       04:A1ED  69 02              adc    #low(2)
       04:A1EF  85 00              sta    <__stack
       04:A1F1  A5 01              lda    <__stack+1
       04:A1F3  69 00              adc    #high(2)
       04:A1F5  85 01              sta    <__stack+1
       04:A1F7  68                 pla
   86                             __ldw_s 10
                0001              .if (10 < 255)
                                   ; short index (bytes :  7/8, cycles : 18/20)
                0000               .if (10 = 0)
                                   .else
       04:A1F8  A0 0A               ldy   #10
       04:A1FA  B1 00               lda   [__sp],Y
       04:A1FC  AA                  tax
       04:A1FD  C8                  iny
       04:A1FE  B1 00               lda   [__sp],Y
                                   .endif
                                  .else
                                  .endif
   87                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:A200  86 0B              stx    <__ptr
       04:A202  85 0C              sta    <__ptr+1
       04:A204  B2 0B              lda    [__ptr]
       04:A206  AA                 tax
       04:A207  62                 cla
                          ;        bpl    .x_00689   ; signed
                          ;        dec    A
                          ;.x_00689:
   88                             __andwi 255
       04:A208  22                 sax
       04:A209  29 FF              and    #low(255)
       04:A20B  22                 sax
       04:A20C  29 00              and    #high(255)
   89                             __stw_s 6
                0001              .if (6 < 255)
                                   ; short index (bytes :  9, cycles : 22)
                          
       04:A20E  22                 sax
       04:A20F  A0 06              ldy    #6
       04:A211  91 00              sta    [__sp],Y
       04:A213  22                 sax
       04:A214  C8                 iny
       04:A215  91 00              sta    [__sp],Y
                                  .else
                                  .endif
   90                             __ldw_s 8
                0001              .if (8 < 255)
                                   ; short index (bytes :  7/8, cycles : 18/20)
                0000               .if (8 = 0)
                                   .else
       04:A217  A0 08               ldy   #8
       04:A219  B1 00               lda   [__sp],Y
       04:A21B  AA                  tax
       04:A21C  C8                  iny
       04:A21D  B1 00               lda   [__sp],Y
                                   .endif
                                  .else
                                  .endif
   91                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:A21F  86 0B              stx    <__ptr
       04:A221  85 0C              sta    <__ptr+1
       04:A223  B2 0B              lda    [__ptr]
       04:A225  AA                 tax
       04:A226  62                 cla
                          ;        bpl    .x_00693   ; signed
                          ;        dec    A
                          ;.x_00693:
   92                             __andwi 255
       04:A227  22                 sax
       04:A228  29 FF              and    #low(255)
       04:A22A  22                 sax
       04:A22B  29 00              and    #high(255)
   93                             __stw_s 4
                0001              .if (4 < 255)
                                   ; short index (bytes :  9, cycles : 22)
                          
       04:A22D  22                 sax
       04:A22E  A0 04              ldy    #4
       04:A230  91 00              sta    [__sp],Y
       04:A232  22                 sax
       04:A233  C8                 iny
       04:A234  91 00              sta    [__sp],Y
                                  .else
                                  .endif
   94                             __ldw_s 6
                0001              .if (6 < 255)
                                   ; short index (bytes :  7/8, cycles : 18/20)
                0000               .if (6 = 0)
                                   .else
       04:A236  A0 06               ldy   #6
       04:A238  B1 00               lda   [__sp],Y
       04:A23A  AA                  tax
       04:A23B  C8                  iny
       04:A23C  B1 00               lda   [__sp],Y
                                   .endif
                                  .else
                                  .endif
   95                             __addw_s        4
                0001              .if (4 < 255)
                                   ; short index (bytes : 10, cycles : 24)
                          
       04:A23E  A0 04              ldy    #4
       04:A240  18                 clc
       04:A241  22                 sax
       04:A242  71 00              adc    [__sp],Y
       04:A244  22                 sax
       04:A245  C8                 iny
       04:A246  71 00              adc    [__sp],Y
                                  .else
                                  .endif
   96                             __addw_s        0
                0001              .if (0 < 255)
                                   ; short index (bytes : 10, cycles : 24)
                          
       04:A248  A0 00              ldy    #0
       04:A24A  18                 clc
       04:A24B  22                 sax
       04:A24C  71 00              adc    [__sp],Y
       04:A24E  22                 sax
       04:A24F  C8                 iny
       04:A250  71 00              adc    [__sp],Y
                                  .else
                                  .endif
   97                             __stw_s 2
                0001              .if (2 < 255)
                                   ; short index (bytes :  9, cycles : 22)
                          
       04:A252  22                 sax
       04:A253  A0 02              ldy    #2
       04:A255  91 00              sta    [__sp],Y
       04:A257  22                 sax
       04:A258  C8                 iny
       04:A259  91 00              sta    [__sp],Y
                                  .else
                                  .endif
   98                             __ldwi  _result
       04:A25B  A2 DE              ldx    #low(_result)
       04:A25D  A9 31              lda    #high(_result)
   99                             __pushw
                                 __submi  2,__stack
       04:A25F  48                 pha
       04:A260  38                 sec
       04:A261  A5 00              lda    <__stack
       04:A263  E9 02              sbc    #low(2)
       04:A265  85 00              sta    <__stack
       04:A267  A5 01              lda    <__stack+1
       04:A269  E9 00              sbc    #high(2)
       04:A26B  85 01              sta    <__stack+1
       04:A26D  68                 pla
       04:A26E  22                 sax
       04:A26F  92 00              sta    [__stack]
       04:A271  22                 sax
       04:A272  A0 01              ldy    #1
       04:A274  91 00              sta    [__stack],Y
  100                             __ldw_s 4
                0001              .if (4 < 255)
                                   ; short index (bytes :  7/8, cycles : 18/20)
                0000               .if (4 = 0)
                                   .else
       04:A276  A0 04               ldy   #4
       04:A278  B1 00               lda   [__sp],Y
       04:A27A  AA                  tax
       04:A27B  C8                  iny
       04:A27C  B1 00               lda   [__sp],Y
                                   .endif
                                  .else
                                  .endif
  101                             __andwi 255
       04:A27E  22                 sax
       04:A27F  29 FF              and    #low(255)
       04:A281  22                 sax
       04:A282  29 00              and    #high(255)
  102                             __stbps
                                 __stw    <__temp
       04:A284  86 03              stx    <__temp
       04:A286  85 04              sta    <__temp+1
                                 __ldwp    __stack
       04:A288  B2 00              lda    [__stack]
       04:A28A  AA                 tax
       04:A28B  A0 01              ldy    #1
       04:A28D  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       04:A28F  86 0B              stx    <__ptr
       04:A291  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       04:A293  A6 03              ldx    <__temp
       04:A295  A5 04              lda    <__temp+1
                                  .endif
       04:A297  22                 sax
       04:A298  92 0B              sta    [__ptr]
       04:A29A  22                 sax
                                 __addmi  2,__stack
       04:A29B  48                 pha
       04:A29C  18                 clc
       04:A29D  A5 00              lda    <__stack
       04:A29F  69 02              adc    #low(2)
       04:A2A1  85 00              sta    <__stack
       04:A2A3  A5 01              lda    <__stack+1
       04:A2A5  69 00              adc    #high(2)
       04:A2A7  85 01              sta    <__stack+1
       04:A2A9  68                 pla
  103  04:A2AA            LL1:
  104                     
  105                             __addmi 12,__stack
       04:A2AA  48                 pha
       04:A2AB  18                 clc
       04:A2AC  A5 00              lda    <__stack
       04:A2AE  69 0C              adc    #low(12)
       04:A2B0  85 00              sta    <__stack
       04:A2B2  A5 01              lda    <__stack+1
       04:A2B4  69 00              adc    #high(12)
       04:A2B6  85 01              sta    <__stack+1
       04:A2B8  68                 pla
  106  04:A2B9  60                  rts
  107                             .endp
  108                     
  109  04:42BA                    .proc _sub_3digit
  110                             __pushw
                                 __submi  2,__stack
       04:A2BA  48                 pha
       04:A2BB  38                 sec
       04:A2BC  A5 00              lda    <__stack
       04:A2BE  E9 02              sbc    #low(2)
       04:A2C0  85 00              sta    <__stack
       04:A2C2  A5 01              lda    <__stack+1
       04:A2C4  E9 00              sbc    #high(2)
       04:A2C6  85 01              sta    <__stack+1
       04:A2C8  68                 pla
       04:A2C9  22                 sax
       04:A2CA  92 00              sta    [__stack]
       04:A2CC  22                 sax
       04:A2CD  A0 01              ldy    #1
       04:A2CF  91 00              sta    [__stack],Y
  111                             __addmi -8,__stack
       04:A2D1  48                 pha
       04:A2D2  18                 clc
       04:A2D3  A5 00              lda    <__stack
       04:A2D5  69 F8              adc    #low(-8)
       04:A2D7  85 00              sta    <__stack
       04:A2D9  A5 01              lda    <__stack+1
       04:A2DB  69 FF              adc    #high(-8)
       04:A2DD  85 01              sta    <__stack+1
       04:A2DF  68                 pla
  112                             __ldw_s 10
                0001              .if (10 < 255)
                                   ; short index (bytes :  7/8, cycles : 18/20)
                0000               .if (10 = 0)
                                   .else
       04:A2E0  A0 0A               ldy   #10
       04:A2E2  B1 00               lda   [__sp],Y
       04:A2E4  AA                  tax
       04:A2E5  C8                  iny
       04:A2E6  B1 00               lda   [__sp],Y
                                   .endif
                                  .else
                                  .endif
  113                             __addwi 2
       04:A2E8  18                 clc
       04:A2E9  22                 sax
       04:A2EA  69 02              adc    #low(2)
       04:A2EC  22                 sax
       04:A2ED  69 00              adc    #high(2)
  114                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:A2EF  86 0B              stx    <__ptr
       04:A2F1  85 0C              sta    <__ptr+1
       04:A2F3  B2 0B              lda    [__ptr]
       04:A2F5  AA                 tax
       04:A2F6  62                 cla
                          ;        bpl    .x_00717   ; signed
                          ;        dec    A
                          ;.x_00717:
  115                             __andwi 255
       04:A2F7  22                 sax
       04:A2F8  29 FF              and    #low(255)
       04:A2FA  22                 sax
       04:A2FB  29 00              and    #high(255)
  116                             __stw_s 6
                0001              .if (6 < 255)
                                   ; short index (bytes :  9, cycles : 22)
                          
       04:A2FD  22                 sax
       04:A2FE  A0 06              ldy    #6
       04:A300  91 00              sta    [__sp],Y
       04:A302  22                 sax
       04:A303  C8                 iny
       04:A304  91 00              sta    [__sp],Y
                                  .else
                                  .endif
  117                             __ldw_s 8
                0001              .if (8 < 255)
                                   ; short index (bytes :  7/8, cycles : 18/20)
                0000               .if (8 = 0)
                                   .else
       04:A306  A0 08               ldy   #8
       04:A308  B1 00               lda   [__sp],Y
       04:A30A  AA                  tax
       04:A30B  C8                  iny
       04:A30C  B1 00               lda   [__sp],Y
                                   .endif
                                  .else
                                  .endif
  118                             __addwi 2
       04:A30E  18                 clc
       04:A30F  22                 sax
       04:A310  69 02              adc    #low(2)
       04:A312  22                 sax
       04:A313  69 00              adc    #high(2)
  119                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:A315  86 0B              stx    <__ptr
       04:A317  85 0C              sta    <__ptr+1
       04:A319  B2 0B              lda    [__ptr]
       04:A31B  AA                 tax
       04:A31C  62                 cla
                          ;        bpl    .x_00722   ; signed
                          ;        dec    A
                          ;.x_00722:
  120                             __andwi 255
       04:A31D  22                 sax
       04:A31E  29 FF              and    #low(255)
       04:A320  22                 sax
       04:A321  29 00              and    #high(255)
  121                             __stw_s 4
                0001              .if (4 < 255)
                                   ; short index (bytes :  9, cycles : 22)
                          
       04:A323  22                 sax
       04:A324  A0 04              ldy    #4
       04:A326  91 00              sta    [__sp],Y
       04:A328  22                 sax
       04:A329  C8                 iny
       04:A32A  91 00              sta    [__sp],Y
                                  .else
                                  .endif
  122                             __ldw_s 6
                0001              .if (6 < 255)
                                   ; short index (bytes :  7/8, cycles : 18/20)
                0000               .if (6 = 0)
                                   .else
       04:A32C  A0 06               ldy   #6
       04:A32E  B1 00               lda   [__sp],Y
       04:A330  AA                  tax
       04:A331  C8                  iny
       04:A332  B1 00               lda   [__sp],Y
                                   .endif
                                  .else
                                  .endif
  123                             __pushw
                                 __submi  2,__stack
       04:A334  48                 pha
       04:A335  38                 sec
       04:A336  A5 00              lda    <__stack
       04:A338  E9 02              sbc    #low(2)
       04:A33A  85 00              sta    <__stack
       04:A33C  A5 01              lda    <__stack+1
       04:A33E  E9 00              sbc    #high(2)
       04:A340  85 01              sta    <__stack+1
       04:A342  68                 pla
       04:A343  22                 sax
       04:A344  92 00              sta    [__stack]
       04:A346  22                 sax
       04:A347  A0 01              ldy    #1
       04:A349  91 00              sta    [__stack],Y
  124                             __ldw_s 6
                0001              .if (6 < 255)
                                   ; short index (bytes :  7/8, cycles : 18/20)
                0000               .if (6 = 0)
                                   .else
       04:A34B  A0 06               ldy   #6
       04:A34D  B1 00               lda   [__sp],Y
       04:A34F  AA                  tax
       04:A350  C8                  iny
       04:A351  B1 00               lda   [__sp],Y
                                   .endif
                                  .else
                                  .endif
  125                             __subws
       04:A353  86 03             stx     <__temp
       04:A355  85 04             sta     <__temp+1
       04:A357  38                sec
       04:A358  B2 00             lda     [__stack]
       04:A35A  E5 03             sbc     <__temp
       04:A35C  AA                tax
       04:A35D  A0 01             ldy     #1
       04:A35F  B1 00             lda     [__stack],Y
       04:A361  E5 04             sbc     <__temp+1
                                  __addmi 2, __stack
       04:A363  48                 pha
       04:A364  18                 clc
       04:A365  A5 00              lda    <__stack
       04:A367  69 02              adc    #low(2)
       04:A369  85 00              sta    <__stack
       04:A36B  A5 01              lda    <__stack+1
       04:A36D  69 00              adc    #high(2)
       04:A36F  85 01              sta    <__stack+1
       04:A371  68                 pla
  126                             __stw_s 2
                0001              .if (2 < 255)
                                   ; short index (bytes :  9, cycles : 22)
                          
       04:A372  22                 sax
       04:A373  A0 02              ldy    #2
       04:A375  91 00              sta    [__sp],Y
       04:A377  22                 sax
       04:A378  C8                 iny
       04:A379  91 00              sta    [__sp],Y
                                  .else
                                  .endif
  127                             __pushw
                                 __submi  2,__stack
       04:A37B  48                 pha
       04:A37C  38                 sec
       04:A37D  A5 00              lda    <__stack
       04:A37F  E9 02              sbc    #low(2)
       04:A381  85 00              sta    <__stack
       04:A383  A5 01              lda    <__stack+1
       04:A385  E9 00              sbc    #high(2)
       04:A387  85 01              sta    <__stack+1
       04:A389  68                 pla
       04:A38A  22                 sax
       04:A38B  92 00              sta    [__stack]
       04:A38D  22                 sax
       04:A38E  A0 01              ldy    #1
       04:A390  91 00              sta    [__stack],Y
  128                             __ldwi  8
       04:A392  A2 08              ldx    #low(8)
       04:A394  A9 00              lda    #high(8)
  129  04:A396  20 E5 C9            jsr   asr
  130                             __andwi 1
       04:A399  22                 sax
       04:A39A  29 01              and    #low(1)
       04:A39C  22                 sax
       04:A39D  29 00              and    #high(1)
  131                             __stw_s 0
                0001              .if (0 < 255)
                                   ; short index (bytes :  9, cycles : 22)
                          
       04:A39F  22                 sax
       04:A3A0  A0 00              ldy    #0
       04:A3A2  91 00              sta    [__sp],Y
       04:A3A4  22                 sax
       04:A3A5  C8                 iny
       04:A3A6  91 00              sta    [__sp],Y
                                  .else
                                  .endif
  132                             __ldwi  _result
       04:A3A8  A2 DE              ldx    #low(_result)
       04:A3AA  A9 31              lda    #high(_result)
  133                             __addwi 2
       04:A3AC  18                 clc
       04:A3AD  22                 sax
       04:A3AE  69 02              adc    #low(2)
       04:A3B0  22                 sax
       04:A3B1  69 00              adc    #high(2)
  134                             __pushw
                                 __submi  2,__stack
       04:A3B3  48                 pha
       04:A3B4  38                 sec
       04:A3B5  A5 00              lda    <__stack
       04:A3B7  E9 02              sbc    #low(2)
       04:A3B9  85 00              sta    <__stack
       04:A3BB  A5 01              lda    <__stack+1
       04:A3BD  E9 00              sbc    #high(2)
       04:A3BF  85 01              sta    <__stack+1
       04:A3C1  68                 pla
       04:A3C2  22                 sax
       04:A3C3  92 00              sta    [__stack]
       04:A3C5  22                 sax
       04:A3C6  A0 01              ldy    #1
       04:A3C8  91 00              sta    [__stack],Y
  135                             __ldw_s 4
                0001              .if (4 < 255)
                                   ; short index (bytes :  7/8, cycles : 18/20)
                0000               .if (4 = 0)
                                   .else
       04:A3CA  A0 04               ldy   #4
       04:A3CC  B1 00               lda   [__sp],Y
       04:A3CE  AA                  tax
       04:A3CF  C8                  iny
       04:A3D0  B1 00               lda   [__sp],Y
                                   .endif
                                  .else
                                  .endif
  136                             __andwi 255
       04:A3D2  22                 sax
       04:A3D3  29 FF              and    #low(255)
       04:A3D5  22                 sax
       04:A3D6  29 00              and    #high(255)
  137                             __stbps
                                 __stw    <__temp
       04:A3D8  86 03              stx    <__temp
       04:A3DA  85 04              sta    <__temp+1
                                 __ldwp    __stack
       04:A3DC  B2 00              lda    [__stack]
       04:A3DE  AA                 tax
       04:A3DF  A0 01              ldy    #1
       04:A3E1  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       04:A3E3  86 0B              stx    <__ptr
       04:A3E5  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       04:A3E7  A6 03              ldx    <__temp
       04:A3E9  A5 04              lda    <__temp+1
                                  .endif
       04:A3EB  22                 sax
       04:A3EC  92 0B              sta    [__ptr]
       04:A3EE  22                 sax
                                 __addmi  2,__stack
       04:A3EF  48                 pha
       04:A3F0  18                 clc
       04:A3F1  A5 00              lda    <__stack
       04:A3F3  69 02              adc    #low(2)
       04:A3F5  85 00              sta    <__stack
       04:A3F7  A5 01              lda    <__stack+1
       04:A3F9  69 00              adc    #high(2)
       04:A3FB  85 01              sta    <__stack+1
       04:A3FD  68                 pla
  138                             __ldw_s 10
                0001              .if (10 < 255)
                                   ; short index (bytes :  7/8, cycles : 18/20)
                0000               .if (10 = 0)
                                   .else
       04:A3FE  A0 0A               ldy   #10
       04:A400  B1 00               lda   [__sp],Y
       04:A402  AA                  tax
       04:A403  C8                  iny
       04:A404  B1 00               lda   [__sp],Y
                                   .endif
                                  .else
                                  .endif
  139                             __addwi 1
       04:A406  18                 clc
       04:A407  22                 sax
       04:A408  69 01              adc    #low(1)
       04:A40A  22                 sax
       04:A40B  69 00              adc    #high(1)
  140                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:A40D  86 0B              stx    <__ptr
       04:A40F  85 0C              sta    <__ptr+1
       04:A411  B2 0B              lda    [__ptr]
       04:A413  AA                 tax
       04:A414  62                 cla
                          ;        bpl    .x_00751   ; signed
                          ;        dec    A
                          ;.x_00751:
  141                             __andwi 255
       04:A415  22                 sax
       04:A416  29 FF              and    #low(255)
       04:A418  22                 sax
       04:A419  29 00              and    #high(255)
  142                             __stw_s 6
                0001              .if (6 < 255)
                                   ; short index (bytes :  9, cycles : 22)
                          
       04:A41B  22                 sax
       04:A41C  A0 06              ldy    #6
       04:A41E  91 00              sta    [__sp],Y
       04:A420  22                 sax
       04:A421  C8                 iny
       04:A422  91 00              sta    [__sp],Y
                                  .else
                                  .endif
  143                             __ldw_s 8
                0001              .if (8 < 255)
                                   ; short index (bytes :  7/8, cycles : 18/20)
                0000               .if (8 = 0)
                                   .else
       04:A424  A0 08               ldy   #8
       04:A426  B1 00               lda   [__sp],Y
       04:A428  AA                  tax
       04:A429  C8                  iny
       04:A42A  B1 00               lda   [__sp],Y
                                   .endif
                                  .else
                                  .endif
  144                             __addwi 1
       04:A42C  18                 clc
       04:A42D  22                 sax
       04:A42E  69 01              adc    #low(1)
       04:A430  22                 sax
       04:A431  69 00              adc    #high(1)
  145                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:A433  86 0B              stx    <__ptr
       04:A435  85 0C              sta    <__ptr+1
       04:A437  B2 0B              lda    [__ptr]
       04:A439  AA                 tax
       04:A43A  62                 cla
                          ;        bpl    .x_00756   ; signed
                          ;        dec    A
                          ;.x_00756:
  146                             __andwi 255
       04:A43B  22                 sax
       04:A43C  29 FF              and    #low(255)
       04:A43E  22                 sax
       04:A43F  29 00              and    #high(255)
  147                             __stw_s 4
                0001              .if (4 < 255)
                                   ; short index (bytes :  9, cycles : 22)
                          
       04:A441  22                 sax
       04:A442  A0 04              ldy    #4
       04:A444  91 00              sta    [__sp],Y
       04:A446  22                 sax
       04:A447  C8                 iny
       04:A448  91 00              sta    [__sp],Y
                                  .else
                                  .endif
  148                             __ldw_s 6
                0001              .if (6 < 255)
                                   ; short index (bytes :  7/8, cycles : 18/20)
                0000               .if (6 = 0)
                                   .else
       04:A44A  A0 06               ldy   #6
       04:A44C  B1 00               lda   [__sp],Y
       04:A44E  AA                  tax
       04:A44F  C8                  iny
       04:A450  B1 00               lda   [__sp],Y
                                   .endif
                                  .else
                                  .endif
  149                             __pushw
                                 __submi  2,__stack
       04:A452  48                 pha
       04:A453  38                 sec
       04:A454  A5 00              lda    <__stack
       04:A456  E9 02              sbc    #low(2)
       04:A458  85 00              sta    <__stack
       04:A45A  A5 01              lda    <__stack+1
       04:A45C  E9 00              sbc    #high(2)
       04:A45E  85 01              sta    <__stack+1
       04:A460  68                 pla
       04:A461  22                 sax
       04:A462  92 00              sta    [__stack]
       04:A464  22                 sax
       04:A465  A0 01              ldy    #1
       04:A467  91 00              sta    [__stack],Y
  150                             __ldw_s 6
                0001              .if (6 < 255)
                                   ; short index (bytes :  7/8, cycles : 18/20)
                0000               .if (6 = 0)
                                   .else
       04:A469  A0 06               ldy   #6
       04:A46B  B1 00               lda   [__sp],Y
       04:A46D  AA                  tax
       04:A46E  C8                  iny
       04:A46F  B1 00               lda   [__sp],Y
                                   .endif
                                  .else
                                  .endif
  151                             __subws
       04:A471  86 03             stx     <__temp
       04:A473  85 04             sta     <__temp+1
       04:A475  38                sec
       04:A476  B2 00             lda     [__stack]
       04:A478  E5 03             sbc     <__temp
       04:A47A  AA                tax
       04:A47B  A0 01             ldy     #1
       04:A47D  B1 00             lda     [__stack],Y
       04:A47F  E5 04             sbc     <__temp+1
                                  __addmi 2, __stack
       04:A481  48                 pha
       04:A482  18                 clc
       04:A483  A5 00              lda    <__stack
       04:A485  69 02              adc    #low(2)
       04:A487  85 00              sta    <__stack
       04:A489  A5 01              lda    <__stack+1
       04:A48B  69 00              adc    #high(2)
       04:A48D  85 01              sta    <__stack+1
       04:A48F  68                 pla
  152                             __pushw
                                 __submi  2,__stack
       04:A490  48                 pha
       04:A491  38                 sec
       04:A492  A5 00              lda    <__stack
       04:A494  E9 02              sbc    #low(2)
       04:A496  85 00              sta    <__stack
       04:A498  A5 01              lda    <__stack+1
       04:A49A  E9 00              sbc    #high(2)
       04:A49C  85 01              sta    <__stack+1
       04:A49E  68                 pla
       04:A49F  22                 sax
       04:A4A0  92 00              sta    [__stack]
       04:A4A2  22                 sax
       04:A4A3  A0 01              ldy    #1
       04:A4A5  91 00              sta    [__stack],Y
  153                             __ldw_s 2
                0001              .if (2 < 255)
                                   ; short index (bytes :  7/8, cycles : 18/20)
                0000               .if (2 = 0)
                                   .else
       04:A4A7  A0 02               ldy   #2
       04:A4A9  B1 00               lda   [__sp],Y
       04:A4AB  AA                  tax
       04:A4AC  C8                  iny
       04:A4AD  B1 00               lda   [__sp],Y
                                   .endif
                                  .else
                                  .endif
  154                             __subws
       04:A4AF  86 03             stx     <__temp
       04:A4B1  85 04             sta     <__temp+1
       04:A4B3  38                sec
       04:A4B4  B2 00             lda     [__stack]
       04:A4B6  E5 03             sbc     <__temp
       04:A4B8  AA                tax
       04:A4B9  A0 01             ldy     #1
       04:A4BB  B1 00             lda     [__stack],Y
       04:A4BD  E5 04             sbc     <__temp+1
                                  __addmi 2, __stack
       04:A4BF  48                 pha
       04:A4C0  18                 clc
       04:A4C1  A5 00              lda    <__stack
       04:A4C3  69 02              adc    #low(2)
       04:A4C5  85 00              sta    <__stack
       04:A4C7  A5 01              lda    <__stack+1
       04:A4C9  69 00              adc    #high(2)
       04:A4CB  85 01              sta    <__stack+1
       04:A4CD  68                 pla
  155                             __stw_s 2
                0001              .if (2 < 255)
                                   ; short index (bytes :  9, cycles : 22)
                          
       04:A4CE  22                 sax
       04:A4CF  A0 02              ldy    #2
       04:A4D1  91 00              sta    [__sp],Y
       04:A4D3  22                 sax
       04:A4D4  C8                 iny
       04:A4D5  91 00              sta    [__sp],Y
                                  .else
                                  .endif
  156                             __pushw
                                 __submi  2,__stack
       04:A4D7  48                 pha
       04:A4D8  38                 sec
       04:A4D9  A5 00              lda    <__stack
       04:A4DB  E9 02              sbc    #low(2)
       04:A4DD  85 00              sta    <__stack
       04:A4DF  A5 01              lda    <__stack+1
       04:A4E1  E9 00              sbc    #high(2)
       04:A4E3  85 01              sta    <__stack+1
       04:A4E5  68                 pla
       04:A4E6  22                 sax
       04:A4E7  92 00              sta    [__stack]
       04:A4E9  22                 sax
       04:A4EA  A0 01              ldy    #1
       04:A4EC  91 00              sta    [__stack],Y
  157                             __ldwi  8
       04:A4EE  A2 08              ldx    #low(8)
       04:A4F0  A9 00              lda    #high(8)
  158  04:A4F2  20 E5 C9            jsr   asr
  159                             __andwi 1
       04:A4F5  22                 sax
       04:A4F6  29 01              and    #low(1)
       04:A4F8  22                 sax
       04:A4F9  29 00              and    #high(1)
  160                             __stw_s 0
                0001              .if (0 < 255)
                                   ; short index (bytes :  9, cycles : 22)
                          
       04:A4FB  22                 sax
       04:A4FC  A0 00              ldy    #0
       04:A4FE  91 00              sta    [__sp],Y
       04:A500  22                 sax
       04:A501  C8                 iny
       04:A502  91 00              sta    [__sp],Y
                                  .else
                                  .endif
  161                             __ldwi  _result
       04:A504  A2 DE              ldx    #low(_result)
       04:A506  A9 31              lda    #high(_result)
  162                             __addwi 1
       04:A508  18                 clc
       04:A509  22                 sax
       04:A50A  69 01              adc    #low(1)
       04:A50C  22                 sax
       04:A50D  69 00              adc    #high(1)
  163                             __pushw
                                 __submi  2,__stack
       04:A50F  48                 pha
       04:A510  38                 sec
       04:A511  A5 00              lda    <__stack
       04:A513  E9 02              sbc    #low(2)
       04:A515  85 00              sta    <__stack
       04:A517  A5 01              lda    <__stack+1
       04:A519  E9 00              sbc    #high(2)
       04:A51B  85 01              sta    <__stack+1
       04:A51D  68                 pla
       04:A51E  22                 sax
       04:A51F  92 00              sta    [__stack]
       04:A521  22                 sax
       04:A522  A0 01              ldy    #1
       04:A524  91 00              sta    [__stack],Y
  164                             __ldw_s 4
                0001              .if (4 < 255)
                                   ; short index (bytes :  7/8, cycles : 18/20)
                0000               .if (4 = 0)
                                   .else
       04:A526  A0 04               ldy   #4
       04:A528  B1 00               lda   [__sp],Y
       04:A52A  AA                  tax
       04:A52B  C8                  iny
       04:A52C  B1 00               lda   [__sp],Y
                                   .endif
                                  .else
                                  .endif
  165                             __andwi 255
       04:A52E  22                 sax
       04:A52F  29 FF              and    #low(255)
       04:A531  22                 sax
       04:A532  29 00              and    #high(255)
  166                             __stbps
                                 __stw    <__temp
       04:A534  86 03              stx    <__temp
       04:A536  85 04              sta    <__temp+1
                                 __ldwp    __stack
       04:A538  B2 00              lda    [__stack]
       04:A53A  AA                 tax
       04:A53B  A0 01              ldy    #1
       04:A53D  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       04:A53F  86 0B              stx    <__ptr
       04:A541  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       04:A543  A6 03              ldx    <__temp
       04:A545  A5 04              lda    <__temp+1
                                  .endif
       04:A547  22                 sax
       04:A548  92 0B              sta    [__ptr]
       04:A54A  22                 sax
                                 __addmi  2,__stack
       04:A54B  48                 pha
       04:A54C  18                 clc
       04:A54D  A5 00              lda    <__stack
       04:A54F  69 02              adc    #low(2)
       04:A551  85 00              sta    <__stack
       04:A553  A5 01              lda    <__stack+1
       04:A555  69 00              adc    #high(2)
       04:A557  85 01              sta    <__stack+1
       04:A559  68                 pla
  167                             __ldw_s 10
                0001              .if (10 < 255)
                                   ; short index (bytes :  7/8, cycles : 18/20)
                0000               .if (10 = 0)
                                   .else
       04:A55A  A0 0A               ldy   #10
       04:A55C  B1 00               lda   [__sp],Y
       04:A55E  AA                  tax
       04:A55F  C8                  iny
       04:A560  B1 00               lda   [__sp],Y
                                   .endif
                                  .else
                                  .endif
  168                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:A562  86 0B              stx    <__ptr
       04:A564  85 0C              sta    <__ptr+1
       04:A566  B2 0B              lda    [__ptr]
       04:A568  AA                 tax
       04:A569  62                 cla
                          ;        bpl    .x_00789   ; signed
                          ;        dec    A
                          ;.x_00789:
  169                             __andwi 255
       04:A56A  22                 sax
       04:A56B  29 FF              and    #low(255)
       04:A56D  22                 sax
       04:A56E  29 00              and    #high(255)
  170                             __stw_s 6
                0001              .if (6 < 255)
                                   ; short index (bytes :  9, cycles : 22)
                          
       04:A570  22                 sax
       04:A571  A0 06              ldy    #6
       04:A573  91 00              sta    [__sp],Y
       04:A575  22                 sax
       04:A576  C8                 iny
       04:A577  91 00              sta    [__sp],Y
                                  .else
                                  .endif
  171                             __ldw_s 8
                0001              .if (8 < 255)
                                   ; short index (bytes :  7/8, cycles : 18/20)
                0000               .if (8 = 0)
                                   .else
       04:A579  A0 08               ldy   #8
       04:A57B  B1 00               lda   [__sp],Y
       04:A57D  AA                  tax
       04:A57E  C8                  iny
       04:A57F  B1 00               lda   [__sp],Y
                                   .endif
                                  .else
                                  .endif
  172                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:A581  86 0B              stx    <__ptr
       04:A583  85 0C              sta    <__ptr+1
       04:A585  B2 0B              lda    [__ptr]
       04:A587  AA                 tax
       04:A588  62                 cla
                          ;        bpl    .x_00793   ; signed
                          ;        dec    A
                          ;.x_00793:
  173                             __andwi 255
       04:A589  22                 sax
       04:A58A  29 FF              and    #low(255)
       04:A58C  22                 sax
       04:A58D  29 00              and    #high(255)
  174                             __stw_s 4
                0001              .if (4 < 255)
                                   ; short index (bytes :  9, cycles : 22)
                          
       04:A58F  22                 sax
       04:A590  A0 04              ldy    #4
       04:A592  91 00              sta    [__sp],Y
       04:A594  22                 sax
       04:A595  C8                 iny
       04:A596  91 00              sta    [__sp],Y
                                  .else
                                  .endif
  175                             __ldw_s 6
                0001              .if (6 < 255)
                                   ; short index (bytes :  7/8, cycles : 18/20)
                0000               .if (6 = 0)
                                   .else
       04:A598  A0 06               ldy   #6
       04:A59A  B1 00               lda   [__sp],Y
       04:A59C  AA                  tax
       04:A59D  C8                  iny
       04:A59E  B1 00               lda   [__sp],Y
                                   .endif
                                  .else
                                  .endif
  176                             __pushw
                                 __submi  2,__stack
       04:A5A0  48                 pha
       04:A5A1  38                 sec
       04:A5A2  A5 00              lda    <__stack
       04:A5A4  E9 02              sbc    #low(2)
       04:A5A6  85 00              sta    <__stack
       04:A5A8  A5 01              lda    <__stack+1
       04:A5AA  E9 00              sbc    #high(2)
       04:A5AC  85 01              sta    <__stack+1
       04:A5AE  68                 pla
       04:A5AF  22                 sax
       04:A5B0  92 00              sta    [__stack]
       04:A5B2  22                 sax
       04:A5B3  A0 01              ldy    #1
       04:A5B5  91 00              sta    [__stack],Y
  177                             __ldw_s 6
                0001              .if (6 < 255)
                                   ; short index (bytes :  7/8, cycles : 18/20)
                0000               .if (6 = 0)
                                   .else
       04:A5B7  A0 06               ldy   #6
       04:A5B9  B1 00               lda   [__sp],Y
       04:A5BB  AA                  tax
       04:A5BC  C8                  iny
       04:A5BD  B1 00               lda   [__sp],Y
                                   .endif
                                  .else
                                  .endif
  178                             __subws
       04:A5BF  86 03             stx     <__temp
       04:A5C1  85 04             sta     <__temp+1
       04:A5C3  38                sec
       04:A5C4  B2 00             lda     [__stack]
       04:A5C6  E5 03             sbc     <__temp
       04:A5C8  AA                tax
       04:A5C9  A0 01             ldy     #1
       04:A5CB  B1 00             lda     [__stack],Y
       04:A5CD  E5 04             sbc     <__temp+1
                                  __addmi 2, __stack
       04:A5CF  48                 pha
       04:A5D0  18                 clc
       04:A5D1  A5 00              lda    <__stack
       04:A5D3  69 02              adc    #low(2)
       04:A5D5  85 00              sta    <__stack
       04:A5D7  A5 01              lda    <__stack+1
       04:A5D9  69 00              adc    #high(2)
       04:A5DB  85 01              sta    <__stack+1
       04:A5DD  68                 pla
  179                             __pushw
                                 __submi  2,__stack
       04:A5DE  48                 pha
       04:A5DF  38                 sec
       04:A5E0  A5 00              lda    <__stack
       04:A5E2  E9 02              sbc    #low(2)
       04:A5E4  85 00              sta    <__stack
       04:A5E6  A5 01              lda    <__stack+1
       04:A5E8  E9 00              sbc    #high(2)
       04:A5EA  85 01              sta    <__stack+1
       04:A5EC  68                 pla
       04:A5ED  22                 sax
       04:A5EE  92 00              sta    [__stack]
       04:A5F0  22                 sax
       04:A5F1  A0 01              ldy    #1
       04:A5F3  91 00              sta    [__stack],Y
  180                             __ldw_s 2
                0001              .if (2 < 255)
                                   ; short index (bytes :  7/8, cycles : 18/20)
                0000               .if (2 = 0)
                                   .else
       04:A5F5  A0 02               ldy   #2
       04:A5F7  B1 00               lda   [__sp],Y
       04:A5F9  AA                  tax
       04:A5FA  C8                  iny
       04:A5FB  B1 00               lda   [__sp],Y
                                   .endif
                                  .else
                                  .endif
  181                             __subws
       04:A5FD  86 03             stx     <__temp
       04:A5FF  85 04             sta     <__temp+1
       04:A601  38                sec
       04:A602  B2 00             lda     [__stack]
       04:A604  E5 03             sbc     <__temp
       04:A606  AA                tax
       04:A607  A0 01             ldy     #1
       04:A609  B1 00             lda     [__stack],Y
       04:A60B  E5 04             sbc     <__temp+1
                                  __addmi 2, __stack
       04:A60D  48                 pha
       04:A60E  18                 clc
       04:A60F  A5 00              lda    <__stack
       04:A611  69 02              adc    #low(2)
       04:A613  85 00              sta    <__stack
       04:A615  A5 01              lda    <__stack+1
       04:A617  69 00              adc    #high(2)
       04:A619  85 01              sta    <__stack+1
       04:A61B  68                 pla
  182                             __stw_s 2
                0001              .if (2 < 255)
                                   ; short index (bytes :  9, cycles : 22)
                          
       04:A61C  22                 sax
       04:A61D  A0 02              ldy    #2
       04:A61F  91 00              sta    [__sp],Y
       04:A621  22                 sax
       04:A622  C8                 iny
       04:A623  91 00              sta    [__sp],Y
                                  .else
                                  .endif
  183                             __ldwi  _result
       04:A625  A2 DE              ldx    #low(_result)
       04:A627  A9 31              lda    #high(_result)
  184                             __pushw
                                 __submi  2,__stack
       04:A629  48                 pha
       04:A62A  38                 sec
       04:A62B  A5 00              lda    <__stack
       04:A62D  E9 02              sbc    #low(2)
       04:A62F  85 00              sta    <__stack
       04:A631  A5 01              lda    <__stack+1
       04:A633  E9 00              sbc    #high(2)
       04:A635  85 01              sta    <__stack+1
       04:A637  68                 pla
       04:A638  22                 sax
       04:A639  92 00              sta    [__stack]
       04:A63B  22                 sax
       04:A63C  A0 01              ldy    #1
       04:A63E  91 00              sta    [__stack],Y
  185                             __ldw_s 4
                0001              .if (4 < 255)
                                   ; short index (bytes :  7/8, cycles : 18/20)
                0000               .if (4 = 0)
                                   .else
       04:A640  A0 04               ldy   #4
       04:A642  B1 00               lda   [__sp],Y
       04:A644  AA                  tax
       04:A645  C8                  iny
       04:A646  B1 00               lda   [__sp],Y
                                   .endif
                                  .else
                                  .endif
  186                             __andwi 255
       04:A648  22                 sax
       04:A649  29 FF              and    #low(255)
       04:A64B  22                 sax
       04:A64C  29 00              and    #high(255)
  187                             __stbps
                                 __stw    <__temp
       04:A64E  86 03              stx    <__temp
       04:A650  85 04              sta    <__temp+1
                                 __ldwp    __stack
       04:A652  B2 00              lda    [__stack]
       04:A654  AA                 tax
       04:A655  A0 01              ldy    #1
       04:A657  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       04:A659  86 0B              stx    <__ptr
       04:A65B  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       04:A65D  A6 03              ldx    <__temp
       04:A65F  A5 04              lda    <__temp+1
                                  .endif
       04:A661  22                 sax
       04:A662  92 0B              sta    [__ptr]
       04:A664  22                 sax
                                 __addmi  2,__stack
       04:A665  48                 pha
       04:A666  18                 clc
       04:A667  A5 00              lda    <__stack
       04:A669  69 02              adc    #low(2)
       04:A66B  85 00              sta    <__stack
       04:A66D  A5 01              lda    <__stack+1
       04:A66F  69 00              adc    #high(2)
       04:A671  85 01              sta    <__stack+1
       04:A673  68                 pla
  188  04:A674            LL2:
  189                     
  190                             __addmi 12,__stack
       04:A674  48                 pha
       04:A675  18                 clc
       04:A676  A5 00              lda    <__stack
       04:A678  69 0C              adc    #low(12)
       04:A67A  85 00              sta    <__stack
       04:A67C  A5 01              lda    <__stack+1
       04:A67E  69 00              adc    #high(12)
       04:A680  85 01              sta    <__stack+1
       04:A682  68                 pla
  191  04:A683  60                  rts
  192                             .endp
  193                     
  194  04:4684                    .proc _show_startpos
  195                             __ldwi  _start_pos
       04:A684  A2 D5              ldx    #low(_start_pos)
       04:A686  A9 31              lda    #high(_start_pos)
  196                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:A688  86 0B              stx    <__ptr
       04:A68A  85 0C              sta    <__ptr+1
       04:A68C  B2 0B              lda    [__ptr]
       04:A68E  AA                 tax
       04:A68F  62                 cla
                          ;        bpl    .x_00821   ; signed
                          ;        dec    A
                          ;.x_00821:
  197                             __phw   4,4
                                   ; #1 (bytes :  9, cycles : 16)
                                   ; #2 (bytes : 16, cycles : 28)
                          
                0001              .if (2 = 2)
       04:A690  A8                 tay
       04:A691  A5 02              lda    <__arg_idx
                                   add    #4
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       04:A693  18                 clc
       04:A694  69 04              adc    #4
                                  .endif
       04:A696  85 02              sta    <__arg_idx
       04:A698  42                 say
                                  .else
                                  .endif
                          
       04:A699  99 FB 31           sta    __arg-(4),Y
       04:A69C  8A                 txa
       04:A69D  99 FC 31           sta    __arg-(4-1),Y
  198                             __ldwi  2
       04:A6A0  A2 02              ldx    #low(2)
       04:A6A2  A9 00              lda    #high(2)
  199                             __phb   2
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       04:A6A4  A4 02              ldy    <__arg_idx
                                  .endif
                          
       04:A6A6  8A                 txa
       04:A6A7  99 FD 31           sta    __arg-(2),Y
  200                             __ldwi  14
       04:A6AA  A2 0E              ldx    #low(14)
       04:A6AC  A9 00              lda    #high(14)
  201                             __phb   1
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       04:A6AE  A4 02              ldy    <__arg_idx
                                  .endif
                          
       04:A6B0  8A                 txa
       04:A6B1  99 FE 31           sta    __arg-(1),Y
  202                             __ldwi  5
       04:A6B4  A2 05              ldx    #low(5)
       04:A6B6  A9 00              lda    #high(5)
  203  04:A6B8  20 8B CE            call  _put_hex.4
  204                             __ldwi  _start_pos
       04:A6BB  A2 D5              ldx    #low(_start_pos)
       04:A6BD  A9 31              lda    #high(_start_pos)
  205                             __addwi 1
       04:A6BF  18                 clc
       04:A6C0  22                 sax
       04:A6C1  69 01              adc    #low(1)
       04:A6C3  22                 sax
       04:A6C4  69 00              adc    #high(1)
  206                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:A6C6  86 0B              stx    <__ptr
       04:A6C8  85 0C              sta    <__ptr+1
       04:A6CA  B2 0B              lda    [__ptr]
       04:A6CC  AA                 tax
       04:A6CD  62                 cla
                          ;        bpl    .x_00831   ; signed
                          ;        dec    A
                          ;.x_00831:
  207                             __phw   4,4
                                   ; #1 (bytes :  9, cycles : 16)
                                   ; #2 (bytes : 16, cycles : 28)
                          
                0001              .if (2 = 2)
       04:A6CE  A8                 tay
       04:A6CF  A5 02              lda    <__arg_idx
                                   add    #4
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       04:A6D1  18                 clc
       04:A6D2  69 04              adc    #4
                                  .endif
       04:A6D4  85 02              sta    <__arg_idx
       04:A6D6  42                 say
                                  .else
                                  .endif
                          
       04:A6D7  99 FB 31           sta    __arg-(4),Y
       04:A6DA  8A                 txa
       04:A6DB  99 FC 31           sta    __arg-(4-1),Y
  208                             __ldwi  2
       04:A6DE  A2 02              ldx    #low(2)
       04:A6E0  A9 00              lda    #high(2)
  209                             __phb   2
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       04:A6E2  A4 02              ldy    <__arg_idx
                                  .endif
                          
       04:A6E4  8A                 txa
       04:A6E5  99 FD 31           sta    __arg-(2),Y
  210                             __ldwi  16
       04:A6E8  A2 10              ldx    #low(16)
       04:A6EA  A9 00              lda    #high(16)
  211                             __phb   1
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       04:A6EC  A4 02              ldy    <__arg_idx
                                  .endif
                          
       04:A6EE  8A                 txa
       04:A6EF  99 FE 31           sta    __arg-(1),Y
  212                             __ldwi  5
       04:A6F2  A2 05              ldx    #low(5)
       04:A6F4  A9 00              lda    #high(5)
  213  04:A6F6  20 8B CE            call  _put_hex.4
  214                             __ldwi  _start_pos
       04:A6F9  A2 D5              ldx    #low(_start_pos)
       04:A6FB  A9 31              lda    #high(_start_pos)
  215                             __addwi 2
       04:A6FD  18                 clc
       04:A6FE  22                 sax
       04:A6FF  69 02              adc    #low(2)
       04:A701  22                 sax
       04:A702  69 00              adc    #high(2)
  216                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:A704  86 0B              stx    <__ptr
       04:A706  85 0C              sta    <__ptr+1
       04:A708  B2 0B              lda    [__ptr]
       04:A70A  AA                 tax
       04:A70B  62                 cla
                          ;        bpl    .x_00841   ; signed
                          ;        dec    A
                          ;.x_00841:
  217                             __phw   4,4
                                   ; #1 (bytes :  9, cycles : 16)
                                   ; #2 (bytes : 16, cycles : 28)
                          
                0001              .if (2 = 2)
       04:A70C  A8                 tay
       04:A70D  A5 02              lda    <__arg_idx
                                   add    #4
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       04:A70F  18                 clc
       04:A710  69 04              adc    #4
                                  .endif
       04:A712  85 02              sta    <__arg_idx
       04:A714  42                 say
                                  .else
                                  .endif
                          
       04:A715  99 FB 31           sta    __arg-(4),Y
       04:A718  8A                 txa
       04:A719  99 FC 31           sta    __arg-(4-1),Y
  218                             __ldwi  2
       04:A71C  A2 02              ldx    #low(2)
       04:A71E  A9 00              lda    #high(2)
  219                             __phb   2
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       04:A720  A4 02              ldy    <__arg_idx
                                  .endif
                          
       04:A722  8A                 txa
       04:A723  99 FD 31           sta    __arg-(2),Y
  220                             __ldwi  18
       04:A726  A2 12              ldx    #low(18)
       04:A728  A9 00              lda    #high(18)
  221                             __phb   1
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       04:A72A  A4 02              ldy    <__arg_idx
                                  .endif
                          
       04:A72C  8A                 txa
       04:A72D  99 FE 31           sta    __arg-(1),Y
  222                             __ldwi  5
       04:A730  A2 05              ldx    #low(5)
       04:A732  A9 00              lda    #high(5)
  223  04:A734  20 8B CE            call  _put_hex.4
  224  04:A737            LL3:
  225                     
  226  04:A737  60                  rts
  227                             .endp
  228                     
  229  04:4738                    .proc _show_offset
  230                             __ldwi  _offset
       04:A738  A2 D8              ldx    #low(_offset)
       04:A73A  A9 31              lda    #high(_offset)
  231                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:A73C  86 0B              stx    <__ptr
       04:A73E  85 0C              sta    <__ptr+1
       04:A740  B2 0B              lda    [__ptr]
       04:A742  AA                 tax
       04:A743  62                 cla
                          ;        bpl    .x_00850   ; signed
                          ;        dec    A
                          ;.x_00850:
  232                             __phw   4,4
                                   ; #1 (bytes :  9, cycles : 16)
                                   ; #2 (bytes : 16, cycles : 28)
                          
                0001              .if (2 = 2)
       04:A744  A8                 tay
       04:A745  A5 02              lda    <__arg_idx
                                   add    #4
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       04:A747  18                 clc
       04:A748  69 04              adc    #4
                                  .endif
       04:A74A  85 02              sta    <__arg_idx
       04:A74C  42                 say
                                  .else
                                  .endif
                          
       04:A74D  99 FB 31           sta    __arg-(4),Y
       04:A750  8A                 txa
       04:A751  99 FC 31           sta    __arg-(4-1),Y
  233                             __ldwi  2
       04:A754  A2 02              ldx    #low(2)
       04:A756  A9 00              lda    #high(2)
  234                             __phb   2
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       04:A758  A4 02              ldy    <__arg_idx
                                  .endif
                          
       04:A75A  8A                 txa
       04:A75B  99 FD 31           sta    __arg-(2),Y
  235                             __ldwi  14
       04:A75E  A2 0E              ldx    #low(14)
       04:A760  A9 00              lda    #high(14)
  236                             __phb   1
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       04:A762  A4 02              ldy    <__arg_idx
                                  .endif
                          
       04:A764  8A                 txa
       04:A765  99 FE 31           sta    __arg-(1),Y
  237                             __ldwi  7
       04:A768  A2 07              ldx    #low(7)
       04:A76A  A9 00              lda    #high(7)
  238  04:A76C  20 8B CE            call  _put_hex.4
  239                             __ldwi  _offset
       04:A76F  A2 D8              ldx    #low(_offset)
       04:A771  A9 31              lda    #high(_offset)
  240                             __addwi 1
       04:A773  18                 clc
       04:A774  22                 sax
       04:A775  69 01              adc    #low(1)
       04:A777  22                 sax
       04:A778  69 00              adc    #high(1)
  241                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:A77A  86 0B              stx    <__ptr
       04:A77C  85 0C              sta    <__ptr+1
       04:A77E  B2 0B              lda    [__ptr]
       04:A780  AA                 tax
       04:A781  62                 cla
                          ;        bpl    .x_00860   ; signed
                          ;        dec    A
                          ;.x_00860:
  242                             __phw   4,4
                                   ; #1 (bytes :  9, cycles : 16)
                                   ; #2 (bytes : 16, cycles : 28)
                          
                0001              .if (2 = 2)
       04:A782  A8                 tay
       04:A783  A5 02              lda    <__arg_idx
                                   add    #4
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       04:A785  18                 clc
       04:A786  69 04              adc    #4
                                  .endif
       04:A788  85 02              sta    <__arg_idx
       04:A78A  42                 say
                                  .else
                                  .endif
                          
       04:A78B  99 FB 31           sta    __arg-(4),Y
       04:A78E  8A                 txa
       04:A78F  99 FC 31           sta    __arg-(4-1),Y
  243                             __ldwi  2
       04:A792  A2 02              ldx    #low(2)
       04:A794  A9 00              lda    #high(2)
  244                             __phb   2
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       04:A796  A4 02              ldy    <__arg_idx
                                  .endif
                          
       04:A798  8A                 txa
       04:A799  99 FD 31           sta    __arg-(2),Y
  245                             __ldwi  16
       04:A79C  A2 10              ldx    #low(16)
       04:A79E  A9 00              lda    #high(16)
  246                             __phb   1
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       04:A7A0  A4 02              ldy    <__arg_idx
                                  .endif
                          
       04:A7A2  8A                 txa
       04:A7A3  99 FE 31           sta    __arg-(1),Y
  247                             __ldwi  7
       04:A7A6  A2 07              ldx    #low(7)
       04:A7A8  A9 00              lda    #high(7)
  248  04:A7AA  20 8B CE            call  _put_hex.4
  249                             __ldwi  _offset
       04:A7AD  A2 D8              ldx    #low(_offset)
       04:A7AF  A9 31              lda    #high(_offset)
  250                             __addwi 2
       04:A7B1  18                 clc
       04:A7B2  22                 sax
       04:A7B3  69 02              adc    #low(2)
       04:A7B5  22                 sax
       04:A7B6  69 00              adc    #high(2)
  251                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:A7B8  86 0B              stx    <__ptr
       04:A7BA  85 0C              sta    <__ptr+1
       04:A7BC  B2 0B              lda    [__ptr]
       04:A7BE  AA                 tax
       04:A7BF  62                 cla
                          ;        bpl    .x_00870   ; signed
                          ;        dec    A
                          ;.x_00870:
  252                             __phw   4,4
                                   ; #1 (bytes :  9, cycles : 16)
                                   ; #2 (bytes : 16, cycles : 28)
                          
                0001              .if (2 = 2)
       04:A7C0  A8                 tay
       04:A7C1  A5 02              lda    <__arg_idx
                                   add    #4
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       04:A7C3  18                 clc
       04:A7C4  69 04              adc    #4
                                  .endif
       04:A7C6  85 02              sta    <__arg_idx
       04:A7C8  42                 say
                                  .else
                                  .endif
                          
       04:A7C9  99 FB 31           sta    __arg-(4),Y
       04:A7CC  8A                 txa
       04:A7CD  99 FC 31           sta    __arg-(4-1),Y
  253                             __ldwi  2
       04:A7D0  A2 02              ldx    #low(2)
       04:A7D2  A9 00              lda    #high(2)
  254                             __phb   2
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       04:A7D4  A4 02              ldy    <__arg_idx
                                  .endif
                          
       04:A7D6  8A                 txa
       04:A7D7  99 FD 31           sta    __arg-(2),Y
  255                             __ldwi  18
       04:A7DA  A2 12              ldx    #low(18)
       04:A7DC  A9 00              lda    #high(18)
  256                             __phb   1
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       04:A7DE  A4 02              ldy    <__arg_idx
                                  .endif
                          
       04:A7E0  8A                 txa
       04:A7E1  99 FE 31           sta    __arg-(1),Y
  257                             __ldwi  7
       04:A7E4  A2 07              ldx    #low(7)
       04:A7E6  A9 00              lda    #high(7)
  258  04:A7E8  20 8B CE            call  _put_hex.4
  259  04:A7EB            LL4:
  260                     
  261  04:A7EB  60                  rts
  262                             .endp
  263                     
  264  04:47EC                    .proc _show_target
  265                             __ldwi  _target
       04:A7EC  A2 DB              ldx    #low(_target)
       04:A7EE  A9 31              lda    #high(_target)
  266                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:A7F0  86 0B              stx    <__ptr
       04:A7F2  85 0C              sta    <__ptr+1
       04:A7F4  B2 0B              lda    [__ptr]
       04:A7F6  AA                 tax
       04:A7F7  62                 cla
                          ;        bpl    .x_00879   ; signed
                          ;        dec    A
                          ;.x_00879:
  267                             __phw   4,4
                                   ; #1 (bytes :  9, cycles : 16)
                                   ; #2 (bytes : 16, cycles : 28)
                          
                0001              .if (2 = 2)
       04:A7F8  A8                 tay
       04:A7F9  A5 02              lda    <__arg_idx
                                   add    #4
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       04:A7FB  18                 clc
       04:A7FC  69 04              adc    #4
                                  .endif
       04:A7FE  85 02              sta    <__arg_idx
       04:A800  42                 say
                                  .else
                                  .endif
                          
       04:A801  99 FB 31           sta    __arg-(4),Y
       04:A804  8A                 txa
       04:A805  99 FC 31           sta    __arg-(4-1),Y
  268                             __ldwi  2
       04:A808  A2 02              ldx    #low(2)
       04:A80A  A9 00              lda    #high(2)
  269                             __phb   2
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       04:A80C  A4 02              ldy    <__arg_idx
                                  .endif
                          
       04:A80E  8A                 txa
       04:A80F  99 FD 31           sta    __arg-(2),Y
  270                             __ldwi  14
       04:A812  A2 0E              ldx    #low(14)
       04:A814  A9 00              lda    #high(14)
  271                             __phb   1
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       04:A816  A4 02              ldy    <__arg_idx
                                  .endif
                          
       04:A818  8A                 txa
       04:A819  99 FE 31           sta    __arg-(1),Y
  272                             __ldwi  9
       04:A81C  A2 09              ldx    #low(9)
       04:A81E  A9 00              lda    #high(9)
  273  04:A820  20 8B CE            call  _put_hex.4
  274                             __ldwi  _target
       04:A823  A2 DB              ldx    #low(_target)
       04:A825  A9 31              lda    #high(_target)
  275                             __addwi 1
       04:A827  18                 clc
       04:A828  22                 sax
       04:A829  69 01              adc    #low(1)
       04:A82B  22                 sax
       04:A82C  69 00              adc    #high(1)
  276                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:A82E  86 0B              stx    <__ptr
       04:A830  85 0C              sta    <__ptr+1
       04:A832  B2 0B              lda    [__ptr]
       04:A834  AA                 tax
       04:A835  62                 cla
                          ;        bpl    .x_00889   ; signed
                          ;        dec    A
                          ;.x_00889:
  277                             __phw   4,4
                                   ; #1 (bytes :  9, cycles : 16)
                                   ; #2 (bytes : 16, cycles : 28)
                          
                0001              .if (2 = 2)
       04:A836  A8                 tay
       04:A837  A5 02              lda    <__arg_idx
                                   add    #4
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       04:A839  18                 clc
       04:A83A  69 04              adc    #4
                                  .endif
       04:A83C  85 02              sta    <__arg_idx
       04:A83E  42                 say
                                  .else
                                  .endif
                          
       04:A83F  99 FB 31           sta    __arg-(4),Y
       04:A842  8A                 txa
       04:A843  99 FC 31           sta    __arg-(4-1),Y
  278                             __ldwi  2
       04:A846  A2 02              ldx    #low(2)
       04:A848  A9 00              lda    #high(2)
  279                             __phb   2
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       04:A84A  A4 02              ldy    <__arg_idx
                                  .endif
                          
       04:A84C  8A                 txa
       04:A84D  99 FD 31           sta    __arg-(2),Y
  280                             __ldwi  16
       04:A850  A2 10              ldx    #low(16)
       04:A852  A9 00              lda    #high(16)
  281                             __phb   1
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       04:A854  A4 02              ldy    <__arg_idx
                                  .endif
                          
       04:A856  8A                 txa
       04:A857  99 FE 31           sta    __arg-(1),Y
  282                             __ldwi  9
       04:A85A  A2 09              ldx    #low(9)
       04:A85C  A9 00              lda    #high(9)
  283  04:A85E  20 8B CE            call  _put_hex.4
  284                             __ldwi  _target
       04:A861  A2 DB              ldx    #low(_target)
       04:A863  A9 31              lda    #high(_target)
  285                             __addwi 2
       04:A865  18                 clc
       04:A866  22                 sax
       04:A867  69 02              adc    #low(2)
       04:A869  22                 sax
       04:A86A  69 00              adc    #high(2)
  286                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:A86C  86 0B              stx    <__ptr
       04:A86E  85 0C              sta    <__ptr+1
       04:A870  B2 0B              lda    [__ptr]
       04:A872  AA                 tax
       04:A873  62                 cla
                          ;        bpl    .x_00899   ; signed
                          ;        dec    A
                          ;.x_00899:
  287                             __phw   4,4
                                   ; #1 (bytes :  9, cycles : 16)
                                   ; #2 (bytes : 16, cycles : 28)
                          
                0001              .if (2 = 2)
       04:A874  A8                 tay
       04:A875  A5 02              lda    <__arg_idx
                                   add    #4
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       04:A877  18                 clc
       04:A878  69 04              adc    #4
                                  .endif
       04:A87A  85 02              sta    <__arg_idx
       04:A87C  42                 say
                                  .else
                                  .endif
                          
       04:A87D  99 FB 31           sta    __arg-(4),Y
       04:A880  8A                 txa
       04:A881  99 FC 31           sta    __arg-(4-1),Y
  288                             __ldwi  2
       04:A884  A2 02              ldx    #low(2)
       04:A886  A9 00              lda    #high(2)
  289                             __phb   2
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       04:A888  A4 02              ldy    <__arg_idx
                                  .endif
                          
       04:A88A  8A                 txa
       04:A88B  99 FD 31           sta    __arg-(2),Y
  290                             __ldwi  18
       04:A88E  A2 12              ldx    #low(18)
       04:A890  A9 00              lda    #high(18)
  291                             __phb   1
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       04:A892  A4 02              ldy    <__arg_idx
                                  .endif
                          
       04:A894  8A                 txa
       04:A895  99 FE 31           sta    __arg-(1),Y
  292                             __ldwi  9
       04:A898  A2 09              ldx    #low(9)
       04:A89A  A9 00              lda    #high(9)
  293  04:A89C  20 8B CE            call  _put_hex.4
  294  04:A89F            LL5:
  295                     
  296  04:A89F  60                  rts
  297                             .endp
  298                     
  299  04:48A0                    .proc _limit_startpos
  300                             __ldwi  _result
       04:A8A0  A2 DE              ldx    #low(_result)
       04:A8A2  A9 31              lda    #high(_result)
  301                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:A8A4  86 0B              stx    <__ptr
       04:A8A6  85 0C              sta    <__ptr+1
       04:A8A8  B2 0B              lda    [__ptr]
       04:A8AA  AA                 tax
       04:A8AB  62                 cla
                          ;        bpl    .x_00908   ; signed
                          ;        dec    A
                          ;.x_00908:
  302                             __stw   <__temp
       04:A8AC  86 03              stx    <__temp
       04:A8AE  85 04              sta    <__temp+1
  303                             __ldwi  0
       04:A8B0  A2 00              ldx    #low(0)
       04:A8B2  A9 00              lda    #high(0)
  304  04:A8B4  20 FF C8            jsr   ltzp
  305                             __lbne  LL8
       04:A8B7  F0 03              beq    .x00911
       04:A8B9  4C D3 A8           jmp    LL8
       04:A8BC            .x00911
  306                             __ldwi  _result
       04:A8BC  A2 DE              ldx    #low(_result)
       04:A8BE  A9 31              lda    #high(_result)
  307                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:A8C0  86 0B              stx    <__ptr
       04:A8C2  85 0C              sta    <__ptr+1
       04:A8C4  B2 0B              lda    [__ptr]
       04:A8C6  AA                 tax
       04:A8C7  62                 cla
                          ;        bpl    .x_00913   ; signed
                          ;        dec    A
                          ;.x_00913:
  308                             __stw   <__temp
       04:A8C8  86 03              stx    <__temp
       04:A8CA  85 04              sta    <__temp+1
  309                             __ldwi  128
       04:A8CC  A2 80              ldx    #low(128)
       04:A8CE  A9 00              lda    #high(128)
  310  04:A8D0  20 56 C9            jsr   gezp
  311  04:A8D3            LL8:
  312                     
  313                             __boolw
       04:A8D3  86 03              stx    <__temp
       04:A8D5  05 03              ora    <__temp
       04:A8D7  82                 clx
       04:A8D8  F0 01              beq    .x00916
       04:A8DA  E8                 inx
       04:A8DB  62        .x00916     cla
  314                             __tstw
                                   ; pha
       04:A8DC  86 03              stx    <__temp
       04:A8DE  05 03              ora    <__temp
                                   ; pla
  315                             __lbeq  LL7
       04:A8E0  D0 03              bne    .x00918
       04:A8E2  4C C2 A9           jmp    LL7
       04:A8E5            .x00918
  316                             __ldwi  _result
       04:A8E5  A2 DE              ldx    #low(_result)
       04:A8E7  A9 31              lda    #high(_result)
  317                             __pushw
                                 __submi  2,__stack
       04:A8E9  48                 pha
       04:A8EA  38                 sec
       04:A8EB  A5 00              lda    <__stack
       04:A8ED  E9 02              sbc    #low(2)
       04:A8EF  85 00              sta    <__stack
       04:A8F1  A5 01              lda    <__stack+1
       04:A8F3  E9 00              sbc    #high(2)
       04:A8F5  85 01              sta    <__stack+1
       04:A8F7  68                 pla
       04:A8F8  22                 sax
       04:A8F9  92 00              sta    [__stack]
       04:A8FB  22                 sax
       04:A8FC  A0 01              ldy    #1
       04:A8FE  91 00              sta    [__stack],Y
  318                             __ldwi  0
       04:A900  A2 00              ldx    #low(0)
       04:A902  A9 00              lda    #high(0)
  319                             __stbps
                                 __stw    <__temp
       04:A904  86 03              stx    <__temp
       04:A906  85 04              sta    <__temp+1
                                 __ldwp    __stack
       04:A908  B2 00              lda    [__stack]
       04:A90A  AA                 tax
       04:A90B  A0 01              ldy    #1
       04:A90D  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       04:A90F  86 0B              stx    <__ptr
       04:A911  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       04:A913  A6 03              ldx    <__temp
       04:A915  A5 04              lda    <__temp+1
                                  .endif
       04:A917  22                 sax
       04:A918  92 0B              sta    [__ptr]
       04:A91A  22                 sax
                                 __addmi  2,__stack
       04:A91B  48                 pha
       04:A91C  18                 clc
       04:A91D  A5 00              lda    <__stack
       04:A91F  69 02              adc    #low(2)
       04:A921  85 00              sta    <__stack
       04:A923  A5 01              lda    <__stack+1
       04:A925  69 00              adc    #high(2)
       04:A927  85 01              sta    <__stack+1
       04:A929  68                 pla
  320                             __ldwi  _result
       04:A92A  A2 DE              ldx    #low(_result)
       04:A92C  A9 31              lda    #high(_result)
  321                             __addwi 1
       04:A92E  18                 clc
       04:A92F  22                 sax
       04:A930  69 01              adc    #low(1)
       04:A932  22                 sax
       04:A933  69 00              adc    #high(1)
  322                             __pushw
                                 __submi  2,__stack
       04:A935  48                 pha
       04:A936  38                 sec
       04:A937  A5 00              lda    <__stack
       04:A939  E9 02              sbc    #low(2)
       04:A93B  85 00              sta    <__stack
       04:A93D  A5 01              lda    <__stack+1
       04:A93F  E9 00              sbc    #high(2)
       04:A941  85 01              sta    <__stack+1
       04:A943  68                 pla
       04:A944  22                 sax
       04:A945  92 00              sta    [__stack]
       04:A947  22                 sax
       04:A948  A0 01              ldy    #1
       04:A94A  91 00              sta    [__stack],Y
  323                             __ldwi  0
       04:A94C  A2 00              ldx    #low(0)
       04:A94E  A9 00              lda    #high(0)
  324                             __stbps
                                 __stw    <__temp
       04:A950  86 03              stx    <__temp
       04:A952  85 04              sta    <__temp+1
                                 __ldwp    __stack
       04:A954  B2 00              lda    [__stack]
       04:A956  AA                 tax
       04:A957  A0 01              ldy    #1
       04:A959  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       04:A95B  86 0B              stx    <__ptr
       04:A95D  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       04:A95F  A6 03              ldx    <__temp
       04:A961  A5 04              lda    <__temp+1
                                  .endif
       04:A963  22                 sax
       04:A964  92 0B              sta    [__ptr]
       04:A966  22                 sax
                                 __addmi  2,__stack
       04:A967  48                 pha
       04:A968  18                 clc
       04:A969  A5 00              lda    <__stack
       04:A96B  69 02              adc    #low(2)
       04:A96D  85 00              sta    <__stack
       04:A96F  A5 01              lda    <__stack+1
       04:A971  69 00              adc    #high(2)
       04:A973  85 01              sta    <__stack+1
       04:A975  68                 pla
  325                             __ldwi  _result
       04:A976  A2 DE              ldx    #low(_result)
       04:A978  A9 31              lda    #high(_result)
  326                             __addwi 2
       04:A97A  18                 clc
       04:A97B  22                 sax
       04:A97C  69 02              adc    #low(2)
       04:A97E  22                 sax
       04:A97F  69 00              adc    #high(2)
  327                             __pushw
                                 __submi  2,__stack
       04:A981  48                 pha
       04:A982  38                 sec
       04:A983  A5 00              lda    <__stack
       04:A985  E9 02              sbc    #low(2)
       04:A987  85 00              sta    <__stack
       04:A989  A5 01              lda    <__stack+1
       04:A98B  E9 00              sbc    #high(2)
       04:A98D  85 01              sta    <__stack+1
       04:A98F  68                 pla
       04:A990  22                 sax
       04:A991  92 00              sta    [__stack]
       04:A993  22                 sax
       04:A994  A0 01              ldy    #1
       04:A996  91 00              sta    [__stack],Y
  328                             __ldwi  0
       04:A998  A2 00              ldx    #low(0)
       04:A99A  A9 00              lda    #high(0)
  329                             __stbps
                                 __stw    <__temp
       04:A99C  86 03              stx    <__temp
       04:A99E  85 04              sta    <__temp+1
                                 __ldwp    __stack
       04:A9A0  B2 00              lda    [__stack]
       04:A9A2  AA                 tax
       04:A9A3  A0 01              ldy    #1
       04:A9A5  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       04:A9A7  86 0B              stx    <__ptr
       04:A9A9  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       04:A9AB  A6 03              ldx    <__temp
       04:A9AD  A5 04              lda    <__temp+1
                                  .endif
       04:A9AF  22                 sax
       04:A9B0  92 0B              sta    [__ptr]
       04:A9B2  22                 sax
                                 __addmi  2,__stack
       04:A9B3  48                 pha
       04:A9B4  18                 clc
       04:A9B5  A5 00              lda    <__stack
       04:A9B7  69 02              adc    #low(2)
       04:A9B9  85 00              sta    <__stack
       04:A9BB  A5 01              lda    <__stack+1
       04:A9BD  69 00              adc    #high(2)
       04:A9BF  85 01              sta    <__stack+1
       04:A9C1  68                 pla
  330  04:A9C2            LL7:
  331                     
  332                             __ldwi  _result
       04:A9C2  A2 DE              ldx    #low(_result)
       04:A9C4  A9 31              lda    #high(_result)
  333                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:A9C6  86 0B              stx    <__ptr
       04:A9C8  85 0C              sta    <__ptr+1
       04:A9CA  B2 0B              lda    [__ptr]
       04:A9CC  AA                 tax
       04:A9CD  62                 cla
                          ;        bpl    .x_00952   ; signed
                          ;        dec    A
                          ;.x_00952:
  334                             __stw   <__temp
       04:A9CE  86 03              stx    <__temp
       04:A9D0  85 04              sta    <__temp+1
  335                             __ldwi  4
       04:A9D2  A2 04              ldx    #low(4)
       04:A9D4  A9 00              lda    #high(4)
  336  04:A9D6  20 28 C9            jsr   gtzp
  337                             __lbeq  LL9
       04:A9D9  D0 03              bne    .x00955
       04:A9DB  4C BB AA           jmp    LL9
       04:A9DE            .x00955
  338                             __ldwi  _result
       04:A9DE  A2 DE              ldx    #low(_result)
       04:A9E0  A9 31              lda    #high(_result)
  339                             __pushw
                                 __submi  2,__stack
       04:A9E2  48                 pha
       04:A9E3  38                 sec
       04:A9E4  A5 00              lda    <__stack
       04:A9E6  E9 02              sbc    #low(2)
       04:A9E8  85 00              sta    <__stack
       04:A9EA  A5 01              lda    <__stack+1
       04:A9EC  E9 00              sbc    #high(2)
       04:A9EE  85 01              sta    <__stack+1
       04:A9F0  68                 pla
       04:A9F1  22                 sax
       04:A9F2  92 00              sta    [__stack]
       04:A9F4  22                 sax
       04:A9F5  A0 01              ldy    #1
       04:A9F7  91 00              sta    [__stack],Y
  340                             __ldwi  4
       04:A9F9  A2 04              ldx    #low(4)
       04:A9FB  A9 00              lda    #high(4)
  341                             __stbps
                                 __stw    <__temp
       04:A9FD  86 03              stx    <__temp
       04:A9FF  85 04              sta    <__temp+1
                                 __ldwp    __stack
       04:AA01  B2 00              lda    [__stack]
       04:AA03  AA                 tax
       04:AA04  A0 01              ldy    #1
       04:AA06  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       04:AA08  86 0B              stx    <__ptr
       04:AA0A  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       04:AA0C  A6 03              ldx    <__temp
       04:AA0E  A5 04              lda    <__temp+1
                                  .endif
       04:AA10  22                 sax
       04:AA11  92 0B              sta    [__ptr]
       04:AA13  22                 sax
                                 __addmi  2,__stack
       04:AA14  48                 pha
       04:AA15  18                 clc
       04:AA16  A5 00              lda    <__stack
       04:AA18  69 02              adc    #low(2)
       04:AA1A  85 00              sta    <__stack
       04:AA1C  A5 01              lda    <__stack+1
       04:AA1E  69 00              adc    #high(2)
       04:AA20  85 01              sta    <__stack+1
       04:AA22  68                 pla
  342                             __ldwi  _result
       04:AA23  A2 DE              ldx    #low(_result)
       04:AA25  A9 31              lda    #high(_result)
  343                             __addwi 1
       04:AA27  18                 clc
       04:AA28  22                 sax
       04:AA29  69 01              adc    #low(1)
       04:AA2B  22                 sax
       04:AA2C  69 00              adc    #high(1)
  344                             __pushw
                                 __submi  2,__stack
       04:AA2E  48                 pha
       04:AA2F  38                 sec
       04:AA30  A5 00              lda    <__stack
       04:AA32  E9 02              sbc    #low(2)
       04:AA34  85 00              sta    <__stack
       04:AA36  A5 01              lda    <__stack+1
       04:AA38  E9 00              sbc    #high(2)
       04:AA3A  85 01              sta    <__stack+1
       04:AA3C  68                 pla
       04:AA3D  22                 sax
       04:AA3E  92 00              sta    [__stack]
       04:AA40  22                 sax
       04:AA41  A0 01              ldy    #1
       04:AA43  91 00              sta    [__stack],Y
  345                             __ldwi  255
       04:AA45  A2 FF              ldx    #low(255)
       04:AA47  A9 00              lda    #high(255)
  346                             __stbps
                                 __stw    <__temp
       04:AA49  86 03              stx    <__temp
       04:AA4B  85 04              sta    <__temp+1
                                 __ldwp    __stack
       04:AA4D  B2 00              lda    [__stack]
       04:AA4F  AA                 tax
       04:AA50  A0 01              ldy    #1
       04:AA52  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       04:AA54  86 0B              stx    <__ptr
       04:AA56  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       04:AA58  A6 03              ldx    <__temp
       04:AA5A  A5 04              lda    <__temp+1
                                  .endif
       04:AA5C  22                 sax
       04:AA5D  92 0B              sta    [__ptr]
       04:AA5F  22                 sax
                                 __addmi  2,__stack
       04:AA60  48                 pha
       04:AA61  18                 clc
       04:AA62  A5 00              lda    <__stack
       04:AA64  69 02              adc    #low(2)
       04:AA66  85 00              sta    <__stack
       04:AA68  A5 01              lda    <__stack+1
       04:AA6A  69 00              adc    #high(2)
       04:AA6C  85 01              sta    <__stack+1
       04:AA6E  68                 pla
  347                             __ldwi  _result
       04:AA6F  A2 DE              ldx    #low(_result)
       04:AA71  A9 31              lda    #high(_result)
  348                             __addwi 2
       04:AA73  18                 clc
       04:AA74  22                 sax
       04:AA75  69 02              adc    #low(2)
       04:AA77  22                 sax
       04:AA78  69 00              adc    #high(2)
  349                             __pushw
                                 __submi  2,__stack
       04:AA7A  48                 pha
       04:AA7B  38                 sec
       04:AA7C  A5 00              lda    <__stack
       04:AA7E  E9 02              sbc    #low(2)
       04:AA80  85 00              sta    <__stack
       04:AA82  A5 01              lda    <__stack+1
       04:AA84  E9 00              sbc    #high(2)
       04:AA86  85 01              sta    <__stack+1
       04:AA88  68                 pla
       04:AA89  22                 sax
       04:AA8A  92 00              sta    [__stack]
       04:AA8C  22                 sax
       04:AA8D  A0 01              ldy    #1
       04:AA8F  91 00              sta    [__stack],Y
  350                             __ldwi  255
       04:AA91  A2 FF              ldx    #low(255)
       04:AA93  A9 00              lda    #high(255)
  351                             __stbps
                                 __stw    <__temp
       04:AA95  86 03              stx    <__temp
       04:AA97  85 04              sta    <__temp+1
                                 __ldwp    __stack
       04:AA99  B2 00              lda    [__stack]
       04:AA9B  AA                 tax
       04:AA9C  A0 01              ldy    #1
       04:AA9E  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       04:AAA0  86 0B              stx    <__ptr
       04:AAA2  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       04:AAA4  A6 03              ldx    <__temp
       04:AAA6  A5 04              lda    <__temp+1
                                  .endif
       04:AAA8  22                 sax
       04:AAA9  92 0B              sta    [__ptr]
       04:AAAB  22                 sax
                                 __addmi  2,__stack
       04:AAAC  48                 pha
       04:AAAD  18                 clc
       04:AAAE  A5 00              lda    <__stack
       04:AAB0  69 02              adc    #low(2)
       04:AAB2  85 00              sta    <__stack
       04:AAB4  A5 01              lda    <__stack+1
       04:AAB6  69 00              adc    #high(2)
       04:AAB8  85 01              sta    <__stack+1
       04:AABA  68                 pla
  352  04:AABB            LL9:
  353                     
  354  04:AABB            LL6:
  355                     
  356  04:AABB  60                  rts
  357                             .endp
  358                     
  359  04:4ABC                    .proc _limit_offset
  360                             __ldwi  _result
       04:AABC  A2 DE              ldx    #low(_result)
       04:AABE  A9 31              lda    #high(_result)
  361                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:AAC0  86 0B              stx    <__ptr
       04:AAC2  85 0C              sta    <__ptr+1
       04:AAC4  B2 0B              lda    [__ptr]
       04:AAC6  AA                 tax
       04:AAC7  62                 cla
                          ;        bpl    .x_00989   ; signed
                          ;        dec    A
                          ;.x_00989:
  362                             __stw   <__temp
       04:AAC8  86 03              stx    <__temp
       04:AACA  85 04              sta    <__temp+1
  363                             __ldwi  0
       04:AACC  A2 00              ldx    #low(0)
       04:AACE  A9 00              lda    #high(0)
  364  04:AAD0  20 FF C8            jsr   ltzp
  365                             __lbne  LL12
       04:AAD3  F0 03              beq    .x00992
       04:AAD5  4C EF AA           jmp    LL12
       04:AAD8            .x00992
  366                             __ldwi  _result
       04:AAD8  A2 DE              ldx    #low(_result)
       04:AADA  A9 31              lda    #high(_result)
  367                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:AADC  86 0B              stx    <__ptr
       04:AADE  85 0C              sta    <__ptr+1
       04:AAE0  B2 0B              lda    [__ptr]
       04:AAE2  AA                 tax
       04:AAE3  62                 cla
                          ;        bpl    .x_00994   ; signed
                          ;        dec    A
                          ;.x_00994:
  368                             __stw   <__temp
       04:AAE4  86 03              stx    <__temp
       04:AAE6  85 04              sta    <__temp+1
  369                             __ldwi  128
       04:AAE8  A2 80              ldx    #low(128)
       04:AAEA  A9 00              lda    #high(128)
  370  04:AAEC  20 56 C9            jsr   gezp
  371  04:AAEF            LL12:
  372                     
  373                             __boolw
       04:AAEF  86 03              stx    <__temp
       04:AAF1  05 03              ora    <__temp
       04:AAF3  82                 clx
       04:AAF4  F0 01              beq    .x00997
       04:AAF6  E8                 inx
       04:AAF7  62        .x00997     cla
  374                             __tstw
                                   ; pha
       04:AAF8  86 03              stx    <__temp
       04:AAFA  05 03              ora    <__temp
                                   ; pla
  375                             __lbeq  LL11
       04:AAFC  D0 03              bne    .x00999
       04:AAFE  4C DE AB           jmp    LL11
       04:AB01            .x00999
  376                             __ldwi  _result
       04:AB01  A2 DE              ldx    #low(_result)
       04:AB03  A9 31              lda    #high(_result)
  377                             __pushw
                                 __submi  2,__stack
       04:AB05  48                 pha
       04:AB06  38                 sec
       04:AB07  A5 00              lda    <__stack
       04:AB09  E9 02              sbc    #low(2)
       04:AB0B  85 00              sta    <__stack
       04:AB0D  A5 01              lda    <__stack+1
       04:AB0F  E9 00              sbc    #high(2)
       04:AB11  85 01              sta    <__stack+1
       04:AB13  68                 pla
       04:AB14  22                 sax
       04:AB15  92 00              sta    [__stack]
       04:AB17  22                 sax
       04:AB18  A0 01              ldy    #1
       04:AB1A  91 00              sta    [__stack],Y
  378                             __ldwi  0
       04:AB1C  A2 00              ldx    #low(0)
       04:AB1E  A9 00              lda    #high(0)
  379                             __stbps
                                 __stw    <__temp
       04:AB20  86 03              stx    <__temp
       04:AB22  85 04              sta    <__temp+1
                                 __ldwp    __stack
       04:AB24  B2 00              lda    [__stack]
       04:AB26  AA                 tax
       04:AB27  A0 01              ldy    #1
       04:AB29  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       04:AB2B  86 0B              stx    <__ptr
       04:AB2D  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       04:AB2F  A6 03              ldx    <__temp
       04:AB31  A5 04              lda    <__temp+1
                                  .endif
       04:AB33  22                 sax
       04:AB34  92 0B              sta    [__ptr]
       04:AB36  22                 sax
                                 __addmi  2,__stack
       04:AB37  48                 pha
       04:AB38  18                 clc
       04:AB39  A5 00              lda    <__stack
       04:AB3B  69 02              adc    #low(2)
       04:AB3D  85 00              sta    <__stack
       04:AB3F  A5 01              lda    <__stack+1
       04:AB41  69 00              adc    #high(2)
       04:AB43  85 01              sta    <__stack+1
       04:AB45  68                 pla
  380                             __ldwi  _result
       04:AB46  A2 DE              ldx    #low(_result)
       04:AB48  A9 31              lda    #high(_result)
  381                             __addwi 1
       04:AB4A  18                 clc
       04:AB4B  22                 sax
       04:AB4C  69 01              adc    #low(1)
       04:AB4E  22                 sax
       04:AB4F  69 00              adc    #high(1)
  382                             __pushw
                                 __submi  2,__stack
       04:AB51  48                 pha
       04:AB52  38                 sec
       04:AB53  A5 00              lda    <__stack
       04:AB55  E9 02              sbc    #low(2)
       04:AB57  85 00              sta    <__stack
       04:AB59  A5 01              lda    <__stack+1
       04:AB5B  E9 00              sbc    #high(2)
       04:AB5D  85 01              sta    <__stack+1
       04:AB5F  68                 pla
       04:AB60  22                 sax
       04:AB61  92 00              sta    [__stack]
       04:AB63  22                 sax
       04:AB64  A0 01              ldy    #1
       04:AB66  91 00              sta    [__stack],Y
  383                             __ldwi  0
       04:AB68  A2 00              ldx    #low(0)
       04:AB6A  A9 00              lda    #high(0)
  384                             __stbps
                                 __stw    <__temp
       04:AB6C  86 03              stx    <__temp
       04:AB6E  85 04              sta    <__temp+1
                                 __ldwp    __stack
       04:AB70  B2 00              lda    [__stack]
       04:AB72  AA                 tax
       04:AB73  A0 01              ldy    #1
       04:AB75  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       04:AB77  86 0B              stx    <__ptr
       04:AB79  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       04:AB7B  A6 03              ldx    <__temp
       04:AB7D  A5 04              lda    <__temp+1
                                  .endif
       04:AB7F  22                 sax
       04:AB80  92 0B              sta    [__ptr]
       04:AB82  22                 sax
                                 __addmi  2,__stack
       04:AB83  48                 pha
       04:AB84  18                 clc
       04:AB85  A5 00              lda    <__stack
       04:AB87  69 02              adc    #low(2)
       04:AB89  85 00              sta    <__stack
       04:AB8B  A5 01              lda    <__stack+1
       04:AB8D  69 00              adc    #high(2)
       04:AB8F  85 01              sta    <__stack+1
       04:AB91  68                 pla
  385                             __ldwi  _result
       04:AB92  A2 DE              ldx    #low(_result)
       04:AB94  A9 31              lda    #high(_result)
  386                             __addwi 2
       04:AB96  18                 clc
       04:AB97  22                 sax
       04:AB98  69 02              adc    #low(2)
       04:AB9A  22                 sax
       04:AB9B  69 00              adc    #high(2)
  387                             __pushw
                                 __submi  2,__stack
       04:AB9D  48                 pha
       04:AB9E  38                 sec
       04:AB9F  A5 00              lda    <__stack
       04:ABA1  E9 02              sbc    #low(2)
       04:ABA3  85 00              sta    <__stack
       04:ABA5  A5 01              lda    <__stack+1
       04:ABA7  E9 00              sbc    #high(2)
       04:ABA9  85 01              sta    <__stack+1
       04:ABAB  68                 pla
       04:ABAC  22                 sax
       04:ABAD  92 00              sta    [__stack]
       04:ABAF  22                 sax
       04:ABB0  A0 01              ldy    #1
       04:ABB2  91 00              sta    [__stack],Y
  388                             __ldwi  0
       04:ABB4  A2 00              ldx    #low(0)
       04:ABB6  A9 00              lda    #high(0)
  389                             __stbps
                                 __stw    <__temp
       04:ABB8  86 03              stx    <__temp
       04:ABBA  85 04              sta    <__temp+1
                                 __ldwp    __stack
       04:ABBC  B2 00              lda    [__stack]
       04:ABBE  AA                 tax
       04:ABBF  A0 01              ldy    #1
       04:ABC1  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       04:ABC3  86 0B              stx    <__ptr
       04:ABC5  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       04:ABC7  A6 03              ldx    <__temp
       04:ABC9  A5 04              lda    <__temp+1
                                  .endif
       04:ABCB  22                 sax
       04:ABCC  92 0B              sta    [__ptr]
       04:ABCE  22                 sax
                                 __addmi  2,__stack
       04:ABCF  48                 pha
       04:ABD0  18                 clc
       04:ABD1  A5 00              lda    <__stack
       04:ABD3  69 02              adc    #low(2)
       04:ABD5  85 00              sta    <__stack
       04:ABD7  A5 01              lda    <__stack+1
       04:ABD9  69 00              adc    #high(2)
       04:ABDB  85 01              sta    <__stack+1
       04:ABDD  68                 pla
  390  04:ABDE            LL11:
  391                     
  392  04:ABDE            LL10:
  393                     
  394  04:ABDE  60                  rts
  395                             .endp
  396                     
  397  04:4BDF                    .proc _fix_offset
  398                             __ldb   _direction
                0000              .if (1 = 2)
                                  .else
       04:ABDF  AE E3 31           ldx    _direction
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01033
                          ;        dec    A
                          ;.x_01033:
       04:ABE2  62                 cla    ; unsigned
                                  .endif
  399                             __stw   <__temp
       04:ABE3  86 03              stx    <__temp
       04:ABE5  85 04              sta    <__temp+1
  400                             __ldwi  0
       04:ABE7  A2 00              ldx    #low(0)
       04:ABE9  A9 00              lda    #high(0)
  401  04:ABEB  20 58 C8            jsr   eqzp
  402                             __lbeq  LL14
       04:ABEE  D0 03              bne    .x01036
       04:ABF0  4C 58 AE           jmp    LL14
       04:ABF3            .x01036
  403                             __ldwi  _start_pos
       04:ABF3  A2 D5              ldx    #low(_start_pos)
       04:ABF5  A9 31              lda    #high(_start_pos)
  404                             __pushw
                                 __submi  2,__stack
       04:ABF7  48                 pha
       04:ABF8  38                 sec
       04:ABF9  A5 00              lda    <__stack
       04:ABFB  E9 02              sbc    #low(2)
       04:ABFD  85 00              sta    <__stack
       04:ABFF  A5 01              lda    <__stack+1
       04:AC01  E9 00              sbc    #high(2)
       04:AC03  85 01              sta    <__stack+1
       04:AC05  68                 pla
       04:AC06  22                 sax
       04:AC07  92 00              sta    [__stack]
       04:AC09  22                 sax
       04:AC0A  A0 01              ldy    #1
       04:AC0C  91 00              sta    [__stack],Y
  405                             __ldwi  _offset
       04:AC0E  A2 D8              ldx    #low(_offset)
       04:AC10  A9 31              lda    #high(_offset)
  406  04:AC12  20 00 A0            call  _add_3digit
  407                             __ldwi  _result
       04:AC15  A2 DE              ldx    #low(_result)
       04:AC17  A9 31              lda    #high(_result)
  408                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:AC19  86 0B              stx    <__ptr
       04:AC1B  85 0C              sta    <__ptr+1
       04:AC1D  B2 0B              lda    [__ptr]
       04:AC1F  AA                 tax
       04:AC20  62                 cla
                          ;        bpl    .x_01042   ; signed
                          ;        dec    A
                          ;.x_01042:
  409                             __stw   <__temp
       04:AC21  86 03              stx    <__temp
       04:AC23  85 04              sta    <__temp+1
  410                             __ldwi  4
       04:AC25  A2 04              ldx    #low(4)
       04:AC27  A9 00              lda    #high(4)
  411  04:AC29  20 28 C9            jsr   gtzp
  412                             __lbeq  LL15
       04:AC2C  D0 03              bne    .x01045
       04:AC2E  4C 55 AE           jmp    LL15
       04:AC31            .x01045
  413                             __ldwi  _target
       04:AC31  A2 DB              ldx    #low(_target)
       04:AC33  A9 31              lda    #high(_target)
  414                             __pushw
                                 __submi  2,__stack
       04:AC35  48                 pha
       04:AC36  38                 sec
       04:AC37  A5 00              lda    <__stack
       04:AC39  E9 02              sbc    #low(2)
       04:AC3B  85 00              sta    <__stack
       04:AC3D  A5 01              lda    <__stack+1
       04:AC3F  E9 00              sbc    #high(2)
       04:AC41  85 01              sta    <__stack+1
       04:AC43  68                 pla
       04:AC44  22                 sax
       04:AC45  92 00              sta    [__stack]
       04:AC47  22                 sax
       04:AC48  A0 01              ldy    #1
       04:AC4A  91 00              sta    [__stack],Y
  415                             __ldwi  4
       04:AC4C  A2 04              ldx    #low(4)
       04:AC4E  A9 00              lda    #high(4)
  416                             __stbps
                                 __stw    <__temp
       04:AC50  86 03              stx    <__temp
       04:AC52  85 04              sta    <__temp+1
                                 __ldwp    __stack
       04:AC54  B2 00              lda    [__stack]
       04:AC56  AA                 tax
       04:AC57  A0 01              ldy    #1
       04:AC59  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       04:AC5B  86 0B              stx    <__ptr
       04:AC5D  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       04:AC5F  A6 03              ldx    <__temp
       04:AC61  A5 04              lda    <__temp+1
                                  .endif
       04:AC63  22                 sax
       04:AC64  92 0B              sta    [__ptr]
       04:AC66  22                 sax
                                 __addmi  2,__stack
       04:AC67  48                 pha
       04:AC68  18                 clc
       04:AC69  A5 00              lda    <__stack
       04:AC6B  69 02              adc    #low(2)
       04:AC6D  85 00              sta    <__stack
       04:AC6F  A5 01              lda    <__stack+1
       04:AC71  69 00              adc    #high(2)
       04:AC73  85 01              sta    <__stack+1
       04:AC75  68                 pla
  417                             __ldwi  _target
       04:AC76  A2 DB              ldx    #low(_target)
       04:AC78  A9 31              lda    #high(_target)
  418                             __addwi 1
       04:AC7A  18                 clc
       04:AC7B  22                 sax
       04:AC7C  69 01              adc    #low(1)
       04:AC7E  22                 sax
       04:AC7F  69 00              adc    #high(1)
  419                             __pushw
                                 __submi  2,__stack
       04:AC81  48                 pha
       04:AC82  38                 sec
       04:AC83  A5 00              lda    <__stack
       04:AC85  E9 02              sbc    #low(2)
       04:AC87  85 00              sta    <__stack
       04:AC89  A5 01              lda    <__stack+1
       04:AC8B  E9 00              sbc    #high(2)
       04:AC8D  85 01              sta    <__stack+1
       04:AC8F  68                 pla
       04:AC90  22                 sax
       04:AC91  92 00              sta    [__stack]
       04:AC93  22                 sax
       04:AC94  A0 01              ldy    #1
       04:AC96  91 00              sta    [__stack],Y
  420                             __ldwi  255
       04:AC98  A2 FF              ldx    #low(255)
       04:AC9A  A9 00              lda    #high(255)
  421                             __stbps
                                 __stw    <__temp
       04:AC9C  86 03              stx    <__temp
       04:AC9E  85 04              sta    <__temp+1
                                 __ldwp    __stack
       04:ACA0  B2 00              lda    [__stack]
       04:ACA2  AA                 tax
       04:ACA3  A0 01              ldy    #1
       04:ACA5  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       04:ACA7  86 0B              stx    <__ptr
       04:ACA9  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       04:ACAB  A6 03              ldx    <__temp
       04:ACAD  A5 04              lda    <__temp+1
                                  .endif
       04:ACAF  22                 sax
       04:ACB0  92 0B              sta    [__ptr]
       04:ACB2  22                 sax
                                 __addmi  2,__stack
       04:ACB3  48                 pha
       04:ACB4  18                 clc
       04:ACB5  A5 00              lda    <__stack
       04:ACB7  69 02              adc    #low(2)
       04:ACB9  85 00              sta    <__stack
       04:ACBB  A5 01              lda    <__stack+1
       04:ACBD  69 00              adc    #high(2)
       04:ACBF  85 01              sta    <__stack+1
       04:ACC1  68                 pla
  422                             __ldwi  _target
       04:ACC2  A2 DB              ldx    #low(_target)
       04:ACC4  A9 31              lda    #high(_target)
  423                             __addwi 2
       04:ACC6  18                 clc
       04:ACC7  22                 sax
       04:ACC8  69 02              adc    #low(2)
       04:ACCA  22                 sax
       04:ACCB  69 00              adc    #high(2)
  424                             __pushw
                                 __submi  2,__stack
       04:ACCD  48                 pha
       04:ACCE  38                 sec
       04:ACCF  A5 00              lda    <__stack
       04:ACD1  E9 02              sbc    #low(2)
       04:ACD3  85 00              sta    <__stack
       04:ACD5  A5 01              lda    <__stack+1
       04:ACD7  E9 00              sbc    #high(2)
       04:ACD9  85 01              sta    <__stack+1
       04:ACDB  68                 pla
       04:ACDC  22                 sax
       04:ACDD  92 00              sta    [__stack]
       04:ACDF  22                 sax
       04:ACE0  A0 01              ldy    #1
       04:ACE2  91 00              sta    [__stack],Y
  425                             __ldwi  255
       04:ACE4  A2 FF              ldx    #low(255)
       04:ACE6  A9 00              lda    #high(255)
  426                             __stbps
                                 __stw    <__temp
       04:ACE8  86 03              stx    <__temp
       04:ACEA  85 04              sta    <__temp+1
                                 __ldwp    __stack
       04:ACEC  B2 00              lda    [__stack]
       04:ACEE  AA                 tax
       04:ACEF  A0 01              ldy    #1
       04:ACF1  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       04:ACF3  86 0B              stx    <__ptr
       04:ACF5  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       04:ACF7  A6 03              ldx    <__temp
       04:ACF9  A5 04              lda    <__temp+1
                                  .endif
       04:ACFB  22                 sax
       04:ACFC  92 0B              sta    [__ptr]
       04:ACFE  22                 sax
                                 __addmi  2,__stack
       04:ACFF  48                 pha
       04:AD00  18                 clc
       04:AD01  A5 00              lda    <__stack
       04:AD03  69 02              adc    #low(2)
       04:AD05  85 00              sta    <__stack
       04:AD07  A5 01              lda    <__stack+1
       04:AD09  69 00              adc    #high(2)
       04:AD0B  85 01              sta    <__stack+1
       04:AD0D  68                 pla
  427                             __ldwi  _target
       04:AD0E  A2 DB              ldx    #low(_target)
       04:AD10  A9 31              lda    #high(_target)
  428                             __pushw
                                 __submi  2,__stack
       04:AD12  48                 pha
       04:AD13  38                 sec
       04:AD14  A5 00              lda    <__stack
       04:AD16  E9 02              sbc    #low(2)
       04:AD18  85 00              sta    <__stack
       04:AD1A  A5 01              lda    <__stack+1
       04:AD1C  E9 00              sbc    #high(2)
       04:AD1E  85 01              sta    <__stack+1
       04:AD20  68                 pla
       04:AD21  22                 sax
       04:AD22  92 00              sta    [__stack]
       04:AD24  22                 sax
       04:AD25  A0 01              ldy    #1
       04:AD27  91 00              sta    [__stack],Y
  429                             __ldwi  _start_pos
       04:AD29  A2 D5              ldx    #low(_start_pos)
       04:AD2B  A9 31              lda    #high(_start_pos)
  430  04:AD2D  20 BA A2            call  _sub_3digit
  431                             __ldwi  _offset
       04:AD30  A2 D8              ldx    #low(_offset)
       04:AD32  A9 31              lda    #high(_offset)
  432                             __pushw
                                 __submi  2,__stack
       04:AD34  48                 pha
       04:AD35  38                 sec
       04:AD36  A5 00              lda    <__stack
       04:AD38  E9 02              sbc    #low(2)
       04:AD3A  85 00              sta    <__stack
       04:AD3C  A5 01              lda    <__stack+1
       04:AD3E  E9 00              sbc    #high(2)
       04:AD40  85 01              sta    <__stack+1
       04:AD42  68                 pla
       04:AD43  22                 sax
       04:AD44  92 00              sta    [__stack]
       04:AD46  22                 sax
       04:AD47  A0 01              ldy    #1
       04:AD49  91 00              sta    [__stack],Y
  433                             __ldwi  _result
       04:AD4B  A2 DE              ldx    #low(_result)
       04:AD4D  A9 31              lda    #high(_result)
  434                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:AD4F  86 0B              stx    <__ptr
       04:AD51  85 0C              sta    <__ptr+1
       04:AD53  B2 0B              lda    [__ptr]
       04:AD55  AA                 tax
       04:AD56  62                 cla
                          ;        bpl    .x_01086   ; signed
                          ;        dec    A
                          ;.x_01086:
  435                             __stbps
                                 __stw    <__temp
       04:AD57  86 03              stx    <__temp
       04:AD59  85 04              sta    <__temp+1
                                 __ldwp    __stack
       04:AD5B  B2 00              lda    [__stack]
       04:AD5D  AA                 tax
       04:AD5E  A0 01              ldy    #1
       04:AD60  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       04:AD62  86 0B              stx    <__ptr
       04:AD64  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       04:AD66  A6 03              ldx    <__temp
       04:AD68  A5 04              lda    <__temp+1
                                  .endif
       04:AD6A  22                 sax
       04:AD6B  92 0B              sta    [__ptr]
       04:AD6D  22                 sax
                                 __addmi  2,__stack
       04:AD6E  48                 pha
       04:AD6F  18                 clc
       04:AD70  A5 00              lda    <__stack
       04:AD72  69 02              adc    #low(2)
       04:AD74  85 00              sta    <__stack
       04:AD76  A5 01              lda    <__stack+1
       04:AD78  69 00              adc    #high(2)
       04:AD7A  85 01              sta    <__stack+1
       04:AD7C  68                 pla
  436                             __ldwi  _offset
       04:AD7D  A2 D8              ldx    #low(_offset)
       04:AD7F  A9 31              lda    #high(_offset)
  437                             __addwi 1
       04:AD81  18                 clc
       04:AD82  22                 sax
       04:AD83  69 01              adc    #low(1)
       04:AD85  22                 sax
       04:AD86  69 00              adc    #high(1)
  438                             __pushw
                                 __submi  2,__stack
       04:AD88  48                 pha
       04:AD89  38                 sec
       04:AD8A  A5 00              lda    <__stack
       04:AD8C  E9 02              sbc    #low(2)
       04:AD8E  85 00              sta    <__stack
       04:AD90  A5 01              lda    <__stack+1
       04:AD92  E9 00              sbc    #high(2)
       04:AD94  85 01              sta    <__stack+1
       04:AD96  68                 pla
       04:AD97  22                 sax
       04:AD98  92 00              sta    [__stack]
       04:AD9A  22                 sax
       04:AD9B  A0 01              ldy    #1
       04:AD9D  91 00              sta    [__stack],Y
  439                             __ldwi  _result
       04:AD9F  A2 DE              ldx    #low(_result)
       04:ADA1  A9 31              lda    #high(_result)
  440                             __addwi 1
       04:ADA3  18                 clc
       04:ADA4  22                 sax
       04:ADA5  69 01              adc    #low(1)
       04:ADA7  22                 sax
       04:ADA8  69 00              adc    #high(1)
  441                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:ADAA  86 0B              stx    <__ptr
       04:ADAC  85 0C              sta    <__ptr+1
       04:ADAE  B2 0B              lda    [__ptr]
       04:ADB0  AA                 tax
       04:ADB1  62                 cla
                          ;        bpl    .x_01099   ; signed
                          ;        dec    A
                          ;.x_01099:
  442                             __stbps
                                 __stw    <__temp
       04:ADB2  86 03              stx    <__temp
       04:ADB4  85 04              sta    <__temp+1
                                 __ldwp    __stack
       04:ADB6  B2 00              lda    [__stack]
       04:ADB8  AA                 tax
       04:ADB9  A0 01              ldy    #1
       04:ADBB  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       04:ADBD  86 0B              stx    <__ptr
       04:ADBF  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       04:ADC1  A6 03              ldx    <__temp
       04:ADC3  A5 04              lda    <__temp+1
                                  .endif
       04:ADC5  22                 sax
       04:ADC6  92 0B              sta    [__ptr]
       04:ADC8  22                 sax
                                 __addmi  2,__stack
       04:ADC9  48                 pha
       04:ADCA  18                 clc
       04:ADCB  A5 00              lda    <__stack
       04:ADCD  69 02              adc    #low(2)
       04:ADCF  85 00              sta    <__stack
       04:ADD1  A5 01              lda    <__stack+1
       04:ADD3  69 00              adc    #high(2)
       04:ADD5  85 01              sta    <__stack+1
       04:ADD7  68                 pla
  443                             __ldwi  _offset
       04:ADD8  A2 D8              ldx    #low(_offset)
       04:ADDA  A9 31              lda    #high(_offset)
  444                             __addwi 2
       04:ADDC  18                 clc
       04:ADDD  22                 sax
       04:ADDE  69 02              adc    #low(2)
       04:ADE0  22                 sax
       04:ADE1  69 00              adc    #high(2)
  445                             __pushw
                                 __submi  2,__stack
       04:ADE3  48                 pha
       04:ADE4  38                 sec
       04:ADE5  A5 00              lda    <__stack
       04:ADE7  E9 02              sbc    #low(2)
       04:ADE9  85 00              sta    <__stack
       04:ADEB  A5 01              lda    <__stack+1
       04:ADED  E9 00              sbc    #high(2)
       04:ADEF  85 01              sta    <__stack+1
       04:ADF1  68                 pla
       04:ADF2  22                 sax
       04:ADF3  92 00              sta    [__stack]
       04:ADF5  22                 sax
       04:ADF6  A0 01              ldy    #1
       04:ADF8  91 00              sta    [__stack],Y
  446                             __ldwi  _result
       04:ADFA  A2 DE              ldx    #low(_result)
       04:ADFC  A9 31              lda    #high(_result)
  447                             __addwi 2
       04:ADFE  18                 clc
       04:ADFF  22                 sax
       04:AE00  69 02              adc    #low(2)
       04:AE02  22                 sax
       04:AE03  69 00              adc    #high(2)
  448                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:AE05  86 0B              stx    <__ptr
       04:AE07  85 0C              sta    <__ptr+1
       04:AE09  B2 0B              lda    [__ptr]
       04:AE0B  AA                 tax
       04:AE0C  62                 cla
                          ;        bpl    .x_01112   ; signed
                          ;        dec    A
                          ;.x_01112:
  449                             __stbps
                                 __stw    <__temp
       04:AE0D  86 03              stx    <__temp
       04:AE0F  85 04              sta    <__temp+1
                                 __ldwp    __stack
       04:AE11  B2 00              lda    [__stack]
       04:AE13  AA                 tax
       04:AE14  A0 01              ldy    #1
       04:AE16  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       04:AE18  86 0B              stx    <__ptr
       04:AE1A  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       04:AE1C  A6 03              ldx    <__temp
       04:AE1E  A5 04              lda    <__temp+1
                                  .endif
       04:AE20  22                 sax
       04:AE21  92 0B              sta    [__ptr]
       04:AE23  22                 sax
                                 __addmi  2,__stack
       04:AE24  48                 pha
       04:AE25  18                 clc
       04:AE26  A5 00              lda    <__stack
       04:AE28  69 02              adc    #low(2)
       04:AE2A  85 00              sta    <__stack
       04:AE2C  A5 01              lda    <__stack+1
       04:AE2E  69 00              adc    #high(2)
       04:AE30  85 01              sta    <__stack+1
       04:AE32  68                 pla
  450                             __ldwi  _start_pos
       04:AE33  A2 D5              ldx    #low(_start_pos)
       04:AE35  A9 31              lda    #high(_start_pos)
  451                             __pushw
                                 __submi  2,__stack
       04:AE37  48                 pha
       04:AE38  38                 sec
       04:AE39  A5 00              lda    <__stack
       04:AE3B  E9 02              sbc    #low(2)
       04:AE3D  85 00              sta    <__stack
       04:AE3F  A5 01              lda    <__stack+1
       04:AE41  E9 00              sbc    #high(2)
       04:AE43  85 01              sta    <__stack+1
       04:AE45  68                 pla
       04:AE46  22                 sax
       04:AE47  92 00              sta    [__stack]
       04:AE49  22                 sax
       04:AE4A  A0 01              ldy    #1
       04:AE4C  91 00              sta    [__stack],Y
  452                             __ldwi  _offset
       04:AE4E  A2 D8              ldx    #low(_offset)
       04:AE50  A9 31              lda    #high(_offset)
  453  04:AE52  20 00 A0            call  _add_3digit
  454  04:AE55            LL15:
  455                     
  456                             __lbra  LL16
       04:AE55  4C 3E B1           jmp    LL16
  457  04:AE58            LL14:
  458                     
  459                             __ldb   _direction
                0000              .if (1 = 2)
                                  .else
       04:AE58  AE E3 31           ldx    _direction
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01125
                          ;        dec    A
                          ;.x_01125:
       04:AE5B  62                 cla    ; unsigned
                                  .endif
  460                             __stw   <__temp
       04:AE5C  86 03              stx    <__temp
       04:AE5E  85 04              sta    <__temp+1
  461                             __ldwi  1
       04:AE60  A2 01              ldx    #low(1)
       04:AE62  A9 00              lda    #high(1)
  462  04:AE64  20 58 C8            jsr   eqzp
  463                             __lbeq  LL17
       04:AE67  D0 03              bne    .x01128
       04:AE69  4C 3E B1           jmp    LL17
       04:AE6C            .x01128
  464                             __ldwi  _offset
       04:AE6C  A2 D8              ldx    #low(_offset)
       04:AE6E  A9 31              lda    #high(_offset)
  465                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:AE70  86 0B              stx    <__ptr
       04:AE72  85 0C              sta    <__ptr+1
       04:AE74  B2 0B              lda    [__ptr]
       04:AE76  AA                 tax
       04:AE77  62                 cla
                          ;        bpl    .x_01130   ; signed
                          ;        dec    A
                          ;.x_01130:
  466                             __pushw
                                 __submi  2,__stack
       04:AE78  48                 pha
       04:AE79  38                 sec
       04:AE7A  A5 00              lda    <__stack
       04:AE7C  E9 02              sbc    #low(2)
       04:AE7E  85 00              sta    <__stack
       04:AE80  A5 01              lda    <__stack+1
       04:AE82  E9 00              sbc    #high(2)
       04:AE84  85 01              sta    <__stack+1
       04:AE86  68                 pla
       04:AE87  22                 sax
       04:AE88  92 00              sta    [__stack]
       04:AE8A  22                 sax
       04:AE8B  A0 01              ldy    #1
       04:AE8D  91 00              sta    [__stack],Y
  467                             __ldwi  _start_pos
       04:AE8F  A2 D5              ldx    #low(_start_pos)
       04:AE91  A9 31              lda    #high(_start_pos)
  468                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:AE93  86 0B              stx    <__ptr
       04:AE95  85 0C              sta    <__ptr+1
       04:AE97  B2 0B              lda    [__ptr]
       04:AE99  AA                 tax
       04:AE9A  62                 cla
                          ;        bpl    .x_01134   ; signed
                          ;        dec    A
                          ;.x_01134:
  469  04:AE9B  20 B4 C8            jsr   gt
  470                             __lbne  LL19
       04:AE9E  F0 03              beq    .x01135
       04:AEA0  4C 23 AF           jmp    LL19
       04:AEA3            .x01135
  471                             __ldwi  _offset
       04:AEA3  A2 D8              ldx    #low(_offset)
       04:AEA5  A9 31              lda    #high(_offset)
  472                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:AEA7  86 0B              stx    <__ptr
       04:AEA9  85 0C              sta    <__ptr+1
       04:AEAB  B2 0B              lda    [__ptr]
       04:AEAD  AA                 tax
       04:AEAE  62                 cla
                          ;        bpl    .x_01137   ; signed
                          ;        dec    A
                          ;.x_01137:
  473                             __pushw
                                 __submi  2,__stack
       04:AEAF  48                 pha
       04:AEB0  38                 sec
       04:AEB1  A5 00              lda    <__stack
       04:AEB3  E9 02              sbc    #low(2)
       04:AEB5  85 00              sta    <__stack
       04:AEB7  A5 01              lda    <__stack+1
       04:AEB9  E9 00              sbc    #high(2)
       04:AEBB  85 01              sta    <__stack+1
       04:AEBD  68                 pla
       04:AEBE  22                 sax
       04:AEBF  92 00              sta    [__stack]
       04:AEC1  22                 sax
       04:AEC2  A0 01              ldy    #1
       04:AEC4  91 00              sta    [__stack],Y
  474                             __ldwi  _start_pos
       04:AEC6  A2 D5              ldx    #low(_start_pos)
       04:AEC8  A9 31              lda    #high(_start_pos)
  475                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:AECA  86 0B              stx    <__ptr
       04:AECC  85 0C              sta    <__ptr+1
       04:AECE  B2 0B              lda    [__ptr]
       04:AED0  AA                 tax
       04:AED1  62                 cla
                          ;        bpl    .x_01141   ; signed
                          ;        dec    A
                          ;.x_01141:
  476  04:AED2  20 2A C8            jsr   eq
  477                             __lbeq  LL20
       04:AED5  D0 03              bne    .x01142
       04:AED7  4C 1A AF           jmp    LL20
       04:AEDA            .x01142
  478                             __ldwi  _offset
       04:AEDA  A2 D8              ldx    #low(_offset)
       04:AEDC  A9 31              lda    #high(_offset)
  479                             __addwi 1
       04:AEDE  18                 clc
       04:AEDF  22                 sax
       04:AEE0  69 01              adc    #low(1)
       04:AEE2  22                 sax
       04:AEE3  69 00              adc    #high(1)
  480                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:AEE5  86 0B              stx    <__ptr
       04:AEE7  85 0C              sta    <__ptr+1
       04:AEE9  B2 0B              lda    [__ptr]
       04:AEEB  AA                 tax
       04:AEEC  62                 cla
                          ;        bpl    .x_01145   ; signed
                          ;        dec    A
                          ;.x_01145:
  481                             __pushw
                                 __submi  2,__stack
       04:AEED  48                 pha
       04:AEEE  38                 sec
       04:AEEF  A5 00              lda    <__stack
       04:AEF1  E9 02              sbc    #low(2)
       04:AEF3  85 00              sta    <__stack
       04:AEF5  A5 01              lda    <__stack+1
       04:AEF7  E9 00              sbc    #high(2)
       04:AEF9  85 01              sta    <__stack+1
       04:AEFB  68                 pla
       04:AEFC  22                 sax
       04:AEFD  92 00              sta    [__stack]
       04:AEFF  22                 sax
       04:AF00  A0 01              ldy    #1
       04:AF02  91 00              sta    [__stack],Y
  482                             __ldwi  _start_pos
       04:AF04  A2 D5              ldx    #low(_start_pos)
       04:AF06  A9 31              lda    #high(_start_pos)
  483                             __addwi 1
       04:AF08  18                 clc
       04:AF09  22                 sax
       04:AF0A  69 01              adc    #low(1)
       04:AF0C  22                 sax
       04:AF0D  69 00              adc    #high(1)
  484                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:AF0F  86 0B              stx    <__ptr
       04:AF11  85 0C              sta    <__ptr+1
       04:AF13  B2 0B              lda    [__ptr]
       04:AF15  AA                 tax
       04:AF16  62                 cla
                          ;        bpl    .x_01150   ; signed
                          ;        dec    A
                          ;.x_01150:
  485  04:AF17  20 B4 C8            jsr   gt
  486  04:AF1A            LL20:
  487                     
  488                             __boolw
       04:AF1A  86 03              stx    <__temp
       04:AF1C  05 03              ora    <__temp
       04:AF1E  82                 clx
       04:AF1F  F0 01              beq    .x01151
       04:AF21  E8                 inx
       04:AF22  62        .x01151     cla
  489  04:AF23            LL19:
  490                     
  491                             __boolw
       04:AF23  86 03              stx    <__temp
       04:AF25  05 03              ora    <__temp
       04:AF27  82                 clx
       04:AF28  F0 01              beq    .x01152
       04:AF2A  E8                 inx
       04:AF2B  62        .x01152     cla
  492                             __tstw
                                   ; pha
       04:AF2C  86 03              stx    <__temp
       04:AF2E  05 03              ora    <__temp
                                   ; pla
  493                             __lbne  LL21
       04:AF30  F0 03              beq    .x01154
       04:AF32  4C 07 B0           jmp    LL21
       04:AF35            .x01154
  494                             __ldwi  _offset
       04:AF35  A2 D8              ldx    #low(_offset)
       04:AF37  A9 31              lda    #high(_offset)
  495                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:AF39  86 0B              stx    <__ptr
       04:AF3B  85 0C              sta    <__ptr+1
       04:AF3D  B2 0B              lda    [__ptr]
       04:AF3F  AA                 tax
       04:AF40  62                 cla
                          ;        bpl    .x_01156   ; signed
                          ;        dec    A
                          ;.x_01156:
  496                             __pushw
                                 __submi  2,__stack
       04:AF41  48                 pha
       04:AF42  38                 sec
       04:AF43  A5 00              lda    <__stack
       04:AF45  E9 02              sbc    #low(2)
       04:AF47  85 00              sta    <__stack
       04:AF49  A5 01              lda    <__stack+1
       04:AF4B  E9 00              sbc    #high(2)
       04:AF4D  85 01              sta    <__stack+1
       04:AF4F  68                 pla
       04:AF50  22                 sax
       04:AF51  92 00              sta    [__stack]
       04:AF53  22                 sax
       04:AF54  A0 01              ldy    #1
       04:AF56  91 00              sta    [__stack],Y
  497                             __ldwi  _start_pos
       04:AF58  A2 D5              ldx    #low(_start_pos)
       04:AF5A  A9 31              lda    #high(_start_pos)
  498                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:AF5C  86 0B              stx    <__ptr
       04:AF5E  85 0C              sta    <__ptr+1
       04:AF60  B2 0B              lda    [__ptr]
       04:AF62  AA                 tax
       04:AF63  62                 cla
                          ;        bpl    .x_01160   ; signed
                          ;        dec    A
                          ;.x_01160:
  499  04:AF64  20 2A C8            jsr   eq
  500                             __lbeq  LL22
       04:AF67  D0 03              bne    .x01161
       04:AF69  4C AC AF           jmp    LL22
       04:AF6C            .x01161
  501                             __ldwi  _offset
       04:AF6C  A2 D8              ldx    #low(_offset)
       04:AF6E  A9 31              lda    #high(_offset)
  502                             __addwi 1
       04:AF70  18                 clc
       04:AF71  22                 sax
       04:AF72  69 01              adc    #low(1)
       04:AF74  22                 sax
       04:AF75  69 00              adc    #high(1)
  503                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:AF77  86 0B              stx    <__ptr
       04:AF79  85 0C              sta    <__ptr+1
       04:AF7B  B2 0B              lda    [__ptr]
       04:AF7D  AA                 tax
       04:AF7E  62                 cla
                          ;        bpl    .x_01164   ; signed
                          ;        dec    A
                          ;.x_01164:
  504                             __pushw
                                 __submi  2,__stack
       04:AF7F  48                 pha
       04:AF80  38                 sec
       04:AF81  A5 00              lda    <__stack
       04:AF83  E9 02              sbc    #low(2)
       04:AF85  85 00              sta    <__stack
       04:AF87  A5 01              lda    <__stack+1
       04:AF89  E9 00              sbc    #high(2)
       04:AF8B  85 01              sta    <__stack+1
       04:AF8D  68                 pla
       04:AF8E  22                 sax
       04:AF8F  92 00              sta    [__stack]
       04:AF91  22                 sax
       04:AF92  A0 01              ldy    #1
       04:AF94  91 00              sta    [__stack],Y
  505                             __ldwi  _start_pos
       04:AF96  A2 D5              ldx    #low(_start_pos)
       04:AF98  A9 31              lda    #high(_start_pos)
  506                             __addwi 1
       04:AF9A  18                 clc
       04:AF9B  22                 sax
       04:AF9C  69 01              adc    #low(1)
       04:AF9E  22                 sax
       04:AF9F  69 00              adc    #high(1)
  507                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:AFA1  86 0B              stx    <__ptr
       04:AFA3  85 0C              sta    <__ptr+1
       04:AFA5  B2 0B              lda    [__ptr]
       04:AFA7  AA                 tax
       04:AFA8  62                 cla
                          ;        bpl    .x_01169   ; signed
                          ;        dec    A
                          ;.x_01169:
  508  04:AFA9  20 2A C8            jsr   eq
  509  04:AFAC            LL22:
  510                     
  511                             __boolw
       04:AFAC  86 03              stx    <__temp
       04:AFAE  05 03              ora    <__temp
       04:AFB0  82                 clx
       04:AFB1  F0 01              beq    .x01170
       04:AFB3  E8                 inx
       04:AFB4  62        .x01170     cla
  512                             __tstw
                                   ; pha
       04:AFB5  86 03              stx    <__temp
       04:AFB7  05 03              ora    <__temp
                                   ; pla
  513                             __lbeq  LL23
       04:AFB9  D0 03              bne    .x01172
       04:AFBB  4C FE AF           jmp    LL23
       04:AFBE            .x01172
  514                             __ldwi  _offset
       04:AFBE  A2 D8              ldx    #low(_offset)
       04:AFC0  A9 31              lda    #high(_offset)
  515                             __addwi 2
       04:AFC2  18                 clc
       04:AFC3  22                 sax
       04:AFC4  69 02              adc    #low(2)
       04:AFC6  22                 sax
       04:AFC7  69 00              adc    #high(2)
  516                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:AFC9  86 0B              stx    <__ptr
       04:AFCB  85 0C              sta    <__ptr+1
       04:AFCD  B2 0B              lda    [__ptr]
       04:AFCF  AA                 tax
       04:AFD0  62                 cla
                          ;        bpl    .x_01175   ; signed
                          ;        dec    A
                          ;.x_01175:
  517                             __pushw
                                 __submi  2,__stack
       04:AFD1  48                 pha
       04:AFD2  38                 sec
       04:AFD3  A5 00              lda    <__stack
       04:AFD5  E9 02              sbc    #low(2)
       04:AFD7  85 00              sta    <__stack
       04:AFD9  A5 01              lda    <__stack+1
       04:AFDB  E9 00              sbc    #high(2)
       04:AFDD  85 01              sta    <__stack+1
       04:AFDF  68                 pla
       04:AFE0  22                 sax
       04:AFE1  92 00              sta    [__stack]
       04:AFE3  22                 sax
       04:AFE4  A0 01              ldy    #1
       04:AFE6  91 00              sta    [__stack],Y
  518                             __ldwi  _start_pos
       04:AFE8  A2 D5              ldx    #low(_start_pos)
       04:AFEA  A9 31              lda    #high(_start_pos)
  519                             __addwi 2
       04:AFEC  18                 clc
       04:AFED  22                 sax
       04:AFEE  69 02              adc    #low(2)
       04:AFF0  22                 sax
       04:AFF1  69 00              adc    #high(2)
  520                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:AFF3  86 0B              stx    <__ptr
       04:AFF5  85 0C              sta    <__ptr+1
       04:AFF7  B2 0B              lda    [__ptr]
       04:AFF9  AA                 tax
       04:AFFA  62                 cla
                          ;        bpl    .x_01180   ; signed
                          ;        dec    A
                          ;.x_01180:
  521  04:AFFB  20 B4 C8            jsr   gt
  522  04:AFFE            LL23:
  523                     
  524                             __boolw
       04:AFFE  86 03              stx    <__temp
       04:B000  05 03              ora    <__temp
       04:B002  82                 clx
       04:B003  F0 01              beq    .x01181
       04:B005  E8                 inx
       04:B006  62        .x01181     cla
  525  04:B007            LL21:
  526                     
  527                             __boolw
       04:B007  86 03              stx    <__temp
       04:B009  05 03              ora    <__temp
       04:B00B  82                 clx
       04:B00C  F0 01              beq    .x01182
       04:B00E  E8                 inx
       04:B00F  62        .x01182     cla
  528                             __tstw
                                   ; pha
       04:B010  86 03              stx    <__temp
       04:B012  05 03              ora    <__temp
                                   ; pla
  529                             __lbeq  LL18
       04:B014  D0 03              bne    .x01184
       04:B016  4C 1C B1           jmp    LL18
       04:B019            .x01184
  530                             __ldwi  _offset
       04:B019  A2 D8              ldx    #low(_offset)
       04:B01B  A9 31              lda    #high(_offset)
  531                             __pushw
                                 __submi  2,__stack
       04:B01D  48                 pha
       04:B01E  38                 sec
       04:B01F  A5 00              lda    <__stack
       04:B021  E9 02              sbc    #low(2)
       04:B023  85 00              sta    <__stack
       04:B025  A5 01              lda    <__stack+1
       04:B027  E9 00              sbc    #high(2)
       04:B029  85 01              sta    <__stack+1
       04:B02B  68                 pla
       04:B02C  22                 sax
       04:B02D  92 00              sta    [__stack]
       04:B02F  22                 sax
       04:B030  A0 01              ldy    #1
       04:B032  91 00              sta    [__stack],Y
  532                             __ldwi  _start_pos
       04:B034  A2 D5              ldx    #low(_start_pos)
       04:B036  A9 31              lda    #high(_start_pos)
  533                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:B038  86 0B              stx    <__ptr
       04:B03A  85 0C              sta    <__ptr+1
       04:B03C  B2 0B              lda    [__ptr]
       04:B03E  AA                 tax
       04:B03F  62                 cla
                          ;        bpl    .x_01189   ; signed
                          ;        dec    A
                          ;.x_01189:
  534                             __stbps
                                 __stw    <__temp
       04:B040  86 03              stx    <__temp
       04:B042  85 04              sta    <__temp+1
                                 __ldwp    __stack
       04:B044  B2 00              lda    [__stack]
       04:B046  AA                 tax
       04:B047  A0 01              ldy    #1
       04:B049  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       04:B04B  86 0B              stx    <__ptr
       04:B04D  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       04:B04F  A6 03              ldx    <__temp
       04:B051  A5 04              lda    <__temp+1
                                  .endif
       04:B053  22                 sax
       04:B054  92 0B              sta    [__ptr]
       04:B056  22                 sax
                                 __addmi  2,__stack
       04:B057  48                 pha
       04:B058  18                 clc
       04:B059  A5 00              lda    <__stack
       04:B05B  69 02              adc    #low(2)
       04:B05D  85 00              sta    <__stack
       04:B05F  A5 01              lda    <__stack+1
       04:B061  69 00              adc    #high(2)
       04:B063  85 01              sta    <__stack+1
       04:B065  68                 pla
  535                             __ldwi  _offset
       04:B066  A2 D8              ldx    #low(_offset)
       04:B068  A9 31              lda    #high(_offset)
  536                             __addwi 1
       04:B06A  18                 clc
       04:B06B  22                 sax
       04:B06C  69 01              adc    #low(1)
       04:B06E  22                 sax
       04:B06F  69 00              adc    #high(1)
  537                             __pushw
                                 __submi  2,__stack
       04:B071  48                 pha
       04:B072  38                 sec
       04:B073  A5 00              lda    <__stack
       04:B075  E9 02              sbc    #low(2)
       04:B077  85 00              sta    <__stack
       04:B079  A5 01              lda    <__stack+1
       04:B07B  E9 00              sbc    #high(2)
       04:B07D  85 01              sta    <__stack+1
       04:B07F  68                 pla
       04:B080  22                 sax
       04:B081  92 00              sta    [__stack]
       04:B083  22                 sax
       04:B084  A0 01              ldy    #1
       04:B086  91 00              sta    [__stack],Y
  538                             __ldwi  _start_pos
       04:B088  A2 D5              ldx    #low(_start_pos)
       04:B08A  A9 31              lda    #high(_start_pos)
  539                             __addwi 1
       04:B08C  18                 clc
       04:B08D  22                 sax
       04:B08E  69 01              adc    #low(1)
       04:B090  22                 sax
       04:B091  69 00              adc    #high(1)
  540                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:B093  86 0B              stx    <__ptr
       04:B095  85 0C              sta    <__ptr+1
       04:B097  B2 0B              lda    [__ptr]
       04:B099  AA                 tax
       04:B09A  62                 cla
                          ;        bpl    .x_01202   ; signed
                          ;        dec    A
                          ;.x_01202:
  541                             __stbps
                                 __stw    <__temp
       04:B09B  86 03              stx    <__temp
       04:B09D  85 04              sta    <__temp+1
                                 __ldwp    __stack
       04:B09F  B2 00              lda    [__stack]
       04:B0A1  AA                 tax
       04:B0A2  A0 01              ldy    #1
       04:B0A4  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       04:B0A6  86 0B              stx    <__ptr
       04:B0A8  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       04:B0AA  A6 03              ldx    <__temp
       04:B0AC  A5 04              lda    <__temp+1
                                  .endif
       04:B0AE  22                 sax
       04:B0AF  92 0B              sta    [__ptr]
       04:B0B1  22                 sax
                                 __addmi  2,__stack
       04:B0B2  48                 pha
       04:B0B3  18                 clc
       04:B0B4  A5 00              lda    <__stack
       04:B0B6  69 02              adc    #low(2)
       04:B0B8  85 00              sta    <__stack
       04:B0BA  A5 01              lda    <__stack+1
       04:B0BC  69 00              adc    #high(2)
       04:B0BE  85 01              sta    <__stack+1
       04:B0C0  68                 pla
  542                             __ldwi  _offset
       04:B0C1  A2 D8              ldx    #low(_offset)
       04:B0C3  A9 31              lda    #high(_offset)
  543                             __addwi 2
       04:B0C5  18                 clc
       04:B0C6  22                 sax
       04:B0C7  69 02              adc    #low(2)
       04:B0C9  22                 sax
       04:B0CA  69 00              adc    #high(2)
  544                             __pushw
                                 __submi  2,__stack
       04:B0CC  48                 pha
       04:B0CD  38                 sec
       04:B0CE  A5 00              lda    <__stack
       04:B0D0  E9 02              sbc    #low(2)
       04:B0D2  85 00              sta    <__stack
       04:B0D4  A5 01              lda    <__stack+1
       04:B0D6  E9 00              sbc    #high(2)
       04:B0D8  85 01              sta    <__stack+1
       04:B0DA  68                 pla
       04:B0DB  22                 sax
       04:B0DC  92 00              sta    [__stack]
       04:B0DE  22                 sax
       04:B0DF  A0 01              ldy    #1
       04:B0E1  91 00              sta    [__stack],Y
  545                             __ldwi  _start_pos
       04:B0E3  A2 D5              ldx    #low(_start_pos)
       04:B0E5  A9 31              lda    #high(_start_pos)
  546                             __addwi 2
       04:B0E7  18                 clc
       04:B0E8  22                 sax
       04:B0E9  69 02              adc    #low(2)
       04:B0EB  22                 sax
       04:B0EC  69 00              adc    #high(2)
  547                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:B0EE  86 0B              stx    <__ptr
       04:B0F0  85 0C              sta    <__ptr+1
       04:B0F2  B2 0B              lda    [__ptr]
       04:B0F4  AA                 tax
       04:B0F5  62                 cla
                          ;        bpl    .x_01215   ; signed
                          ;        dec    A
                          ;.x_01215:
  548                             __stbps
                                 __stw    <__temp
       04:B0F6  86 03              stx    <__temp
       04:B0F8  85 04              sta    <__temp+1
                                 __ldwp    __stack
       04:B0FA  B2 00              lda    [__stack]
       04:B0FC  AA                 tax
       04:B0FD  A0 01              ldy    #1
       04:B0FF  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       04:B101  86 0B              stx    <__ptr
       04:B103  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       04:B105  A6 03              ldx    <__temp
       04:B107  A5 04              lda    <__temp+1
                                  .endif
       04:B109  22                 sax
       04:B10A  92 0B              sta    [__ptr]
       04:B10C  22                 sax
                                 __addmi  2,__stack
       04:B10D  48                 pha
       04:B10E  18                 clc
       04:B10F  A5 00              lda    <__stack
       04:B111  69 02              adc    #low(2)
       04:B113  85 00              sta    <__stack
       04:B115  A5 01              lda    <__stack+1
       04:B117  69 00              adc    #high(2)
       04:B119  85 01              sta    <__stack+1
       04:B11B  68                 pla
  549  04:B11C            LL18:
  550                     
  551                             __ldwi  _start_pos
       04:B11C  A2 D5              ldx    #low(_start_pos)
       04:B11E  A9 31              lda    #high(_start_pos)
  552                             __pushw
                                 __submi  2,__stack
       04:B120  48                 pha
       04:B121  38                 sec
       04:B122  A5 00              lda    <__stack
       04:B124  E9 02              sbc    #low(2)
       04:B126  85 00              sta    <__stack
       04:B128  A5 01              lda    <__stack+1
       04:B12A  E9 00              sbc    #high(2)
       04:B12C  85 01              sta    <__stack+1
       04:B12E  68                 pla
       04:B12F  22                 sax
       04:B130  92 00              sta    [__stack]
       04:B132  22                 sax
       04:B133  A0 01              ldy    #1
       04:B135  91 00              sta    [__stack],Y
  553                             __ldwi  _offset
       04:B137  A2 D8              ldx    #low(_offset)
       04:B139  A9 31              lda    #high(_offset)
  554  04:B13B  20 BA A2            call  _sub_3digit
  555  04:B13E            LL17:
  556                     
  557  04:B13E            LL16:
  558                     
  559                             __ldwi  _target
       04:B13E  A2 DB              ldx    #low(_target)
       04:B140  A9 31              lda    #high(_target)
  560                             __pushw
                                 __submi  2,__stack
       04:B142  48                 pha
       04:B143  38                 sec
       04:B144  A5 00              lda    <__stack
       04:B146  E9 02              sbc    #low(2)
       04:B148  85 00              sta    <__stack
       04:B14A  A5 01              lda    <__stack+1
       04:B14C  E9 00              sbc    #high(2)
       04:B14E  85 01              sta    <__stack+1
       04:B150  68                 pla
       04:B151  22                 sax
       04:B152  92 00              sta    [__stack]
       04:B154  22                 sax
       04:B155  A0 01              ldy    #1
       04:B157  91 00              sta    [__stack],Y
  561                             __ldwi  _result
       04:B159  A2 DE              ldx    #low(_result)
       04:B15B  A9 31              lda    #high(_result)
  562                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:B15D  86 0B              stx    <__ptr
       04:B15F  85 0C              sta    <__ptr+1
       04:B161  B2 0B              lda    [__ptr]
       04:B163  AA                 tax
       04:B164  62                 cla
                          ;        bpl    .x_01230   ; signed
                          ;        dec    A
                          ;.x_01230:
  563                             __stbps
                                 __stw    <__temp
       04:B165  86 03              stx    <__temp
       04:B167  85 04              sta    <__temp+1
                                 __ldwp    __stack
       04:B169  B2 00              lda    [__stack]
       04:B16B  AA                 tax
       04:B16C  A0 01              ldy    #1
       04:B16E  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       04:B170  86 0B              stx    <__ptr
       04:B172  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       04:B174  A6 03              ldx    <__temp
       04:B176  A5 04              lda    <__temp+1
                                  .endif
       04:B178  22                 sax
       04:B179  92 0B              sta    [__ptr]
       04:B17B  22                 sax
                                 __addmi  2,__stack
       04:B17C  48                 pha
       04:B17D  18                 clc
       04:B17E  A5 00              lda    <__stack
       04:B180  69 02              adc    #low(2)
       04:B182  85 00              sta    <__stack
       04:B184  A5 01              lda    <__stack+1
       04:B186  69 00              adc    #high(2)
       04:B188  85 01              sta    <__stack+1
       04:B18A  68                 pla
  564                             __ldwi  _target
       04:B18B  A2 DB              ldx    #low(_target)
       04:B18D  A9 31              lda    #high(_target)
  565                             __addwi 1
       04:B18F  18                 clc
       04:B190  22                 sax
       04:B191  69 01              adc    #low(1)
       04:B193  22                 sax
       04:B194  69 00              adc    #high(1)
  566                             __pushw
                                 __submi  2,__stack
       04:B196  48                 pha
       04:B197  38                 sec
       04:B198  A5 00              lda    <__stack
       04:B19A  E9 02              sbc    #low(2)
       04:B19C  85 00              sta    <__stack
       04:B19E  A5 01              lda    <__stack+1
       04:B1A0  E9 00              sbc    #high(2)
       04:B1A2  85 01              sta    <__stack+1
       04:B1A4  68                 pla
       04:B1A5  22                 sax
       04:B1A6  92 00              sta    [__stack]
       04:B1A8  22                 sax
       04:B1A9  A0 01              ldy    #1
       04:B1AB  91 00              sta    [__stack],Y
  567                             __ldwi  _result
       04:B1AD  A2 DE              ldx    #low(_result)
       04:B1AF  A9 31              lda    #high(_result)
  568                             __addwi 1
       04:B1B1  18                 clc
       04:B1B2  22                 sax
       04:B1B3  69 01              adc    #low(1)
       04:B1B5  22                 sax
       04:B1B6  69 00              adc    #high(1)
  569                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:B1B8  86 0B              stx    <__ptr
       04:B1BA  85 0C              sta    <__ptr+1
       04:B1BC  B2 0B              lda    [__ptr]
       04:B1BE  AA                 tax
       04:B1BF  62                 cla
                          ;        bpl    .x_01243   ; signed
                          ;        dec    A
                          ;.x_01243:
  570                             __stbps
                                 __stw    <__temp
       04:B1C0  86 03              stx    <__temp
       04:B1C2  85 04              sta    <__temp+1
                                 __ldwp    __stack
       04:B1C4  B2 00              lda    [__stack]
       04:B1C6  AA                 tax
       04:B1C7  A0 01              ldy    #1
       04:B1C9  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       04:B1CB  86 0B              stx    <__ptr
       04:B1CD  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       04:B1CF  A6 03              ldx    <__temp
       04:B1D1  A5 04              lda    <__temp+1
                                  .endif
       04:B1D3  22                 sax
       04:B1D4  92 0B              sta    [__ptr]
       04:B1D6  22                 sax
                                 __addmi  2,__stack
       04:B1D7  48                 pha
       04:B1D8  18                 clc
       04:B1D9  A5 00              lda    <__stack
       04:B1DB  69 02              adc    #low(2)
       04:B1DD  85 00              sta    <__stack
       04:B1DF  A5 01              lda    <__stack+1
       04:B1E1  69 00              adc    #high(2)
       04:B1E3  85 01              sta    <__stack+1
       04:B1E5  68                 pla
  571                             __ldwi  _target
       04:B1E6  A2 DB              ldx    #low(_target)
       04:B1E8  A9 31              lda    #high(_target)
  572                             __addwi 2
       04:B1EA  18                 clc
       04:B1EB  22                 sax
       04:B1EC  69 02              adc    #low(2)
       04:B1EE  22                 sax
       04:B1EF  69 00              adc    #high(2)
  573                             __pushw
                                 __submi  2,__stack
       04:B1F1  48                 pha
       04:B1F2  38                 sec
       04:B1F3  A5 00              lda    <__stack
       04:B1F5  E9 02              sbc    #low(2)
       04:B1F7  85 00              sta    <__stack
       04:B1F9  A5 01              lda    <__stack+1
       04:B1FB  E9 00              sbc    #high(2)
       04:B1FD  85 01              sta    <__stack+1
       04:B1FF  68                 pla
       04:B200  22                 sax
       04:B201  92 00              sta    [__stack]
       04:B203  22                 sax
       04:B204  A0 01              ldy    #1
       04:B206  91 00              sta    [__stack],Y
  574                             __ldwi  _result
       04:B208  A2 DE              ldx    #low(_result)
       04:B20A  A9 31              lda    #high(_result)
  575                             __addwi 2
       04:B20C  18                 clc
       04:B20D  22                 sax
       04:B20E  69 02              adc    #low(2)
       04:B210  22                 sax
       04:B211  69 00              adc    #high(2)
  576                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       04:B213  86 0B              stx    <__ptr
       04:B215  85 0C              sta    <__ptr+1
       04:B217  B2 0B              lda    [__ptr]
       04:B219  AA                 tax
       04:B21A  62                 cla
                          ;        bpl    .x_01256   ; signed
                          ;        dec    A
                          ;.x_01256:
  577                             __stbps
                                 __stw    <__temp
       04:B21B  86 03              stx    <__temp
       04:B21D  85 04              sta    <__temp+1
                                 __ldwp    __stack
       04:B21F  B2 00              lda    [__stack]
       04:B221  AA                 tax
       04:B222  A0 01              ldy    #1
       04:B224  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       04:B226  86 0B              stx    <__ptr
       04:B228  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       04:B22A  A6 03              ldx    <__temp
       04:B22C  A5 04              lda    <__temp+1
                                  .endif
       04:B22E  22                 sax
       04:B22F  92 0B              sta    [__ptr]
       04:B231  22                 sax
                                 __addmi  2,__stack
       04:B232  48                 pha
       04:B233  18                 clc
       04:B234  A5 00              lda    <__stack
       04:B236  69 02              adc    #low(2)
       04:B238  85 00              sta    <__stack
       04:B23A  A5 01              lda    <__stack+1
       04:B23C  69 00              adc    #high(2)
       04:B23E  85 01              sta    <__stack+1
       04:B240  68                 pla
  578  04:B241            LL13:
  579                     
  580  04:B241  60                  rts
  581                             .endp
  582                     
  583  04:5242                    .proc _clear_index
  584                             __ldwi  LL0+0
       04:B242  A2 00              ldx    #low(LL0+0)
       04:B244  A9 40              lda    #high(LL0+0)
  585                             __phw   3,3
                                   ; #1 (bytes :  9, cycles : 16)
                                   ; #2 (bytes : 16, cycles : 28)
                          
                0001              .if (2 = 2)
       04:B246  A8                 tay
       04:B247  A5 02              lda    <__arg_idx
                                   add    #3
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       04:B249  18                 clc
       04:B24A  69 03              adc    #3
                                  .endif
       04:B24C  85 02              sta    <__arg_idx
       04:B24E  42                 say
                                  .else
                                  .endif
                          
       04:B24F  99 FC 31           sta    __arg-(3),Y
       04:B252  8A                 txa
       04:B253  99 FD 31           sta    __arg-(3-1),Y
  586                             __ldwi  14
       04:B256  A2 0E              ldx    #low(14)
       04:B258  A9 00              lda    #high(14)
  587                             __phb   1
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       04:B25A  A4 02              ldy    <__arg_idx
                                  .endif
                          
       04:B25C  8A                 txa
       04:B25D  99 FE 31           sta    __arg-(1),Y
  588                             __ldwi  6
       04:B260  A2 06              ldx    #low(6)
       04:B262  A9 00              lda    #high(6)
  589  04:B264  20 ED CE            call  _put_string.3
  590                             __ldwi  LL0+7
       04:B267  A2 07              ldx    #low(LL0+7)
       04:B269  A9 40              lda    #high(LL0+7)
  591                             __phw   3,3
                                   ; #1 (bytes :  9, cycles : 16)
                                   ; #2 (bytes : 16, cycles : 28)
                          
                0001              .if (2 = 2)
       04:B26B  A8                 tay
       04:B26C  A5 02              lda    <__arg_idx
                                   add    #3
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       04:B26E  18                 clc
       04:B26F  69 03              adc    #3
                                  .endif
       04:B271  85 02              sta    <__arg_idx
       04:B273  42                 say
                                  .else
                                  .endif
                          
       04:B274  99 FC 31           sta    __arg-(3),Y
       04:B277  8A                 txa
       04:B278  99 FD 31           sta    __arg-(3-1),Y
  592                             __ldwi  14
       04:B27B  A2 0E              ldx    #low(14)
       04:B27D  A9 00              lda    #high(14)
  593                             __phb   1
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       04:B27F  A4 02              ldy    <__arg_idx
                                  .endif
                          
       04:B281  8A                 txa
       04:B282  99 FE 31           sta    __arg-(1),Y
  594                             __ldwi  8
       04:B285  A2 08              ldx    #low(8)
       04:B287  A9 00              lda    #high(8)
  595  04:B289  20 ED CE            call  _put_string.3
  596                             __ldwi  LL0+14
       04:B28C  A2 0E              ldx    #low(LL0+14)
       04:B28E  A9 40              lda    #high(LL0+14)
  597                             __phw   3,3
                                   ; #1 (bytes :  9, cycles : 16)
                                   ; #2 (bytes : 16, cycles : 28)
                          
                0001              .if (2 = 2)
       04:B290  A8                 tay
       04:B291  A5 02              lda    <__arg_idx
                                   add    #3
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       04:B293  18                 clc
       04:B294  69 03              adc    #3
                                  .endif
       04:B296  85 02              sta    <__arg_idx
       04:B298  42                 say
                                  .else
                                  .endif
                          
       04:B299  99 FC 31           sta    __arg-(3),Y
       04:B29C  8A                 txa
       04:B29D  99 FD 31           sta    __arg-(3-1),Y
  598                             __ldwi  2
       04:B2A0  A2 02              ldx    #low(2)
       04:B2A2  A9 00              lda    #high(2)
  599                             __phb   1
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       04:B2A4  A4 02              ldy    <__arg_idx
                                  .endif
                          
       04:B2A6  8A                 txa
       04:B2A7  99 FE 31           sta    __arg-(1),Y
  600                             __ldwi  3
       04:B2AA  A2 03              ldx    #low(3)
       04:B2AC  A9 00              lda    #high(3)
  601  04:B2AE  20 ED CE            call  _put_string.3
  602                             __ldwi  LL0+18
       04:B2B1  A2 12              ldx    #low(LL0+18)
       04:B2B3  A9 40              lda    #high(LL0+18)
  603                             __phw   3,3
                                   ; #1 (bytes :  9, cycles : 16)
                                   ; #2 (bytes : 16, cycles : 28)
                          
                0001              .if (2 = 2)
       04:B2B5  A8                 tay
       04:B2B6  A5 02              lda    <__arg_idx
                                   add    #3
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       04:B2B8  18                 clc
       04:B2B9  69 03              adc    #3
                                  .endif
       04:B2BB  85 02              sta    <__arg_idx
       04:B2BD  42                 say
                                  .else
                                  .endif
                          
       04:B2BE  99 FC 31           sta    __arg-(3),Y
       04:B2C1  8A                 txa
       04:B2C2  99 FD 31           sta    __arg-(3-1),Y
  604                             __ldwi  26
       04:B2C5  A2 1A              ldx    #low(26)
       04:B2C7  A9 00              lda    #high(26)
  605                             __phb   1
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       04:B2C9  A4 02              ldy    <__arg_idx
                                  .endif
                          
       04:B2CB  8A                 txa
       04:B2CC  99 FE 31           sta    __arg-(1),Y
  606                             __ldwi  3
       04:B2CF  A2 03              ldx    #low(3)
       04:B2D1  A9 00              lda    #high(3)
  607  04:B2D3  20 ED CE            call  _put_string.3
  608  04:B2D6            LL24:
  609                     
  610  04:B2D6  60                  rts
  611                             .endp
  612                     
  613  04:52D7                    .proc _put_index
  614                             __ldb   _direction
                0000              .if (1 = 2)
                                  .else
       04:B2D7  AE E3 31           ldx    _direction
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01288
                          ;        dec    A
                          ;.x_01288:
       04:B2DA  62                 cla    ; unsigned
                                  .endif
  615                             __stw   <__temp
       04:B2DB  86 03              stx    <__temp
       04:B2DD  85 04              sta    <__temp+1
  616                             __ldwi  0
       04:B2DF  A2 00              ldx    #low(0)
       04:B2E1  A9 00              lda    #high(0)
  617  04:B2E3  20 58 C8            jsr   eqzp
  618                             __lbeq  LL26
       04:B2E6  D0 03              bne    .x01291
       04:B2E8  4C 13 B3           jmp    LL26
       04:B2EB            .x01291
  619                             __ldwi  LL0+22
       04:B2EB  A2 16              ldx    #low(LL0+22)
       04:B2ED  A9 40              lda    #high(LL0+22)
  620                             __phw   3,3
                                   ; #1 (bytes :  9, cycles : 16)
                                   ; #2 (bytes : 16, cycles : 28)
                          
                0001              .if (2 = 2)
       04:B2EF  A8                 tay
       04:B2F0  A5 02              lda    <__arg_idx
                                   add    #3
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       04:B2F2  18                 clc
       04:B2F3  69 03              adc    #3
                                  .endif
       04:B2F5  85 02              sta    <__arg_idx
       04:B2F7  42                 say
                                  .else
                                  .endif
                          
       04:B2F8  99 FC 31           sta    __arg-(3),Y
       04:B2FB  8A                 txa
       04:B2FC  99 FD 31           sta    __arg-(3-1),Y
  621                             __ldwi  14
       04:B2FF  A2 0E              ldx    #low(14)
       04:B301  A9 00              lda    #high(14)
  622                             __phb   1
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       04:B303  A4 02              ldy    <__arg_idx
                                  .endif
                          
       04:B305  8A                 txa
       04:B306  99 FE 31           sta    __arg-(1),Y
  623                             __ldwi  3
       04:B309  A2 03              ldx    #low(3)
       04:B30B  A9 00              lda    #high(3)
  624  04:B30D  20 ED CE            call  _put_string.3
  625                             __lbra  LL27
       04:B310  4C 38 B3           jmp    LL27
  626  04:B313            LL26:
  627                     
  628                             __ldwi  LL0+31
       04:B313  A2 1F              ldx    #low(LL0+31)
       04:B315  A9 40              lda    #high(LL0+31)
  629                             __phw   3,3
                                   ; #1 (bytes :  9, cycles : 16)
                                   ; #2 (bytes : 16, cycles : 28)
                          
                0001              .if (2 = 2)
       04:B317  A8                 tay
       04:B318  A5 02              lda    <__arg_idx
                                   add    #3
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       04:B31A  18                 clc
       04:B31B  69 03              adc    #3
                                  .endif
       04:B31D  85 02              sta    <__arg_idx
       04:B31F  42                 say
                                  .else
                                  .endif
                          
       04:B320  99 FC 31           sta    __arg-(3),Y
       04:B323  8A                 txa
       04:B324  99 FD 31           sta    __arg-(3-1),Y
  630                             __ldwi  14
       04:B327  A2 0E              ldx    #low(14)
       04:B329  A9 00              lda    #high(14)
  631                             __phb   1
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       04:B32B  A4 02              ldy    <__arg_idx
                                  .endif
                          
       04:B32D  8A                 txa
       04:B32E  99 FE 31           sta    __arg-(1),Y
  632                             __ldwi  3
       04:B331  A2 03              ldx    #low(3)
       04:B333  A9 00              lda    #high(3)
  633  04:B335  20 ED CE            call  _put_string.3
  634  04:B338            LL27:
  635                     
  636                             __ldb   _adjust
                0000              .if (1 = 2)
                                  .else
       04:B338  AE E1 31           ldx    _adjust
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01306
                          ;        dec    A
                          ;.x_01306:
       04:B33B  62                 cla    ; unsigned
                                  .endif
  637                             __stw   <__temp
       04:B33C  86 03              stx    <__temp
       04:B33E  85 04              sta    <__temp+1
  638                             __ldwi  0
       04:B340  A2 00              ldx    #low(0)
       04:B342  A9 00              lda    #high(0)
  639  04:B344  20 58 C8            jsr   eqzp
  640                             __lbeq  LL28
       04:B347  D0 03              bne    .x01309
       04:B349  4C 99 B3           jmp    LL28
       04:B34C            .x01309
  641                             __ldwi  LL0+40
       04:B34C  A2 28              ldx    #low(LL0+40)
       04:B34E  A9 40              lda    #high(LL0+40)
  642                             __phw   3,3
                                   ; #1 (bytes :  9, cycles : 16)
                                   ; #2 (bytes : 16, cycles : 28)
                          
                0001              .if (2 = 2)
       04:B350  A8                 tay
       04:B351  A5 02              lda    <__arg_idx
                                   add    #3
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       04:B353  18                 clc
       04:B354  69 03              adc    #3
                                  .endif
       04:B356  85 02              sta    <__arg_idx
       04:B358  42                 say
                                  .else
                                  .endif
                          
       04:B359  99 FC 31           sta    __arg-(3),Y
       04:B35C  8A                 txa
       04:B35D  99 FD 31           sta    __arg-(3-1),Y
  643                             __ldwi  2
       04:B360  A2 02              ldx    #low(2)
       04:B362  A9 00              lda    #high(2)
  644                             __phb   1
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       04:B364  A4 02              ldy    <__arg_idx
                                  .endif
                          
       04:B366  8A                 txa
       04:B367  99 FE 31           sta    __arg-(1),Y
  645                             __ldwi  3
       04:B36A  A2 03              ldx    #low(3)
       04:B36C  A9 00              lda    #high(3)
  646  04:B36E  20 ED CE            call  _put_string.3
  647                             __ldwi  LL0+44
       04:B371  A2 2C              ldx    #low(LL0+44)
       04:B373  A9 40              lda    #high(LL0+44)
  648                             __phw   3,3
                                   ; #1 (bytes :  9, cycles : 16)
                                   ; #2 (bytes : 16, cycles : 28)
                          
                0001              .if (2 = 2)
       04:B375  A8                 tay
       04:B376  A5 02              lda    <__arg_idx
                                   add    #3
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       04:B378  18                 clc
       04:B379  69 03              adc    #3
                                  .endif
       04:B37B  85 02              sta    <__arg_idx
       04:B37D  42                 say
                                  .else
                                  .endif
                          
       04:B37E  99 FC 31           sta    __arg-(3),Y
       04:B381  8A                 txa
       04:B382  99 FD 31           sta    __arg-(3-1),Y
  649                             __ldwi  26
       04:B385  A2 1A              ldx    #low(26)
       04:B387  A9 00              lda    #high(26)
  650                             __phb   1
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       04:B389  A4 02              ldy    <__arg_idx
                                  .endif
                          
       04:B38B  8A                 txa
       04:B38C  99 FE 31           sta    __arg-(1),Y
  651                             __ldwi  3
       04:B38F  A2 03              ldx    #low(3)
       04:B391  A9 00              lda    #high(3)
  652  04:B393  20 ED CE            call  _put_string.3
  653                             __lbra  LL29
       04:B396  4C BE B4           jmp    LL29
  654  04:B399            LL28:
  655                     
  656                             __ldb   _adjust
                0000              .if (1 = 2)
                                  .else
       04:B399  AE E1 31           ldx    _adjust
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01324
                          ;        dec    A
                          ;.x_01324:
       04:B39C  62                 cla    ; unsigned
                                  .endif
  657                             __stw   <__temp
       04:B39D  86 03              stx    <__temp
       04:B39F  85 04              sta    <__temp+1
  658                             __ldwi  1
       04:B3A1  A2 01              ldx    #low(1)
       04:B3A3  A9 00              lda    #high(1)
  659  04:B3A5  20 58 C8            jsr   eqzp
  660                             __lbeq  LL30
       04:B3A8  D0 03              bne    .x01327
       04:B3AA  4C 2D B4           jmp    LL30
       04:B3AD            .x01327
  661                             __ldwi  LL0+48
       04:B3AD  A2 30              ldx    #low(LL0+48)
       04:B3AF  A9 40              lda    #high(LL0+48)
  662                             __phw   3,3
                                   ; #1 (bytes :  9, cycles : 16)
                                   ; #2 (bytes : 16, cycles : 28)
                          
                0001              .if (2 = 2)
       04:B3B1  A8                 tay
       04:B3B2  A5 02              lda    <__arg_idx
                                   add    #3
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       04:B3B4  18                 clc
       04:B3B5  69 03              adc    #3
                                  .endif
       04:B3B7  85 02              sta    <__arg_idx
       04:B3B9  42                 say
                                  .else
                                  .endif
                          
       04:B3BA  99 FC 31           sta    __arg-(3),Y
       04:B3BD  8A                 txa
       04:B3BE  99 FD 31           sta    __arg-(3-1),Y
  663                             __ldwi  14
       04:B3C1  A2 0E              ldx    #low(14)
       04:B3C3  A9 00              lda    #high(14)
  664                             __phb   1
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       04:B3C5  A4 02              ldy    <__arg_idx
                                  .endif
                          
       04:B3C7  8A                 txa
       04:B3C8  99 FE 31           sta    __arg-(1),Y
  665                             __ldwi  6
       04:B3CB  A2 06              ldx    #low(6)
       04:B3CD  A9 00              lda    #high(6)
  666  04:B3CF  20 ED CE            call  _put_string.3
  667                             __ldwi  LL0+55
       04:B3D2  A2 37              ldx    #low(LL0+55)
       04:B3D4  A9 40              lda    #high(LL0+55)
  668                             __phw   3,3
                                   ; #1 (bytes :  9, cycles : 16)
                                   ; #2 (bytes : 16, cycles : 28)
                          
                0001              .if (2 = 2)
       04:B3D6  A8                 tay
       04:B3D7  A5 02              lda    <__arg_idx
                                   add    #3
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       04:B3D9  18                 clc
       04:B3DA  69 03              adc    #3
                                  .endif
       04:B3DC  85 02              sta    <__arg_idx
       04:B3DE  42                 say
                                  .else
                                  .endif
                          
       04:B3DF  99 FC 31           sta    __arg-(3),Y
       04:B3E2  8A                 txa
       04:B3E3  99 FD 31           sta    __arg-(3-1),Y
  669                             __ldwi  14
       04:B3E6  A2 0E              ldx    #low(14)
       04:B3E8  A9 00              lda    #high(14)
  670                             __pushw
                                 __submi  2,__stack
       04:B3EA  48                 pha
       04:B3EB  38                 sec
       04:B3EC  A5 00              lda    <__stack
       04:B3EE  E9 02              sbc    #low(2)
       04:B3F0  85 00              sta    <__stack
       04:B3F2  A5 01              lda    <__stack+1
       04:B3F4  E9 00              sbc    #high(2)
       04:B3F6  85 01              sta    <__stack+1
       04:B3F8  68                 pla
       04:B3F9  22                 sax
       04:B3FA  92 00              sta    [__stack]
       04:B3FC  22                 sax
       04:B3FD  A0 01              ldy    #1
       04:B3FF  91 00              sta    [__stack],Y
  671                             __ldb   _edit_pos
                0000              .if (1 = 2)
                                  .else
       04:B401  AE E2 31           ldx    _edit_pos
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01341
                          ;        dec    A
                          ;.x_01341:
       04:B404  62                 cla    ; unsigned
                                  .endif
  672                             __addws
       04:B405  22                 sax
       04:B406  18                 clc
       04:B407  72 00              adc    [__stack]
       04:B409  22                 sax
       04:B40A  A0 01              ldy    #1
       04:B40C  71 00              adc    [__stack],Y
                                 __addmi 2, __stack
       04:B40E  48                 pha
       04:B40F  18                 clc
       04:B410  A5 00              lda    <__stack
       04:B412  69 02              adc    #low(2)
       04:B414  85 00              sta    <__stack
       04:B416  A5 01              lda    <__stack+1
       04:B418  69 00              adc    #high(2)
       04:B41A  85 01              sta    <__stack+1
       04:B41C  68                 pla
  673                             __phb   1
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       04:B41D  A4 02              ldy    <__arg_idx
                                  .endif
                          
       04:B41F  8A                 txa
       04:B420  99 FE 31           sta    __arg-(1),Y
  674                             __ldwi  6
       04:B423  A2 06              ldx    #low(6)
       04:B425  A9 00              lda    #high(6)
  675  04:B427  20 ED CE            call  _put_string.3
  676                             __lbra  LL31
       04:B42A  4C BE B4           jmp    LL31
  677  04:B42D            LL30:
  678                     
  679                             __ldb   _adjust
                0000              .if (1 = 2)
                                  .else
       04:B42D  AE E1 31           ldx    _adjust
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01348
                          ;        dec    A
                          ;.x_01348:
       04:B430  62                 cla    ; unsigned
                                  .endif
  680                             __stw   <__temp
       04:B431  86 03              stx    <__temp
       04:B433  85 04              sta    <__temp+1
  681                             __ldwi  2
       04:B435  A2 02              ldx    #low(2)
       04:B437  A9 00              lda    #high(2)
  682  04:B439  20 58 C8            jsr   eqzp
  683                             __lbeq  LL32
       04:B43C  D0 03              bne    .x01351
       04:B43E  4C BE B4           jmp    LL32
       04:B441            .x01351
  684                             __ldwi  LL0+57
       04:B441  A2 39              ldx    #low(LL0+57)
       04:B443  A9 40              lda    #high(LL0+57)
  685                             __phw   3,3
                                   ; #1 (bytes :  9, cycles : 16)
                                   ; #2 (bytes : 16, cycles : 28)
                          
                0001              .if (2 = 2)
       04:B445  A8                 tay
       04:B446  A5 02              lda    <__arg_idx
                                   add    #3
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       04:B448  18                 clc
       04:B449  69 03              adc    #3
                                  .endif
       04:B44B  85 02              sta    <__arg_idx
       04:B44D  42                 say
                                  .else
                                  .endif
                          
       04:B44E  99 FC 31           sta    __arg-(3),Y
       04:B451  8A                 txa
       04:B452  99 FD 31           sta    __arg-(3-1),Y
  686                             __ldwi  14
       04:B455  A2 0E              ldx    #low(14)
       04:B457  A9 00              lda    #high(14)
  687                             __phb   1
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       04:B459  A4 02              ldy    <__arg_idx
                                  .endif
                          
       04:B45B  8A                 txa
       04:B45C  99 FE 31           sta    __arg-(1),Y
  688                             __ldwi  8
       04:B45F  A2 08              ldx    #low(8)
       04:B461  A9 00              lda    #high(8)
  689  04:B463  20 ED CE            call  _put_string.3
  690                             __ldwi  LL0+64
       04:B466  A2 40              ldx    #low(LL0+64)
       04:B468  A9 40              lda    #high(LL0+64)
  691                             __phw   3,3
                                   ; #1 (bytes :  9, cycles : 16)
                                   ; #2 (bytes : 16, cycles : 28)
                          
                0001              .if (2 = 2)
       04:B46A  A8                 tay
       04:B46B  A5 02              lda    <__arg_idx
                                   add    #3
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       04:B46D  18                 clc
       04:B46E  69 03              adc    #3
                                  .endif
       04:B470  85 02              sta    <__arg_idx
       04:B472  42                 say
                                  .else
                                  .endif
                          
       04:B473  99 FC 31           sta    __arg-(3),Y
       04:B476  8A                 txa
       04:B477  99 FD 31           sta    __arg-(3-1),Y
  692                             __ldwi  14
       04:B47A  A2 0E              ldx    #low(14)
       04:B47C  A9 00              lda    #high(14)
  693                             __pushw
                                 __submi  2,__stack
       04:B47E  48                 pha
       04:B47F  38                 sec
       04:B480  A5 00              lda    <__stack
       04:B482  E9 02              sbc    #low(2)
       04:B484  85 00              sta    <__stack
       04:B486  A5 01              lda    <__stack+1
       04:B488  E9 00              sbc    #high(2)
       04:B48A  85 01              sta    <__stack+1
       04:B48C  68                 pla
       04:B48D  22                 sax
       04:B48E  92 00              sta    [__stack]
       04:B490  22                 sax
       04:B491  A0 01              ldy    #1
       04:B493  91 00              sta    [__stack],Y
  694                             __ldb   _edit_pos
                0000              .if (1 = 2)
                                  .else
       04:B495  AE E2 31           ldx    _edit_pos
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01365
                          ;        dec    A
                          ;.x_01365:
       04:B498  62                 cla    ; unsigned
                                  .endif
  695                             __addws
       04:B499  22                 sax
       04:B49A  18                 clc
       04:B49B  72 00              adc    [__stack]
       04:B49D  22                 sax
       04:B49E  A0 01              ldy    #1
       04:B4A0  71 00              adc    [__stack],Y
                                 __addmi 2, __stack
       04:B4A2  48                 pha
       04:B4A3  18                 clc
       04:B4A4  A5 00              lda    <__stack
       04:B4A6  69 02              adc    #low(2)
       04:B4A8  85 00              sta    <__stack
       04:B4AA  A5 01              lda    <__stack+1
       04:B4AC  69 00              adc    #high(2)
       04:B4AE  85 01              sta    <__stack+1
       04:B4B0  68                 pla
  696                             __phb   1
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       04:B4B1  A4 02              ldy    <__arg_idx
                                  .endif
                          
       04:B4B3  8A                 txa
       04:B4B4  99 FE 31           sta    __arg-(1),Y
  697                             __ldwi  8
       04:B4B7  A2 08              ldx    #low(8)
       04:B4B9  A9 00              lda    #high(8)
  698  04:B4BB  20 ED CE            call  _put_string.3
  699  04:B4BE            LL32:
  700                     
  701  04:B4BE            LL31:
  702                     
  703  04:B4BE            LL29:
  704                     
  705  04:B4BE            LL25:
  706                     
  707  04:B4BE  60                  rts
  708                             .endp
  709                     
  710  05:4000                    .proc _main
  711                             __ldwi  0
       05:A000  A2 00              ldx    #low(0)
       05:A002  A9 00              lda    #high(0)
  712                             __stw   _color_reg
       05:A004  8E 02 04           stx    _color_reg
       05:A007  8D 03 04           sta    _color_reg+1
  713                             __ldwi  0
       05:A00A  A2 00              ldx    #low(0)
       05:A00C  A9 00              lda    #high(0)
  714                             __stw   _color_data
       05:A00E  8E 04 04           stx    _color_data
       05:A011  8D 05 04           sta    _color_data+1
  715                             __ldwi  1
       05:A014  A2 01              ldx    #low(1)
       05:A016  A9 00              lda    #high(1)
  716                             __stw   _color_reg
       05:A018  8E 02 04           stx    _color_reg
       05:A01B  8D 03 04           sta    _color_reg+1
  717                             __ldwi  511
       05:A01E  A2 FF              ldx    #low(511)
       05:A020  A9 01              lda    #high(511)
  718                             __stw   _color_data
       05:A022  8E 04 04           stx    _color_data
       05:A025  8D 05 04           sta    _color_data+1
  719                             __ldwi  0
       05:A028  A2 00              ldx    #low(0)
       05:A02A  A9 00              lda    #high(0)
  720  05:A02C  8E FE 31            stx   _i
  721  05:A02F            LL34:
  722                     
  723                             __ldb   _i
                0000              .if (1 = 2)
                                  .else
       05:A02F  AE FE 31           ldx    _i
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01380
                          ;        dec    A
                          ;.x_01380:
       05:A032  62                 cla    ; unsigned
                                  .endif
  724                             __stw   <__temp
       05:A033  86 03              stx    <__temp
       05:A035  85 04              sta    <__temp+1
  725                             __ldwi  3
       05:A037  A2 03              ldx    #low(3)
       05:A039  A9 00              lda    #high(3)
  726  05:A03B  20 FF C8            jsr   ltzp
  727                             __lbne  LL36
       05:A03E  F0 03              beq    .x01383
       05:A040  4C 5E A0           jmp    LL36
       05:A043            .x01383
  728                             __lbra  LL37
       05:A043  4C C9 A1           jmp    LL37
  729  05:A046            LL35:
  730                     
  731                             __ldb   _i
                0000              .if (1 = 2)
                                  .else
       05:A046  AE FE 31           ldx    _i
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01386
                          ;        dec    A
                          ;.x_01386:
       05:A049  62                 cla    ; unsigned
                                  .endif
  732                             __addwi 1
       05:A04A  18                 clc
       05:A04B  22                 sax
       05:A04C  69 01              adc    #low(1)
       05:A04E  22                 sax
       05:A04F  69 00              adc    #high(1)
  733  05:A051  8E FE 31            stx   _i
  734                             __subwi 1
       05:A054  38                 sec
       05:A055  22                 sax
       05:A056  E9 01              sbc    #low(1)
       05:A058  22                 sax
       05:A059  E9 00              sbc    #high(1)
  735                             __lbra  LL34
       05:A05B  4C 2F A0           jmp    LL34
  736  05:A05E            LL36:
  737                     
  738                             __ldwi  _start_pos
       05:A05E  A2 D5              ldx    #low(_start_pos)
       05:A060  A9 31              lda    #high(_start_pos)
  739                             __pushw
                                 __submi  2,__stack
       05:A062  48                 pha
       05:A063  38                 sec
       05:A064  A5 00              lda    <__stack
       05:A066  E9 02              sbc    #low(2)
       05:A068  85 00              sta    <__stack
       05:A06A  A5 01              lda    <__stack+1
       05:A06C  E9 00              sbc    #high(2)
       05:A06E  85 01              sta    <__stack+1
       05:A070  68                 pla
       05:A071  22                 sax
       05:A072  92 00              sta    [__stack]
       05:A074  22                 sax
       05:A075  A0 01              ldy    #1
       05:A077  91 00              sta    [__stack],Y
  740                             __ldb   _i
                0000              .if (1 = 2)
                                  .else
       05:A079  AE FE 31           ldx    _i
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01394
                          ;        dec    A
                          ;.x_01394:
       05:A07C  62                 cla    ; unsigned
                                  .endif
  741                             __addws
       05:A07D  22                 sax
       05:A07E  18                 clc
       05:A07F  72 00              adc    [__stack]
       05:A081  22                 sax
       05:A082  A0 01              ldy    #1
       05:A084  71 00              adc    [__stack],Y
                                 __addmi 2, __stack
       05:A086  48                 pha
       05:A087  18                 clc
       05:A088  A5 00              lda    <__stack
       05:A08A  69 02              adc    #low(2)
       05:A08C  85 00              sta    <__stack
       05:A08E  A5 01              lda    <__stack+1
       05:A090  69 00              adc    #high(2)
       05:A092  85 01              sta    <__stack+1
       05:A094  68                 pla
  742                             __pushw
                                 __submi  2,__stack
       05:A095  48                 pha
       05:A096  38                 sec
       05:A097  A5 00              lda    <__stack
       05:A099  E9 02              sbc    #low(2)
       05:A09B  85 00              sta    <__stack
       05:A09D  A5 01              lda    <__stack+1
       05:A09F  E9 00              sbc    #high(2)
       05:A0A1  85 01              sta    <__stack+1
       05:A0A3  68                 pla
       05:A0A4  22                 sax
       05:A0A5  92 00              sta    [__stack]
       05:A0A7  22                 sax
       05:A0A8  A0 01              ldy    #1
       05:A0AA  91 00              sta    [__stack],Y
  743                             __ldwi  0
       05:A0AC  A2 00              ldx    #low(0)
       05:A0AE  A9 00              lda    #high(0)
  744                             __stbps
                                 __stw    <__temp
       05:A0B0  86 03              stx    <__temp
       05:A0B2  85 04              sta    <__temp+1
                                 __ldwp    __stack
       05:A0B4  B2 00              lda    [__stack]
       05:A0B6  AA                 tax
       05:A0B7  A0 01              ldy    #1
       05:A0B9  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       05:A0BB  86 0B              stx    <__ptr
       05:A0BD  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       05:A0BF  A6 03              ldx    <__temp
       05:A0C1  A5 04              lda    <__temp+1
                                  .endif
       05:A0C3  22                 sax
       05:A0C4  92 0B              sta    [__ptr]
       05:A0C6  22                 sax
                                 __addmi  2,__stack
       05:A0C7  48                 pha
       05:A0C8  18                 clc
       05:A0C9  A5 00              lda    <__stack
       05:A0CB  69 02              adc    #low(2)
       05:A0CD  85 00              sta    <__stack
       05:A0CF  A5 01              lda    <__stack+1
       05:A0D1  69 00              adc    #high(2)
       05:A0D3  85 01              sta    <__stack+1
       05:A0D5  68                 pla
  745                             __ldwi  _offset
       05:A0D6  A2 D8              ldx    #low(_offset)
       05:A0D8  A9 31              lda    #high(_offset)
  746                             __pushw
                                 __submi  2,__stack
       05:A0DA  48                 pha
       05:A0DB  38                 sec
       05:A0DC  A5 00              lda    <__stack
       05:A0DE  E9 02              sbc    #low(2)
       05:A0E0  85 00              sta    <__stack
       05:A0E2  A5 01              lda    <__stack+1
       05:A0E4  E9 00              sbc    #high(2)
       05:A0E6  85 01              sta    <__stack+1
       05:A0E8  68                 pla
       05:A0E9  22                 sax
       05:A0EA  92 00              sta    [__stack]
       05:A0EC  22                 sax
       05:A0ED  A0 01              ldy    #1
       05:A0EF  91 00              sta    [__stack],Y
  747                             __ldb   _i
                0000              .if (1 = 2)
                                  .else
       05:A0F1  AE FE 31           ldx    _i
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01410
                          ;        dec    A
                          ;.x_01410:
       05:A0F4  62                 cla    ; unsigned
                                  .endif
  748                             __addws
       05:A0F5  22                 sax
       05:A0F6  18                 clc
       05:A0F7  72 00              adc    [__stack]
       05:A0F9  22                 sax
       05:A0FA  A0 01              ldy    #1
       05:A0FC  71 00              adc    [__stack],Y
                                 __addmi 2, __stack
       05:A0FE  48                 pha
       05:A0FF  18                 clc
       05:A100  A5 00              lda    <__stack
       05:A102  69 02              adc    #low(2)
       05:A104  85 00              sta    <__stack
       05:A106  A5 01              lda    <__stack+1
       05:A108  69 00              adc    #high(2)
       05:A10A  85 01              sta    <__stack+1
       05:A10C  68                 pla
  749                             __pushw
                                 __submi  2,__stack
       05:A10D  48                 pha
       05:A10E  38                 sec
       05:A10F  A5 00              lda    <__stack
       05:A111  E9 02              sbc    #low(2)
       05:A113  85 00              sta    <__stack
       05:A115  A5 01              lda    <__stack+1
       05:A117  E9 00              sbc    #high(2)
       05:A119  85 01              sta    <__stack+1
       05:A11B  68                 pla
       05:A11C  22                 sax
       05:A11D  92 00              sta    [__stack]
       05:A11F  22                 sax
       05:A120  A0 01              ldy    #1
       05:A122  91 00              sta    [__stack],Y
  750                             __ldwi  0
       05:A124  A2 00              ldx    #low(0)
       05:A126  A9 00              lda    #high(0)
  751                             __stbps
                                 __stw    <__temp
       05:A128  86 03              stx    <__temp
       05:A12A  85 04              sta    <__temp+1
                                 __ldwp    __stack
       05:A12C  B2 00              lda    [__stack]
       05:A12E  AA                 tax
       05:A12F  A0 01              ldy    #1
       05:A131  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       05:A133  86 0B              stx    <__ptr
       05:A135  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       05:A137  A6 03              ldx    <__temp
       05:A139  A5 04              lda    <__temp+1
                                  .endif
       05:A13B  22                 sax
       05:A13C  92 0B              sta    [__ptr]
       05:A13E  22                 sax
                                 __addmi  2,__stack
       05:A13F  48                 pha
       05:A140  18                 clc
       05:A141  A5 00              lda    <__stack
       05:A143  69 02              adc    #low(2)
       05:A145  85 00              sta    <__stack
       05:A147  A5 01              lda    <__stack+1
       05:A149  69 00              adc    #high(2)
       05:A14B  85 01              sta    <__stack+1
       05:A14D  68                 pla
  752                             __ldwi  _target
       05:A14E  A2 DB              ldx    #low(_target)
       05:A150  A9 31              lda    #high(_target)
  753                             __pushw
                                 __submi  2,__stack
       05:A152  48                 pha
       05:A153  38                 sec
       05:A154  A5 00              lda    <__stack
       05:A156  E9 02              sbc    #low(2)
       05:A158  85 00              sta    <__stack
       05:A15A  A5 01              lda    <__stack+1
       05:A15C  E9 00              sbc    #high(2)
       05:A15E  85 01              sta    <__stack+1
       05:A160  68                 pla
       05:A161  22                 sax
       05:A162  92 00              sta    [__stack]
       05:A164  22                 sax
       05:A165  A0 01              ldy    #1
       05:A167  91 00              sta    [__stack],Y
  754                             __ldb   _i
                0000              .if (1 = 2)
                                  .else
       05:A169  AE FE 31           ldx    _i
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01426
                          ;        dec    A
                          ;.x_01426:
       05:A16C  62                 cla    ; unsigned
                                  .endif
  755                             __addws
       05:A16D  22                 sax
       05:A16E  18                 clc
       05:A16F  72 00              adc    [__stack]
       05:A171  22                 sax
       05:A172  A0 01              ldy    #1
       05:A174  71 00              adc    [__stack],Y
                                 __addmi 2, __stack
       05:A176  48                 pha
       05:A177  18                 clc
       05:A178  A5 00              lda    <__stack
       05:A17A  69 02              adc    #low(2)
       05:A17C  85 00              sta    <__stack
       05:A17E  A5 01              lda    <__stack+1
       05:A180  69 00              adc    #high(2)
       05:A182  85 01              sta    <__stack+1
       05:A184  68                 pla
  756                             __pushw
                                 __submi  2,__stack
       05:A185  48                 pha
       05:A186  38                 sec
       05:A187  A5 00              lda    <__stack
       05:A189  E9 02              sbc    #low(2)
       05:A18B  85 00              sta    <__stack
       05:A18D  A5 01              lda    <__stack+1
       05:A18F  E9 00              sbc    #high(2)
       05:A191  85 01              sta    <__stack+1
       05:A193  68                 pla
       05:A194  22                 sax
       05:A195  92 00              sta    [__stack]
       05:A197  22                 sax
       05:A198  A0 01              ldy    #1
       05:A19A  91 00              sta    [__stack],Y
  757                             __ldwi  0
       05:A19C  A2 00              ldx    #low(0)
       05:A19E  A9 00              lda    #high(0)
  758                             __stbps
                                 __stw    <__temp
       05:A1A0  86 03              stx    <__temp
       05:A1A2  85 04              sta    <__temp+1
                                 __ldwp    __stack
       05:A1A4  B2 00              lda    [__stack]
       05:A1A6  AA                 tax
       05:A1A7  A0 01              ldy    #1
       05:A1A9  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       05:A1AB  86 0B              stx    <__ptr
       05:A1AD  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       05:A1AF  A6 03              ldx    <__temp
       05:A1B1  A5 04              lda    <__temp+1
                                  .endif
       05:A1B3  22                 sax
       05:A1B4  92 0B              sta    [__ptr]
       05:A1B6  22                 sax
                                 __addmi  2,__stack
       05:A1B7  48                 pha
       05:A1B8  18                 clc
       05:A1B9  A5 00              lda    <__stack
       05:A1BB  69 02              adc    #low(2)
       05:A1BD  85 00              sta    <__stack
       05:A1BF  A5 01              lda    <__stack+1
       05:A1C1  69 00              adc    #high(2)
       05:A1C3  85 01              sta    <__stack+1
       05:A1C5  68                 pla
  759                             __lbra  LL35
       05:A1C6  4C 46 A0           jmp    LL35
  760  05:A1C9            LL37:
  761                     
  762                             __ldwi  0
       05:A1C9  A2 00              ldx    #low(0)
       05:A1CB  A9 00              lda    #high(0)
  763  05:A1CD  8E E2 31            stx   _edit_pos
  764                             __ldwi  1
       05:A1D0  A2 01              ldx    #low(1)
       05:A1D2  A9 00              lda    #high(1)
  765  05:A1D4  8E E1 31            stx   _adjust
  766                             __ldwi  0
       05:A1D7  A2 00              ldx    #low(0)
       05:A1D9  A9 00              lda    #high(0)
  767  05:A1DB  8E E3 31            stx   _direction
  768                             __ldwi  LL0+66
       05:A1DE  A2 42              ldx    #low(LL0+66)
       05:A1E0  A9 40              lda    #high(LL0+66)
  769                             __phw   3,3
                                   ; #1 (bytes :  9, cycles : 16)
                                   ; #2 (bytes : 16, cycles : 28)
                          
                0001              .if (2 = 2)
       05:A1E2  A8                 tay
       05:A1E3  A5 02              lda    <__arg_idx
                                   add    #3
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       05:A1E5  18                 clc
       05:A1E6  69 03              adc    #3
                                  .endif
       05:A1E8  85 02              sta    <__arg_idx
       05:A1EA  42                 say
                                  .else
                                  .endif
                          
       05:A1EB  99 FC 31           sta    __arg-(3),Y
       05:A1EE  8A                 txa
       05:A1EF  99 FD 31           sta    __arg-(3-1),Y
  770                             __ldwi  10
       05:A1F2  A2 0A              ldx    #low(10)
       05:A1F4  A9 00              lda    #high(10)
  771                             __phb   1
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       05:A1F6  A4 02              ldy    <__arg_idx
                                  .endif
                          
       05:A1F8  8A                 txa
       05:A1F9  99 FE 31           sta    __arg-(1),Y
  772                             __ldwi  1
       05:A1FC  A2 01              ldx    #low(1)
       05:A1FE  A9 00              lda    #high(1)
  773  05:A200  20 ED CE            call  _put_string.3
  774                             __ldwi  LL0+81
       05:A203  A2 51              ldx    #low(LL0+81)
       05:A205  A9 40              lda    #high(LL0+81)
  775                             __phw   3,3
                                   ; #1 (bytes :  9, cycles : 16)
                                   ; #2 (bytes : 16, cycles : 28)
                          
                0001              .if (2 = 2)
       05:A207  A8                 tay
       05:A208  A5 02              lda    <__arg_idx
                                   add    #3
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       05:A20A  18                 clc
       05:A20B  69 03              adc    #3
                                  .endif
       05:A20D  85 02              sta    <__arg_idx
       05:A20F  42                 say
                                  .else
                                  .endif
                          
       05:A210  99 FC 31           sta    __arg-(3),Y
       05:A213  8A                 txa
       05:A214  99 FD 31           sta    __arg-(3-1),Y
  776                             __ldwi  2
       05:A217  A2 02              ldx    #low(2)
       05:A219  A9 00              lda    #high(2)
  777                             __phb   1
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       05:A21B  A4 02              ldy    <__arg_idx
                                  .endif
                          
       05:A21D  8A                 txa
       05:A21E  99 FE 31           sta    __arg-(1),Y
  778                             __ldwi  3
       05:A221  A2 03              ldx    #low(3)
       05:A223  A9 00              lda    #high(3)
  779  05:A225  20 ED CE            call  _put_string.3
  780                             __ldwi  LL0+94
       05:A228  A2 5E              ldx    #low(LL0+94)
       05:A22A  A9 40              lda    #high(LL0+94)
  781                             __phw   3,3
                                   ; #1 (bytes :  9, cycles : 16)
                                   ; #2 (bytes : 16, cycles : 28)
                          
                0001              .if (2 = 2)
       05:A22C  A8                 tay
       05:A22D  A5 02              lda    <__arg_idx
                                   add    #3
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       05:A22F  18                 clc
       05:A230  69 03              adc    #3
                                  .endif
       05:A232  85 02              sta    <__arg_idx
       05:A234  42                 say
                                  .else
                                  .endif
                          
       05:A235  99 FC 31           sta    __arg-(3),Y
       05:A238  8A                 txa
       05:A239  99 FD 31           sta    __arg-(3-1),Y
  782                             __ldwi  2
       05:A23C  A2 02              ldx    #low(2)
       05:A23E  A9 00              lda    #high(2)
  783                             __phb   1
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       05:A240  A4 02              ldy    <__arg_idx
                                  .endif
                          
       05:A242  8A                 txa
       05:A243  99 FE 31           sta    __arg-(1),Y
  784                             __ldwi  5
       05:A246  A2 05              ldx    #low(5)
       05:A248  A9 00              lda    #high(5)
  785  05:A24A  20 ED CE            call  _put_string.3
  786                             __ldwi  LL0+107
       05:A24D  A2 6B              ldx    #low(LL0+107)
       05:A24F  A9 40              lda    #high(LL0+107)
  787                             __phw   3,3
                                   ; #1 (bytes :  9, cycles : 16)
                                   ; #2 (bytes : 16, cycles : 28)
                          
                0001              .if (2 = 2)
       05:A251  A8                 tay
       05:A252  A5 02              lda    <__arg_idx
                                   add    #3
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       05:A254  18                 clc
       05:A255  69 03              adc    #3
                                  .endif
       05:A257  85 02              sta    <__arg_idx
       05:A259  42                 say
                                  .else
                                  .endif
                          
       05:A25A  99 FC 31           sta    __arg-(3),Y
       05:A25D  8A                 txa
       05:A25E  99 FD 31           sta    __arg-(3-1),Y
  788                             __ldwi  2
       05:A261  A2 02              ldx    #low(2)
       05:A263  A9 00              lda    #high(2)
  789                             __phb   1
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       05:A265  A4 02              ldy    <__arg_idx
                                  .endif
                          
       05:A267  8A                 txa
       05:A268  99 FE 31           sta    __arg-(1),Y
  790                             __ldwi  7
       05:A26B  A2 07              ldx    #low(7)
       05:A26D  A9 00              lda    #high(7)
  791  05:A26F  20 ED CE            call  _put_string.3
  792                             __ldwi  LL0+120
       05:A272  A2 78              ldx    #low(LL0+120)
       05:A274  A9 40              lda    #high(LL0+120)
  793                             __phw   3,3
                                   ; #1 (bytes :  9, cycles : 16)
                                   ; #2 (bytes : 16, cycles : 28)
                          
                0001              .if (2 = 2)
       05:A276  A8                 tay
       05:A277  A5 02              lda    <__arg_idx
                                   add    #3
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       05:A279  18                 clc
       05:A27A  69 03              adc    #3
                                  .endif
       05:A27C  85 02              sta    <__arg_idx
       05:A27E  42                 say
                                  .else
                                  .endif
                          
       05:A27F  99 FC 31           sta    __arg-(3),Y
       05:A282  8A                 txa
       05:A283  99 FD 31           sta    __arg-(3-1),Y
  794                             __ldwi  2
       05:A286  A2 02              ldx    #low(2)
       05:A288  A9 00              lda    #high(2)
  795                             __phb   1
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       05:A28A  A4 02              ldy    <__arg_idx
                                  .endif
                          
       05:A28C  8A                 txa
       05:A28D  99 FE 31           sta    __arg-(1),Y
  796                             __ldwi  9
       05:A290  A2 09              ldx    #low(9)
       05:A292  A9 00              lda    #high(9)
  797  05:A294  20 ED CE            call  _put_string.3
  798  05:A297  20 00 80            call  _show_startpos
  799  05:A29A  20 12 80            call  _show_offset
  800  05:A29D  20 24 80            call  _show_target
  801                             __ldwi  LL0+133
       05:A2A0  A2 85              ldx    #low(LL0+133)
       05:A2A2  A9 40              lda    #high(LL0+133)
  802                             __phw   3,3
                                   ; #1 (bytes :  9, cycles : 16)
                                   ; #2 (bytes : 16, cycles : 28)
                          
                0001              .if (2 = 2)
       05:A2A4  A8                 tay
       05:A2A5  A5 02              lda    <__arg_idx
                                   add    #3
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       05:A2A7  18                 clc
       05:A2A8  69 03              adc    #3
                                  .endif
       05:A2AA  85 02              sta    <__arg_idx
       05:A2AC  42                 say
                                  .else
                                  .endif
                          
       05:A2AD  99 FC 31           sta    __arg-(3),Y
       05:A2B0  8A                 txa
       05:A2B1  99 FD 31           sta    __arg-(3-1),Y
  803                             __ldwi  2
       05:A2B4  A2 02              ldx    #low(2)
       05:A2B6  A9 00              lda    #high(2)
  804                             __phb   1
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       05:A2B8  A4 02              ldy    <__arg_idx
                                  .endif
                          
       05:A2BA  8A                 txa
       05:A2BB  99 FE 31           sta    __arg-(1),Y
  805                             __ldwi  24
       05:A2BE  A2 18              ldx    #low(24)
       05:A2C0  A9 00              lda    #high(24)
  806  05:A2C2  20 ED CE            call  _put_string.3
  807                             __ldwi  LL0+162
       05:A2C5  A2 A2              ldx    #low(LL0+162)
       05:A2C7  A9 40              lda    #high(LL0+162)
  808                             __phw   3,3
                                   ; #1 (bytes :  9, cycles : 16)
                                   ; #2 (bytes : 16, cycles : 28)
                          
                0001              .if (2 = 2)
       05:A2C9  A8                 tay
       05:A2CA  A5 02              lda    <__arg_idx
                                   add    #3
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       05:A2CC  18                 clc
       05:A2CD  69 03              adc    #3
                                  .endif
       05:A2CF  85 02              sta    <__arg_idx
       05:A2D1  42                 say
                                  .else
                                  .endif
                          
       05:A2D2  99 FC 31           sta    __arg-(3),Y
       05:A2D5  8A                 txa
       05:A2D6  99 FD 31           sta    __arg-(3-1),Y
  809                             __ldwi  2
       05:A2D9  A2 02              ldx    #low(2)
       05:A2DB  A9 00              lda    #high(2)
  810                             __phb   1
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       05:A2DD  A4 02              ldy    <__arg_idx
                                  .endif
                          
       05:A2DF  8A                 txa
       05:A2E0  99 FE 31           sta    __arg-(1),Y
  811                             __ldwi  26
       05:A2E3  A2 1A              ldx    #low(26)
       05:A2E5  A9 00              lda    #high(26)
  812  05:A2E7  20 ED CE            call  _put_string.3
  813  05:A2EA            LL38:
  814                     
  815                             __ldwi  1
       05:A2EA  A2 01              ldx    #low(1)
       05:A2EC  A9 00              lda    #high(1)
  816                             __tstw
                                   ; pha
       05:A2EE  86 03              stx    <__temp
       05:A2F0  05 03              ora    <__temp
                                   ; pla
  817                             __lbeq  LL39
       05:A2F2  D0 03              bne    .x01486
       05:A2F4  4C 90 B1           jmp    LL39
       05:A2F7            .x01486
  818  05:A2F7  20 36 80            call  _put_index
  819                             __ldwi  0
       05:A2FA  A2 00              ldx    #low(0)
       05:A2FC  A9 00              lda    #high(0)
  820  05:A2FE  20 49 DA            call  _joytrg
  821  05:A301  8E D1 31            stx   _pad
  822                             __ldb   _adjust
                0000              .if (1 = 2)
                                  .else
       05:A304  AE E1 31           ldx    _adjust
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01489
                          ;        dec    A
                          ;.x_01489:
       05:A307  62                 cla    ; unsigned
                                  .endif
  823                             __stw   <__temp
       05:A308  86 03              stx    <__temp
       05:A30A  85 04              sta    <__temp+1
  824                             __ldwi  0
       05:A30C  A2 00              ldx    #low(0)
       05:A30E  A9 00              lda    #high(0)
  825  05:A310  20 58 C8            jsr   eqzp
  826                             __lbeq  LL40
       05:A313  D0 03              bne    .x01492
       05:A315  4C 8B A3           jmp    LL40
       05:A318            .x01492
  827                             __ldb   _pad
                0000              .if (1 = 2)
                                  .else
       05:A318  AE D1 31           ldx    _pad
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01494
                          ;        dec    A
                          ;.x_01494:
       05:A31B  62                 cla    ; unsigned
                                  .endif
  828                             __andwi 240
       05:A31C  22                 sax
       05:A31D  29 F0              and    #low(240)
       05:A31F  22                 sax
       05:A320  29 00              and    #high(240)
  829                             __tstw
                                   ; pha
       05:A322  86 03              stx    <__temp
       05:A324  05 03              ora    <__temp
                                   ; pla
  830                             __lbeq  LL41
       05:A326  D0 03              bne    .x01497
       05:A328  4C 68 A3           jmp    LL41
       05:A32B            .x01497
  831                             __ldb   _direction
                0000              .if (1 = 2)
                                  .else
       05:A32B  AE E3 31           ldx    _direction
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01499
                          ;        dec    A
                          ;.x_01499:
       05:A32E  62                 cla    ; unsigned
                                  .endif
  832                             __stw   <__temp
       05:A32F  86 03              stx    <__temp
       05:A331  85 04              sta    <__temp+1
  833                             __ldwi  0
       05:A333  A2 00              ldx    #low(0)
       05:A335  A9 00              lda    #high(0)
  834  05:A337  20 58 C8            jsr   eqzp
  835                             __lbeq  LL42
       05:A33A  D0 03              bne    .x01502
       05:A33C  4C 55 A3           jmp    LL42
       05:A33F            .x01502
  836                             __ldwi  1
       05:A33F  A2 01              ldx    #low(1)
       05:A341  A9 00              lda    #high(1)
  837  05:A343  8E E3 31            stx   _direction
  838  05:A346  20 36 80            call  _put_index
  839  05:A349  20 48 80            call  _fix_offset
  840  05:A34C  20 12 80            call  _show_offset
  841  05:A34F  20 24 80            call  _show_target
  842                             __lbra  LL43
       05:A352  4C 68 A3           jmp    LL43
  843  05:A355            LL42:
  844                     
  845                             __ldwi  0
       05:A355  A2 00              ldx    #low(0)
       05:A357  A9 00              lda    #high(0)
  846  05:A359  8E E3 31            stx   _direction
  847  05:A35C  20 36 80            call  _put_index
  848  05:A35F  20 48 80            call  _fix_offset
  849  05:A362  20 12 80            call  _show_offset
  850  05:A365  20 24 80            call  _show_target
  851  05:A368            LL43:
  852                     
  853  05:A368            LL41:
  854                     
  855                             __ldb   _pad
                0000              .if (1 = 2)
                                  .else
       05:A368  AE D1 31           ldx    _pad
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01507
                          ;        dec    A
                          ;.x_01507:
       05:A36B  62                 cla    ; unsigned
                                  .endif
  856                             __andwi 2
       05:A36C  22                 sax
       05:A36D  29 02              and    #low(2)
       05:A36F  22                 sax
       05:A370  29 00              and    #high(2)
  857                             __tstw
                                   ; pha
       05:A372  86 03              stx    <__temp
       05:A374  05 03              ora    <__temp
                                   ; pla
  858                             __lbeq  LL44
       05:A376  D0 03              bne    .x01510
       05:A378  4C 88 A3           jmp    LL44
       05:A37B            .x01510
  859                             __ldwi  1
       05:A37B  A2 01              ldx    #low(1)
       05:A37D  A9 00              lda    #high(1)
  860  05:A37F  8E E1 31            stx   _adjust
  861  05:A382  20 5A 80            call  _clear_index
  862  05:A385  20 36 80            call  _put_index
  863  05:A388            LL44:
  864                     
  865                             __lbra  LL45
       05:A388  4C 84 B1           jmp    LL45
  866  05:A38B            LL40:
  867                     
  868                             __ldb   _adjust
                0000              .if (1 = 2)
                                  .else
       05:A38B  AE E1 31           ldx    _adjust
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01514
                          ;        dec    A
                          ;.x_01514:
       05:A38E  62                 cla    ; unsigned
                                  .endif
  869                             __stw   <__temp
       05:A38F  86 03              stx    <__temp
       05:A391  85 04              sta    <__temp+1
  870                             __ldwi  1
       05:A393  A2 01              ldx    #low(1)
       05:A395  A9 00              lda    #high(1)
  871  05:A397  20 58 C8            jsr   eqzp
  872                             __lbne  LL47
       05:A39A  F0 03              beq    .x01517
       05:A39C  4C AE A3           jmp    LL47
       05:A39F            .x01517
  873                             __ldb   _adjust
                0000              .if (1 = 2)
                                  .else
       05:A39F  AE E1 31           ldx    _adjust
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01519
                          ;        dec    A
                          ;.x_01519:
       05:A3A2  62                 cla    ; unsigned
                                  .endif
  874                             __stw   <__temp
       05:A3A3  86 03              stx    <__temp
       05:A3A5  85 04              sta    <__temp+1
  875                             __ldwi  2
       05:A3A7  A2 02              ldx    #low(2)
       05:A3A9  A9 00              lda    #high(2)
  876  05:A3AB  20 58 C8            jsr   eqzp
  877  05:A3AE            LL47:
  878                     
  879                             __boolw
       05:A3AE  86 03              stx    <__temp
       05:A3B0  05 03              ora    <__temp
       05:A3B2  82                 clx
       05:A3B3  F0 01              beq    .x01522
       05:A3B5  E8                 inx
       05:A3B6  62        .x01522     cla
  880                             __tstw
                                   ; pha
       05:A3B7  86 03              stx    <__temp
       05:A3B9  05 03              ora    <__temp
                                   ; pla
  881                             __lbeq  LL46
       05:A3BB  D0 03              bne    .x01524
       05:A3BD  4C 84 B1           jmp    LL46
       05:A3C0            .x01524
  882                             __ldb   _pad
                0000              .if (1 = 2)
                                  .else
       05:A3C0  AE D1 31           ldx    _pad
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01526
                          ;        dec    A
                          ;.x_01526:
       05:A3C3  62                 cla    ; unsigned
                                  .endif
  883                             __andwi 128
       05:A3C4  22                 sax
       05:A3C5  29 80              and    #low(128)
       05:A3C7  22                 sax
       05:A3C8  29 00              and    #high(128)
  884                             __tstw
                                   ; pha
       05:A3CA  86 03              stx    <__temp
       05:A3CC  05 03              ora    <__temp
                                   ; pla
  885                             __lbeq  LL48
       05:A3CE  D0 03              bne    .x01529
       05:A3D0  4C F8 A3           jmp    LL48
       05:A3D3            .x01529
  886                             __ldb   _edit_pos
                0000              .if (1 = 2)
                                  .else
       05:A3D3  AE E2 31           ldx    _edit_pos
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01531
                          ;        dec    A
                          ;.x_01531:
       05:A3D6  62                 cla    ; unsigned
                                  .endif
  887                             __stw   <__temp
       05:A3D7  86 03              stx    <__temp
       05:A3D9  85 04              sta    <__temp+1
  888                             __ldwi  0
       05:A3DB  A2 00              ldx    #low(0)
       05:A3DD  A9 00              lda    #high(0)
  889  05:A3DF  20 28 C9            jsr   gtzp
  890                             __lbeq  LL49
       05:A3E2  D0 03              bne    .x01534
       05:A3E4  4C F8 A3           jmp    LL49
       05:A3E7            .x01534
  891                             __ldb   _edit_pos
                0000              .if (1 = 2)
                                  .else
       05:A3E7  AE E2 31           ldx    _edit_pos
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01536
                          ;        dec    A
                          ;.x_01536:
       05:A3EA  62                 cla    ; unsigned
                                  .endif
  892                             __subwi 1
       05:A3EB  38                 sec
       05:A3EC  22                 sax
       05:A3ED  E9 01              sbc    #low(1)
       05:A3EF  22                 sax
       05:A3F0  E9 00              sbc    #high(1)
  893  05:A3F2  8E E2 31            stx   _edit_pos
  894  05:A3F5  20 36 80            call  _put_index
  895  05:A3F8            LL49:
  896                     
  897  05:A3F8            LL48:
  898                     
  899                             __ldb   _pad
                0000              .if (1 = 2)
                                  .else
       05:A3F8  AE D1 31           ldx    _pad
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01539
                          ;        dec    A
                          ;.x_01539:
       05:A3FB  62                 cla    ; unsigned
                                  .endif
  900                             __andwi 32
       05:A3FC  22                 sax
       05:A3FD  29 20              and    #low(32)
       05:A3FF  22                 sax
       05:A400  29 00              and    #high(32)
  901                             __tstw
                                   ; pha
       05:A402  86 03              stx    <__temp
       05:A404  05 03              ora    <__temp
                                   ; pla
  902                             __lbeq  LL50
       05:A406  D0 03              bne    .x01542
       05:A408  4C 30 A4           jmp    LL50
       05:A40B            .x01542
  903                             __ldb   _edit_pos
                0000              .if (1 = 2)
                                  .else
       05:A40B  AE E2 31           ldx    _edit_pos
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01544
                          ;        dec    A
                          ;.x_01544:
       05:A40E  62                 cla    ; unsigned
                                  .endif
  904                             __stw   <__temp
       05:A40F  86 03              stx    <__temp
       05:A411  85 04              sta    <__temp+1
  905                             __ldwi  5
       05:A413  A2 05              ldx    #low(5)
       05:A415  A9 00              lda    #high(5)
  906  05:A417  20 FF C8            jsr   ltzp
  907                             __lbeq  LL51
       05:A41A  D0 03              bne    .x01547
       05:A41C  4C 30 A4           jmp    LL51
       05:A41F            .x01547
  908                             __ldb   _edit_pos
                0000              .if (1 = 2)
                                  .else
       05:A41F  AE E2 31           ldx    _edit_pos
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01549
                          ;        dec    A
                          ;.x_01549:
       05:A422  62                 cla    ; unsigned
                                  .endif
  909                             __addwi 1
       05:A423  18                 clc
       05:A424  22                 sax
       05:A425  69 01              adc    #low(1)
       05:A427  22                 sax
       05:A428  69 00              adc    #high(1)
  910  05:A42A  8E E2 31            stx   _edit_pos
  911  05:A42D  20 36 80            call  _put_index
  912  05:A430            LL51:
  913                     
  914  05:A430            LL50:
  915                     
  916                             __ldb   _pad
                0000              .if (1 = 2)
                                  .else
       05:A430  AE D1 31           ldx    _pad
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01552
                          ;        dec    A
                          ;.x_01552:
       05:A433  62                 cla    ; unsigned
                                  .endif
  917                             __andwi 16
       05:A434  22                 sax
       05:A435  29 10              and    #low(16)
       05:A437  22                 sax
       05:A438  29 00              and    #high(16)
  918                             __tstw
                                   ; pha
       05:A43A  86 03              stx    <__temp
       05:A43C  05 03              ora    <__temp
                                   ; pla
  919                             __lbeq  LL52
       05:A43E  D0 03              bne    .x01555
       05:A440  4C 75 A7           jmp    LL52
       05:A443            .x01555
  920                             __ldb   _adjust
                0000              .if (1 = 2)
                                  .else
       05:A443  AE E1 31           ldx    _adjust
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01557
                          ;        dec    A
                          ;.x_01557:
       05:A446  62                 cla    ; unsigned
                                  .endif
  921                             __stw   <__temp
       05:A447  86 03              stx    <__temp
       05:A449  85 04              sta    <__temp+1
  922                             __ldwi  1
       05:A44B  A2 01              ldx    #low(1)
       05:A44D  A9 00              lda    #high(1)
  923  05:A44F  20 58 C8            jsr   eqzp
  924                             __lbeq  LL53
       05:A452  D0 03              bne    .x01560
       05:A454  4C DF A5           jmp    LL53
       05:A457            .x01560
  925                             __ldwi  _start_pos
       05:A457  A2 D5              ldx    #low(_start_pos)
       05:A459  A9 31              lda    #high(_start_pos)
  926                             __pushw
                                 __submi  2,__stack
       05:A45B  48                 pha
       05:A45C  38                 sec
       05:A45D  A5 00              lda    <__stack
       05:A45F  E9 02              sbc    #low(2)
       05:A461  85 00              sta    <__stack
       05:A463  A5 01              lda    <__stack+1
       05:A465  E9 00              sbc    #high(2)
       05:A467  85 01              sta    <__stack+1
       05:A469  68                 pla
       05:A46A  22                 sax
       05:A46B  92 00              sta    [__stack]
       05:A46D  22                 sax
       05:A46E  A0 01              ldy    #1
       05:A470  91 00              sta    [__stack],Y
  927                             __ldwi  _add_num
       05:A472  A2 48              ldx    #low(_add_num)
       05:A474  A9 41              lda    #high(_add_num)
  928                             __pushw
                                 __submi  2,__stack
       05:A476  48                 pha
       05:A477  38                 sec
       05:A478  A5 00              lda    <__stack
       05:A47A  E9 02              sbc    #low(2)
       05:A47C  85 00              sta    <__stack
       05:A47E  A5 01              lda    <__stack+1
       05:A480  E9 00              sbc    #high(2)
       05:A482  85 01              sta    <__stack+1
       05:A484  68                 pla
       05:A485  22                 sax
       05:A486  92 00              sta    [__stack]
       05:A488  22                 sax
       05:A489  A0 01              ldy    #1
       05:A48B  91 00              sta    [__stack],Y
  929                             __ldb   _edit_pos
                0000              .if (1 = 2)
                                  .else
       05:A48D  AE E2 31           ldx    _edit_pos
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01568
                          ;        dec    A
                          ;.x_01568:
       05:A490  62                 cla    ; unsigned
                                  .endif
  930                             __pushw
                                 __submi  2,__stack
       05:A491  48                 pha
       05:A492  38                 sec
       05:A493  A5 00              lda    <__stack
       05:A495  E9 02              sbc    #low(2)
       05:A497  85 00              sta    <__stack
       05:A499  A5 01              lda    <__stack+1
       05:A49B  E9 00              sbc    #high(2)
       05:A49D  85 01              sta    <__stack+1
       05:A49F  68                 pla
       05:A4A0  22                 sax
       05:A4A1  92 00              sta    [__stack]
       05:A4A3  22                 sax
       05:A4A4  A0 01              ldy    #1
       05:A4A6  91 00              sta    [__stack],Y
  931                             __ldwi  3
       05:A4A8  A2 03              ldx    #low(3)
       05:A4AA  A9 00              lda    #high(3)
  932  05:A4AC  20 10 CA            jsr   smul
  933                             __addws
       05:A4AF  22                 sax
       05:A4B0  18                 clc
       05:A4B1  72 00              adc    [__stack]
       05:A4B3  22                 sax
       05:A4B4  A0 01              ldy    #1
       05:A4B6  71 00              adc    [__stack],Y
                                 __addmi 2, __stack
       05:A4B8  48                 pha
       05:A4B9  18                 clc
       05:A4BA  A5 00              lda    <__stack
       05:A4BC  69 02              adc    #low(2)
       05:A4BE  85 00              sta    <__stack
       05:A4C0  A5 01              lda    <__stack+1
       05:A4C2  69 00              adc    #high(2)
       05:A4C4  85 01              sta    <__stack+1
       05:A4C6  68                 pla
  934  05:A4C7  20 6C 80            call  _add_3digit
  935  05:A4CA  20 7E 80            call  _limit_startpos
  936                             __ldwi  _start_pos
       05:A4CD  A2 D5              ldx    #low(_start_pos)
       05:A4CF  A9 31              lda    #high(_start_pos)
  937                             __pushw
                                 __submi  2,__stack
       05:A4D1  48                 pha
       05:A4D2  38                 sec
       05:A4D3  A5 00              lda    <__stack
       05:A4D5  E9 02              sbc    #low(2)
       05:A4D7  85 00              sta    <__stack
       05:A4D9  A5 01              lda    <__stack+1
       05:A4DB  E9 00              sbc    #high(2)
       05:A4DD  85 01              sta    <__stack+1
       05:A4DF  68                 pla
       05:A4E0  22                 sax
       05:A4E1  92 00              sta    [__stack]
       05:A4E3  22                 sax
       05:A4E4  A0 01              ldy    #1
       05:A4E6  91 00              sta    [__stack],Y
  938                             __ldwi  _result
       05:A4E8  A2 DE              ldx    #low(_result)
       05:A4EA  A9 31              lda    #high(_result)
  939                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       05:A4EC  86 0B              stx    <__ptr
       05:A4EE  85 0C              sta    <__ptr+1
       05:A4F0  B2 0B              lda    [__ptr]
       05:A4F2  AA                 tax
       05:A4F3  62                 cla
                          ;        bpl    .x_01578   ; signed
                          ;        dec    A
                          ;.x_01578:
  940                             __stbps
                                 __stw    <__temp
       05:A4F4  86 03              stx    <__temp
       05:A4F6  85 04              sta    <__temp+1
                                 __ldwp    __stack
       05:A4F8  B2 00              lda    [__stack]
       05:A4FA  AA                 tax
       05:A4FB  A0 01              ldy    #1
       05:A4FD  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       05:A4FF  86 0B              stx    <__ptr
       05:A501  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       05:A503  A6 03              ldx    <__temp
       05:A505  A5 04              lda    <__temp+1
                                  .endif
       05:A507  22                 sax
       05:A508  92 0B              sta    [__ptr]
       05:A50A  22                 sax
                                 __addmi  2,__stack
       05:A50B  48                 pha
       05:A50C  18                 clc
       05:A50D  A5 00              lda    <__stack
       05:A50F  69 02              adc    #low(2)
       05:A511  85 00              sta    <__stack
       05:A513  A5 01              lda    <__stack+1
       05:A515  69 00              adc    #high(2)
       05:A517  85 01              sta    <__stack+1
       05:A519  68                 pla
  941                             __ldwi  _start_pos
       05:A51A  A2 D5              ldx    #low(_start_pos)
       05:A51C  A9 31              lda    #high(_start_pos)
  942                             __addwi 1
       05:A51E  18                 clc
       05:A51F  22                 sax
       05:A520  69 01              adc    #low(1)
       05:A522  22                 sax
       05:A523  69 00              adc    #high(1)
  943                             __pushw
                                 __submi  2,__stack
       05:A525  48                 pha
       05:A526  38                 sec
       05:A527  A5 00              lda    <__stack
       05:A529  E9 02              sbc    #low(2)
       05:A52B  85 00              sta    <__stack
       05:A52D  A5 01              lda    <__stack+1
       05:A52F  E9 00              sbc    #high(2)
       05:A531  85 01              sta    <__stack+1
       05:A533  68                 pla
       05:A534  22                 sax
       05:A535  92 00              sta    [__stack]
       05:A537  22                 sax
       05:A538  A0 01              ldy    #1
       05:A53A  91 00              sta    [__stack],Y
  944                             __ldwi  _result
       05:A53C  A2 DE              ldx    #low(_result)
       05:A53E  A9 31              lda    #high(_result)
  945                             __addwi 1
       05:A540  18                 clc
       05:A541  22                 sax
       05:A542  69 01              adc    #low(1)
       05:A544  22                 sax
       05:A545  69 00              adc    #high(1)
  946                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       05:A547  86 0B              stx    <__ptr
       05:A549  85 0C              sta    <__ptr+1
       05:A54B  B2 0B              lda    [__ptr]
       05:A54D  AA                 tax
       05:A54E  62                 cla
                          ;        bpl    .x_01591   ; signed
                          ;        dec    A
                          ;.x_01591:
  947                             __stbps
                                 __stw    <__temp
       05:A54F  86 03              stx    <__temp
       05:A551  85 04              sta    <__temp+1
                                 __ldwp    __stack
       05:A553  B2 00              lda    [__stack]
       05:A555  AA                 tax
       05:A556  A0 01              ldy    #1
       05:A558  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       05:A55A  86 0B              stx    <__ptr
       05:A55C  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       05:A55E  A6 03              ldx    <__temp
       05:A560  A5 04              lda    <__temp+1
                                  .endif
       05:A562  22                 sax
       05:A563  92 0B              sta    [__ptr]
       05:A565  22                 sax
                                 __addmi  2,__stack
       05:A566  48                 pha
       05:A567  18                 clc
       05:A568  A5 00              lda    <__stack
       05:A56A  69 02              adc    #low(2)
       05:A56C  85 00              sta    <__stack
       05:A56E  A5 01              lda    <__stack+1
       05:A570  69 00              adc    #high(2)
       05:A572  85 01              sta    <__stack+1
       05:A574  68                 pla
  948                             __ldwi  _start_pos
       05:A575  A2 D5              ldx    #low(_start_pos)
       05:A577  A9 31              lda    #high(_start_pos)
  949                             __addwi 2
       05:A579  18                 clc
       05:A57A  22                 sax
       05:A57B  69 02              adc    #low(2)
       05:A57D  22                 sax
       05:A57E  69 00              adc    #high(2)
  950                             __pushw
                                 __submi  2,__stack
       05:A580  48                 pha
       05:A581  38                 sec
       05:A582  A5 00              lda    <__stack
       05:A584  E9 02              sbc    #low(2)
       05:A586  85 00              sta    <__stack
       05:A588  A5 01              lda    <__stack+1
       05:A58A  E9 00              sbc    #high(2)
       05:A58C  85 01              sta    <__stack+1
       05:A58E  68                 pla
       05:A58F  22                 sax
       05:A590  92 00              sta    [__stack]
       05:A592  22                 sax
       05:A593  A0 01              ldy    #1
       05:A595  91 00              sta    [__stack],Y
  951                             __ldwi  _result
       05:A597  A2 DE              ldx    #low(_result)
       05:A599  A9 31              lda    #high(_result)
  952                             __addwi 2
       05:A59B  18                 clc
       05:A59C  22                 sax
       05:A59D  69 02              adc    #low(2)
       05:A59F  22                 sax
       05:A5A0  69 00              adc    #high(2)
  953                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       05:A5A2  86 0B              stx    <__ptr
       05:A5A4  85 0C              sta    <__ptr+1
       05:A5A6  B2 0B              lda    [__ptr]
       05:A5A8  AA                 tax
       05:A5A9  62                 cla
                          ;        bpl    .x_01604   ; signed
                          ;        dec    A
                          ;.x_01604:
  954                             __stbps
                                 __stw    <__temp
       05:A5AA  86 03              stx    <__temp
       05:A5AC  85 04              sta    <__temp+1
                                 __ldwp    __stack
       05:A5AE  B2 00              lda    [__stack]
       05:A5B0  AA                 tax
       05:A5B1  A0 01              ldy    #1
       05:A5B3  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       05:A5B5  86 0B              stx    <__ptr
       05:A5B7  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       05:A5B9  A6 03              ldx    <__temp
       05:A5BB  A5 04              lda    <__temp+1
                                  .endif
       05:A5BD  22                 sax
       05:A5BE  92 0B              sta    [__ptr]
       05:A5C0  22                 sax
                                 __addmi  2,__stack
       05:A5C1  48                 pha
       05:A5C2  18                 clc
       05:A5C3  A5 00              lda    <__stack
       05:A5C5  69 02              adc    #low(2)
       05:A5C7  85 00              sta    <__stack
       05:A5C9  A5 01              lda    <__stack+1
       05:A5CB  69 00              adc    #high(2)
       05:A5CD  85 01              sta    <__stack+1
       05:A5CF  68                 pla
  955  05:A5D0  20 00 80            call  _show_startpos
  956  05:A5D3  20 48 80            call  _fix_offset
  957  05:A5D6  20 12 80            call  _show_offset
  958  05:A5D9  20 24 80            call  _show_target
  959                             __lbra  LL54
       05:A5DC  4C 75 A7           jmp    LL54
  960  05:A5DF            LL53:
  961                     
  962                             __ldb   _adjust
                0000              .if (1 = 2)
                                  .else
       05:A5DF  AE E1 31           ldx    _adjust
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01613
                          ;        dec    A
                          ;.x_01613:
       05:A5E2  62                 cla    ; unsigned
                                  .endif
  963                             __stw   <__temp
       05:A5E3  86 03              stx    <__temp
       05:A5E5  85 04              sta    <__temp+1
  964                             __ldwi  2
       05:A5E7  A2 02              ldx    #low(2)
       05:A5E9  A9 00              lda    #high(2)
  965  05:A5EB  20 58 C8            jsr   eqzp
  966                             __lbeq  LL55
       05:A5EE  D0 03              bne    .x01616
       05:A5F0  4C 75 A7           jmp    LL55
       05:A5F3            .x01616
  967                             __ldwi  _offset
       05:A5F3  A2 D8              ldx    #low(_offset)
       05:A5F5  A9 31              lda    #high(_offset)
  968                             __pushw
                                 __submi  2,__stack
       05:A5F7  48                 pha
       05:A5F8  38                 sec
       05:A5F9  A5 00              lda    <__stack
       05:A5FB  E9 02              sbc    #low(2)
       05:A5FD  85 00              sta    <__stack
       05:A5FF  A5 01              lda    <__stack+1
       05:A601  E9 00              sbc    #high(2)
       05:A603  85 01              sta    <__stack+1
       05:A605  68                 pla
       05:A606  22                 sax
       05:A607  92 00              sta    [__stack]
       05:A609  22                 sax
       05:A60A  A0 01              ldy    #1
       05:A60C  91 00              sta    [__stack],Y
  969                             __ldwi  _add_num
       05:A60E  A2 48              ldx    #low(_add_num)
       05:A610  A9 41              lda    #high(_add_num)
  970                             __pushw
                                 __submi  2,__stack
       05:A612  48                 pha
       05:A613  38                 sec
       05:A614  A5 00              lda    <__stack
       05:A616  E9 02              sbc    #low(2)
       05:A618  85 00              sta    <__stack
       05:A61A  A5 01              lda    <__stack+1
       05:A61C  E9 00              sbc    #high(2)
       05:A61E  85 01              sta    <__stack+1
       05:A620  68                 pla
       05:A621  22                 sax
       05:A622  92 00              sta    [__stack]
       05:A624  22                 sax
       05:A625  A0 01              ldy    #1
       05:A627  91 00              sta    [__stack],Y
  971                             __ldb   _edit_pos
                0000              .if (1 = 2)
                                  .else
       05:A629  AE E2 31           ldx    _edit_pos
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01624
                          ;        dec    A
                          ;.x_01624:
       05:A62C  62                 cla    ; unsigned
                                  .endif
  972                             __pushw
                                 __submi  2,__stack
       05:A62D  48                 pha
       05:A62E  38                 sec
       05:A62F  A5 00              lda    <__stack
       05:A631  E9 02              sbc    #low(2)
       05:A633  85 00              sta    <__stack
       05:A635  A5 01              lda    <__stack+1
       05:A637  E9 00              sbc    #high(2)
       05:A639  85 01              sta    <__stack+1
       05:A63B  68                 pla
       05:A63C  22                 sax
       05:A63D  92 00              sta    [__stack]
       05:A63F  22                 sax
       05:A640  A0 01              ldy    #1
       05:A642  91 00              sta    [__stack],Y
  973                             __ldwi  3
       05:A644  A2 03              ldx    #low(3)
       05:A646  A9 00              lda    #high(3)
  974  05:A648  20 10 CA            jsr   smul
  975                             __addws
       05:A64B  22                 sax
       05:A64C  18                 clc
       05:A64D  72 00              adc    [__stack]
       05:A64F  22                 sax
       05:A650  A0 01              ldy    #1
       05:A652  71 00              adc    [__stack],Y
                                 __addmi 2, __stack
       05:A654  48                 pha
       05:A655  18                 clc
       05:A656  A5 00              lda    <__stack
       05:A658  69 02              adc    #low(2)
       05:A65A  85 00              sta    <__stack
       05:A65C  A5 01              lda    <__stack+1
       05:A65E  69 00              adc    #high(2)
       05:A660  85 01              sta    <__stack+1
       05:A662  68                 pla
  976  05:A663  20 6C 80            call  _add_3digit
  977  05:A666  20 90 80            call  _limit_offset
  978                             __ldwi  _offset
       05:A669  A2 D8              ldx    #low(_offset)
       05:A66B  A9 31              lda    #high(_offset)
  979                             __pushw
                                 __submi  2,__stack
       05:A66D  48                 pha
       05:A66E  38                 sec
       05:A66F  A5 00              lda    <__stack
       05:A671  E9 02              sbc    #low(2)
       05:A673  85 00              sta    <__stack
       05:A675  A5 01              lda    <__stack+1
       05:A677  E9 00              sbc    #high(2)
       05:A679  85 01              sta    <__stack+1
       05:A67B  68                 pla
       05:A67C  22                 sax
       05:A67D  92 00              sta    [__stack]
       05:A67F  22                 sax
       05:A680  A0 01              ldy    #1
       05:A682  91 00              sta    [__stack],Y
  980                             __ldwi  _result
       05:A684  A2 DE              ldx    #low(_result)
       05:A686  A9 31              lda    #high(_result)
  981                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       05:A688  86 0B              stx    <__ptr
       05:A68A  85 0C              sta    <__ptr+1
       05:A68C  B2 0B              lda    [__ptr]
       05:A68E  AA                 tax
       05:A68F  62                 cla
                          ;        bpl    .x_01634   ; signed
                          ;        dec    A
                          ;.x_01634:
  982                             __stbps
                                 __stw    <__temp
       05:A690  86 03              stx    <__temp
       05:A692  85 04              sta    <__temp+1
                                 __ldwp    __stack
       05:A694  B2 00              lda    [__stack]
       05:A696  AA                 tax
       05:A697  A0 01              ldy    #1
       05:A699  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       05:A69B  86 0B              stx    <__ptr
       05:A69D  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       05:A69F  A6 03              ldx    <__temp
       05:A6A1  A5 04              lda    <__temp+1
                                  .endif
       05:A6A3  22                 sax
       05:A6A4  92 0B              sta    [__ptr]
       05:A6A6  22                 sax
                                 __addmi  2,__stack
       05:A6A7  48                 pha
       05:A6A8  18                 clc
       05:A6A9  A5 00              lda    <__stack
       05:A6AB  69 02              adc    #low(2)
       05:A6AD  85 00              sta    <__stack
       05:A6AF  A5 01              lda    <__stack+1
       05:A6B1  69 00              adc    #high(2)
       05:A6B3  85 01              sta    <__stack+1
       05:A6B5  68                 pla
  983                             __ldwi  _offset
       05:A6B6  A2 D8              ldx    #low(_offset)
       05:A6B8  A9 31              lda    #high(_offset)
  984                             __addwi 1
       05:A6BA  18                 clc
       05:A6BB  22                 sax
       05:A6BC  69 01              adc    #low(1)
       05:A6BE  22                 sax
       05:A6BF  69 00              adc    #high(1)
  985                             __pushw
                                 __submi  2,__stack
       05:A6C1  48                 pha
       05:A6C2  38                 sec
       05:A6C3  A5 00              lda    <__stack
       05:A6C5  E9 02              sbc    #low(2)
       05:A6C7  85 00              sta    <__stack
       05:A6C9  A5 01              lda    <__stack+1
       05:A6CB  E9 00              sbc    #high(2)
       05:A6CD  85 01              sta    <__stack+1
       05:A6CF  68                 pla
       05:A6D0  22                 sax
       05:A6D1  92 00              sta    [__stack]
       05:A6D3  22                 sax
       05:A6D4  A0 01              ldy    #1
       05:A6D6  91 00              sta    [__stack],Y
  986                             __ldwi  _result
       05:A6D8  A2 DE              ldx    #low(_result)
       05:A6DA  A9 31              lda    #high(_result)
  987                             __addwi 1
       05:A6DC  18                 clc
       05:A6DD  22                 sax
       05:A6DE  69 01              adc    #low(1)
       05:A6E0  22                 sax
       05:A6E1  69 00              adc    #high(1)
  988                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       05:A6E3  86 0B              stx    <__ptr
       05:A6E5  85 0C              sta    <__ptr+1
       05:A6E7  B2 0B              lda    [__ptr]
       05:A6E9  AA                 tax
       05:A6EA  62                 cla
                          ;        bpl    .x_01647   ; signed
                          ;        dec    A
                          ;.x_01647:
  989                             __stbps
                                 __stw    <__temp
       05:A6EB  86 03              stx    <__temp
       05:A6ED  85 04              sta    <__temp+1
                                 __ldwp    __stack
       05:A6EF  B2 00              lda    [__stack]
       05:A6F1  AA                 tax
       05:A6F2  A0 01              ldy    #1
       05:A6F4  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       05:A6F6  86 0B              stx    <__ptr
       05:A6F8  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       05:A6FA  A6 03              ldx    <__temp
       05:A6FC  A5 04              lda    <__temp+1
                                  .endif
       05:A6FE  22                 sax
       05:A6FF  92 0B              sta    [__ptr]
       05:A701  22                 sax
                                 __addmi  2,__stack
       05:A702  48                 pha
       05:A703  18                 clc
       05:A704  A5 00              lda    <__stack
       05:A706  69 02              adc    #low(2)
       05:A708  85 00              sta    <__stack
       05:A70A  A5 01              lda    <__stack+1
       05:A70C  69 00              adc    #high(2)
       05:A70E  85 01              sta    <__stack+1
       05:A710  68                 pla
  990                             __ldwi  _offset
       05:A711  A2 D8              ldx    #low(_offset)
       05:A713  A9 31              lda    #high(_offset)
  991                             __addwi 2
       05:A715  18                 clc
       05:A716  22                 sax
       05:A717  69 02              adc    #low(2)
       05:A719  22                 sax
       05:A71A  69 00              adc    #high(2)
  992                             __pushw
                                 __submi  2,__stack
       05:A71C  48                 pha
       05:A71D  38                 sec
       05:A71E  A5 00              lda    <__stack
       05:A720  E9 02              sbc    #low(2)
       05:A722  85 00              sta    <__stack
       05:A724  A5 01              lda    <__stack+1
       05:A726  E9 00              sbc    #high(2)
       05:A728  85 01              sta    <__stack+1
       05:A72A  68                 pla
       05:A72B  22                 sax
       05:A72C  92 00              sta    [__stack]
       05:A72E  22                 sax
       05:A72F  A0 01              ldy    #1
       05:A731  91 00              sta    [__stack],Y
  993                             __ldwi  _result
       05:A733  A2 DE              ldx    #low(_result)
       05:A735  A9 31              lda    #high(_result)
  994                             __addwi 2
       05:A737  18                 clc
       05:A738  22                 sax
       05:A739  69 02              adc    #low(2)
       05:A73B  22                 sax
       05:A73C  69 00              adc    #high(2)
  995                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       05:A73E  86 0B              stx    <__ptr
       05:A740  85 0C              sta    <__ptr+1
       05:A742  B2 0B              lda    [__ptr]
       05:A744  AA                 tax
       05:A745  62                 cla
                          ;        bpl    .x_01660   ; signed
                          ;        dec    A
                          ;.x_01660:
  996                             __stbps
                                 __stw    <__temp
       05:A746  86 03              stx    <__temp
       05:A748  85 04              sta    <__temp+1
                                 __ldwp    __stack
       05:A74A  B2 00              lda    [__stack]
       05:A74C  AA                 tax
       05:A74D  A0 01              ldy    #1
       05:A74F  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       05:A751  86 0B              stx    <__ptr
       05:A753  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       05:A755  A6 03              ldx    <__temp
       05:A757  A5 04              lda    <__temp+1
                                  .endif
       05:A759  22                 sax
       05:A75A  92 0B              sta    [__ptr]
       05:A75C  22                 sax
                                 __addmi  2,__stack
       05:A75D  48                 pha
       05:A75E  18                 clc
       05:A75F  A5 00              lda    <__stack
       05:A761  69 02              adc    #low(2)
       05:A763  85 00              sta    <__stack
       05:A765  A5 01              lda    <__stack+1
       05:A767  69 00              adc    #high(2)
       05:A769  85 01              sta    <__stack+1
       05:A76B  68                 pla
  997  05:A76C  20 48 80            call  _fix_offset
  998  05:A76F  20 12 80            call  _show_offset
  999  05:A772  20 24 80            call  _show_target
 1000  05:A775            LL55:
 1001                     
 1002  05:A775            LL54:
 1003                     
 1004  05:A775            LL52:
 1005                     
 1006                             __ldb   _pad
                0000              .if (1 = 2)
                                  .else
       05:A775  AE D1 31           ldx    _pad
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01668
                          ;        dec    A
                          ;.x_01668:
       05:A778  62                 cla    ; unsigned
                                  .endif
 1007                             __andwi 64
       05:A779  22                 sax
       05:A77A  29 40              and    #low(64)
       05:A77C  22                 sax
       05:A77D  29 00              and    #high(64)
 1008                             __tstw
                                   ; pha
       05:A77F  86 03              stx    <__temp
       05:A781  05 03              ora    <__temp
                                   ; pla
 1009                             __lbeq  LL56
       05:A783  D0 03              bne    .x01671
       05:A785  4C BA AA           jmp    LL56
       05:A788            .x01671
 1010                             __ldb   _adjust
                0000              .if (1 = 2)
                                  .else
       05:A788  AE E1 31           ldx    _adjust
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01673
                          ;        dec    A
                          ;.x_01673:
       05:A78B  62                 cla    ; unsigned
                                  .endif
 1011                             __stw   <__temp
       05:A78C  86 03              stx    <__temp
       05:A78E  85 04              sta    <__temp+1
 1012                             __ldwi  1
       05:A790  A2 01              ldx    #low(1)
       05:A792  A9 00              lda    #high(1)
 1013  05:A794  20 58 C8            jsr   eqzp
 1014                             __lbeq  LL57
       05:A797  D0 03              bne    .x01676
       05:A799  4C 24 A9           jmp    LL57
       05:A79C            .x01676
 1015                             __ldwi  _start_pos
       05:A79C  A2 D5              ldx    #low(_start_pos)
       05:A79E  A9 31              lda    #high(_start_pos)
 1016                             __pushw
                                 __submi  2,__stack
       05:A7A0  48                 pha
       05:A7A1  38                 sec
       05:A7A2  A5 00              lda    <__stack
       05:A7A4  E9 02              sbc    #low(2)
       05:A7A6  85 00              sta    <__stack
       05:A7A8  A5 01              lda    <__stack+1
       05:A7AA  E9 00              sbc    #high(2)
       05:A7AC  85 01              sta    <__stack+1
       05:A7AE  68                 pla
       05:A7AF  22                 sax
       05:A7B0  92 00              sta    [__stack]
       05:A7B2  22                 sax
       05:A7B3  A0 01              ldy    #1
       05:A7B5  91 00              sta    [__stack],Y
 1017                             __ldwi  _add_num
       05:A7B7  A2 48              ldx    #low(_add_num)
       05:A7B9  A9 41              lda    #high(_add_num)
 1018                             __pushw
                                 __submi  2,__stack
       05:A7BB  48                 pha
       05:A7BC  38                 sec
       05:A7BD  A5 00              lda    <__stack
       05:A7BF  E9 02              sbc    #low(2)
       05:A7C1  85 00              sta    <__stack
       05:A7C3  A5 01              lda    <__stack+1
       05:A7C5  E9 00              sbc    #high(2)
       05:A7C7  85 01              sta    <__stack+1
       05:A7C9  68                 pla
       05:A7CA  22                 sax
       05:A7CB  92 00              sta    [__stack]
       05:A7CD  22                 sax
       05:A7CE  A0 01              ldy    #1
       05:A7D0  91 00              sta    [__stack],Y
 1019                             __ldb   _edit_pos
                0000              .if (1 = 2)
                                  .else
       05:A7D2  AE E2 31           ldx    _edit_pos
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01684
                          ;        dec    A
                          ;.x_01684:
       05:A7D5  62                 cla    ; unsigned
                                  .endif
 1020                             __pushw
                                 __submi  2,__stack
       05:A7D6  48                 pha
       05:A7D7  38                 sec
       05:A7D8  A5 00              lda    <__stack
       05:A7DA  E9 02              sbc    #low(2)
       05:A7DC  85 00              sta    <__stack
       05:A7DE  A5 01              lda    <__stack+1
       05:A7E0  E9 00              sbc    #high(2)
       05:A7E2  85 01              sta    <__stack+1
       05:A7E4  68                 pla
       05:A7E5  22                 sax
       05:A7E6  92 00              sta    [__stack]
       05:A7E8  22                 sax
       05:A7E9  A0 01              ldy    #1
       05:A7EB  91 00              sta    [__stack],Y
 1021                             __ldwi  3
       05:A7ED  A2 03              ldx    #low(3)
       05:A7EF  A9 00              lda    #high(3)
 1022  05:A7F1  20 10 CA            jsr   smul
 1023                             __addws
       05:A7F4  22                 sax
       05:A7F5  18                 clc
       05:A7F6  72 00              adc    [__stack]
       05:A7F8  22                 sax
       05:A7F9  A0 01              ldy    #1
       05:A7FB  71 00              adc    [__stack],Y
                                 __addmi 2, __stack
       05:A7FD  48                 pha
       05:A7FE  18                 clc
       05:A7FF  A5 00              lda    <__stack
       05:A801  69 02              adc    #low(2)
       05:A803  85 00              sta    <__stack
       05:A805  A5 01              lda    <__stack+1
       05:A807  69 00              adc    #high(2)
       05:A809  85 01              sta    <__stack+1
       05:A80B  68                 pla
 1024  05:A80C  20 A2 80            call  _sub_3digit
 1025  05:A80F  20 7E 80            call  _limit_startpos
 1026                             __ldwi  _start_pos
       05:A812  A2 D5              ldx    #low(_start_pos)
       05:A814  A9 31              lda    #high(_start_pos)
 1027                             __pushw
                                 __submi  2,__stack
       05:A816  48                 pha
       05:A817  38                 sec
       05:A818  A5 00              lda    <__stack
       05:A81A  E9 02              sbc    #low(2)
       05:A81C  85 00              sta    <__stack
       05:A81E  A5 01              lda    <__stack+1
       05:A820  E9 00              sbc    #high(2)
       05:A822  85 01              sta    <__stack+1
       05:A824  68                 pla
       05:A825  22                 sax
       05:A826  92 00              sta    [__stack]
       05:A828  22                 sax
       05:A829  A0 01              ldy    #1
       05:A82B  91 00              sta    [__stack],Y
 1028                             __ldwi  _result
       05:A82D  A2 DE              ldx    #low(_result)
       05:A82F  A9 31              lda    #high(_result)
 1029                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       05:A831  86 0B              stx    <__ptr
       05:A833  85 0C              sta    <__ptr+1
       05:A835  B2 0B              lda    [__ptr]
       05:A837  AA                 tax
       05:A838  62                 cla
                          ;        bpl    .x_01694   ; signed
                          ;        dec    A
                          ;.x_01694:
 1030                             __stbps
                                 __stw    <__temp
       05:A839  86 03              stx    <__temp
       05:A83B  85 04              sta    <__temp+1
                                 __ldwp    __stack
       05:A83D  B2 00              lda    [__stack]
       05:A83F  AA                 tax
       05:A840  A0 01              ldy    #1
       05:A842  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       05:A844  86 0B              stx    <__ptr
       05:A846  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       05:A848  A6 03              ldx    <__temp
       05:A84A  A5 04              lda    <__temp+1
                                  .endif
       05:A84C  22                 sax
       05:A84D  92 0B              sta    [__ptr]
       05:A84F  22                 sax
                                 __addmi  2,__stack
       05:A850  48                 pha
       05:A851  18                 clc
       05:A852  A5 00              lda    <__stack
       05:A854  69 02              adc    #low(2)
       05:A856  85 00              sta    <__stack
       05:A858  A5 01              lda    <__stack+1
       05:A85A  69 00              adc    #high(2)
       05:A85C  85 01              sta    <__stack+1
       05:A85E  68                 pla
 1031                             __ldwi  _start_pos
       05:A85F  A2 D5              ldx    #low(_start_pos)
       05:A861  A9 31              lda    #high(_start_pos)
 1032                             __addwi 1
       05:A863  18                 clc
       05:A864  22                 sax
       05:A865  69 01              adc    #low(1)
       05:A867  22                 sax
       05:A868  69 00              adc    #high(1)
 1033                             __pushw
                                 __submi  2,__stack
       05:A86A  48                 pha
       05:A86B  38                 sec
       05:A86C  A5 00              lda    <__stack
       05:A86E  E9 02              sbc    #low(2)
       05:A870  85 00              sta    <__stack
       05:A872  A5 01              lda    <__stack+1
       05:A874  E9 00              sbc    #high(2)
       05:A876  85 01              sta    <__stack+1
       05:A878  68                 pla
       05:A879  22                 sax
       05:A87A  92 00              sta    [__stack]
       05:A87C  22                 sax
       05:A87D  A0 01              ldy    #1
       05:A87F  91 00              sta    [__stack],Y
 1034                             __ldwi  _result
       05:A881  A2 DE              ldx    #low(_result)
       05:A883  A9 31              lda    #high(_result)
 1035                             __addwi 1
       05:A885  18                 clc
       05:A886  22                 sax
       05:A887  69 01              adc    #low(1)
       05:A889  22                 sax
       05:A88A  69 00              adc    #high(1)
 1036                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       05:A88C  86 0B              stx    <__ptr
       05:A88E  85 0C              sta    <__ptr+1
       05:A890  B2 0B              lda    [__ptr]
       05:A892  AA                 tax
       05:A893  62                 cla
                          ;        bpl    .x_01707   ; signed
                          ;        dec    A
                          ;.x_01707:
 1037                             __stbps
                                 __stw    <__temp
       05:A894  86 03              stx    <__temp
       05:A896  85 04              sta    <__temp+1
                                 __ldwp    __stack
       05:A898  B2 00              lda    [__stack]
       05:A89A  AA                 tax
       05:A89B  A0 01              ldy    #1
       05:A89D  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       05:A89F  86 0B              stx    <__ptr
       05:A8A1  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       05:A8A3  A6 03              ldx    <__temp
       05:A8A5  A5 04              lda    <__temp+1
                                  .endif
       05:A8A7  22                 sax
       05:A8A8  92 0B              sta    [__ptr]
       05:A8AA  22                 sax
                                 __addmi  2,__stack
       05:A8AB  48                 pha
       05:A8AC  18                 clc
       05:A8AD  A5 00              lda    <__stack
       05:A8AF  69 02              adc    #low(2)
       05:A8B1  85 00              sta    <__stack
       05:A8B3  A5 01              lda    <__stack+1
       05:A8B5  69 00              adc    #high(2)
       05:A8B7  85 01              sta    <__stack+1
       05:A8B9  68                 pla
 1038                             __ldwi  _start_pos
       05:A8BA  A2 D5              ldx    #low(_start_pos)
       05:A8BC  A9 31              lda    #high(_start_pos)
 1039                             __addwi 2
       05:A8BE  18                 clc
       05:A8BF  22                 sax
       05:A8C0  69 02              adc    #low(2)
       05:A8C2  22                 sax
       05:A8C3  69 00              adc    #high(2)
 1040                             __pushw
                                 __submi  2,__stack
       05:A8C5  48                 pha
       05:A8C6  38                 sec
       05:A8C7  A5 00              lda    <__stack
       05:A8C9  E9 02              sbc    #low(2)
       05:A8CB  85 00              sta    <__stack
       05:A8CD  A5 01              lda    <__stack+1
       05:A8CF  E9 00              sbc    #high(2)
       05:A8D1  85 01              sta    <__stack+1
       05:A8D3  68                 pla
       05:A8D4  22                 sax
       05:A8D5  92 00              sta    [__stack]
       05:A8D7  22                 sax
       05:A8D8  A0 01              ldy    #1
       05:A8DA  91 00              sta    [__stack],Y
 1041                             __ldwi  _result
       05:A8DC  A2 DE              ldx    #low(_result)
       05:A8DE  A9 31              lda    #high(_result)
 1042                             __addwi 2
       05:A8E0  18                 clc
       05:A8E1  22                 sax
       05:A8E2  69 02              adc    #low(2)
       05:A8E4  22                 sax
       05:A8E5  69 00              adc    #high(2)
 1043                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       05:A8E7  86 0B              stx    <__ptr
       05:A8E9  85 0C              sta    <__ptr+1
       05:A8EB  B2 0B              lda    [__ptr]
       05:A8ED  AA                 tax
       05:A8EE  62                 cla
                          ;        bpl    .x_01720   ; signed
                          ;        dec    A
                          ;.x_01720:
 1044                             __stbps
                                 __stw    <__temp
       05:A8EF  86 03              stx    <__temp
       05:A8F1  85 04              sta    <__temp+1
                                 __ldwp    __stack
       05:A8F3  B2 00              lda    [__stack]
       05:A8F5  AA                 tax
       05:A8F6  A0 01              ldy    #1
       05:A8F8  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       05:A8FA  86 0B              stx    <__ptr
       05:A8FC  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       05:A8FE  A6 03              ldx    <__temp
       05:A900  A5 04              lda    <__temp+1
                                  .endif
       05:A902  22                 sax
       05:A903  92 0B              sta    [__ptr]
       05:A905  22                 sax
                                 __addmi  2,__stack
       05:A906  48                 pha
       05:A907  18                 clc
       05:A908  A5 00              lda    <__stack
       05:A90A  69 02              adc    #low(2)
       05:A90C  85 00              sta    <__stack
       05:A90E  A5 01              lda    <__stack+1
       05:A910  69 00              adc    #high(2)
       05:A912  85 01              sta    <__stack+1
       05:A914  68                 pla
 1045  05:A915  20 00 80            call  _show_startpos
 1046  05:A918  20 48 80            call  _fix_offset
 1047  05:A91B  20 12 80            call  _show_offset
 1048  05:A91E  20 24 80            call  _show_target
 1049                             __lbra  LL58
       05:A921  4C BA AA           jmp    LL58
 1050  05:A924            LL57:
 1051                     
 1052                             __ldb   _adjust
                0000              .if (1 = 2)
                                  .else
       05:A924  AE E1 31           ldx    _adjust
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01729
                          ;        dec    A
                          ;.x_01729:
       05:A927  62                 cla    ; unsigned
                                  .endif
 1053                             __stw   <__temp
       05:A928  86 03              stx    <__temp
       05:A92A  85 04              sta    <__temp+1
 1054                             __ldwi  2
       05:A92C  A2 02              ldx    #low(2)
       05:A92E  A9 00              lda    #high(2)
 1055  05:A930  20 58 C8            jsr   eqzp
 1056                             __lbeq  LL59
       05:A933  D0 03              bne    .x01732
       05:A935  4C BA AA           jmp    LL59
       05:A938            .x01732
 1057                             __ldwi  _offset
       05:A938  A2 D8              ldx    #low(_offset)
       05:A93A  A9 31              lda    #high(_offset)
 1058                             __pushw
                                 __submi  2,__stack
       05:A93C  48                 pha
       05:A93D  38                 sec
       05:A93E  A5 00              lda    <__stack
       05:A940  E9 02              sbc    #low(2)
       05:A942  85 00              sta    <__stack
       05:A944  A5 01              lda    <__stack+1
       05:A946  E9 00              sbc    #high(2)
       05:A948  85 01              sta    <__stack+1
       05:A94A  68                 pla
       05:A94B  22                 sax
       05:A94C  92 00              sta    [__stack]
       05:A94E  22                 sax
       05:A94F  A0 01              ldy    #1
       05:A951  91 00              sta    [__stack],Y
 1059                             __ldwi  _add_num
       05:A953  A2 48              ldx    #low(_add_num)
       05:A955  A9 41              lda    #high(_add_num)
 1060                             __pushw
                                 __submi  2,__stack
       05:A957  48                 pha
       05:A958  38                 sec
       05:A959  A5 00              lda    <__stack
       05:A95B  E9 02              sbc    #low(2)
       05:A95D  85 00              sta    <__stack
       05:A95F  A5 01              lda    <__stack+1
       05:A961  E9 00              sbc    #high(2)
       05:A963  85 01              sta    <__stack+1
       05:A965  68                 pla
       05:A966  22                 sax
       05:A967  92 00              sta    [__stack]
       05:A969  22                 sax
       05:A96A  A0 01              ldy    #1
       05:A96C  91 00              sta    [__stack],Y
 1061                             __ldb   _edit_pos
                0000              .if (1 = 2)
                                  .else
       05:A96E  AE E2 31           ldx    _edit_pos
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01740
                          ;        dec    A
                          ;.x_01740:
       05:A971  62                 cla    ; unsigned
                                  .endif
 1062                             __pushw
                                 __submi  2,__stack
       05:A972  48                 pha
       05:A973  38                 sec
       05:A974  A5 00              lda    <__stack
       05:A976  E9 02              sbc    #low(2)
       05:A978  85 00              sta    <__stack
       05:A97A  A5 01              lda    <__stack+1
       05:A97C  E9 00              sbc    #high(2)
       05:A97E  85 01              sta    <__stack+1
       05:A980  68                 pla
       05:A981  22                 sax
       05:A982  92 00              sta    [__stack]
       05:A984  22                 sax
       05:A985  A0 01              ldy    #1
       05:A987  91 00              sta    [__stack],Y
 1063                             __ldwi  3
       05:A989  A2 03              ldx    #low(3)
       05:A98B  A9 00              lda    #high(3)
 1064  05:A98D  20 10 CA            jsr   smul
 1065                             __addws
       05:A990  22                 sax
       05:A991  18                 clc
       05:A992  72 00              adc    [__stack]
       05:A994  22                 sax
       05:A995  A0 01              ldy    #1
       05:A997  71 00              adc    [__stack],Y
                                 __addmi 2, __stack
       05:A999  48                 pha
       05:A99A  18                 clc
       05:A99B  A5 00              lda    <__stack
       05:A99D  69 02              adc    #low(2)
       05:A99F  85 00              sta    <__stack
       05:A9A1  A5 01              lda    <__stack+1
       05:A9A3  69 00              adc    #high(2)
       05:A9A5  85 01              sta    <__stack+1
       05:A9A7  68                 pla
 1066  05:A9A8  20 A2 80            call  _sub_3digit
 1067  05:A9AB  20 90 80            call  _limit_offset
 1068                             __ldwi  _offset
       05:A9AE  A2 D8              ldx    #low(_offset)
       05:A9B0  A9 31              lda    #high(_offset)
 1069                             __pushw
                                 __submi  2,__stack
       05:A9B2  48                 pha
       05:A9B3  38                 sec
       05:A9B4  A5 00              lda    <__stack
       05:A9B6  E9 02              sbc    #low(2)
       05:A9B8  85 00              sta    <__stack
       05:A9BA  A5 01              lda    <__stack+1
       05:A9BC  E9 00              sbc    #high(2)
       05:A9BE  85 01              sta    <__stack+1
       05:A9C0  68                 pla
       05:A9C1  22                 sax
       05:A9C2  92 00              sta    [__stack]
       05:A9C4  22                 sax
       05:A9C5  A0 01              ldy    #1
       05:A9C7  91 00              sta    [__stack],Y
 1070                             __ldwi  _result
       05:A9C9  A2 DE              ldx    #low(_result)
       05:A9CB  A9 31              lda    #high(_result)
 1071                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       05:A9CD  86 0B              stx    <__ptr
       05:A9CF  85 0C              sta    <__ptr+1
       05:A9D1  B2 0B              lda    [__ptr]
       05:A9D3  AA                 tax
       05:A9D4  62                 cla
                          ;        bpl    .x_01750   ; signed
                          ;        dec    A
                          ;.x_01750:
 1072                             __stbps
                                 __stw    <__temp
       05:A9D5  86 03              stx    <__temp
       05:A9D7  85 04              sta    <__temp+1
                                 __ldwp    __stack
       05:A9D9  B2 00              lda    [__stack]
       05:A9DB  AA                 tax
       05:A9DC  A0 01              ldy    #1
       05:A9DE  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       05:A9E0  86 0B              stx    <__ptr
       05:A9E2  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       05:A9E4  A6 03              ldx    <__temp
       05:A9E6  A5 04              lda    <__temp+1
                                  .endif
       05:A9E8  22                 sax
       05:A9E9  92 0B              sta    [__ptr]
       05:A9EB  22                 sax
                                 __addmi  2,__stack
       05:A9EC  48                 pha
       05:A9ED  18                 clc
       05:A9EE  A5 00              lda    <__stack
       05:A9F0  69 02              adc    #low(2)
       05:A9F2  85 00              sta    <__stack
       05:A9F4  A5 01              lda    <__stack+1
       05:A9F6  69 00              adc    #high(2)
       05:A9F8  85 01              sta    <__stack+1
       05:A9FA  68                 pla
 1073                             __ldwi  _offset
       05:A9FB  A2 D8              ldx    #low(_offset)
       05:A9FD  A9 31              lda    #high(_offset)
 1074                             __addwi 1
       05:A9FF  18                 clc
       05:AA00  22                 sax
       05:AA01  69 01              adc    #low(1)
       05:AA03  22                 sax
       05:AA04  69 00              adc    #high(1)
 1075                             __pushw
                                 __submi  2,__stack
       05:AA06  48                 pha
       05:AA07  38                 sec
       05:AA08  A5 00              lda    <__stack
       05:AA0A  E9 02              sbc    #low(2)
       05:AA0C  85 00              sta    <__stack
       05:AA0E  A5 01              lda    <__stack+1
       05:AA10  E9 00              sbc    #high(2)
       05:AA12  85 01              sta    <__stack+1
       05:AA14  68                 pla
       05:AA15  22                 sax
       05:AA16  92 00              sta    [__stack]
       05:AA18  22                 sax
       05:AA19  A0 01              ldy    #1
       05:AA1B  91 00              sta    [__stack],Y
 1076                             __ldwi  _result
       05:AA1D  A2 DE              ldx    #low(_result)
       05:AA1F  A9 31              lda    #high(_result)
 1077                             __addwi 1
       05:AA21  18                 clc
       05:AA22  22                 sax
       05:AA23  69 01              adc    #low(1)
       05:AA25  22                 sax
       05:AA26  69 00              adc    #high(1)
 1078                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       05:AA28  86 0B              stx    <__ptr
       05:AA2A  85 0C              sta    <__ptr+1
       05:AA2C  B2 0B              lda    [__ptr]
       05:AA2E  AA                 tax
       05:AA2F  62                 cla
                          ;        bpl    .x_01763   ; signed
                          ;        dec    A
                          ;.x_01763:
 1079                             __stbps
                                 __stw    <__temp
       05:AA30  86 03              stx    <__temp
       05:AA32  85 04              sta    <__temp+1
                                 __ldwp    __stack
       05:AA34  B2 00              lda    [__stack]
       05:AA36  AA                 tax
       05:AA37  A0 01              ldy    #1
       05:AA39  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       05:AA3B  86 0B              stx    <__ptr
       05:AA3D  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       05:AA3F  A6 03              ldx    <__temp
       05:AA41  A5 04              lda    <__temp+1
                                  .endif
       05:AA43  22                 sax
       05:AA44  92 0B              sta    [__ptr]
       05:AA46  22                 sax
                                 __addmi  2,__stack
       05:AA47  48                 pha
       05:AA48  18                 clc
       05:AA49  A5 00              lda    <__stack
       05:AA4B  69 02              adc    #low(2)
       05:AA4D  85 00              sta    <__stack
       05:AA4F  A5 01              lda    <__stack+1
       05:AA51  69 00              adc    #high(2)
       05:AA53  85 01              sta    <__stack+1
       05:AA55  68                 pla
 1080                             __ldwi  _offset
       05:AA56  A2 D8              ldx    #low(_offset)
       05:AA58  A9 31              lda    #high(_offset)
 1081                             __addwi 2
       05:AA5A  18                 clc
       05:AA5B  22                 sax
       05:AA5C  69 02              adc    #low(2)
       05:AA5E  22                 sax
       05:AA5F  69 00              adc    #high(2)
 1082                             __pushw
                                 __submi  2,__stack
       05:AA61  48                 pha
       05:AA62  38                 sec
       05:AA63  A5 00              lda    <__stack
       05:AA65  E9 02              sbc    #low(2)
       05:AA67  85 00              sta    <__stack
       05:AA69  A5 01              lda    <__stack+1
       05:AA6B  E9 00              sbc    #high(2)
       05:AA6D  85 01              sta    <__stack+1
       05:AA6F  68                 pla
       05:AA70  22                 sax
       05:AA71  92 00              sta    [__stack]
       05:AA73  22                 sax
       05:AA74  A0 01              ldy    #1
       05:AA76  91 00              sta    [__stack],Y
 1083                             __ldwi  _result
       05:AA78  A2 DE              ldx    #low(_result)
       05:AA7A  A9 31              lda    #high(_result)
 1084                             __addwi 2
       05:AA7C  18                 clc
       05:AA7D  22                 sax
       05:AA7E  69 02              adc    #low(2)
       05:AA80  22                 sax
       05:AA81  69 00              adc    #high(2)
 1085                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       05:AA83  86 0B              stx    <__ptr
       05:AA85  85 0C              sta    <__ptr+1
       05:AA87  B2 0B              lda    [__ptr]
       05:AA89  AA                 tax
       05:AA8A  62                 cla
                          ;        bpl    .x_01776   ; signed
                          ;        dec    A
                          ;.x_01776:
 1086                             __stbps
                                 __stw    <__temp
       05:AA8B  86 03              stx    <__temp
       05:AA8D  85 04              sta    <__temp+1
                                 __ldwp    __stack
       05:AA8F  B2 00              lda    [__stack]
       05:AA91  AA                 tax
       05:AA92  A0 01              ldy    #1
       05:AA94  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       05:AA96  86 0B              stx    <__ptr
       05:AA98  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       05:AA9A  A6 03              ldx    <__temp
       05:AA9C  A5 04              lda    <__temp+1
                                  .endif
       05:AA9E  22                 sax
       05:AA9F  92 0B              sta    [__ptr]
       05:AAA1  22                 sax
                                 __addmi  2,__stack
       05:AAA2  48                 pha
       05:AAA3  18                 clc
       05:AAA4  A5 00              lda    <__stack
       05:AAA6  69 02              adc    #low(2)
       05:AAA8  85 00              sta    <__stack
       05:AAAA  A5 01              lda    <__stack+1
       05:AAAC  69 00              adc    #high(2)
       05:AAAE  85 01              sta    <__stack+1
       05:AAB0  68                 pla
 1087  05:AAB1  20 48 80            call  _fix_offset
 1088  05:AAB4  20 12 80            call  _show_offset
 1089  05:AAB7  20 24 80            call  _show_target
 1090  05:AABA            LL59:
 1091                     
 1092  05:AABA            LL58:
 1093                     
 1094  05:AABA            LL56:
 1095                     
 1096                             __ldb   _pad
                0000              .if (1 = 2)
                                  .else
       05:AABA  AE D1 31           ldx    _pad
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01784
                          ;        dec    A
                          ;.x_01784:
       05:AABD  62                 cla    ; unsigned
                                  .endif
 1097                             __andwi 2
       05:AABE  22                 sax
       05:AABF  29 02              and    #low(2)
       05:AAC1  22                 sax
       05:AAC2  29 00              and    #high(2)
 1098                             __tstw
                                   ; pha
       05:AAC4  86 03              stx    <__temp
       05:AAC6  05 03              ora    <__temp
                                   ; pla
 1099                             __lbeq  LL60
       05:AAC8  D0 03              bne    .x01787
       05:AACA  4C 2C B1           jmp    LL60
       05:AACD            .x01787
 1100                             __ldb   _adjust
                0000              .if (1 = 2)
                                  .else
       05:AACD  AE E1 31           ldx    _adjust
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01789
                          ;        dec    A
                          ;.x_01789:
       05:AAD0  62                 cla    ; unsigned
                                  .endif
 1101                             __stw   <__temp
       05:AAD1  86 03              stx    <__temp
       05:AAD3  85 04              sta    <__temp+1
 1102                             __ldwi  1
       05:AAD5  A2 01              ldx    #low(1)
       05:AAD7  A9 00              lda    #high(1)
 1103  05:AAD9  20 58 C8            jsr   eqzp
 1104                             __lbeq  LL61
       05:AADC  D0 03              bne    .x01792
       05:AADE  4C F1 AA           jmp    LL61
       05:AAE1            .x01792
 1105                             __ldwi  2
       05:AAE1  A2 02              ldx    #low(2)
       05:AAE3  A9 00              lda    #high(2)
 1106  05:AAE5  8E E1 31            stx   _adjust
 1107  05:AAE8  20 5A 80            call  _clear_index
 1108  05:AAEB  20 36 80            call  _put_index
 1109                             __lbra  LL62
       05:AAEE  4C 2C B1           jmp    LL62
 1110  05:AAF1            LL61:
 1111                     
 1112                             __ldb   _adjust
                0000              .if (1 = 2)
                                  .else
       05:AAF1  AE E1 31           ldx    _adjust
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01796
                          ;        dec    A
                          ;.x_01796:
       05:AAF4  62                 cla    ; unsigned
                                  .endif
 1113                             __stw   <__temp
       05:AAF5  86 03              stx    <__temp
       05:AAF7  85 04              sta    <__temp+1
 1114                             __ldwi  2
       05:AAF9  A2 02              ldx    #low(2)
       05:AAFB  A9 00              lda    #high(2)
 1115  05:AAFD  20 58 C8            jsr   eqzp
 1116                             __lbeq  LL63
       05:AB00  D0 03              bne    .x01799
       05:AB02  4C 2C B1           jmp    LL63
       05:AB05            .x01799
 1117  05:AB05  20 5A 80            call  _clear_index
 1118                             __ldwi  1
       05:AB08  A2 01              ldx    #low(1)
       05:AB0A  A9 00              lda    #high(1)
 1119  05:AB0C  8E E1 31            stx   _adjust
 1120                             __ldwi  0
       05:AB0F  A2 00              ldx    #low(0)
       05:AB11  A9 00              lda    #high(0)
 1121  05:AB13  8E FE 31            stx   _i
 1122  05:AB16            LL64:
 1123                     
 1124                             __ldb   _i
                0000              .if (1 = 2)
                                  .else
       05:AB16  AE FE 31           ldx    _i
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01803
                          ;        dec    A
                          ;.x_01803:
       05:AB19  62                 cla    ; unsigned
                                  .endif
 1125                             __stw   <__temp
       05:AB1A  86 03              stx    <__temp
       05:AB1C  85 04              sta    <__temp+1
 1126                             __ldwi  10
       05:AB1E  A2 0A              ldx    #low(10)
       05:AB20  A9 00              lda    #high(10)
 1127  05:AB22  20 FF C8            jsr   ltzp
 1128                             __lbne  LL66
       05:AB25  F0 03              beq    .x01806
       05:AB27  4C 45 AB           jmp    LL66
       05:AB2A            .x01806
 1129                             __lbra  LL67
       05:AB2A  4C A0 AB           jmp    LL67
 1130  05:AB2D            LL65:
 1131                     
 1132                             __ldb   _i
                0000              .if (1 = 2)
                                  .else
       05:AB2D  AE FE 31           ldx    _i
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01809
                          ;        dec    A
                          ;.x_01809:
       05:AB30  62                 cla    ; unsigned
                                  .endif
 1133                             __addwi 1
       05:AB31  18                 clc
       05:AB32  22                 sax
       05:AB33  69 01              adc    #low(1)
       05:AB35  22                 sax
       05:AB36  69 00              adc    #high(1)
 1134  05:AB38  8E FE 31            stx   _i
 1135                             __subwi 1
       05:AB3B  38                 sec
       05:AB3C  22                 sax
       05:AB3D  E9 01              sbc    #low(1)
       05:AB3F  22                 sax
       05:AB40  E9 00              sbc    #high(1)
 1136                             __lbra  LL64
       05:AB42  4C 16 AB           jmp    LL64
 1137  05:AB45            LL66:
 1138                     
 1139                             __ldwi  LL0+188
       05:AB45  A2 BC              ldx    #low(LL0+188)
       05:AB47  A9 40              lda    #high(LL0+188)
 1140                             __phw   3,3
                                   ; #1 (bytes :  9, cycles : 16)
                                   ; #2 (bytes : 16, cycles : 28)
                          
                0001              .if (2 = 2)
       05:AB49  A8                 tay
       05:AB4A  A5 02              lda    <__arg_idx
                                   add    #3
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       05:AB4C  18                 clc
       05:AB4D  69 03              adc    #3
                                  .endif
       05:AB4F  85 02              sta    <__arg_idx
       05:AB51  42                 say
                                  .else
                                  .endif
                          
       05:AB52  99 FC 31           sta    __arg-(3),Y
       05:AB55  8A                 txa
       05:AB56  99 FD 31           sta    __arg-(3-1),Y
 1141                             __ldwi  5
       05:AB59  A2 05              ldx    #low(5)
       05:AB5B  A9 00              lda    #high(5)
 1142                             __phb   1
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       05:AB5D  A4 02              ldy    <__arg_idx
                                  .endif
                          
       05:AB5F  8A                 txa
       05:AB60  99 FE 31           sta    __arg-(1),Y
 1143                             __ldwi  13
       05:AB63  A2 0D              ldx    #low(13)
       05:AB65  A9 00              lda    #high(13)
 1144                             __pushw
                                 __submi  2,__stack
       05:AB67  48                 pha
       05:AB68  38                 sec
       05:AB69  A5 00              lda    <__stack
       05:AB6B  E9 02              sbc    #low(2)
       05:AB6D  85 00              sta    <__stack
       05:AB6F  A5 01              lda    <__stack+1
       05:AB71  E9 00              sbc    #high(2)
       05:AB73  85 01              sta    <__stack+1
       05:AB75  68                 pla
       05:AB76  22                 sax
       05:AB77  92 00              sta    [__stack]
       05:AB79  22                 sax
       05:AB7A  A0 01              ldy    #1
       05:AB7C  91 00              sta    [__stack],Y
 1145                             __ldb   _i
                0000              .if (1 = 2)
                                  .else
       05:AB7E  AE FE 31           ldx    _i
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01822
                          ;        dec    A
                          ;.x_01822:
       05:AB81  62                 cla    ; unsigned
                                  .endif
 1146                             __addws
       05:AB82  22                 sax
       05:AB83  18                 clc
       05:AB84  72 00              adc    [__stack]
       05:AB86  22                 sax
       05:AB87  A0 01              ldy    #1
       05:AB89  71 00              adc    [__stack],Y
                                 __addmi 2, __stack
       05:AB8B  48                 pha
       05:AB8C  18                 clc
       05:AB8D  A5 00              lda    <__stack
       05:AB8F  69 02              adc    #low(2)
       05:AB91  85 00              sta    <__stack
       05:AB93  A5 01              lda    <__stack+1
       05:AB95  69 00              adc    #high(2)
       05:AB97  85 01              sta    <__stack+1
       05:AB99  68                 pla
 1147  05:AB9A  20 ED CE            call  _put_string.3
 1148                             __lbra  LL65
       05:AB9D  4C 2D AB           jmp    LL65
 1149  05:ABA0            LL67:
 1150                     
 1151                             __ldwi  LL0+194
       05:ABA0  A2 C2              ldx    #low(LL0+194)
       05:ABA2  A9 40              lda    #high(LL0+194)
 1152                             __phw   3,3
                                   ; #1 (bytes :  9, cycles : 16)
                                   ; #2 (bytes : 16, cycles : 28)
                          
                0001              .if (2 = 2)
       05:ABA4  A8                 tay
       05:ABA5  A5 02              lda    <__arg_idx
                                   add    #3
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       05:ABA7  18                 clc
       05:ABA8  69 03              adc    #3
                                  .endif
       05:ABAA  85 02              sta    <__arg_idx
       05:ABAC  42                 say
                                  .else
                                  .endif
                          
       05:ABAD  99 FC 31           sta    __arg-(3),Y
       05:ABB0  8A                 txa
       05:ABB1  99 FD 31           sta    __arg-(3-1),Y
 1153                             __ldwi  18
       05:ABB4  A2 12              ldx    #low(18)
       05:ABB6  A9 00              lda    #high(18)
 1154                             __phb   1
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       05:ABB8  A4 02              ldy    <__arg_idx
                                  .endif
                          
       05:ABBA  8A                 txa
       05:ABBB  99 FE 31           sta    __arg-(1),Y
 1155                             __ldwi  14
       05:ABBE  A2 0E              ldx    #low(14)
       05:ABC0  A9 00              lda    #high(14)
 1156  05:ABC2  20 ED CE            call  _put_string.3
 1157                             __ldwi  LL0+205
       05:ABC5  A2 CD              ldx    #low(LL0+205)
       05:ABC7  A9 40              lda    #high(LL0+205)
 1158                             __phw   3,3
                                   ; #1 (bytes :  9, cycles : 16)
                                   ; #2 (bytes : 16, cycles : 28)
                          
                0001              .if (2 = 2)
       05:ABC9  A8                 tay
       05:ABCA  A5 02              lda    <__arg_idx
                                   add    #3
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       05:ABCC  18                 clc
       05:ABCD  69 03              adc    #3
                                  .endif
       05:ABCF  85 02              sta    <__arg_idx
       05:ABD1  42                 say
                                  .else
                                  .endif
                          
       05:ABD2  99 FC 31           sta    __arg-(3),Y
       05:ABD5  8A                 txa
       05:ABD6  99 FD 31           sta    __arg-(3-1),Y
 1159                             __ldwi  18
       05:ABD9  A2 12              ldx    #low(18)
       05:ABDB  A9 00              lda    #high(18)
 1160                             __phb   1
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       05:ABDD  A4 02              ldy    <__arg_idx
                                  .endif
                          
       05:ABDF  8A                 txa
       05:ABE0  99 FE 31           sta    __arg-(1),Y
 1161                             __ldwi  15
       05:ABE3  A2 0F              ldx    #low(15)
       05:ABE5  A9 00              lda    #high(15)
 1162  05:ABE7  20 ED CE            call  _put_string.3
 1163                             __ldwi  32767
       05:ABEA  A2 FF              ldx    #low(32767)
       05:ABEC  A9 7F              lda    #high(32767)
 1164                             __stw   _min
       05:ABEE  8E F8 31           stx    _min
       05:ABF1  8D F9 31           sta    _min+1
 1165                             __ldwi  0
       05:ABF4  A2 00              ldx    #low(0)
       05:ABF6  A9 00              lda    #high(0)
 1166                             __stw   _tot
       05:ABF8  8E FC 31           stx    _tot
       05:ABFB  8D FD 31           sta    _tot+1
 1167                             __ldwi  0
       05:ABFE  A2 00              ldx    #low(0)
       05:AC00  A9 00              lda    #high(0)
 1168  05:AC02  8E FE 31            stx   _i
 1169  05:AC05            LL68:
 1170                     
 1171                             __ldb   _i
                0000              .if (1 = 2)
                                  .else
       05:AC05  AE FE 31           ldx    _i
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01844
                          ;        dec    A
                          ;.x_01844:
       05:AC08  62                 cla    ; unsigned
                                  .endif
 1172                             __stw   <__temp
       05:AC09  86 03              stx    <__temp
       05:AC0B  85 04              sta    <__temp+1
 1173                             __ldwi  10
       05:AC0D  A2 0A              ldx    #low(10)
       05:AC0F  A9 00              lda    #high(10)
 1174  05:AC11  20 FF C8            jsr   ltzp
 1175                             __lbne  LL70
       05:AC14  F0 03              beq    .x01847
       05:AC16  4C 34 AC           jmp    LL70
       05:AC19            .x01847
 1176                             __lbra  LL71
       05:AC19  4C 31 B0           jmp    LL71
 1177  05:AC1C            LL69:
 1178                     
 1179                             __ldb   _i
                0000              .if (1 = 2)
                                  .else
       05:AC1C  AE FE 31           ldx    _i
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01850
                          ;        dec    A
                          ;.x_01850:
       05:AC1F  62                 cla    ; unsigned
                                  .endif
 1180                             __addwi 1
       05:AC20  18                 clc
       05:AC21  22                 sax
       05:AC22  69 01              adc    #low(1)
       05:AC24  22                 sax
       05:AC25  69 00              adc    #high(1)
 1181  05:AC27  8E FE 31            stx   _i
 1182                             __subwi 1
       05:AC2A  38                 sec
       05:AC2B  22                 sax
       05:AC2C  E9 01              sbc    #low(1)
       05:AC2E  22                 sax
       05:AC2F  E9 00              sbc    #high(1)
 1183                             __lbra  LL68
       05:AC31  4C 05 AC           jmp    LL68
 1184  05:AC34            LL70:
 1185                     
 1186                             __ldwi  LL0+216
       05:AC34  A2 D8              ldx    #low(LL0+216)
       05:AC36  A9 40              lda    #high(LL0+216)
 1187                             __phw   3,3
                                   ; #1 (bytes :  9, cycles : 16)
                                   ; #2 (bytes : 16, cycles : 28)
                          
                0001              .if (2 = 2)
       05:AC38  A8                 tay
       05:AC39  A5 02              lda    <__arg_idx
                                   add    #3
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       05:AC3B  18                 clc
       05:AC3C  69 03              adc    #3
                                  .endif
       05:AC3E  85 02              sta    <__arg_idx
       05:AC40  42                 say
                                  .else
                                  .endif
                          
       05:AC41  99 FC 31           sta    __arg-(3),Y
       05:AC44  8A                 txa
       05:AC45  99 FD 31           sta    __arg-(3-1),Y
 1188                             __ldwi  2
       05:AC48  A2 02              ldx    #low(2)
       05:AC4A  A9 00              lda    #high(2)
 1189                             __phb   1
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       05:AC4C  A4 02              ldy    <__arg_idx
                                  .endif
                          
       05:AC4E  8A                 txa
       05:AC4F  99 FE 31           sta    __arg-(1),Y
 1190                             __ldwi  11
       05:AC52  A2 0B              ldx    #low(11)
       05:AC54  A9 00              lda    #high(11)
 1191  05:AC56  20 ED CE            call  _put_string.3
 1192                             __ldwi  _start_pos
       05:AC59  A2 D5              ldx    #low(_start_pos)
       05:AC5B  A9 31              lda    #high(_start_pos)
 1193                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       05:AC5D  86 0B              stx    <__ptr
       05:AC5F  85 0C              sta    <__ptr+1
       05:AC61  B2 0B              lda    [__ptr]
       05:AC63  AA                 tax
       05:AC64  62                 cla
                          ;        bpl    .x_01861   ; signed
                          ;        dec    A
                          ;.x_01861:
 1194  05:AC65  8E CE 29            stx   _rec_h
 1195                             __ldwi  _start_pos
       05:AC68  A2 D5              ldx    #low(_start_pos)
       05:AC6A  A9 31              lda    #high(_start_pos)
 1196                             __addwi 1
       05:AC6C  18                 clc
       05:AC6D  22                 sax
       05:AC6E  69 01              adc    #low(1)
       05:AC70  22                 sax
       05:AC71  69 00              adc    #high(1)
 1197                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       05:AC73  86 0B              stx    <__ptr
       05:AC75  85 0C              sta    <__ptr+1
       05:AC77  B2 0B              lda    [__ptr]
       05:AC79  AA                 tax
       05:AC7A  62                 cla
                          ;        bpl    .x_01864   ; signed
                          ;        dec    A
                          ;.x_01864:
 1198  05:AC7B  8E CF 29            stx   _rec_m
 1199                             __ldwi  _start_pos
       05:AC7E  A2 D5              ldx    #low(_start_pos)
       05:AC80  A9 31              lda    #high(_start_pos)
 1200                             __addwi 2
       05:AC82  18                 clc
       05:AC83  22                 sax
       05:AC84  69 02              adc    #low(2)
       05:AC86  22                 sax
       05:AC87  69 00              adc    #high(2)
 1201                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       05:AC89  86 0B              stx    <__ptr
       05:AC8B  85 0C              sta    <__ptr+1
       05:AC8D  B2 0B              lda    [__ptr]
       05:AC8F  AA                 tax
       05:AC90  62                 cla
                          ;        bpl    .x_01867   ; signed
                          ;        dec    A
                          ;.x_01867:
 1202  05:AC91  8E D0 29            stx   _rec_l
 1203  05:AC94  20 C7 DE            call  _cd_read_sector
 1204                             __ldwi  LL0+241
       05:AC97  A2 F1              ldx    #low(LL0+241)
       05:AC99  A9 40              lda    #high(LL0+241)
 1205                             __phw   3,3
                                   ; #1 (bytes :  9, cycles : 16)
                                   ; #2 (bytes : 16, cycles : 28)
                          
                0001              .if (2 = 2)
       05:AC9B  A8                 tay
       05:AC9C  A5 02              lda    <__arg_idx
                                   add    #3
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       05:AC9E  18                 clc
       05:AC9F  69 03              adc    #3
                                  .endif
       05:ACA1  85 02              sta    <__arg_idx
       05:ACA3  42                 say
                                  .else
                                  .endif
                          
       05:ACA4  99 FC 31           sta    __arg-(3),Y
       05:ACA7  8A                 txa
       05:ACA8  99 FD 31           sta    __arg-(3-1),Y
 1206                             __ldwi  2
       05:ACAB  A2 02              ldx    #low(2)
       05:ACAD  A9 00              lda    #high(2)
 1207                             __phb   1
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       05:ACAF  A4 02              ldy    <__arg_idx
                                  .endif
                          
       05:ACB1  8A                 txa
       05:ACB2  99 FE 31           sta    __arg-(1),Y
 1208                             __ldwi  11
       05:ACB5  A2 0B              ldx    #low(11)
       05:ACB7  A9 00              lda    #high(11)
 1209  05:ACB9  20 ED CE            call  _put_string.3
 1210                             __ldwi  55
       05:ACBC  A2 37              ldx    #low(55)
       05:ACBE  A9 00              lda    #high(55)
 1211  05:ACC0  20 82 DB            call  _random
 1212                             __addwi 5
       05:ACC3  18                 clc
       05:ACC4  22                 sax
       05:ACC5  69 05              adc    #low(5)
       05:ACC7  22                 sax
       05:ACC8  69 00              adc    #high(5)
 1213  05:ACCA  A0 01               ldy   #1
 1214  05:ACCC  20 2F CF            call  _vsync
 1215                             __ldwi  LL0+266
       05:ACCF  A2 0A              ldx    #low(LL0+266)
       05:ACD1  A9 41              lda    #high(LL0+266)
 1216                             __phw   3,3
                                   ; #1 (bytes :  9, cycles : 16)
                                   ; #2 (bytes : 16, cycles : 28)
                          
                0001              .if (2 = 2)
       05:ACD3  A8                 tay
       05:ACD4  A5 02              lda    <__arg_idx
                                   add    #3
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       05:ACD6  18                 clc
       05:ACD7  69 03              adc    #3
                                  .endif
       05:ACD9  85 02              sta    <__arg_idx
       05:ACDB  42                 say
                                  .else
                                  .endif
                          
       05:ACDC  99 FC 31           sta    __arg-(3),Y
       05:ACDF  8A                 txa
       05:ACE0  99 FD 31           sta    __arg-(3-1),Y
 1217                             __ldwi  2
       05:ACE3  A2 02              ldx    #low(2)
       05:ACE5  A9 00              lda    #high(2)
 1218                             __phb   1
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       05:ACE7  A4 02              ldy    <__arg_idx
                                  .endif
                          
       05:ACE9  8A                 txa
       05:ACEA  99 FE 31           sta    __arg-(1),Y
 1219                             __ldwi  11
       05:ACED  A2 0B              ldx    #low(11)
       05:ACEF  A9 00              lda    #high(11)
 1220  05:ACF1  20 ED CE            call  _put_string.3
 1221                             __ldwi  _target
       05:ACF4  A2 DB              ldx    #low(_target)
       05:ACF6  A9 31              lda    #high(_target)
 1222                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       05:ACF8  86 0B              stx    <__ptr
       05:ACFA  85 0C              sta    <__ptr+1
       05:ACFC  B2 0B              lda    [__ptr]
       05:ACFE  AA                 tax
       05:ACFF  62                 cla
                          ;        bpl    .x_01883   ; signed
                          ;        dec    A
                          ;.x_01883:
 1223  05:AD00  8E CE 29            stx   _rec_h
 1224                             __ldwi  _target
       05:AD03  A2 DB              ldx    #low(_target)
       05:AD05  A9 31              lda    #high(_target)
 1225                             __addwi 1
       05:AD07  18                 clc
       05:AD08  22                 sax
       05:AD09  69 01              adc    #low(1)
       05:AD0B  22                 sax
       05:AD0C  69 00              adc    #high(1)
 1226                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       05:AD0E  86 0B              stx    <__ptr
       05:AD10  85 0C              sta    <__ptr+1
       05:AD12  B2 0B              lda    [__ptr]
       05:AD14  AA                 tax
       05:AD15  62                 cla
                          ;        bpl    .x_01886   ; signed
                          ;        dec    A
                          ;.x_01886:
 1227  05:AD16  8E CF 29            stx   _rec_m
 1228                             __ldwi  _target
       05:AD19  A2 DB              ldx    #low(_target)
       05:AD1B  A9 31              lda    #high(_target)
 1229                             __addwi 2
       05:AD1D  18                 clc
       05:AD1E  22                 sax
       05:AD1F  69 02              adc    #low(2)
       05:AD21  22                 sax
       05:AD22  69 00              adc    #high(2)
 1230                             __ldb_p
                                   ; (bytes : 11, cycles : 19/23)
       05:AD24  86 0B              stx    <__ptr
       05:AD26  85 0C              sta    <__ptr+1
       05:AD28  B2 0B              lda    [__ptr]
       05:AD2A  AA                 tax
       05:AD2B  62                 cla
                          ;        bpl    .x_01889   ; signed
                          ;        dec    A
                          ;.x_01889:
 1231  05:AD2C  8E D0 29            stx   _rec_l
 1232                             __ldwi  0
       05:AD2F  A2 00              ldx    #low(0)
       05:AD31  A9 00              lda    #high(0)
 1233  05:AD33  A0 01               ldy   #1
 1234  05:AD35  20 2F CF            call  _vsync
 1235  05:AD38  20 F3 DA            call  _clock_reset
 1236  05:AD3B  20 C7 DE            call  _cd_read_sector
 1237                             __ldwi  _timing
       05:AD3E  A2 E4              ldx    #low(_timing)
       05:AD40  A9 31              lda    #high(_timing)
 1238                             __pushw
                                 __submi  2,__stack
       05:AD42  48                 pha
       05:AD43  38                 sec
       05:AD44  A5 00              lda    <__stack
       05:AD46  E9 02              sbc    #low(2)
       05:AD48  85 00              sta    <__stack
       05:AD4A  A5 01              lda    <__stack+1
       05:AD4C  E9 00              sbc    #high(2)
       05:AD4E  85 01              sta    <__stack+1
       05:AD50  68                 pla
       05:AD51  22                 sax
       05:AD52  92 00              sta    [__stack]
       05:AD54  22                 sax
       05:AD55  A0 01              ldy    #1
       05:AD57  91 00              sta    [__stack],Y
 1239                             __ldb   _i
                0000              .if (1 = 2)
                                  .else
       05:AD59  AE FE 31           ldx    _i
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01895
                          ;        dec    A
                          ;.x_01895:
       05:AD5C  62                 cla    ; unsigned
                                  .endif
 1240                             __aslw
       05:AD5D  22                 sax
       05:AD5E  0A                 asl    A
       05:AD5F  22                 sax
       05:AD60  2A                 rol    A
 1241                             __addws
       05:AD61  22                 sax
       05:AD62  18                 clc
       05:AD63  72 00              adc    [__stack]
       05:AD65  22                 sax
       05:AD66  A0 01              ldy    #1
       05:AD68  71 00              adc    [__stack],Y
                                 __addmi 2, __stack
       05:AD6A  48                 pha
       05:AD6B  18                 clc
       05:AD6C  A5 00              lda    <__stack
       05:AD6E  69 02              adc    #low(2)
       05:AD70  85 00              sta    <__stack
       05:AD72  A5 01              lda    <__stack+1
       05:AD74  69 00              adc    #high(2)
       05:AD76  85 01              sta    <__stack+1
       05:AD78  68                 pla
 1242                             __pushw
                                 __submi  2,__stack
       05:AD79  48                 pha
       05:AD7A  38                 sec
       05:AD7B  A5 00              lda    <__stack
       05:AD7D  E9 02              sbc    #low(2)
       05:AD7F  85 00              sta    <__stack
       05:AD81  A5 01              lda    <__stack+1
       05:AD83  E9 00              sbc    #high(2)
       05:AD85  85 01              sta    <__stack+1
       05:AD87  68                 pla
       05:AD88  22                 sax
       05:AD89  92 00              sta    [__stack]
       05:AD8B  22                 sax
       05:AD8C  A0 01              ldy    #1
       05:AD8E  91 00              sta    [__stack],Y
 1243  05:AD90  20 E4 DA            call  _clock_mm
 1244                             __pushw
                                 __submi  2,__stack
       05:AD93  48                 pha
       05:AD94  38                 sec
       05:AD95  A5 00              lda    <__stack
       05:AD97  E9 02              sbc    #low(2)
       05:AD99  85 00              sta    <__stack
       05:AD9B  A5 01              lda    <__stack+1
       05:AD9D  E9 00              sbc    #high(2)
       05:AD9F  85 01              sta    <__stack+1
       05:ADA1  68                 pla
       05:ADA2  22                 sax
       05:ADA3  92 00              sta    [__stack]
       05:ADA5  22                 sax
       05:ADA6  A0 01              ldy    #1
       05:ADA8  91 00              sta    [__stack],Y
 1245                             __ldwi  3600
       05:ADAA  A2 10              ldx    #low(3600)
       05:ADAC  A9 0E              lda    #high(3600)
 1246  05:ADAE  20 10 CA            jsr   smul
 1247                             __pushw
                                 __submi  2,__stack
       05:ADB1  48                 pha
       05:ADB2  38                 sec
       05:ADB3  A5 00              lda    <__stack
       05:ADB5  E9 02              sbc    #low(2)
       05:ADB7  85 00              sta    <__stack
       05:ADB9  A5 01              lda    <__stack+1
       05:ADBB  E9 00              sbc    #high(2)
       05:ADBD  85 01              sta    <__stack+1
       05:ADBF  68                 pla
       05:ADC0  22                 sax
       05:ADC1  92 00              sta    [__stack]
       05:ADC3  22                 sax
       05:ADC4  A0 01              ldy    #1
       05:ADC6  91 00              sta    [__stack],Y
 1248  05:ADC8  20 E9 DA            call  _clock_ss
 1249                             __pushw
                                 __submi  2,__stack
       05:ADCB  48                 pha
       05:ADCC  38                 sec
       05:ADCD  A5 00              lda    <__stack
       05:ADCF  E9 02              sbc    #low(2)
       05:ADD1  85 00              sta    <__stack
       05:ADD3  A5 01              lda    <__stack+1
       05:ADD5  E9 00              sbc    #high(2)
       05:ADD7  85 01              sta    <__stack+1
       05:ADD9  68                 pla
       05:ADDA  22                 sax
       05:ADDB  92 00              sta    [__stack]
       05:ADDD  22                 sax
       05:ADDE  A0 01              ldy    #1
       05:ADE0  91 00              sta    [__stack],Y
 1250                             __ldwi  60
       05:ADE2  A2 3C              ldx    #low(60)
       05:ADE4  A9 00              lda    #high(60)
 1251  05:ADE6  20 10 CA            jsr   smul
 1252                             __addws
       05:ADE9  22                 sax
       05:ADEA  18                 clc
       05:ADEB  72 00              adc    [__stack]
       05:ADED  22                 sax
       05:ADEE  A0 01              ldy    #1
       05:ADF0  71 00              adc    [__stack],Y
                                 __addmi 2, __stack
       05:ADF2  48                 pha
       05:ADF3  18                 clc
       05:ADF4  A5 00              lda    <__stack
       05:ADF6  69 02              adc    #low(2)
       05:ADF8  85 00              sta    <__stack
       05:ADFA  A5 01              lda    <__stack+1
       05:ADFC  69 00              adc    #high(2)
       05:ADFE  85 01              sta    <__stack+1
       05:AE00  68                 pla
 1253                             __pushw
                                 __submi  2,__stack
       05:AE01  48                 pha
       05:AE02  38                 sec
       05:AE03  A5 00              lda    <__stack
       05:AE05  E9 02              sbc    #low(2)
       05:AE07  85 00              sta    <__stack
       05:AE09  A5 01              lda    <__stack+1
       05:AE0B  E9 00              sbc    #high(2)
       05:AE0D  85 01              sta    <__stack+1
       05:AE0F  68                 pla
       05:AE10  22                 sax
       05:AE11  92 00              sta    [__stack]
       05:AE13  22                 sax
       05:AE14  A0 01              ldy    #1
       05:AE16  91 00              sta    [__stack],Y
 1254  05:AE18  20 EE DA            call  _clock_tt
 1255                             __addws
       05:AE1B  22                 sax
       05:AE1C  18                 clc
       05:AE1D  72 00              adc    [__stack]
       05:AE1F  22                 sax
       05:AE20  A0 01              ldy    #1
       05:AE22  71 00              adc    [__stack],Y
                                 __addmi 2, __stack
       05:AE24  48                 pha
       05:AE25  18                 clc
       05:AE26  A5 00              lda    <__stack
       05:AE28  69 02              adc    #low(2)
       05:AE2A  85 00              sta    <__stack
       05:AE2C  A5 01              lda    <__stack+1
       05:AE2E  69 00              adc    #high(2)
       05:AE30  85 01              sta    <__stack+1
       05:AE32  68                 pla
 1256                             __stwps
                                 __stw    <__temp
       05:AE33  86 03              stx    <__temp
       05:AE35  85 04              sta    <__temp+1
                                 __ldwp    __stack
       05:AE37  B2 00              lda    [__stack]
       05:AE39  AA                 tax
       05:AE3A  A0 01              ldy    #1
       05:AE3C  B1 00              lda    [__stack],Y
                                 __stw    <__ptr
       05:AE3E  86 0B              stx    <__ptr
       05:AE40  85 0C              sta    <__ptr+1
                                 __ldw    <__temp
                0000              .if (1 = 2)
                                  .else
       05:AE42  A6 03              ldx    <__temp
       05:AE44  A5 04              lda    <__temp+1
                                  .endif
                                 __stwp    __ptr
       05:AE46  22                 sax
       05:AE47  92 0B              sta    [__ptr]
       05:AE49  22                 sax
       05:AE4A  A0 01              ldy    #1
       05:AE4C  91 0B              sta    [__ptr],Y
                                 __addmi  2,__stack
       05:AE4E  48                 pha
       05:AE4F  18                 clc
       05:AE50  A5 00              lda    <__stack
       05:AE52  69 02              adc    #low(2)
       05:AE54  85 00              sta    <__stack
       05:AE56  A5 01              lda    <__stack+1
       05:AE58  69 00              adc    #high(2)
       05:AE5A  85 01              sta    <__stack+1
       05:AE5C  68                 pla
 1257                             __ldwi  _timing
       05:AE5D  A2 E4              ldx    #low(_timing)
       05:AE5F  A9 31              lda    #high(_timing)
 1258                             __pushw
                                 __submi  2,__stack
       05:AE61  48                 pha
       05:AE62  38                 sec
       05:AE63  A5 00              lda    <__stack
       05:AE65  E9 02              sbc    #low(2)
       05:AE67  85 00              sta    <__stack
       05:AE69  A5 01              lda    <__stack+1
       05:AE6B  E9 00              sbc    #high(2)
       05:AE6D  85 01              sta    <__stack+1
       05:AE6F  68                 pla
       05:AE70  22                 sax
       05:AE71  92 00              sta    [__stack]
       05:AE73  22                 sax
       05:AE74  A0 01              ldy    #1
       05:AE76  91 00              sta    [__stack],Y
 1259                             __ldb   _i
                0000              .if (1 = 2)
                                  .else
       05:AE78  AE FE 31           ldx    _i
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01926
                          ;        dec    A
                          ;.x_01926:
       05:AE7B  62                 cla    ; unsigned
                                  .endif
 1260                             __aslw
       05:AE7C  22                 sax
       05:AE7D  0A                 asl    A
       05:AE7E  22                 sax
       05:AE7F  2A                 rol    A
 1261                             __addws
       05:AE80  22                 sax
       05:AE81  18                 clc
       05:AE82  72 00              adc    [__stack]
       05:AE84  22                 sax
       05:AE85  A0 01              ldy    #1
       05:AE87  71 00              adc    [__stack],Y
                                 __addmi 2, __stack
       05:AE89  48                 pha
       05:AE8A  18                 clc
       05:AE8B  A5 00              lda    <__stack
       05:AE8D  69 02              adc    #low(2)
       05:AE8F  85 00              sta    <__stack
       05:AE91  A5 01              lda    <__stack+1
       05:AE93  69 00              adc    #high(2)
       05:AE95  85 01              sta    <__stack+1
       05:AE97  68                 pla
 1262                             __stw   __ptr
       05:AE98  8E 0B 20           stx    __ptr
       05:AE9B  8D 0C 20           sta    __ptr+1
 1263                             __ldwp  __ptr
       05:AE9E  B2 0B              lda    [__ptr]
       05:AEA0  AA                 tax
       05:AEA1  A0 01              ldy    #1
       05:AEA3  B1 0B              lda    [__ptr],Y
 1264                             __stw   <__temp
       05:AEA5  86 03              stx    <__temp
       05:AEA7  85 04              sta    <__temp+1
 1265                             __ldw   _min
                0000              .if (1 = 2)
                                  .else
       05:AEA9  AE F8 31           ldx    _min
       05:AEAC  AD F9 31           lda    _min+1
                                  .endif
 1266  05:AEAF  20 FF C8            jsr   ltzp
 1267                             __lbeq  LL72
       05:AEB2  D0 03              bne    .x01934
       05:AEB4  4C 05 AF           jmp    LL72
       05:AEB7            .x01934
 1268                             __ldwi  _timing
       05:AEB7  A2 E4              ldx    #low(_timing)
       05:AEB9  A9 31              lda    #high(_timing)
 1269                             __pushw
                                 __submi  2,__stack
       05:AEBB  48                 pha
       05:AEBC  38                 sec
       05:AEBD  A5 00              lda    <__stack
       05:AEBF  E9 02              sbc    #low(2)
       05:AEC1  85 00              sta    <__stack
       05:AEC3  A5 01              lda    <__stack+1
       05:AEC5  E9 00              sbc    #high(2)
       05:AEC7  85 01              sta    <__stack+1
       05:AEC9  68                 pla
       05:AECA  22                 sax
       05:AECB  92 00              sta    [__stack]
       05:AECD  22                 sax
       05:AECE  A0 01              ldy    #1
       05:AED0  91 00              sta    [__stack],Y
 1270                             __ldb   _i
                0000              .if (1 = 2)
                                  .else
       05:AED2  AE FE 31           ldx    _i
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01939
                          ;        dec    A
                          ;.x_01939:
       05:AED5  62                 cla    ; unsigned
                                  .endif
 1271                             __aslw
       05:AED6  22                 sax
       05:AED7  0A                 asl    A
       05:AED8  22                 sax
       05:AED9  2A                 rol    A
 1272                             __addws
       05:AEDA  22                 sax
       05:AEDB  18                 clc
       05:AEDC  72 00              adc    [__stack]
       05:AEDE  22                 sax
       05:AEDF  A0 01              ldy    #1
       05:AEE1  71 00              adc    [__stack],Y
                                 __addmi 2, __stack
       05:AEE3  48                 pha
       05:AEE4  18                 clc
       05:AEE5  A5 00              lda    <__stack
       05:AEE7  69 02              adc    #low(2)
       05:AEE9  85 00              sta    <__stack
       05:AEEB  A5 01              lda    <__stack+1
       05:AEED  69 00              adc    #high(2)
       05:AEEF  85 01              sta    <__stack+1
       05:AEF1  68                 pla
 1273                             __stw   __ptr
       05:AEF2  8E 0B 20           stx    __ptr
       05:AEF5  8D 0C 20           sta    __ptr+1
 1274                             __ldwp  __ptr
       05:AEF8  B2 0B              lda    [__ptr]
       05:AEFA  AA                 tax
       05:AEFB  A0 01              ldy    #1
       05:AEFD  B1 0B              lda    [__ptr],Y
 1275                             __stw   _min
       05:AEFF  8E F8 31           stx    _min
       05:AF02  8D F9 31           sta    _min+1
 1276  05:AF05            LL72:
 1277                     
 1278                             __ldw   _tot
                0000              .if (1 = 2)
                                  .else
       05:AF05  AE FC 31           ldx    _tot
       05:AF08  AD FD 31           lda    _tot+1
                                  .endif
 1279                             __pushw
                                 __submi  2,__stack
       05:AF0B  48                 pha
       05:AF0C  38                 sec
       05:AF0D  A5 00              lda    <__stack
       05:AF0F  E9 02              sbc    #low(2)
       05:AF11  85 00              sta    <__stack
       05:AF13  A5 01              lda    <__stack+1
       05:AF15  E9 00              sbc    #high(2)
       05:AF17  85 01              sta    <__stack+1
       05:AF19  68                 pla
       05:AF1A  22                 sax
       05:AF1B  92 00              sta    [__stack]
       05:AF1D  22                 sax
       05:AF1E  A0 01              ldy    #1
       05:AF20  91 00              sta    [__stack],Y
 1280                             __ldwi  _timing
       05:AF22  A2 E4              ldx    #low(_timing)
       05:AF24  A9 31              lda    #high(_timing)
 1281                             __pushw
                                 __submi  2,__stack
       05:AF26  48                 pha
       05:AF27  38                 sec
       05:AF28  A5 00              lda    <__stack
       05:AF2A  E9 02              sbc    #low(2)
       05:AF2C  85 00              sta    <__stack
       05:AF2E  A5 01              lda    <__stack+1
       05:AF30  E9 00              sbc    #high(2)
       05:AF32  85 01              sta    <__stack+1
       05:AF34  68                 pla
       05:AF35  22                 sax
       05:AF36  92 00              sta    [__stack]
       05:AF38  22                 sax
       05:AF39  A0 01              ldy    #1
       05:AF3B  91 00              sta    [__stack],Y
 1282                             __ldb   _i
                0000              .if (1 = 2)
                                  .else
       05:AF3D  AE FE 31           ldx    _i
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01953
                          ;        dec    A
                          ;.x_01953:
       05:AF40  62                 cla    ; unsigned
                                  .endif
 1283                             __aslw
       05:AF41  22                 sax
       05:AF42  0A                 asl    A
       05:AF43  22                 sax
       05:AF44  2A                 rol    A
 1284                             __addws
       05:AF45  22                 sax
       05:AF46  18                 clc
       05:AF47  72 00              adc    [__stack]
       05:AF49  22                 sax
       05:AF4A  A0 01              ldy    #1
       05:AF4C  71 00              adc    [__stack],Y
                                 __addmi 2, __stack
       05:AF4E  48                 pha
       05:AF4F  18                 clc
       05:AF50  A5 00              lda    <__stack
       05:AF52  69 02              adc    #low(2)
       05:AF54  85 00              sta    <__stack
       05:AF56  A5 01              lda    <__stack+1
       05:AF58  69 00              adc    #high(2)
       05:AF5A  85 01              sta    <__stack+1
       05:AF5C  68                 pla
 1285                             __stw   __ptr
       05:AF5D  8E 0B 20           stx    __ptr
       05:AF60  8D 0C 20           sta    __ptr+1
 1286                             __ldwp  __ptr
       05:AF63  B2 0B              lda    [__ptr]
       05:AF65  AA                 tax
       05:AF66  A0 01              ldy    #1
       05:AF68  B1 0B              lda    [__ptr],Y
 1287                             __addws
       05:AF6A  22                 sax
       05:AF6B  18                 clc
       05:AF6C  72 00              adc    [__stack]
       05:AF6E  22                 sax
       05:AF6F  A0 01              ldy    #1
       05:AF71  71 00              adc    [__stack],Y
                                 __addmi 2, __stack
       05:AF73  48                 pha
       05:AF74  18                 clc
       05:AF75  A5 00              lda    <__stack
       05:AF77  69 02              adc    #low(2)
       05:AF79  85 00              sta    <__stack
       05:AF7B  A5 01              lda    <__stack+1
       05:AF7D  69 00              adc    #high(2)
       05:AF7F  85 01              sta    <__stack+1
       05:AF81  68                 pla
 1288                             __stw   _tot
       05:AF82  8E FC 31           stx    _tot
       05:AF85  8D FD 31           sta    _tot+1
 1289                             __ldwi  _timing
       05:AF88  A2 E4              ldx    #low(_timing)
       05:AF8A  A9 31              lda    #high(_timing)
 1290                             __pushw
                                 __submi  2,__stack
       05:AF8C  48                 pha
       05:AF8D  38                 sec
       05:AF8E  A5 00              lda    <__stack
       05:AF90  E9 02              sbc    #low(2)
       05:AF92  85 00              sta    <__stack
       05:AF94  A5 01              lda    <__stack+1
       05:AF96  E9 00              sbc    #high(2)
       05:AF98  85 01              sta    <__stack+1
       05:AF9A  68                 pla
       05:AF9B  22                 sax
       05:AF9C  92 00              sta    [__stack]
       05:AF9E  22                 sax
       05:AF9F  A0 01              ldy    #1
       05:AFA1  91 00              sta    [__stack],Y
 1291                             __ldb   _i
                0000              .if (1 = 2)
                                  .else
       05:AFA3  AE FE 31           ldx    _i
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01966
                          ;        dec    A
                          ;.x_01966:
       05:AFA6  62                 cla    ; unsigned
                                  .endif
 1292                             __aslw
       05:AFA7  22                 sax
       05:AFA8  0A                 asl    A
       05:AFA9  22                 sax
       05:AFAA  2A                 rol    A
 1293                             __addws
       05:AFAB  22                 sax
       05:AFAC  18                 clc
       05:AFAD  72 00              adc    [__stack]
       05:AFAF  22                 sax
       05:AFB0  A0 01              ldy    #1
       05:AFB2  71 00              adc    [__stack],Y
                                 __addmi 2, __stack
       05:AFB4  48                 pha
       05:AFB5  18                 clc
       05:AFB6  A5 00              lda    <__stack
       05:AFB8  69 02              adc    #low(2)
       05:AFBA  85 00              sta    <__stack
       05:AFBC  A5 01              lda    <__stack+1
       05:AFBE  69 00              adc    #high(2)
       05:AFC0  85 01              sta    <__stack+1
       05:AFC2  68                 pla
 1294                             __stw   __ptr
       05:AFC3  8E 0B 20           stx    __ptr
       05:AFC6  8D 0C 20           sta    __ptr+1
 1295                             __ldwp  __ptr
       05:AFC9  B2 0B              lda    [__ptr]
       05:AFCB  AA                 tax
       05:AFCC  A0 01              ldy    #1
       05:AFCE  B1 0B              lda    [__ptr],Y
 1296                             __phw   4,4
                                   ; #1 (bytes :  9, cycles : 16)
                                   ; #2 (bytes : 16, cycles : 28)
                          
                0001              .if (2 = 2)
       05:AFD0  A8                 tay
       05:AFD1  A5 02              lda    <__arg_idx
                                   add    #4
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       05:AFD3  18                 clc
       05:AFD4  69 04              adc    #4
                                  .endif
       05:AFD6  85 02              sta    <__arg_idx
       05:AFD8  42                 say
                                  .else
                                  .endif
                          
       05:AFD9  99 FB 31           sta    __arg-(4),Y
       05:AFDC  8A                 txa
       05:AFDD  99 FC 31           sta    __arg-(4-1),Y
 1297                             __ldwi  5
       05:AFE0  A2 05              ldx    #low(5)
       05:AFE2  A9 00              lda    #high(5)
 1298                             __phb   2
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       05:AFE4  A4 02              ldy    <__arg_idx
                                  .endif
                          
       05:AFE6  8A                 txa
       05:AFE7  99 FD 31           sta    __arg-(2),Y
 1299                             __ldwi  5
       05:AFEA  A2 05              ldx    #low(5)
       05:AFEC  A9 00              lda    #high(5)
 1300                             __phb   1
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       05:AFEE  A4 02              ldy    <__arg_idx
                                  .endif
                          
       05:AFF0  8A                 txa
       05:AFF1  99 FE 31           sta    __arg-(1),Y
 1301                             __ldwi  13
       05:AFF4  A2 0D              ldx    #low(13)
       05:AFF6  A9 00              lda    #high(13)
 1302                             __pushw
                                 __submi  2,__stack
       05:AFF8  48                 pha
       05:AFF9  38                 sec
       05:AFFA  A5 00              lda    <__stack
       05:AFFC  E9 02              sbc    #low(2)
       05:AFFE  85 00              sta    <__stack
       05:B000  A5 01              lda    <__stack+1
       05:B002  E9 00              sbc    #high(2)
       05:B004  85 01              sta    <__stack+1
       05:B006  68                 pla
       05:B007  22                 sax
       05:B008  92 00              sta    [__stack]
       05:B00A  22                 sax
       05:B00B  A0 01              ldy    #1
       05:B00D  91 00              sta    [__stack],Y
 1303                             __ldb   _i
                0000              .if (1 = 2)
                                  .else
       05:B00F  AE FE 31           ldx    _i
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_01982
                          ;        dec    A
                          ;.x_01982:
       05:B012  62                 cla    ; unsigned
                                  .endif
 1304                             __addws
       05:B013  22                 sax
       05:B014  18                 clc
       05:B015  72 00              adc    [__stack]
       05:B017  22                 sax
       05:B018  A0 01              ldy    #1
       05:B01A  71 00              adc    [__stack],Y
                                 __addmi 2, __stack
       05:B01C  48                 pha
       05:B01D  18                 clc
       05:B01E  A5 00              lda    <__stack
       05:B020  69 02              adc    #low(2)
       05:B022  85 00              sta    <__stack
       05:B024  A5 01              lda    <__stack+1
       05:B026  69 00              adc    #high(2)
       05:B028  85 01              sta    <__stack+1
       05:B02A  68                 pla
 1305  05:B02B  20 79 CE            call  _put_number.4
 1306                             __lbra  LL69
       05:B02E  4C 1C AC           jmp    LL69
 1307  05:B031            LL71:
 1308                     
 1309                             __ldw   _tot
                0000              .if (1 = 2)
                                  .else
       05:B031  AE FC 31           ldx    _tot
       05:B034  AD FD 31           lda    _tot+1
                                  .endif
 1310                             __pushw
                                 __submi  2,__stack
       05:B037  48                 pha
       05:B038  38                 sec
       05:B039  A5 00              lda    <__stack
       05:B03B  E9 02              sbc    #low(2)
       05:B03D  85 00              sta    <__stack
       05:B03F  A5 01              lda    <__stack+1
       05:B041  E9 00              sbc    #high(2)
       05:B043  85 01              sta    <__stack+1
       05:B045  68                 pla
       05:B046  22                 sax
       05:B047  92 00              sta    [__stack]
       05:B049  22                 sax
       05:B04A  A0 01              ldy    #1
       05:B04C  91 00              sta    [__stack],Y
 1311                             __ldwi  10
       05:B04E  A2 0A              ldx    #low(10)
       05:B050  A9 00              lda    #high(10)
 1312  05:B052  20 C9 CA            jsr   sdiv
 1313                             __stw   _avg
       05:B055  8E FA 31           stx    _avg
       05:B058  8D FB 31           sta    _avg+1
 1314                             __ldwi  LL0+291
       05:B05B  A2 23              ldx    #low(LL0+291)
       05:B05D  A9 41              lda    #high(LL0+291)
 1315                             __phw   3,3
                                   ; #1 (bytes :  9, cycles : 16)
                                   ; #2 (bytes : 16, cycles : 28)
                          
                0001              .if (2 = 2)
       05:B05F  A8                 tay
       05:B060  A5 02              lda    <__arg_idx
                                   add    #3
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       05:B062  18                 clc
       05:B063  69 03              adc    #3
                                  .endif
       05:B065  85 02              sta    <__arg_idx
       05:B067  42                 say
                                  .else
                                  .endif
                          
       05:B068  99 FC 31           sta    __arg-(3),Y
       05:B06B  8A                 txa
       05:B06C  99 FD 31           sta    __arg-(3-1),Y
 1316                             __ldwi  2
       05:B06F  A2 02              ldx    #low(2)
       05:B071  A9 00              lda    #high(2)
 1317                             __phb   1
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       05:B073  A4 02              ldy    <__arg_idx
                                  .endif
                          
       05:B075  8A                 txa
       05:B076  99 FE 31           sta    __arg-(1),Y
 1318                             __ldwi  11
       05:B079  A2 0B              ldx    #low(11)
       05:B07B  A9 00              lda    #high(11)
 1319  05:B07D  20 ED CE            call  _put_string.3
 1320                             __ldwi  LL0+316
       05:B080  A2 3C              ldx    #low(LL0+316)
       05:B082  A9 41              lda    #high(LL0+316)
 1321                             __phw   3,3
                                   ; #1 (bytes :  9, cycles : 16)
                                   ; #2 (bytes : 16, cycles : 28)
                          
                0001              .if (2 = 2)
       05:B084  A8                 tay
       05:B085  A5 02              lda    <__arg_idx
                                   add    #3
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       05:B087  18                 clc
       05:B088  69 03              adc    #3
                                  .endif
       05:B08A  85 02              sta    <__arg_idx
       05:B08C  42                 say
                                  .else
                                  .endif
                          
       05:B08D  99 FC 31           sta    __arg-(3),Y
       05:B090  8A                 txa
       05:B091  99 FD 31           sta    __arg-(3-1),Y
 1322                             __ldwi  18
       05:B094  A2 12              ldx    #low(18)
       05:B096  A9 00              lda    #high(18)
 1323                             __phb   1
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       05:B098  A4 02              ldy    <__arg_idx
                                  .endif
                          
       05:B09A  8A                 txa
       05:B09B  99 FE 31           sta    __arg-(1),Y
 1324                             __ldwi  14
       05:B09E  A2 0E              ldx    #low(14)
       05:B0A0  A9 00              lda    #high(14)
 1325  05:B0A2  20 ED CE            call  _put_string.3
 1326                             __ldw   _min
                0000              .if (1 = 2)
                                  .else
       05:B0A5  AE F8 31           ldx    _min
       05:B0A8  AD F9 31           lda    _min+1
                                  .endif
 1327                             __phw   4,4
                                   ; #1 (bytes :  9, cycles : 16)
                                   ; #2 (bytes : 16, cycles : 28)
                          
                0001              .if (2 = 2)
       05:B0AB  A8                 tay
       05:B0AC  A5 02              lda    <__arg_idx
                                   add    #4
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       05:B0AE  18                 clc
       05:B0AF  69 04              adc    #4
                                  .endif
       05:B0B1  85 02              sta    <__arg_idx
       05:B0B3  42                 say
                                  .else
                                  .endif
                          
       05:B0B4  99 FB 31           sta    __arg-(4),Y
       05:B0B7  8A                 txa
       05:B0B8  99 FC 31           sta    __arg-(4-1),Y
 1328                             __ldwi  5
       05:B0BB  A2 05              ldx    #low(5)
       05:B0BD  A9 00              lda    #high(5)
 1329                             __phb   2
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       05:B0BF  A4 02              ldy    <__arg_idx
                                  .endif
                          
       05:B0C1  8A                 txa
       05:B0C2  99 FD 31           sta    __arg-(2),Y
 1330                             __ldwi  23
       05:B0C5  A2 17              ldx    #low(23)
       05:B0C7  A9 00              lda    #high(23)
 1331                             __phb   1
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       05:B0C9  A4 02              ldy    <__arg_idx
                                  .endif
                          
       05:B0CB  8A                 txa
       05:B0CC  99 FE 31           sta    __arg-(1),Y
 1332                             __ldwi  14
       05:B0CF  A2 0E              ldx    #low(14)
       05:B0D1  A9 00              lda    #high(14)
 1333  05:B0D3  20 79 CE            call  _put_number.4
 1334                             __ldwi  LL0+322
       05:B0D6  A2 42              ldx    #low(LL0+322)
       05:B0D8  A9 41              lda    #high(LL0+322)
 1335                             __phw   3,3
                                   ; #1 (bytes :  9, cycles : 16)
                                   ; #2 (bytes : 16, cycles : 28)
                          
                0001              .if (2 = 2)
       05:B0DA  A8                 tay
       05:B0DB  A5 02              lda    <__arg_idx
                                   add    #3
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       05:B0DD  18                 clc
       05:B0DE  69 03              adc    #3
                                  .endif
       05:B0E0  85 02              sta    <__arg_idx
       05:B0E2  42                 say
                                  .else
                                  .endif
                          
       05:B0E3  99 FC 31           sta    __arg-(3),Y
       05:B0E6  8A                 txa
       05:B0E7  99 FD 31           sta    __arg-(3-1),Y
 1336                             __ldwi  18
       05:B0EA  A2 12              ldx    #low(18)
       05:B0EC  A9 00              lda    #high(18)
 1337                             __phb   1
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       05:B0EE  A4 02              ldy    <__arg_idx
                                  .endif
                          
       05:B0F0  8A                 txa
       05:B0F1  99 FE 31           sta    __arg-(1),Y
 1338                             __ldwi  15
       05:B0F4  A2 0F              ldx    #low(15)
       05:B0F6  A9 00              lda    #high(15)
 1339  05:B0F8  20 ED CE            call  _put_string.3
 1340                             __ldw   _avg
                0000              .if (1 = 2)
                                  .else
       05:B0FB  AE FA 31           ldx    _avg
       05:B0FE  AD FB 31           lda    _avg+1
                                  .endif
 1341                             __phw   4,4
                                   ; #1 (bytes :  9, cycles : 16)
                                   ; #2 (bytes : 16, cycles : 28)
                          
                0001              .if (2 = 2)
       05:B101  A8                 tay
       05:B102  A5 02              lda    <__arg_idx
                                   add    #4
                0000              .if (1 = 2)            ; register A (handle carry
                                  .else
       05:B104  18                 clc
       05:B105  69 04              adc    #4
                                  .endif
       05:B107  85 02              sta    <__arg_idx
       05:B109  42                 say
                                  .else
                                  .endif
                          
       05:B10A  99 FB 31           sta    __arg-(4),Y
       05:B10D  8A                 txa
       05:B10E  99 FC 31           sta    __arg-(4-1),Y
 1342                             __ldwi  5
       05:B111  A2 05              ldx    #low(5)
       05:B113  A9 00              lda    #high(5)
 1343                             __phb   2
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       05:B115  A4 02              ldy    <__arg_idx
                                  .endif
                          
       05:B117  8A                 txa
       05:B118  99 FD 31           sta    __arg-(2),Y
 1344                             __ldwi  23
       05:B11B  A2 17              ldx    #low(23)
       05:B11D  A9 00              lda    #high(23)
 1345                             __phb   1
                                   ; #1 (bytes :  6, cycles : 11)
                                   ; #2 (bytes : 12, cycles : 21)
                          
                0000              .if (1 = 2)
                                  .else
       05:B11F  A4 02              ldy    <__arg_idx
                                  .endif
                          
       05:B121  8A                 txa
       05:B122  99 FE 31           sta    __arg-(1),Y
 1346                             __ldwi  15
       05:B125  A2 0F              ldx    #low(15)
       05:B127  A9 00              lda    #high(15)
 1347  05:B129  20 79 CE            call  _put_number.4
 1348  05:B12C            LL63:
 1349                     
 1350  05:B12C            LL62:
 1351                     
 1352  05:B12C            LL60:
 1353                     
 1354                             __ldb   _pad
                0000              .if (1 = 2)
                                  .else
       05:B12C  AE D1 31           ldx    _pad
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_02026
                          ;        dec    A
                          ;.x_02026:
       05:B12F  62                 cla    ; unsigned
                                  .endif
 1355                             __andwi 1
       05:B130  22                 sax
       05:B131  29 01              and    #low(1)
       05:B133  22                 sax
       05:B134  29 00              and    #high(1)
 1356                             __tstw
                                   ; pha
       05:B136  86 03              stx    <__temp
       05:B138  05 03              ora    <__temp
                                   ; pla
 1357                             __lbeq  LL73
       05:B13A  D0 03              bne    .x02029
       05:B13C  4C 84 B1           jmp    LL73
       05:B13F            .x02029
 1358                             __ldb   _adjust
                0000              .if (1 = 2)
                                  .else
       05:B13F  AE E1 31           ldx    _adjust
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_02031
                          ;        dec    A
                          ;.x_02031:
       05:B142  62                 cla    ; unsigned
                                  .endif
 1359                             __stw   <__temp
       05:B143  86 03              stx    <__temp
       05:B145  85 04              sta    <__temp+1
 1360                             __ldwi  2
       05:B147  A2 02              ldx    #low(2)
       05:B149  A9 00              lda    #high(2)
 1361  05:B14B  20 58 C8            jsr   eqzp
 1362                             __lbeq  LL74
       05:B14E  D0 03              bne    .x02034
       05:B150  4C 63 B1           jmp    LL74
       05:B153            .x02034
 1363                             __ldwi  1
       05:B153  A2 01              ldx    #low(1)
       05:B155  A9 00              lda    #high(1)
 1364  05:B157  8E E1 31            stx   _adjust
 1365  05:B15A  20 5A 80            call  _clear_index
 1366  05:B15D  20 36 80            call  _put_index
 1367                             __lbra  LL75
       05:B160  4C 84 B1           jmp    LL75
 1368  05:B163            LL74:
 1369                     
 1370                             __ldb   _adjust
                0000              .if (1 = 2)
                                  .else
       05:B163  AE E1 31           ldx    _adjust
                                 __extw
                          ;        txa    ; signed
                          ;        cla
                          ;        bpl    .x_02038
                          ;        dec    A
                          ;.x_02038:
       05:B166  62                 cla    ; unsigned
                                  .endif
 1371                             __stw   <__temp
       05:B167  86 03              stx    <__temp
       05:B169  85 04              sta    <__temp+1
 1372                             __ldwi  1
       05:B16B  A2 01              ldx    #low(1)
       05:B16D  A9 00              lda    #high(1)
 1373  05:B16F  20 58 C8            jsr   eqzp
 1374                             __lbeq  LL76
       05:B172  D0 03              bne    .x02041
       05:B174  4C 84 B1           jmp    LL76
       05:B177            .x02041
 1375                             __ldwi  0
       05:B177  A2 00              ldx    #low(0)
       05:B179  A9 00              lda    #high(0)
 1376  05:B17B  8E E1 31            stx   _adjust
 1377  05:B17E  20 5A 80            call  _clear_index
 1378  05:B181  20 36 80            call  _put_index
 1379  05:B184            LL76:
 1380                     
 1381  05:B184            LL75:
 1382                     
 1383  05:B184            LL73:
 1384                     
 1385  05:B184            LL46:
 1386                     
 1387  05:B184            LL45:
 1388                     
 1389                             __ldwi  0
       05:B184  A2 00              ldx    #low(0)
       05:B186  A9 00              lda    #high(0)
 1390  05:B188  A0 01               ldy   #1
 1391  05:B18A  20 2F CF            call  _vsync
 1392                             __lbra  LL38
       05:B18D  4C EA A2           jmp    LL38
 1393  05:B190            LL39:
 1394                     
 1395                             __lbra  LL33
       05:B190  4C 93 B1           jmp    LL33
 1396  05:B193            LL33:
 1397                     
 1398  05:B193  60                  rts
 1399                             .endp
 1400                     
 1401           60C8              .data
 1402           0002              .bank CONST_BANK
 1403           4000              .org $4000
 1404  02:4000            LL0:
 1405  02:4000  20 20 20          .db     32,32,32,32,32,32,0,32
       02:4003  20 20 20  
       02:4006  00 20     
 1406  02:4008  20 20 20          .db     32,32,32,32,32,0,32,32
       02:400B  20 20 00  
       02:400E  20 20     
 1407  02:4010  20 00 20          .db     32,0,32,32,32,0,70,79
       02:4013  20 20 00  
       02:4016  46 4F     
 1408  02:4018  52 57 41          .db     82,87,65,82,68,32,0,66
       02:401B  52 44 20  
       02:401E  00 42     
 1409  02:4020  41 43 4B          .db     65,67,75,87,65,82,68,0
       02:4023  57 41 52  
       02:4026  44 00     
 1410  02:4028  3E 3E 3E          .db     62,62,62,0,60,60,60,0
       02:402B  00 3C 3C  
       02:402E  3C 00     
 1411  02:4030  20 20 20          .db     32,32,32,32,32,32,0,94
       02:4033  20 20 20  
       02:4036  00 5E     
 1412  02:4038  00 20 20          .db     0,32,32,32,32,32,32,0
       02:403B  20 20 20  
       02:403E  20 00     
 1413  02:4040  5E 00 48          .db     94,0,72,101,97,100,32,83
       02:4043  65 61 64  
       02:4046  20 53     
 1414  02:4048  65 65 6B          .db     101,101,107,32,84,101,115,116
       02:404B  20 54 65  
       02:404E  73 74     
 1415  02:4050  00 20 20          .db     0,32,32,32,32,32,32,32
       02:4053  20 20 20  
       02:4056  20 20     
 1416  02:4058  44 69 72          .db     68,105,114,58,32,0,83,116
       02:405B  3A 20 00  
       02:405E  53 74     
 1417  02:4060  61 72 74          .db     97,114,116,32,32,76,66,65
       02:4063  20 20 4C  
       02:4066  42 41     
 1418  02:4068  3A 20 00          .db     58,32,0,79,102,102,115,101
       02:406B  4F 66 66  
       02:406E  73 65     
 1419  02:4070  74 20 4C          .db     116,32,76,66,65,58,32,0
       02:4073  42 41 3A  
       02:4076  20 00     
 1420  02:4078  54 61 72          .db     84,97,114,103,101,116,32,76
       02:407B  67 65 74  
       02:407E  20 4C     
 1421  02:4080  42 41 3A          .db     66,65,58,32,0,67,104,97
       02:4083  20 00 43  
       02:4086  68 61     
 1422  02:4088  6E 67 65          .db     110,103,101,32,86,97,108,117
       02:408B  20 56 61  
       02:408E  6C 75     
 1423  02:4090  65 73 3A          .db     101,115,58,32,100,105,114,101
       02:4093  20 64 69  
       02:4096  72 65     
 1424  02:4098  63 74 69          .db     99,116,105,111,110,32,112,97
       02:409B  6F 6E 20  
       02:409E  70 61     
 1425  02:40A0  64 00 42          .db     100,0,66,117,116,116,111,110
       02:40A3  75 74 74  
       02:40A6  6F 6E     
 1426  02:40A8  20 49 49          .db     32,73,73,32,61,32,102,119
       02:40AB  20 3D 20  
       02:40AE  66 77     
 1427  02:40B0  64 3B 20          .db     100,59,32,73,32,61,32,98
       02:40B3  49 20 3D  
       02:40B6  20 62     
 1428  02:40B8  61 63 6B          .db     97,99,107,0,32,32,32,32
       02:40BB  00 20 20  
       02:40BE  20 20     
 1429  02:40C0  20 00 20          .db     32,0,32,32,32,32,32,32
       02:40C3  20 20 20  
       02:40C6  20 20     
 1430  02:40C8  20 20 20          .db     32,32,32,32,0,32,32,32
       02:40CB  20 00 20  
       02:40CE  20 20     
 1431  02:40D0  20 20 20          .db     32,32,32,32,32,32,32,0
       02:40D3  20 20 20  
       02:40D6  20 00     
 1432  02:40D8  4D 6F 76          .db     77,111,118,101,32,116,111,32
       02:40DB  65 20 74  
       02:40DE  6F 20     
 1433  02:40E0  69 6E 69          .db     105,110,105,116,105,97,108,32
       02:40E3  74 69 61  
       02:40E6  6C 20     
 1434  02:40E8  70 6F 73          .db     112,111,115,105,116,105,111,110
       02:40EB  69 74 69  
       02:40EE  6F 6E     
 1435  02:40F0  00 52 61          .db     0,82,97,110,100,111,109,32
       02:40F3  6E 64 6F  
       02:40F6  6D 20     
 1436  02:40F8  64 65 6C          .db     100,101,108,97,121,32,32,32
       02:40FB  61 79 20  
       02:40FE  20 20     
 1437  02:4100  20 20 20          .db     32,32,32,32,32,32,32,32
       02:4103  20 20 20  
       02:4106  20 20     
 1438  02:4108  20 00 53          .db     32,0,83,101,101,107,105,110
       02:410B  65 65 6B  
       02:410E  69 6E     
 1439  02:4110  67 2E 2E          .db     103,46,46,46,32,32,32,32
       02:4113  2E 20 20  
       02:4116  20 20     
 1440  02:4118  20 20 20          .db     32,32,32,32,32,32,32,32
       02:411B  20 20 20  
       02:411E  20 20     
 1441  02:4120  20 20 00          .db     32,32,0,32,32,32,32,32
       02:4123  20 20 20  
       02:4126  20 20     
 1442  02:4128  20 20 20          .db     32,32,32,32,32,32,32,32
       02:412B  20 20 20  
       02:412E  20 20     
 1443  02:4130  20 20 20          .db     32,32,32,32,32,32,32,32
       02:4133  20 20 20  
       02:4136  20 20     
 1444  02:4138  20 20 20          .db     32,32,32,0,77,105,110,58
       02:413B  00 4D 69  
       02:413E  6E 3A     
 1445  02:4140  20 00 41          .db     32,0,65,118,103,58,32,0
       02:4143  76 67 3A  
       02:4146  20 00     
 1446  02:4148            _add_num:
 1447  02:4148  10                .db     0x10
 1448  02:4149  00                .db     0x00
 1449  02:414A  00                .db     0x00
 1450  02:414B  01                .db     0x01
 1451  02:414C  00                .db     0x00
 1452  02:414D  00                .db     0x00
 1453  02:414E  00                .db     0x00
 1454  02:414F  10                .db     0x10
 1455  02:4150  00                .db     0x00
 1456  02:4151  00                .db     0x00
 1457  02:4152  01                .db     0x01
 1458  02:4153  00                .db     0x00
 1459  02:4154  00                .db     0x00
 1460  02:4155  00                .db     0x00
 1461  02:4156  10                .db     0x10
 1462  02:4157  00                .db     0x00
 1463  02:4158  00                .db     0x00
 1464  02:4159  01                .db     0x01
 1465                     
 1466           29CE              .bss
 1467  --:29CE            _rec_h:         .ds     1
 1468  --:29CF            _rec_m:         .ds     1
 1469  --:29D0            _rec_l:         .ds     1
 1470  --:29D1            _target_data:           .ds     2048
 1471  --:31D1            _pad:           .ds     1
 1472  --:31D2            _padhold:               .ds     1
 1473  --:31D3            _hex1:          .ds     1
 1474  --:31D4            _hex2:          .ds     1
 1475  --:31D5            _start_pos:             .ds     3
 1476  --:31D8            _offset:                .ds     3
 1477  --:31DB            _target:                .ds     3
 1478  --:31DE            _result:                .ds     3
 1479  --:31E1            _adjust:                .ds     1
 1480  --:31E2            _edit_pos:              .ds     1
 1481  --:31E3            _direction:             .ds     1
 1482  --:31E4            _timing:                .ds     20
 1483  --:31F8            _min:           .ds     2
 1484  --:31FA            _avg:           .ds     2
 1485  --:31FC            _tot:           .ds     2
 1486  --:31FE            _i:             .ds     1
 1487  --:31FF            __arg:
 1488                     
 1489                     ;0 error(s) in compilation
 1490                     ;       literal pool:328
 1491                     ;       constant pool:18
 1492                     ;       global pool:1568
 1493                     ;       Macro pool:1416
