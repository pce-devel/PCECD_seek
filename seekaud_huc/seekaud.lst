#[1]   seekaud.s
    5                     
    6           0000      .ifdef _SGX
    8                     .endif
    9           0000      .ifdef _AC
   11                     .endif
   12                     
   13                     ; first, set MOUSE to default on:
   14                     ;
   15           0001      SUPPORT_MOUSE	.equ	1
   16                     
   18                     
   19           0001      .ifdef HUC
#[3]   huc.inc
   20                     .include "huc.inc"
    1                     ;
    2                     ; Hu-C internal include file
    3                     ;
    4                     
    5                     
    6                     ; variables
    7                     ; ----
    8                     
    9           2000      	.zp
   10  --:2000            __sp
   11  --:2000            __stack	.ds 2
   12  --:2002            __temp	.ds 4
   13  --:2006            __ptr	.ds 2
   14  --:2008            __fbank	.ds 1
   15  --:2009            __fptr	.ds 2
   16           0000      .ifdef HAVE_LIB3
   18                     .endif
   19                     
   20                     ; macros
   21                     ; ----
   22                     
   23                     	.macro	__farptr
   24                     	ldy	#bank(\1)
   25                     	sty	\2
   26                     	ldy	#low(\1)
   27                     	sty	\3
   28                     	ldy	#high(\1) & $1F
   29                     	sty	\3+1
   30                     .endm
   31                     
   32                     	.macro	__farptr_i
   33                     	sax
   34                     	add	#low(\1)
   35                     .if (\# = 3)
   36                     	sta	<\3
   37                     .else
   38                     	sta	<__fptr
   39                     .endif
   40                     	sax
   41                     	adc	#high(\1) & $1F
   42                     .if (\# = 3)
   43                     	sta	<\3+1
   44                     .else
   45                     	tax
   46                     .endif
   47                     	rol	A
   48                     	rol	A
   49                     	rol	A
   50                     	rol	A
   51                     	and	#$F
   52                     	add	#bank(\1)
   53                     .if (\# = 3)
   54                     	sta	<\2
   55                     .endif
   56                     .endm
   57                     
   58                     	.macro	__farptr_get
   59                     	stx	<\1
   60                     	ldy	#2
   61                     	lda	[__ptr],Y
   62                     	sta	<\2
   63                     	iny
   64                     	lda	[__ptr],Y
   65                     	sta	<\2+1
   66                     .endm
   67                     
   68                     	.macro	__fgetb
   69                     	tam	#3
   70                     	txa
   71                     	and	#$1F
   72                     	ora	#$60
   73                     	sta	<__fptr+1
   74                     	lda	[__fptr]
   75                     	tax
   76                     	bpl	.x_\@
   77                     	dec	A
   78                     .x_\@:
   79                     .endm
   80                     
   81                     	.macro	__fgetub
   82                     	tam	#3
   83                     	txa
   84                     	and	#$1F
   85                     	ora	#$60
   86                     	sta	<__fptr+1
   87                     	lda	[__fptr]
   88                     	tax
   89                     	cla
   90                     .endm
   91                     
   92                     __phax	.macro
   93                     	pha
   94                     	phx
   95                     .endm
   96                     __plax	.macro
   97                     	plx
   98                     	pla
   99                     .endm
  100                     __plxa	.macro
  101                     	pla
  102                     	plx
  103                     .endm
  104                     
  105                     __ldb	.macro
  106                     .if (\# = 2)
  107                     	clx
  108                     	lda	\1
  109                     	clc
  110                     	adc	#low(\2)
  111                     	sax
  112                     	adc	#high(\2)
  113                     .else
  114                     	ldx	\1
  115                     	__extw
  116                     .endif
  117                     .endm
  118                     
  119                     __ldby:	.macro
  120                     	ldx	\1, y
  121                     	__extw
  122                     .endm
  123                     
  124                     __ldub	.macro
  125                     .if (\# = 2)
  126                     	clx
  127                     	lda	\1
  128                     	clc
  129                     	adc	#low(\2)
  130                     	sax
  131                     .else
  132                     	ldx	\1
  133                     	cla
  134                     .endif
  135                     .endm
  136                     
  137                     __ldbp	.macro
  138                     	lda	[\1]
  139                     	tax
  140                     	__extw
  141                     .endm
  142                     
  143                     __ldubp	.macro
  144                     	lda	[\1]
  145                     	tax
  146                     	cla
  147                     .endm
  148                     
  149                     __stbps	.macro
  150                     	__phax
  151                     	__ldwp	__stack
  152                     	__stw	<__ptr
  153                     	__plxa
  154                     	sta	[__ptr]
  155                     	sax
  156                     	__addmi	2,__stack
  157                     .endm
  158                     
  159                     __ldw	.macro
  160                     .if (\# = 2)
  161                     	lda	\1
  162                     	clc
  163                     	adc	#low(\2)
  164                     	tax
  165                     	lda	\1+1
  166                     	adc	#high(\2)
  167                     .else
  168                     	ldx	\1
  169                     	lda	\1+1
  170                     .endif
  171                     .endm
  172                     
  173                     __ldwp	.macro
  174                     	lda	[\1]
  175                     	tax
  176                     	ldy	#1
  177                     	lda	[\1],Y
  178                     .endm
  179                     
  180                     __ldwi	.macro
  181                     	ldx	#low(\1)
  182                     	lda	#high(\1)
  183                     .endm
  184                     
  185                     __stw	.macro
  186                     	stx	\1
  187                     	sta	\1+1
  188                     .endm
  189                     
  190                     __stwi	.macro
  191                     	ldx	#low(\2)
  192                     	stx	\1
  193                     	lda	#high(\2)
  194                     	sta	\1 + 1
  195                     .endm
  196                     
  197                     __stbi	.macro
  198                     	ldx	#low(\2)
  199                     	stx	\1
  200                     	cla
  201                     .endm
  202                     
  203                     __stwz	.macro
  204                     	stz	\1
  205                     	stz	\1 + 1
  206                     .endm
  207                     
  208                     __stwp	.macro
  209                     	sax
  210                     	sta	[\1]
  211                     	sax
  212                     	ldy	#1
  213                     	sta	[\1],Y
  214                     .endm
  215                     
  216                     __stbp	.macro
  217                     	sax
  218                     	sta	[\1]
  219                     	sax
  220                     .endm
  221                     
  222                     __stwps	.macro
  223                     	__phax
  224                     	__ldwp	__stack
  225                     	__stw	<__ptr
  226                     	__plax
  227                     	__stwp	__ptr
  228                     	__addmi	2,__stack
  229                     .endm
  230                     
  231                     __stwip	.macro
  232                     	__stw	__ptr
  233                     	lda	#low(\1)
  234                     	tax
  235                     	sta	[__ptr]
  236                     	lda	#high(\1)
  237                     	ldy	#1
  238                     	sta	[__ptr],Y
  239                     .endm
  240                     
  241                     __stbip	.macro
  242                     	__stw	__ptr
  243                     	lda	#low(\1)
  244                     	sta	[__ptr]
  245                     	tax
  246                     	cla
  247                     .endm
  248                     
  249                     __pushw	.macro
  250                     .ifndef SMALL
  251                     	ldy	<__stack
  252                     	bne	.x_\@
  253                     	dec	<__stack + 1
  254                     .endif
  255                     .x_\@:	dec	<__stack
  256                     	sta	[__stack]
  257                     .ifndef SMALL
  258                     	bne	.y_\@
  259                     	dec	<__stack + 1
  260                     .endif
  261                     .y_\@:	dec	<__stack
  262                     	sax
  263                     	sta	[__stack]
  264                     	sax
  265                     .endm
  266                     
  267                     __popw	.macro
  268                     	lda	[__stack]
  269                     	tax
  270                     	ldy	#1
  271                     	lda	[__stack],Y
  272                     	__addmi	2,__stack
  273                     .endm
  274                     
  275                     __calls	.macro
  276                     	pha
  277                     	ldy	#\1
  278                     	lda	[__stack],Y
  279                     	sta	<__ptr
  280                     .ifndef SMALL
  281                     	incw	<__stack
  282                     .else
  283                     	inc	<__stack
  284                     .endif
  285                     	lda	[__stack],Y
  286                     	sta	<__ptr+1
  287                     .ifndef SMALL
  288                     	incw	<__stack
  289                     .else
  290                     	inc	<__stack
  291                     .endif
  292                     	pla
  293                     	jsr	hook
  294                     .endm
  295                     
  296                     __swapw	.macro
  297                     	pha
  298                     	ldy	#1
  299                     	lda	[__stack],Y
  300                     	sta	<__temp
  301                     	lda	[__stack]
  302                     	sax
  303                     	sta	[__stack]
  304                     	pla
  305                     	sta	[__stack],Y
  306                     	lda	<__temp
  307                     .endm
  308                     
  309                     
  310                     ; TODO : check if we need pha/pla or not
  311                     __tstw	.macro
  312                     	; pha
  313                     	stx	<__temp
  314                     	ora	<__temp
  315                     	cla
  316                     	clx
  317                     	beq	.x_\@
  318                     	inx
  319                     .x_\@:
  320                     	; pla
  321                     .endm
  322                     
  323                     __lsrw	.macro
  324                     	lsr	A
  325                     	sax
  326                     	ror	A
  327                     	sax
  328                     .endm
  329                     
  330                     __aslw	.macro
  331                     	sax
  332                     	asl	A
  333                     	sax
  334                     	rol	A
  335                     .endm
  336                     
  337                     __aslwi	.macro
  338                     .if (\1 = 1)
  339                     	__aslw
  340                     .else
  341                     .if (\1 = 2)
  342                     	__aslw
  343                     	__aslw
  344                     .else
  345                     .if (\1 = 8)
  346                     	txa
  347                     	clx
  348                     .else
  349                     	ldy	#\1
  350                     	jsr	aslzp
  351                     .endif
  352                     .endif
  353                     .endif
  354                     .endm
  355                     
  356                     __aslws	.macro
  357                     	lda	[__stack]
  358                     	asl	a
  359                     	sta	[__stack]
  360                     	ldy	#1
  361                     	lda	[__stack],Y
  362                     	rol	a
  363                     	sta	[__stack],Y
  364                     .endm
  365                     
  366                     __asrw	.macro
  367                     	cmp	#$80
  368                     	ror	A
  369                     	sax
  370                     	ror	A
  371                     	sax
  372                     .endm
  373                     
  374                     __asrwi	.macro
  375                     .if (\1 = 1)
  376                     	__asrw
  377                     .else
  378                     .if (\1 = 2)
  379                     	__asrw
  380                     	__asrw
  381                     .else
  382                     .if (\1 = 8)
  383                     	tax
  384                     	cmp	#$80
  385                     	cla
  386                     	bcc	.x_\@
  387                     	dec a
  388                     .x_\@:
  389                     .else
  390                     	ldy	#\1
  391                     	jsr	asrzp
  392                     .endif
  393                     .endif
  394                     .endif
  395                     .endm
  396                     
  397                     __lsrwi	.macro
  398                     .if (\1 = 1)
  399                     	__lsrw
  400                     .else
  401                     .if (\1 = 2)
  402                     	__lsrw
  403                     	__lsrw
  404                     .else
  405                     .if (\1 = 8)
  406                     	tax
  407                     	cla
  408                     .else
  409                     	ldy	#\1
  410                     	jsr	lsrzp
  411                     .endif
  412                     .endif
  413                     .endif
  414                     .endm
  415                     
  416                     __extw	.macro
  417                     	txa	; signed
  418                     	cla
  419                     	bpl	.x_\@
  420                     	dec	A
  421                     .x_\@:
  422                     .endm
  423                     
  424                     __comw	.macro
  425                     	sax
  426                     	eor	#$FF
  427                     	sax
  428                     	eor	#$FF
  429                     .endm
  430                     
  431                     __negw	.macro
  432                     	sax
  433                     	eor	#$FF
  434                     	clc
  435                     	adc	#1
  436                     	sax
  437                     	eor	#$FF
  438                     	adc	#0
  439                     .endm
  440                     
  441                     __boolw	.macro
  442                     	stx	<__temp
  443                     	ora	<__temp
  444                     	clx
  445                     	beq	.x\@
  446                     	inx
  447                     .x\@	cla
  448                     .endm
  449                     
  450                     __notw	.macro
  451                     	stx	<__temp
  452                     	ora	<__temp
  453                     	clx
  454                     	bne	.x\@
  455                     	inx
  456                     .x\@	cla
  457                     .endm
  458                     
  459                     __addw	.macro
  460                     	clc
  461                     	sax
  462                     	adc	\1
  463                     	sax
  464                     	adc	\1+1
  465                     .endm
  466                     
  467                     __addb	.macro
  468                     	clc
  469                     	sax
  470                     	adc	\1
  471                     	sax
  472                     	ldy	\1
  473                     	bpl	.x\@
  474                     	dec a
  475                     .x\@:	adc	#0
  476                     .endm
  477                     
  478                     __addub	.macro
  479                     	clc
  480                     	sax
  481                     	adc	\1
  482                     	sax
  483                     	adc	#0
  484                     .endm
  485                     
  486                     __addwi	.macro
  487                     .if (\1 = 1)
  488                     	cpx	#$ff
  489                     	inx
  490                     	adc	#0
  491                     .else
  492                     .if (\1 = 2)
  493                     	cpx	#$fe
  494                     	inx
  495                     	inx
  496                     	adc	#0
  497                     .else
  498                     	clc
  499                     	sax
  500                     	adc	#low(\1)
  501                     	sax
  502                     	adc	#high(\1)
  503                     .endif
  504                     .endif
  505                     .endm
  506                     
  507                     ; pceas workaround; the regular __addwi doesn't work if the argument is
  508                     ; symbolic because the code size changes as it is resolved.
  509                     __addwi_sym	.macro
  510                     	clc
  511                     	sax
  512                     	adc	#low(\1)
  513                     	sax
  514                     	adc	#high(\1)
  515                     .endm
  516                     
  517                     __mulwi	.macro
  518                     .if (\1 = 2)
  519                     	__aslw
  520                     .else
  521                     .if (\1 = 3)
  522                     	__stw	<__temp
  523                     	__aslw
  524                     	__addw	<__temp
  525                     .else
  526                     .if (\1 = 4)
  527                     	__aslw
  528                     	__aslw
  529                     .else
  530                     .if (\1 = 5)
  531                     	__stw	<__temp
  532                     	__aslw
  533                     	__aslw
  534                     	__addw	<__temp
  535                     .else
  536                     .if (\1 = 6)
  537                     	__aslw
  538                     	__stw	<__temp
  539                     	__aslw
  540                     	__addw	<__temp
  541                     .else
  542                     .if (\1 = 7)
  543                     	__stw	<__temp
  544                     	__aslw
  545                     	__aslw
  546                     	__aslw
  547                     	__subw	<__temp
  548                     .else
  549                     .if (\1 = 8)
  550                     	__aslw
  551                     	__aslw
  552                     	__aslw
  553                     .else
  554                     .if (\1 = 9)
  555                     	__stw	<__temp
  556                     	__aslw
  557                     	__aslw
  558                     	__aslw
  559                     	__addw	<__temp
  560                     .else
  561                     .if (\1 = 10)
  562                     	__aslw
  563                     	__stw	<__temp
  564                     	__aslw
  565                     	__aslw
  566                     	__addw	<__temp
  567                     .else
  568                     	__pushw
  569                     	__ldwi	\1
  570                     	jsr	umul
  571                     .endif
  572                     .endif
  573                     .endif
  574                     .endif
  575                     .endif
  576                     .endif
  577                     .endif
  578                     .endif
  579                     .endif
  580                     .endm
  581                     
  582                     __addbi	.macro
  583                     .if (\1 = 1)
  584                     	inx
  585                     .else
  586                     .if (\1 = 2)
  587                     	inx
  588                     	inx
  589                     .else
  590                     .if (\1 = 3)
  591                     	inx
  592                     	inx
  593                     	inx
  594                     .else
  595                     	clc
  596                     	txa
  597                     	adc	#low(\1)
  598                     	tax
  599                     .endif
  600                     .endif
  601                     .endif
  602                     	cla
  603                     .endm
  604                     
  605           0000      .ifdef SMALL
  642                     .else ; SMALL
  643                     
  644                     __addmi1	.macro		; 10(14)
  645                     	inc	<\1		; 6
  646                     	bne	.x\@		; 4(2)
  647                     	inc	<\1+1		; 0(6)
  648                     .x\@:
  649                     .endm
  650                     
  651                     __submi1	.macro		; 14(18)
  652                     	ldy	<\1		; 4
  653                     	bne	.x\@		; 4(2)
  654                     	dec	<\1+1		; 0(6)
  655                     .x\@:
  656                     	dec	<\1		; 6
  657                     .endm
  658                     
  659                     __addmi	.macro
  660                     .if (\1 = 1)
  661                     	__addmi1	\2
  662                     .else
  663                     .if (\1 = -1)
  664                     	__submi1	\2
  665                     .else
  666                     	tay			; 2
  667                     	clc			; 2
  668                     	lda	<\2		; 4
  669                     	adc	#low(\1)	; 2
  670                     	sta	<\2		; 4
  671                     .if (\1 < 256) & (\1 >= 0)
  672                     	bcc	.x\@		; 4(2)
  673                     	inc	<\2+1		; 0(6)
  674                     .x\@:
  675                     .else
  676                     .if (\1 >= -256) & (\1 < 0)
  677                     	bcs	.y\@		; 4(2)
  678                     	dec	<\2+1		; 0(6)
  679                     .y\@:
  680                     .else
  681                     	lda	<\2+1		; 4
  682                     	adc	#high(\1)	; 2
  683                     	sta	<\2+1		; 4
  684                     .endif
  685                     .endif
  686                     	tya			; 2 => 20(24) / 26
  687                     .endif
  688                     .endif
  689                     .endm
  690                     
  691                     __addmi_sym	.macro
  692                     	tay			; 2
  693                     	clc			; 2
  694                     	lda	<\2		; 4
  695                     	adc	#low(\1)	; 2
  696                     	sta	<\2		; 4
  697                     	lda	<\2+1		; 4
  698                     	adc	#high(\1)	; 2
  699                     	sta	<\2+1		; 4
  700                     	tya			; 2 => 20(24) / 26
  701                     .endm
  702                     
  703                     .endif ; SMALL
  704                     
  705                     __subw	.macro
  706                     	sec
  707                     	sax
  708                     	sbc	\1
  709                     	sax
  710                     	sbc	\1+1
  711                     .endm
  712                     
  713                     __subwi	.macro
  714                     .if (\1 = 1)
  715                     	cpx	#1
  716                     	dex
  717                     	sbc	#0
  718                     .else
  719                     .if (\1 = 2)
  720                     	cpx	#2
  721                     	dex
  722                     	dex
  723                     	sbc	#0
  724                     .else
  725                     	sec
  726                     	sax
  727                     	sbc	#low(\1)
  728                     	sax
  729                     	sbc	#high(\1)
  730                     .endif
  731                     .endif
  732                     .endm
  733                     
  734                     __submi	.macro
  735                     	pha
  736                     	sec
  737                     	lda	<\2
  738                     	sbc	#low(\1)
  739                     	sta	<\2
  740                     	lda	<\2+1
  741                     	sbc	#high(\1)
  742                     	sta	<\2+1
  743                     	pla
  744                     .endm
  745                     
  746                     __addws	.macro
  747                     	sax
  748                     	clc
  749                     	adc	[__stack]
  750                     	sax
  751                     	ldy	#1
  752                     	adc	[__stack],Y
  753                     	__addmi	2, __stack
  754                     .endm
  755                     
  756                     __addbs	.macro
  757                     	txa
  758                     	clc
  759                     	adc	[__stack]
  760                     	tax
  761                     	cla
  762                     	__addmi	2, __stack
  763                     .endm
  764                     
  765                     __subws	.macro
  766                     	stx	<__temp
  767                     	sta	<__temp+1
  768                     	sec
  769                     	lda	[__stack]
  770                     	sbc	<__temp
  771                     	tax
  772                     	ldy	#1
  773                     	lda	[__stack],Y
  774                     	sbc	<__temp+1
  775                     	__addmi	2, __stack
  776                     .endm
  777                     
  778                     __orws	.macro
  779                     	sax
  780                     	ora	[__stack]
  781                     	sax
  782                     	ldy	#1
  783                     	ora	[__stack],Y
  784                     	__addmi	2,__stack
  785                     .endm
  786                     
  787                     __orwi	.macro
  788                     	sax
  789                     	ora	#low(\1)
  790                     	sax
  791                     	ora	#high(\1)
  792                     .endm
  793                     
  794                     __orw	.macro
  795                     	sax
  796                     	ora	\1
  797                     	sax
  798                     	ora	\1+1
  799                     .endm
  800                     
  801                     __andws	.macro
  802                     	sax
  803                     	and	[__stack]
  804                     	sax
  805                     	ldy	#1
  806                     	and	[__stack],Y
  807                     	__addmi	2,__stack
  808                     .endm
  809                     
  810                     __andwi	.macro
  811                     	sax
  812                     	and	#low(\1)
  813                     	sax
  814                     	and	#high(\1)
  815                     .endm
  816                     
  817                     __andw	.macro
  818                     	sax
  819                     	and	\1
  820                     	sax
  821                     	and	\1+1
  822                     .endm
  823                     
  824                     __eorwi	.macro
  825                     	sax
  826                     	eor	#low(\1)
  827                     	sax
  828                     	eor	#high(\1)
  829                     .endm
  830                     
  831                     __eorws	.macro
  832                     	sax
  833                     	eor	[__stack]
  834                     	sax
  835                     	ldy	#1
  836                     	eor	[__stack],Y
  837                     	__addmi	2,__stack
  838                     .endm
  839                     
  840                     __lbra	.macro
  841                     	jmp	\1
  842                     .endm
  843                     
  844                     __lbran	.macro
  845                     	bra	\1
  846                     .endm
  847                     
  848                     __lbeq	.macro
  849                     	cpx	#0
  850                     	bne	.x\@
  851                     	jmp	\1
  852                     .x\@
  853                     .endm
  854                     
  855                     __lbeqn	.macro
  856                     	cpx	#0
  857                     	beq	\1
  858                     .endm
  859                     
  860                     __lbne	.macro
  861                     	cpx	#0
  862                     	beq	.x\@
  863                     	jmp	\1
  864                     .x\@
  865                     .endm
  866                     
  867                     __lbnen	.macro
  868                     	cpx	#0
  869                     	bne	\1
  870                     .endm
  871                     
  872                     __cmpwi_eq	.macro
  873                     	cpx	#low(\1)
  874                     	clx
  875                     	bne	.f\@
  876                     	cmp	#high(\1)
  877                     	bne	.f\@
  878                     	ldx	#1
  879                     .f\@:	cla
  880                     .endm
  881                     
  882                     __cmpwi_ne	.macro
  883                     	cpx	#low(\1)
  884                     	clx
  885                     	bne	.t\@
  886                     	cmp	#high(\1)
  887                     	beq	.f\@
  888                     .t\@:	ldx	#1
  889                     .f\@:	cla
  890                     .endm
  891                     
  892                     __call	.macro
  893                     	call	\1
  894                     .endm
  895                     
  896                     _set_bgpal	.macro
  897                     	set_bgpal	\1,\2,\3
  898                     .endm
  899                     
  900                     _set_sprpal	.macro
  901                     	set_sprpal	\1,\2,\3
  902                     .endm
  903                     
  904                     _load_background	.macro
  905                     	vload		$1000,\1,#$4000
  906                     	vsync
  907                     	set_bgpal	#0, \2,#16
  908                     	batcpy		#$0, \3, \4, \5
  909                     .endm
  910                     
  911                     __map_callbank	.macro
  912                     .if (PAGE(\1) = 5)	; user function
  913                     	tay
  914                     	tma	#4
  915                     	pha
  916                     	lda	#_call_bank
  917                     	tam	#4
  918                     	tya
  919                     .endif
  920                     .endm
  921                     
  922                     __unmap_callbank	.macro
  923                     .if (PAGE(\1) = 5)	; user function
  924                     	tay
  925                     	pla
  926                     	tam	#4
  927                     	tya
  928                     .endif
  929                     .endm
#[2]   startup.asm
#[3]   huc_opt.inc
   21                     .include "huc_opt.inc"
    1                     ;
    2                     ; Hu-C internal include file
    3                     ;
    4                     
    5                     ; optimized macros
    6                     ; ----
    7                     
    8                     ; lea_s
    9                     ;
   10                     .macro __lea_s
   11                     	; (bytes : 10, cycles : 16)
   12                     	lda	<__sp
   13                     	clc
   14                     	adc	#LOW(\1)
   15                     	tax
   16                     .ifndef SMALL
   17                     	lda	<__sp+1
   18                     	adc	#HIGH(\1)
   19                     .else
   20                     	lda	#$3f
   21                     .endif
   22                     .endm
   23                     
   24                     ; pea_s
   25                     ;
   26                     .macro __pea_s
   27                     	; (bytes : 25, cycles : 44)
   28                     .ifndef SMALL
   29                     	lda	<__sp
   30                     	sec
   31                     	sbc	#2
   32                     	bcs	.x_\@
   33                     	dec	<__sp+1
   34                     .x_\@:	 sta	<__sp
   35                     	clc
   36                     	adc	#LOW(\1+2)
   37                     	sta	[__sp]
   38                     	tax
   39                     	lda	<__sp+1
   40                     	adc	#HIGH(\1+2)
   41                     	ldy	#1
   42                     	sta	[__sp],Y
   43                     .else
   44                     	lda	<__sp
   45                     	dec	a
   46                     	dec	a
   47                     	sta	<__sp
   48                     	clc
   49                     	adc	#LOW(\1+2)
   50                     	sta	[__sp]
   51                     	tax
   52                     	lda	#$3f
   53                     	ldy	#1
   54                     	sta	[__sp],Y
   55                     .endif
   56                     .endm
   57                     
   58                     ; ldb_s
   59                     ;
   60                     .macro __ldb_s
   61                     .if (\1 < 256)
   62                     	; short index (bytes :  9, cycles : 13/17)
   63                     	ldy	#\1
   64                     	lda	[__sp],Y
   65                     	tax
   66                     	cla
   67                     	bpl	.x_\@	; signed
   68                     	dec	A
   69                     .x_\@:
   70                     .else
   71                     	; long index  (bytes : 20, cycles : 37/41)
   72                     	addw	#\1,<__sp,<__ptr	; 13,26
   73                     	lda	[__ptr]
   74                     	tax
   75                     	cla
   76                     	bpl	.x_\@	; signed
   77                     	dec	A
   78                     .x_\@:
   79                     .endif
   80                     .endm
   81                     
   82                     ; addb_s
   83                     ;
   84                     .macro __addb_s
   85                     	; short index (bytes :  9, cycles : 13/17)
   86                     	stx	<__temp
   87                     	sta	<__temp+1
   88                     .if (\1 < 256)
   89                     	ldy	#\1
   90                     	lda	[__sp],Y
   91                     .else
   92                     	addw	#\1,<__sp,<__ptr	; 13,26
   93                     	lda	[__ptr]
   94                     .endif
   95                     	tax
   96                     	__extw
   97                     	sax
   98                     	clc
   99                     	adc	<__temp
  100                     	sax
  101                     	adc	<__temp+1
  102                     .endm
  103                     
  104                     ; ldub_s
  105                     ;
  106                     .macro __ldub_s
  107                     .if (\1 < 256)
  108                     	; short index (bytes :  9, cycles : 13/17)
  109                     	ldy	#\1
  110                     	lda	[__sp],Y
  111                     	tax
  112                     	cla
  113                     .else
  114                     	; long index  (bytes : 20, cycles : 37/41)
  115                     	addw	#\1,<__sp,<__ptr	; 13,26
  116                     	lda	[__ptr]
  117                     	tax
  118                     	cla
  119                     .endif
  120                     .endm
  121                     
  122                     ; addub_s
  123                     ;
  124                     .macro __addub_s
  125                     .if (\1 < 256)
  126                     	; short index (bytes :  9, cycles : 13/17)
  127                     	ldy	#\1
  128                     	sax
  129                     	clc
  130                     	adc	[__sp],Y
  131                     	sax
  132                     	adc	#0
  133                     .else
  134                     	; long index  (bytes : 20, cycles : 37/41)
  135                     	sta	<__temp
  136                     	addw	#\1,<__sp,<__ptr	; 13,26
  137                     	txa
  138                     	clc
  139                     	adc	[__ptr]
  140                     	tax
  141                     	lda	<__temp
  142                     	adc	#0
  143                     .endif
  144                     .endm
  145                     
  146                     ; ldb_p
  147                     ;
  148                     .macro __ldb_p
  149                     	; (bytes : 11, cycles : 19/23)
  150                     	stx	<__ptr
  151                     	sta	<__ptr+1
  152                     	lda	[__ptr]
  153                     	tax
  154                     	cla
  155                     	bpl	.x_\@	; signed
  156                     	dec	A
  157                     .x_\@:
  158                     .endm
  159                     
  160                     ; addbi_p
  161                     .macro __addbi_p
  162                     	stx	<__ptr
  163                     	sta	<__ptr+1
  164                     	lda	[__ptr]
  165                     	clc
  166                     	adc	#\1
  167                     	sta	[__ptr]
  168                     	tax
  169                     	cla
  170                     .endm
  171                     
  172                     ; ldub_p
  173                     ;
  174                     .macro __ldub_p
  175                     	; (bytes : 11, cycles : 19/23)
  176                     	stx	<__ptr
  177                     	sta	<__ptr+1
  178                     	lda	[__ptr]
  179                     	tax
  180                     	cla
  181                     .endm
  182                     
  183                     ; ldw_s
  184                     ;
  185                     .macro __ldw_s
  186                     .if (\1 < 255)
  187                     	; short index (bytes :  7/8, cycles : 18/20)
  188                     .if (\1 = 0)
  189                     	lda	[__sp]
  190                     	tax
  191                     	ldy	#1
  192                     	lda	[__sp],Y
  193                     .else
  194                     	ldy	#\1
  195                     	lda	[__sp],Y
  196                     	tax
  197                     	iny
  198                     	lda	[__sp],Y
  199                     .endif
  200                     .else
  201                     	; long index  (bytes : 20, cycles : 44)
  202                     	addw	#\1,<__sp,<__ptr	; 13,26
  203                     	lda	[__ptr]
  204                     	tax
  205                     	ldy	#1
  206                     	lda	[__ptr],Y
  207                     .endif
  208                     .endm
  209                     
  210                     ; stbi_s
  211                     ;
  212                     .macro __stbi_s
  213                     .if (\2 < 256)
  214                     	; short index (bytes :  8/ 9, cycles : 15)
  215                     	lda	#LOW(\1)
  216                     	ldy	#\2
  217                     	sta	[__sp],Y
  218                     	tax
  219                     	cla
  220                     .else
  221                     	; long index  (bytes : 19/20, cycles : 39)
  222                     
  223                     	addw	#\2,<__sp,<__ptr	; 13,26
  224                     	lda	#LOW(\1)
  225                     	sta	[__ptr]
  226                     	tax
  227                     	cla
  228                     .endif
  229                     .endm
  230                     
  231                     ; stwi_s
  232                     ;
  233                     .macro __stwi_s
  234                     .if (\2 < 255)
  235                     	; short index (bytes : 12, cycles : 24)
  236                     	lda	#LOW(\1)
  237                     	ldy	#\2
  238                     	sta	[__sp],Y
  239                     	tax
  240                     	lda	#HIGH(\1)
  241                     	iny
  242                     	sta	[__sp],Y
  243                     .else
  244                     	; long index  (bytes : 24, cycles : 48)
  245                     	addw	#\2,<__sp,<__ptr	; 13,26
  246                     	lda	#LOW(\1)
  247                     	sta	[__ptr]
  248                     	tax
  249                     	lda	#HIGH(\1)
  250                     	ldy	#1
  251                     	sta	[__ptr],Y
  252                     .endif
  253                     .endm
  254                     
  255                     ; stb_s
  256                     ;
  257                     .macro __stb_s
  258                     .if (\1 < 255)
  259                     	; short index (bytes :  6, cycles : 13)
  260                     	sax
  261                     	ldy	#\1
  262                     	sta	[__sp],Y
  263                     	sax
  264                     .else
  265                     	; long index  (bytes : 18, cycles : 42)
  266                     	pha
  267                     	addw	#\1,<__sp,<__ptr	; 13,26
  268                     	txa
  269                     	sta	[__ptr]
  270                     	pla
  271                     .endif
  272                     .endm
  273                     
  274                     ; stw_s
  275                     ;
  276                     .macro __stw_s
  277                     .if (\1 < 255)
  278                     	; short index (bytes :  9, cycles : 22)
  279                     	sax
  280                     	ldy	#\1
  281                     	sta	[__sp],Y
  282                     	sax
  283                     	iny
  284                     	sta	[__sp],Y
  285                     .else
  286                     	; long index  (bytes : 22, cycles : 51)
  287                     	pha
  288                     	addw	#\1,<__sp,<__ptr	; 13,26
  289                     	txa
  290                     	sta	[__ptr]
  291                     	pla
  292                     	ldy	#1
  293                     	sta	[__ptr],Y
  294                     .endif
  295                     .endm
  296                     
  297                     ; addw_s
  298                     ;
  299                     .macro __addw_s
  300                     .if (\1 < 255)
  301                     	; short index (bytes : 10, cycles : 24)
  302                     	ldy	#\1
  303                     	clc
  304                     	sax
  305                     	adc	[__sp],Y
  306                     	sax
  307                     	iny
  308                     	adc	[__sp],Y
  309                     .else
  310                     	; long index  (bytes : 24, cycles : 55)
  311                     	pha				;  1, 3
  312                     	addw	#\1,<__sp,<__ptr	; 13,26
  313                     	pla				;  1, 4
  314                     	clc
  315                     	sax
  316                     	adc	[__ptr]
  317                     	sax
  318                     	ldy	#1
  319                     	adc	[__ptr],Y
  320                     .endif
  321                     .endm
  322                     
  323                     ; XXX: the semantics of this are ridiculous: It assumes the value of
  324                     ; the incremented variable to be in AX, the memory location to
  325                     ; be incremented and the previous value retained in AX, making it
  326                     ; necessary to spill A.
  327                     ; incw_s
  328                     ;
  329                     .macro __incw_s
  330                     	; (bytes : 16, cycles : 24/40)
  331                     	pha
  332                     	ldy	#\1
  333                     	txa
  334                     	inc A
  335                     	sta	[__sp],Y
  336                     	bne	.x_\@
  337                     	iny
  338                     	lda	[__sp],Y
  339                     	inc A
  340                     	sta	[__sp],Y
  341                     .x_\@:
  342                     	pla
  343                     .endm
  344                     
  345                     ; incb_s
  346                     ;
  347                     .macro __incb_s
  348                     	pha
  349                     	ldy	#\1
  350                     	txa
  351                     	inc A
  352                     	sta	[__sp],Y
  353                     	pla
  354                     .endm
  355                     
  356                     ; ldd_i
  357                     ;
  358                     .macro __ldd_i
  359                     	stw	#(\1) & 0xFFFF,<\2
  360                     	stw	#(\1) >> 16,<\3
  361                     	ldx	#low(\2)
  362                     	lda	#high(\2)
  363                     .endm
  364                     
  365                     ; ldd_b
  366                     ;
  367                     .macro __ldd_b
  368                     	lda	 \1
  369                     	sta	<\2
  370                     	stz	<\2+1
  371                     	stwz	<\3
  372                     	ldx	#low(\2)
  373                     	lda	#high(\2)
  374                     .endm
  375                     
  376                     ; ldd_w
  377                     ;
  378                     .macro __ldd_w
  379                     	stw	 \1,<\2
  380                     	stwz	<\3
  381                     	ldx	#low(\2)
  382                     	lda	#high(\2)
  383                     .endm
  384                     
  385                     ; ldd_s_b
  386                     ;
  387                     .macro __ldd_s_b
  388                     	__ldb_s	\1
  389                     	stx	<\2
  390                     	sta	<\2+1
  391                     	stwz	<\3
  392                     	ldx	#low(\2)
  393                     	lda	#high(\2)
  394                     .endm
  395                     
  396                     ; ldd_s_w
  397                     ;
  398                     .macro __ldd_s_w
  399                     	__ldw_s	\1
  400                     	stx	<\2
  401                     	sta	<\2+1
  402                     	stwz	<\3
  403                     	ldx	#low(\2)
  404                     	lda	#high(\2)
  405                     .endm
  406                     
#[2]   startup.asm
   22                     .endif	; HUC
   23                     
#[3]   standard.inc
   24                     .include  "standard.inc" ; HUCARD
    1                     ;
    2                     ; STANDARD.INC  -  MagicKit standard include file
    3                     ;
#[4]   equ.inc
    4                     .include "equ.inc"
    1                     ;
    2                     ; EQU.INC  -  MagicKit Standard Equates
    3                     ;
    4                     
    5                     
    6                     ; --------
    7                     ; This block defines standard system variables
    8                     ; in zero-page.
    9                     ;
   10                     
   11           20F3      vdc_crl	= $20F3	; VDC control register (copy of)
   12           20F4      vdc_crh	= $20F4	;
   13           20F5      irq_m	= $20F5	; interrupt control mask (copy of)
   14           20F6      vdc_sr	= $20F6	; VDC status register (copy of)
   15           20F7      vdc_reg	= $20F7	; VDC register index (copy of)
   16                     
   17                     ; old aliases (for compatibility only, don't use them)
   18           0000      .ifndef HUC
   22                     .endif
   23                     
   24                     
   25                     ; --------
   26                     ; This block defines standard parameter-passing
   27                     ; areas (in zero-page) for subroutines.
   28                     ;
   29                     
   30           20EC      __bp	= $20EC	; base pointer
   31           20EE      __si	= $20EE	; source address
   32           20F0      __di	= $20F0	; destination address
   33           20F8      __ax	= $20F8
   34           20F8      __al	= $20F8
   35           20F9      __ah	= $20F9
   36           20FA      __bx	= $20FA
   37           20FA      __bl	= $20FA
   38           20FB      __bh	= $20FB
   39           20FC      __cx	= $20FC
   40           20FC      __cl	= $20FC
   41           20FD      __ch	= $20FD
   42           20FE      __dx	= $20FE
   43           20FE      __dl	= $20FE
   44           20FF      __dh	= $20FF
   45                     
   46           0001      .ifdef DEPRECATED
   47                     ; aliases for old assembler code
   48           20EC      _bp	= __bp
   49           20EE      _si	= __si
   50           20F0      _di	= __di
   51           20F8      _ax	= __ax
   52           20F8      _al	= __al
   53           20F9      _ah	= __ah
   54           20FA      _bx	= __bx
   55           20FA      _bl	= __bl
   56           20FB      _bh	= __bh
   57           20FC      _cx	= __cx
   58           20FC      _cl	= __cl
   59           20FD      _ch	= __ch
   60           20FE      _dx	= __dx
   61           20FE      _dl	= __dl
   62           20FF      _dh	= __dh
   63                     .endif
   64                     
   65                     
   66                     ; --------
   67                     ; This block defines names for standard
   68                     ; devices and equipment on the PC-Engine.
   69                     ; (they should be self-explanatory...)
   70                     ;
   71                     
   72                     ; ----
   73                     ; VDC (Video Display Controller)
   74                     
   75           0000      videoport	.equ $0000
   76                     
   77           0000      video_reg	.equ videoport
   78           0000      video_reg_l	.equ video_reg
   79           0001      video_reg_h	.equ video_reg+1
   80                     
   81           0002      video_data	.equ videoport+2
   82           0002      video_data_l	.equ video_data
   83           0003      video_data_h	.equ video_data+1
   84                     
   85                     
   86           0000      .ifdef _SGX
  119                     .endif ; _SGX
  120                     
  121                     
  122           0000      .ifdef _AC
  170                     .endif ; _AC
  171                     
  172                     
  173                     ; ----
  174                     ; VCE (Video Color Encoder)
  175                     
  176           0400      colorport	.equ $0400
  177           0400      color_ctrl	.equ colorport
  178                     
  179           0402      color_reg	.equ colorport+2
  180           0402      color_reg_l	.equ color_reg
  181           0403      color_reg_h	.equ color_reg+1
  182                     
  183           0404      color_data	.equ colorport+4
  184           0404      color_data_l	.equ color_data
  185           0405      color_data_h	.equ color_data+1
  186                     
  187           0001      .ifdef HUC
  188           0402      _color_reg	.equ colorport+2
  189           0404      _color_data	.equ colorport+4
  190                     .endif
  191                     
  192                     
  193                     ; ----
  194                     ; PSG (Programmable Sound Generator)
  195                     
  196           0800      psgport		.equ $0800
  197           0800      psg_ch		.equ psgport
  198           0801      psg_mainvol	.equ psgport+1
  199           0802      psg_freqlo	.equ psgport+2
  200           0803      psg_freqhi	.equ psgport+3
  201           0804      psg_ctrl	.equ psgport+4
  202           0805      psg_pan		.equ psgport+5
  203           0806      psg_wavebuf	.equ psgport+6
  204           0807      psg_noise	.equ psgport+7
  205           0808      psg_lfofreq	.equ psgport+8
  206           0809      psg_lfoctrl	.equ psgport+9
  207                     
  208                     
  209                     ; ----
  210                     ; TIMER
  211                     
  212           0C00      timerport	.equ $0C00
  213           0C00      timer_cnt	.equ timerport
  214           0C01      timer_ctrl	.equ timerport+1
  215                     
  216                     
  217                     ; ----
  218                     ; I/O port
  219                     
  220           1000      joyport		.equ $1000
  221                     
  222                     
  223                     ; ----
  224                     ; IRQ ports
  225                     
  226           1400      irqport		.equ $1400
  227           1402      irq_disable	.equ irqport+2
  228           1403      irq_status	.equ irqport+3
  229                     
  230                     
  231                     ; ----
  232                     ; CDROM/Expansion ports
  233                     
  234           1800      cd_port		.equ $1800
  235                     
  236           1803      bram_lock	.equ cd_port+3	; a read access here will do it
  237           1807      bram_unlock	.equ cd_port+7	; actually, bit #$80 of this byte
  238                     
  239                     
  240                     ; ----
  241                     ; Arcade Card ports
  242                     
  243           1A00      ac_port		.equ $1A00
  244           1A00      ac_data1	.equ ac_port
  245           1A01      ac_data1_alt	.equ ac_port+1
  246           1A02      ac_base1_l	.equ ac_port+2
  247           1A03      ac_base1_m	.equ ac_port+3
  248           1A04      ac_base1_h	.equ ac_port+4
  249           1A05      ac_offset1_l	.equ ac_port+5
  250           1A06      ac_offset1_m	.equ ac_port+6
  251           1A09      ac_cntrol1	.equ ac_port+9
  252           1A0A      ac_addoffset1	.equ ac_port+$0A
  253                     
  254           1AE0      ac_shftreg	.equ $1AE0		; actually, probably rotate register
  255           1AE0      ac_shftreg_0	.equ ac_shftreg
  256           1AE1      ac_shftreg_1	.equ ac_shftreg+1
  257           1AE2      ac_shftreg_2	.equ ac_shftreg+2
  258           1AE3      ac_shftreg_3	.equ ac_shftreg+3
  259           1AE4      ac_shft_bits	.equ ac_shftreg+4	; positive = shift left
  260                     
  261           1AFD      ac_identbase	.equ $1AFD
  262           1AFD      ac_identver_l	.equ ac_identbase
  263           1AFE      ac_identver_h	.equ ac_identbase+1
  264           1AFF      ac_identflag	.equ ac_identbase+2
  265                     
  266           0051      AC_IDENT	.equ $51	; if ac_identflag = AC_IDENT, then AC in use
  267                     
  268                     
  269                     ; --------
  270                     ; This block defines names for macro
  271                     ; argument types (\?x).
  272                     ;
  273                     
  274           0000      ARG_NONE	.equ 0
  275           0001      ARG_REG		.equ 1
  276           0002      ARG_IMMED	.equ 2
  277           0003      ARG_ABS		.equ 3
  278           0003      ARG_ABSOLUTE	.equ 3
  279           0004      ARG_INDIRECT	.equ 4
  280           0005      ARG_STRING	.equ 5
  281           0006      ARG_LABEL	.equ 6
#[3]   standard.inc
#[4]   macro.inc
    5                     .include "macro.inc"
    1                     ;
    2                     ; macro.inc  -  MagicKit standard macro definitions
    3                     ;
    4                     
    5                     map	.macro			; map a memory bank into
    6                     	lda	#bank(\1)	; addressable memory
    7                     	tam	#page(\1)
    8                     .endm
    9                     
   10                     ;
   11                     ; MAPLIBFUNC - Re-map a library function into $A000-space if it's
   12                     ;	       not in library bank #1
   13                     ;
   14                     maplibfunc	.macro
   15                     	tay
   16                     	tma	#page(\1)
   17                     	pha
   18                     	lda	#bank(\1)
   19                     	tam	#page(\1)
   20                     	tya
   21                     	jsr	\1
   22                     	tay
   23                     	pla
   24                     	tam	#page(\1)
   25                     	tya
   26                     .endm
   27                     
   28                     
   29           0000      .ifdef HAVE_LIB3
   47                     .endif ; HAVE_LIB3
   48                     
   49                     ;
   50                     ; STWZ - store a word-sized zero value at stated memory location
   51                     ;
   52                     stwz	.macro
   53                     	stz	LOW_BYTE \1
   54                     	stz	HIGH_BYTE \1
   55                     .endm
   56                     
   57                     ;
   58                     ; STW - store a word-sized value at stated memory location
   59                     ;
   60                     stw	.macro
   61                     	lda	LOW_BYTE \1
   62                     	sta	LOW_BYTE \2
   63                     	lda	HIGH_BYTE \1
   64                     	sta	HIGH_BYTE \2
   65                     .endm
   66                     
   67                     stb	.macro
   68                     	lda	\1
   69                     	sta	\2
   70                     .endm
   71                     
   72                     ;
   73                     ; ADDW - add word-sized value to value at stated memory location,
   74                     ;	 storing result back into stated memory location (or into
   75                     ;	 another destination memory location - third arg)
   76                     ;
   77                     addw	.macro
   78                     .if	(\# = 3)
   79                     	; 3-arg mode
   80                     	;
   81                     	clc
   82                     	lda	LOW_BYTE \2
   83                     	adc	LOW_BYTE \1
   84                     	sta	LOW_BYTE \3
   85                     	lda	HIGH_BYTE \2
   86                     	adc	HIGH_BYTE \1
   87                     	sta	HIGH_BYTE \3
   88                     .else
   89                     	; 2-arg mode
   90                     	;
   91                     	clc
   92                     	lda	LOW_BYTE \2
   93                     	adc	LOW_BYTE \1
   94                     	sta	LOW_BYTE \2
   95                     	lda	HIGH_BYTE \2
   96                     	adc	HIGH_BYTE \1
   97                     	sta	HIGH_BYTE \2
   98                     .endif
   99                     .endm
  100                     
  101                     ;
  102                     ; ADCW - add word-sized value plus carry to value at stated memory location,
  103                     ;	 storing result back into stated memory location
  104                     ;
  105                     adcw	.macro
  106                     	lda	LOW_BYTE \2
  107                     	adc	LOW_BYTE \1
  108                     	sta	LOW_BYTE \2
  109                     	lda	HIGH_BYTE \2
  110                     	adc	HIGH_BYTE \1
  111                     	sta	HIGH_BYTE \2
  112                     .endm
  113                     
  114                     ;
  115                     ; SUBW - substract word-sized value from value at stated memory location,
  116                     ;	 storing result back into stated memory location
  117                     ;
  118                     subw	.macro
  119                     	sec
  120                     	lda	LOW_BYTE \2
  121                     	sbc	LOW_BYTE \1
  122                     	sta	LOW_BYTE \2
  123                     	lda	HIGH_BYTE \2
  124                     	sbc	HIGH_BYTE \1
  125                     	sta	HIGH_BYTE \2
  126                     .endm
  127                     
  128                     ;
  129                     ; SBCW - substract word-sized value plus carry from value at stated memory
  130                     ;	 location, storing result back into stated memory location
  131                     ;
  132                     sbcw	.macro
  133                     	lda	LOW_BYTE \2
  134                     	sbc	LOW_BYTE \1
  135                     	sta	LOW_BYTE \2
  136                     	lda	HIGH_BYTE \2
  137                     	sbc	HIGH_BYTE \1
  138                     	sta	HIGH_BYTE \2
  139                     .endm
  140                     
  141                     cmpw	.macro
  142                     	lda	HIGH_BYTE \2
  143                     	cmp	HIGH_BYTE \1
  144                     	bne	.x_\@
  145                     	lda	LOW_BYTE \2
  146                     	cmp	LOW_BYTE \1
  147                     .x_\@:
  148                     .endm
  149                     
  150                     tstw	.macro			; test if the word-sized 
  151                     	lda	\1		; value at stated memory
  152                     	ora	\1+1		; location is zero
  153                     .endm
  154                     
  155                     incw	.macro			; increment a word-sized
  156                     	inc	\1		; value at stated memory
  157                     	bne	.x_\@		; location
  158                     	inc	\1+1
  159                     .x_\@:
  160                     .endm
  161                     
  162                     decw	.macro			; decrement a word-sized
  163                     	sec			; value at stated memory
  164                     	lda	\1		; location
  165                     	sbc	#1
  166                     	sta	\1
  167                     	lda	\1+1
  168                     	sbc	#0
  169                     	sta	\1+1
  170                     .endm
  171                     
  172                     rolw	.macro			; rotate word-sized value
  173                     	rol	\1		; (at stated memory location)
  174                     	rol	\1+1
  175                     .endm
  176                     
  177                     aslw	.macro			; arithmetic shift-left
  178                     	asl	\1		; word-sized value (at stated
  179                     	rol	\1+1		; memory location)
  180                     .endm
  181                     
  182                     lsrw	.macro			; logical shift-right word-sized
  183                     	lsr	\1+1		; value (at stated memory
  184                     	ror	\1		; location)
  185                     .endm
  186                     
  187                     rorw	.macro			; rotate right word-sized value
  188                     	ror	\1+1		; (at stated memory location)
  189                     	ror	\1
  190                     .endm
  191                     
  192                     negw	.macro			; negate word-sized value
  193                     	cla			; (at stated memory location)
  194                     	sub	\1		; 2's complement
  195                     	sta	\1
  196                     	cla
  197                     	sbc	\1+1
  198                     	sta	\1+1
  199                     .endm
  200                     
  201                     neg	.macro			; negate byte-sized value
  202                     	eor	#$FF		; in register A
  203                     	inc	A		; 2's complement
  204                     .endm
  205                     
  206                     add	.macro			; add byte-sized value to
  207                     .if (\# = 2)			; register A (handle carry
  208                     	lda	\2		; flag)
  209                     	clc
  210                     	adc	\1
  211                     	sta	\2
  212                     .else
  213                     	clc
  214                     	adc	\1
  215                     .endif
  216                     .endm
  217                     
  218                     sub	.macro			; subtract byte-sized value
  219                     .if (\# = 2)			; from register A (handle
  220                     	lda	\2		; carry flag)
  221                     	sec
  222                     	sbc	\1
  223                     	sta	\2
  224                     .else
  225                     	sec
  226                     	sbc	\1
  227                     .endif
  228                     .endm
  229                     
  230                     blo	.macro			; branch if 'lower'
  231                     	bcc	\1
  232                     .endm
  233                     
  234                     bhs	.macro			; branch if 'higher or same'
  235                     	bcs	\1
  236                     .endm
  237                     
  238                     bhi	.macro			; branch if 'higher'
  239                     	beq	.x_\@
  240                     	bcs	\1
  241                     .x_\@:
  242                     .endm
  243                     
  244                     ;-------------------------------
  245                     
  246                     ;
  247                     ; Long branch macros
  248                     ;
  249                     
  250                     lbne	.macro
  251                     	beq	.x_\@
  252                     	jmp	\1
  253                     .x_\@
  254                     .endm
  255                     
  256                     lbeq	.macro
  257                     	bne	.x_\@
  258                     	jmp	\1
  259                     .x_\@
  260                     .endm
  261                     
  262                     lbpl	.macro
  263                     	bmi	.x_\@
  264                     	jmp	\1
  265                     .x_\@
  266                     .endm
  267                     
  268                     lbmi	.macro
  269                     	bpl	.x_\@
  270                     	jmp	\1
  271                     .x_\@
  272                     .endm
  273                     
  274                     lbcc	.macro
  275                     	bcs	.x_\@
  276                     	jmp	\1
  277                     .x_\@
  278                     .endm
  279                     
  280                     lbcs	.macro
  281                     	bcc	.x_\@
  282                     	jmp	\1
  283                     .x_\@
  284                     .endm
  285                     
  286                     lblo	.macro
  287                     	bcs	.x_\@
  288                     	jmp	\1
  289                     .x_\@
  290                     .endm
  291                     
  292                     lbhs	.macro
  293                     	bcc	.x_\@
  294                     	jmp	\1
  295                     .x_\@
  296                     .endm
  297                     
  298                     
  299                     ;-------------------------------
  300                     
  301                     ;
  302                     ; These macros are the same as the macros
  303                     ; without an underscore; the difference
  304                     ; is these macros preserve the state of
  305                     ; the registers they use (at the expense
  306                     ; of speed)
  307                     ;
  308                     
  309                     _stw	.macro
  310                     	pha
  311                     	stw	\1,\2
  312                     	pla
  313                     .endm
  314                     
  315                     _addw	.macro
  316                     	pha
  317                     	addw	\1,\2
  318                     	pla
  319                     .endm
  320                     
  321                     _adcw	.macro
  322                     	pha
  323                     	adcw	\1,\2
  324                     	pla
  325                     .endm
  326                     
  327                     _subw	.macro
  328                     	pha
  329                     	subw	\1,\2
  330                     	pla
  331                     .endm
  332                     
  333                     _sbcw	.macro
  334                     	pha
  335                     	sbcw	\1,\2
  336                     	pla
  337                     .endm
  338                     
  339                     _cmpw	.macro
  340                     	pha
  341                     	cmpw	\1,\2
  342                     	pla
  343                     .endm
  344                     
  345                     _tstw	.macro
  346                     	pha
  347                     	tstw	\1
  348                     	pla
  349                     .endm
  350                     
  351                     _incw	.macro
  352                     	incw	\1
  353                     .endm
  354                     
  355                     _decw	.macro
  356                     	pha
  357                     	decw	\1
  358                     	pla
  359                     .endm
#[3]   standard.inc
#[4]   func.inc
    6                     .include "func.inc"
    1                     ;
    2                     ; FUNC.INC  -  MagicKit Standard Functions
    3                     ;
    4                     ;
    5                     
    6                     ; ----
    7                     ; BATVAL - create a value for the BAT map
    8                     ;
    9                     ; parameters:
   10                     ; \1 = palette (0-15)
   11                     ; \2 = VRAM address of tile
   12                     BATVAL	.func	(\1<<12)|(\2>>4)
   13                     
   14                     ; ----
   15                     ; CHAR - create a BAT value for a character defined
   16                     ;	 using '.defchar' (uses default palette)
   17                     ;
   18                     ; parameters:
   19                     ; \1 = name of character
   20                     ;
   21                     CHAR	.func	(PAL(\1)<<12|VRAM(\1)>>4)
   22                     
   23                     ; ----
   24                     ; SPR_VRAM - return shifted value of sprite-pattern VRAM address
   25                     ;
   26                     ; parameters:
   27                     ; \1 = VRAM address of sprite
   28                     ;
   29                     SPR_VRAM	.func	(VRAM(\1)>>5)
#[3]   standard.inc
#[4]   library.inc
    7                     .include "library.inc"
    1                     ;
    2                     ; LIBRARY.INC  -  MagicKit include-interface to LIBRARY.ASM
    3                     ;
    4                     
    5                     ;
    6                     ; These MACROs are just simple one-line setups to the
    7                     ; back-end library subroutines.  They simply setup
    8                     ; calling parameters, and call the subroutine
    9                     ;
   10                     
   11                     
   12                     ; set video memory read and write address:
   13                     ;
   14                     ; setvraddr(addr)
   15                     ; ----
   16                     ; addr, new address in VRAM to read at
   17                     ;
   18                     .macro setvraddr
   19                     	stw	#\1,<__di
   20                     	jsr	set_read
   21                     .endm
   22                     
   23                     ; setvwaddr(addr)
   24                     ; ----
   25                     ; addr, new address in VRAM to write at
   26                     ;
   27                     .macro setvwaddr
   28                     	stw	#\1,<__di
   29                     	jsr	set_write
   30                     .endm
   31                     
   32                     ; set_bgpal(index, data [, nb])
   33                     ; ----
   34                     ; index,	sub-palette index (0-15)
   35                     ; data,		color data memory address
   36                     ; nb,		number of sub-palette to load (optional, one by default)
   37                     
   38                     .macro set_bgpal
   39                     	lda	\1
   40                     	sta	<__al
   41                     .if (\?2 = ARG_LABEL)
   42                     	stb	#BANK(\2),<__bl
   43                     .else
   44                     	stb	#$FE,<__bl
   45                     .endif
   46                     	stw	#\2,<__si
   47                     .if \?3
   48                     	lda	\3
   49                     .else
   50                     	lda	#1
   51                     .endif
   52                     	sta	<__cl
   53                     	jsr	load_palette
   54                     .endm
   55                     
   56                     ; set_sprpal(index, data [, nb])
   57                     ; ----
   58                     ; index,	sub-palette index (0-15)
   59                     ; data,		palette data memory address
   60                     ; nb,		number of sub-palette to update (optional, one by default)
   61                     
   62                     .macro set_sprpal
   63                     	lda	\1
   64                     	add	#16
   65                     	sta	<__al
   66                     .if (\?2 = ARG_LABEL)
   67                     	stb	#BANK(\2),<__bl
   68                     .else
   69                     	stb	#$FE,<__bl
   70                     .endif
   71                     	stw	#\2,<__si
   72                     .if \?3
   73                     	lda	\3
   74                     .else
   75                     	lda	#1
   76                     .endif
   77                     	sta	<__cl
   78                     	jsr	load_palette
   79                     .endm
   80                     
   81                     ; setcolor(index, r, g, b)
   82                     ; ----
   83                     ; index, color index
   84                     ; r,	red	(0-7)
   85                     ; g,	green	(0-7)
   86                     ; b,	blue	(0-7)
   87                     
   88                     .macro setcolor
   89                     	stw	\1,color_reg
   90                     	stw	#(((\3) << 6) + ((\2) << 3) + (\4)),color_data
   91                     .endm
   92                     
   93                     ; vload([vram,] data, size)
   94                     ; ----
   95                     ; vram, VRAM base address
   96                     ; data, video data memory address
   97                     ; size, number of words to copy
   98                     
   99                     .macro vload
  100                     .if (\# = 3)
  101                     	stw	#\1,<__di
  102                     .if (\?2 = ARG_LABEL)
  103                     	stb	#BANK(\2),<__bl
  104                     .else
  105                     	stb	#$FE,<__bl
  106                     .endif
  107                     	stw	#\2,<__si
  108                     	stw	\3,<__cx
  109                     .else
  110                     	stw	#VRAM(\1),<__di
  111                     	stb	#BANK(\1),<__bl
  112                     	stw	#\1,<__si
  113                     	stw	#\2,<__cx
  114                     .endif
  115                     	jsr	load_vram
  116                     .endm
  117                     
  118                     ; batcpy(vram, bat, w, h)
  119                     ; ----
  120                     ; vram,	VRAM base address
  121                     ; bat,	BAT address in memory
  122                     ; w,	nb of column to copy
  123                     ; h,	nb of row
  124                     
  125                     .macro batcpy
  126                     .if (\# = 5)
  127                     .fail "batcpy syntax has changed, update your code!"
  128                     .endif
  129                     	stw	\1,<__di
  130                     .if (\?2 = ARG_LABEL)
  131                     	stb	#BANK(\2),<__bl
  132                     .else
  133                     	stb	#$FE,<__bl
  134                     .endif
  135                     	stw	#\2,<__si
  136                     	lda	\3
  137                     	sta	<__cl
  138                     	lda	\4
  139                     	sta	<__ch
  140                     	jsr	load_bat
  141                     .endm
  142                     
  143                     ; setmap(map, tile, ctable, w ,h)
  144                     ; ----
  145                     ; map,		map base address
  146                     ; tile,		tile vram address
  147                     ; ctable,	tile palette table address
  148                     ; w,		map width
  149                     ; h,		map height
  150                     
  151                     .macro setmap
  152                     	stw	#BANK(\1),mapbank
  153                     	stw	#\1,mapaddr
  154                     	stw	#(\2)>>4,maptilebase
  155                     	stw	#\3,mapctable
  156                     	stb	#BANK(\3),mapctablebank
  157                     	stw	\4,mapwidth
  158                     	stw	\5,mapheight
  159                     .endm
  160                     
  161                     ; mapcpy(vram, x, y, w, h)
  162                     ; ----
  163                     ; vram, VRAM base address
  164                     ; x,	x start coordinate in the map
  165                     ; y,	y start coordinate
  166                     ; w,	nb of column to copy
  167                     ; h,	nb of row
  168                     
  169                     .macro mapcpy
  170                     	stw	#\1,<__di
  171                     	lda	\2
  172                     	sta	<__cl
  173                     	lda	\3
  174                     	sta	<__ch
  175                     	lda	\4
  176                     	sta	<__dl
  177                     	lda	\5
  178                     	sta	<__dh
  179                     	jsr	load_map
  180                     .endm
  181                     
  182                     ; fntcpy(vram, font, color, bg, nb)
  183                     ; ----
  184                     ; vram,		VRAM base address
  185                     ; font,		font address in memory
  186                     ; color, 	character color
  187                     ; bg,		bg color
  188                     ; nb,		nb of char. to copy
  189                     
  190                     .macro fntcpy
  191                     	stw	#\1,<__di
  192                     	stb	#BANK(\2),<__bl
  193                     	stw	#\2,<__si
  194                     	lda	\3
  195                     	sta	<__al
  196                     	lda	\4
  197                     	sta	<__ah
  198                     	lda	\4
  199                     	sta	<__cl
  200                     	jsr	load_font
  201                     .endm
  202                     
  203                     ; scroll(num, x, y, top, bottom, cr)
  204                     ; ----
  205                     ; num,		scroll number (0-3)
  206                     ; x,		BAT x position
  207                     ; y,		BAT y position
  208                     ; top,		screen window top
  209                     ; bottom,	screen window bottom
  210                     ; cr,		screen window display control (bg/sp)
  211                     
  212                     .macro scroll
  213                     	lda	\1
  214                     	tax
  215                     	lda	LOW_BYTE  \2
  216                     	sta	scroll_xl,X
  217                     	lda	HIGH_BYTE \2
  218                     	sta	scroll_xh,X
  219                     	lda	LOW_BYTE  \3
  220                     	sta	scroll_yl,X
  221                     	lda	HIGH_BYTE \3
  222                     	sta	scroll_yh,X
  223                     	lda	\4
  224                     	sta	scroll_top,X
  225                     	lda	\5
  226                     	sta	scroll_bottom,X
  227                     	lda	\6
  228                     	ora	#$01
  229                     	sta	scroll_cr,X
  230                     .endm
  231                     
  232                     ; scroll_disable(num)
  233                     ; ----
  234                     ; num,	scroll number (0-3)
  235                     
  236                     .macro scroll_disable
  237                     	lda	\1
  238                     	tax
  239                     	lda	scroll_cr,X
  240                     	and	#$fe
  241                     	sta	scroll_cr,X
  242                     .endm
  243                     
  244                     ; setxres (xres)
  245                     ; ----
  246                     ; xres,	horizontal display resolution
  247                     
  248                     .macro setxres
  249                     	stw	#\1,<__ax
  250                     	jsr	set_xres
  251                     .endm
  252                     
#[3]   standard.inc
#[4]   sprites.inc
    8                     .include "sprites.inc"
    1                     ;
    2                     ; SPRITES.INC  -  MagicKit sprite MACRO definitions
    3                     ;
    4                     
    5                     
    6                     ; load_sprites(vram_addr, spr_bank, #nb_group)
    7                     ; ----
    8                     ; vram_addr,	destination address in VRAM
    9                     ; spr_bank,	sprite bank address
   10                     ; nb_group,	number of 32x64 patterns to copy
   11                     
   12                     .macro load_sprites
   13                     	; put the VRAM address in di
   14                     	stw	#\1,<__di
   15                     
   16                     	; put the sprite bank address in si/bl
   17                     	stw	#\2,<__si
   18                     	stb	#BANK(\2),<__bl
   19                     
   20                     	; get the number of patterns to copy, multiply it by $200 -
   21                     	; the size in words of a 32x64 pattern (remember that
   22                     	; 'load_vram' need a size in words), and put it in cx
   23                     	lda	\3
   24                     	asl a
   25                     	stz	<__cx
   26                     	sta	<__cx+1
   27                     
   28                     	; call the 'load_vram' function
   29                     	jsr load_vram
   30                     .endm
   31                     
   32                     
   33                     ; spr_set(#sprite, satb)
   34                     ; ----
   35                     ; sprite,	the sprite number (0-63)
   36                     ; satb,		the address of the SATB in RAM
   37                     
   38                     .macro spr_set
   39                     	; multiply the sprite number by 8 (the size of a SATB entry)
   40                     	; and put the result in si
   41                     	stz	<__si+1
   42                     	lda	\1
   43                     	asl a
   44                     	asl a
   45                     	asl a
   46                     	rol	<__si+1
   47                     	sta	<__si
   48                     
   49                     	; add the satb address to si
   50                     	addw	#\2,<__si
   51                     .endm
   52                     
   53                     
   54                     ; spr_x(#x [,offset])
   55                     ; ----
   56                     ; x, the new x coordinate
   57                     
   58                     .macro spr_x
   59                     	ldy	#2
   60                     .if (\# = 2)
   61                     	lda	LOW_BYTE \1
   62                     	clc
   63                     	adc	LOW_BYTE \2
   64                     	sta	[__si],Y
   65                     	lda	HIGH_BYTE \1
   66                     	adc	HIGH_BYTE \2
   67                     .else
   68                     	lda	LOW_BYTE \1
   69                     	sta	[__si],Y
   70                     	lda	HIGH_BYTE \1
   71                     .endif
   72                     	iny
   73                     	sta	[__si],Y
   74                     .endm
   75                     
   76                     
   77                     ; spr_y(#y [,offset])
   78                     ; ----
   79                     ; y, the new y coordinate
   80                     
   81                     .macro spr_y
   82                     .if (\# = 2)
   83                     	lda	LOW_BYTE \1
   84                     	clc
   85                     	adc	LOW_BYTE \2
   86                     	sta	[__si]
   87                     	lda	HIGH_BYTE \1
   88                     	adc	HIGH_BYTE \2
   89                     .else
   90                     	lda	LOW_BYTE \1
   91                     	sta	[__si]
   92                     	lda	HIGH_BYTE \1
   93                     .endif
   94                     	ldy	#1
   95                     	sta	[__si],Y
   96                     .endm
   97                     
   98                     
   99                     ; spr_pattern(#addr)
  100                     ; ----
  101                     ; addr, address of the sprite pattern in VRAM
  102                     
  103                     .macro spr_pattern
  104                     	ldy	#4
  105                     .if (\?1 = ARG_IMMED)
  106                     	lda	#LOW((\1) >> 5)
  107                     	sta	[__si],Y
  108                     	lda	#HIGH((\1) >> 5)
  109                     .else
  110                     	lda	\1
  111                     	sta	[__si],Y
  112                     	lda	\1+1
  113                     .endif
  114                     	iny
  115                     	sta	[__si],Y
  116                     .endm
  117                     
  118                     
  119                     ; spr_ctrl(#mask, #flag)
  120                     ; ----
  121                     ; mask, mask of the bits to change
  122                     ; flag, new bit value
  123                     
  124                     .macro spr_ctrl
  125                     	ldy	#7
  126                     	lda	\1
  127                     	eor	#$FF
  128                     	and	[__si],Y
  129                     	ora	\2
  130                     	sta	[__si],Y
  131                     .endm
  132                     
  133                     
  134                     ; spr_pri(#flag)
  135                     ; ----
  136                     ; flag, new priority (1 = in foreground, 0 = in background)
  137                     
  138                     .macro spr_pri
  139                     	ldy	#6
  140                     	lda	[__si],Y
  141                     	and	#$7F
  142                     	ldx	\1
  143                     	beq	.x\@
  144                     	ora	#$80
  145                     .x\@:
  146                     	sta [__si],Y
  147                     .endm
  148                     
  149                     
  150                     ; spr_pal(#index)
  151                     ; ----
  152                     ; index, palette index (0-15)
  153                     
  154                     .macro spr_pal
  155                     	ldy	#6
  156                     	lda	[__si],Y
  157                     	and	#$F0
  158                     	ora	\1
  159                     	sta	[__si],Y
  160                     .endm
  161                     
  162                     
  163                     ; init_satb(addr)
  164                     ; ----
  165                     ; addr, the address of the local RAM SATB
  166                     
  167                     .macro init_satb
  168                     	stz	\1
  169                     	tii	\1,\1+1,511
  170                     .endm
  171                     
  172                     
  173                     ; update_satb(satb[, addr] [,nb_sprite])
  174                     ; ----
  175                     ; satb,		the address of the local RAM SATB
  176                     ; addr,		the address where to copy the SATB in VRAM ($7F00 by default)
  177                     ; nb_sprite,	number of sprite entry to copy (64 by default)
  178                     
  179                     .macro update_satb
  180                     	stw	#\1,<__si
  181                     	stb	#BANK(\1),<__bl
  182                     
  183                     .if (\?2)
  184                     	stw	#\2,<__di
  185                     .else
  186                     	stw	#$7F00,<__di
  187                     .endif
  188                     
  189                     .if (\?3)
  190                     	stw	#(\3)*4,<__cx
  191                     .else
  192                     	stw	#$100,<__cx
  193                     .endif
  194                     
  195                     	jsr	load_vram
  196                     .endm
  197                     
  198                     
  199                     ; ----
  200           0008      FLIP_X_MASK	.equ $08
  201           0080      FLIP_Y_MASK	.equ $80
  202           0088      FLIP_MASK	.equ $88
  203           0031      SIZE_MASK	.equ $31
  204                     
  205           0000      NO_FLIP		.equ 0
  206           0000      NO_FLIP_X	.equ 0
  207           0000      NO_FLIP_Y	.equ 0
  208           0008      FLIP_X		.equ $08
  209           0080      FLIP_Y		.equ $80
  210           0000      SIZE_16x16	.equ 0
  211           0010      SIZE_16x32	.equ $10
  212           0030      SIZE_16x64	.equ $30
  213           0001      SIZE_32x16	.equ $01
  214           0011      SIZE_32x32	.equ $11
  215           0031      SIZE_32x64	.equ $31
  216                     
#[3]   standard.inc
#[4]   vdc.inc
    9                     .include "vdc.inc"
    1                     ;
    2                     ; VDC.INC  -  MagicKit PC-Engine video MACRO definitions
    3                     ;
    4                     
    5                     
    6                     ;
    7                     ; VREG - set up video register to be read/written
    8                     ;
    9                     
   10                     .macro vreg
   11                     	lda	\1
   12                     	sta	<vdc_reg
   13                     .if (\?1 = ARG_IMMED)
   14                     	st0	\1
   15                     .else
   16                     	sta	video_reg
   17                     .endif
   18                     .endm
   19                     
   20                     ;
   21                     ; SETVINC - set VRAM auto-increment step
   22                     ;
   23                     
   24                     .macro setvinc
   25                     	vreg	#5
   26                     .if (\?1 = ARG_IMMED)
   27                     	st2	\1
   28                     .else
   29                     	lda	\1
   30                     	sta	video_data_h
   31                     .endif
   32                     .endm
   33                     
   34                     ; standard increment step
   35                     
   36           0000      VADDR_INC_1	= %00_000
   37           0008      VADDR_INC_32	= %01_000
   38           0010      VADDR_INC_64	= %10_000
   39           0018      VADDR_INC_128	= %11_000
   40                     
   41                     ;
   42                     ; SETBGMAP - set the bgmap virtual size
   43                     ;
   44                     
   45                     .macro setbgmap
   46                     	lda	\1
   47                     	jsr	set_bat_size
   48                     .endm
   49                     
   50                     ; standard bgmap size
   51                     
   52           0000      BGMAP_SIZE_32x32	= %000
   53           0001      BGMAP_SIZE_64x32	= %001
   54           0003      BGMAP_SIZE_128x32	= %011
   55           0004      BGMAP_SIZE_32x64	= %100
   56           0005      BGMAP_SIZE_64x64	= %101
   57           0007      BGMAP_SIZE_128x64	= %111
   58                     
   59                     ;
   60                     ; These values represent a bit in the VCE which
   61                     ; does color-correction to fix leading/trailing
   62                     ; edges of images
   63                     ;
   64                     ; Default to XRES_SOFT
   65                     ;
   66           0004      XRES_SOFT	= 4
   67           0000      XRES_SHARP	= 0
#[3]   standard.inc
#[4]   startup.inc
   10                     .include "startup.inc"
    1                     ;
    2                     ; STARTUP.INC  -  MagicKit startup code equates and macros
    3                     ;
    4                     
    5                     ; ----
    6                     ; this block defines names for joypad
    7                     ; direction and button bits
    8                     
    9           0001      JOY_I		= $01
   10           0002      JOY_II		= $02
   11           0004      JOY_SEL		= $04
   12           0008      JOY_RUN		= $08
   13           0010      JOY_UP		= $10
   14           0020      JOY_RIGHT	= $20
   15           0040      JOY_DOWN	= $40
   16           0080      JOY_LEFT	= $80
   17                     
   18           0050      JOY_TYPE6	= $50
   19           0001      JOY_III		= $01
   20           0002      JOY_IV		= $02
   21           0004      JOY_V		= $04
   22           0008      JOY_VI		= $08
   23                     
   24           0000      JOY_BITI	= $0
   25           0001      JOY_BITII	= $1
   26           0002      JOY_BITSEL	= $2
   27           0003      JOY_BITRUN	= $3
   28           0004      JOY_BITUP	= $4
   29           0005      JOY_BITRT	= $5
   30           0006      JOY_BITDN	= $6
   31           0007      JOY_BITLT	= $7
   32                     
   33           0000      JOY_BITIII	= $0
   34           0001      JOY_BITIV	= $1
   35           0002      JOY_BITV	= $2
   36           0003      JOY_BITVI	= $3
   37                     
   38                     ; ----
   39                     ; this block defines names for interrupt
   40                     ; vectors
   41                     ;
   42           0000      IRQ2		= 0
   43           0001      IRQ1		= 1
   44           0002      TIMER		= 2
   45           0003      NMI		= 3
   46           0004      VSYNC		= 4
   47           0005      HSYNC		= 5
   48           0006      SOFT_RESET	= 6
   49                     
   50                     
   51                     ; ----
   52                     ; setvec(num, addr)
   53                     ; ----
   54                     ; num,	vector number (see defines above)
   55                     ; addr,	address of the new routine
   56                     ; ----
   57                     
   58                     setvec	.macro
   59                     	 lda	\1
   60                     	 ldx	#LOW(\2)
   61                     	 ldy	#HIGH(\2)
   62                     	 jsr	set_intvec
   63                     .endm
   64                     
   65                     ; ----
   66                     ; vec_on(num)
   67                     ; ----
   68                     ; num, vector to enable
   69                     ; ----
   70                     
   71                     vec_on	.macro
   72                     .if (\1 = 5)
   73                     	 smb	#6,<irq_m
   74                     .else
   75                     	 smb	\1,<irq_m
   76                     .endif
   77                     .endm
   78                     
   79                     ; ----
   80                     ; vec_off(num)
   81                     ; ----
   82                     ; num, vector to disable
   83                     ; ----
   84                     
   85                     vec_off	.macro
   86                     .if (\1 = 5)
   87                     	 rmb	#6,<irq_m
   88                     .else
   89                     	 rmb	\1,<irq_m
   90                     .endif
   91                     .endm
   92                     
   93                     ; ----
   94                     ; vsync([nb])
   95                     ; ----
   96                     ; nb, number of frames to be sync'ed on
   97                     ; ----
   98                     
   99                     vsync	.macro
  100                     .if (\# = 0)
  101                     	 lda #1
  102                     .else
  103                     	 lda \1
  104                     .endif
  105                     	 jsr	wait_vsync
  106                     .endm
#[3]   standard.inc
#[2]   startup.asm
   25                     
   26                     ; ----
   27                     ; if FONT_VADDR is not specified, then specify it
   28                     ; (VRAM address to load font into)
   29                     ;
   30           0000      .ifndef	FONT_VADDR
   32                     .endif
   33                     
   34                     ; ----
   35                     ; system variables
   36                     ;
   37           200B      		.zp
   38  --:200B            zp_ptr1:	.ds 2
   39                     
   40                     
   41           2200      		.bss
   42                     
   43           0001      .if  (CDROM)	; CDROM def's in system.inc
   44                     
#[3]   system.inc
   45                      .include  "system.inc"
    1                     ;
    2                     ; SYSTEM.INC  -  CD-ROM System standard definitions
    3                     ;
    4                     ;
    5                     
    6                     
    7                     ; --------
    8                     ; This block defines types of supported CD-ROM
    9                     ;
   10                     
   11           0001      STANDARD_CD	= 1
   12           0002      SUPER_CD	= 2
   13                     
   14                     
   15                     ; --------
   16                     ; This block defines standard system variables
   17                     ; in RAM page.
   18                     ;
   19                     
   20           2200      usrvec		= $2200
   21           2200      usr_jmptbl	= $2200
   22           2200      irq2_jmp	= $2200 ;2
   23           2202      irq1_jmp	= $2202 ;2	formerly called irq_jmp
   24           2204      timer_jmp	= $2204 ;2	formerly called timer_jmp
   25           2206      nmi_jmp		= $2206 ;2
   26           2208      vsync_hook	= $2208 ;2	formerly called sync_jmp
   27           220A      hsync_hook	= $220A ;2	formerly called rcr_jmp
   28           220C      bg_x1		= $220C ;2	formerly called bgx1
   29           220E      bg_x2		= $220E ;2
   30           2210      bg_y1		= $2210 ;2
   31           2212      bg_y2		= $2212 ;2
   32           2214      satb_addr	= $2214 ;2	formerly called sat_adr
   33           2216      sprptr		= $2216 ;1
   34           2217      spryl		= $2217 ;1
   35           2218      spryh		= $2218 ;1
   36           2219      sprxl		= $2219 ;1
   37           221A      sprxh		= $221A ;1
   38           221B      sprnl		= $221B ;1
   39           221C      sprnh		= $221C ;1
   40           221D      spral		= $221D ;1
   41           221E      sprah		= $221E ;1
   42           221F      color_cmd	= $221F ;1
   43           2220      bgc_ptr		= $2220 ;2
   44           2222      bgc_len		= $2222 ;1
   45           2223      sprc_ptr	= $2223 ;2
   46           2225      sprc_len	= $2225 ;1
   47           2227      joyena		= $2227 ;1
   48           2228      joy		= $2228 ;5
   49           222D      joytrg		= $222D ;5
   50           2232      joyold		= $2232 ;5
   51           2241      irq_cnt		= $2241 ;1
   52           2242      vdc_mwr		= $2242 ;1	formerly called mwr_m
   53           2243      vdc_dcr		= $2243 ;1	formerly called dcr_m
   54           2249      rndseed		= $2249 ;1
   55           2249      rndl		= $2249 ;1
   56           224A      rndh		= $224A ;1
   57           224B      rndm		= $224B ;1
   58                     
   59                     
   60                     ; --------
   61                     ; This block defines CD-ROM BIOS routine
   62                     ; entry points.
   63                     ;
   64                     
   65           E000      cd_boot		= $E000
   66           E003      cd_reset	= $E003
   67           E006      cd_base		= $E006
   68           E009      cd_read		= $E009
   69           E00C      cd_seek		= $E00C
   70           E00F      cd_exec		= $E00F
   71           E012      cd_play		= $E012
   72           E015      cd_search	= $E015
   73           E018      cd_pause	= $E018
   74           E01B      cd_stat		= $E01B
   75           E01E      cd_subq		= $E01E
   76           E021      cd_dinfo	= $E021
   77           E024      cd_contnts	= $E024
   78           E027      cd_subrd	= $E027
   79           E02A      cd_pcmrd	= $E02A
   80           E02D      cd_fade		= $E02D
   81                     
   82           E030      ad_reset	= $E030
   83           E033      ad_trans	= $E033
   84           E036      ad_read		= $E036
   85           E039      ad_write	= $E039
   86           E03C      ad_play		= $E03C
   87           E03F      ad_cplay	= $E03F
   88           E042      ad_stop		= $E042
   89           E045      ad_stat		= $E045
   90                     
   91           E048      bm_format	= $E048
   92           E04B      bm_free		= $E04B
   93           E04E      bm_read		= $E04E
   94           E051      bm_write	= $E051
   95           E054      bm_delete	= $E054
   96           E057      bm_files	= $E057
   97                     
   98           E05A      ex_getver	= $E05A
   99           E05D      ex_setvec	= $E05D
  100           E060      ex_getfnt	= $E060
  101           E063      ex_joysns	= $E063
  102           E066      ex_joyrep	= $E066
  103           E069      ex_scrsiz	= $E069
  104           E06C      ex_dotmod	= $E06C
  105           E06F      ex_scrmod	= $E06F
  106           E072      ex_imode	= $E072
  107           E075      ex_vmode	= $E075
  108           E078      ex_hmode	= $E078
  109           E07B      ex_vsync	= $E07B
  110           E07E      ex_rcron	= $E07E
  111           E081      ex_rcroff	= $E081
  112           E084      ex_irqon	= $E084
  113           E087      ex_irqoff	= $E087
  114           E08A      ex_bgon		= $E08A
  115           E08D      ex_bgoff	= $E08D
  116           E090      ex_spron	= $E090
  117           E093      ex_sproff	= $E093
  118           E096      ex_dspon	= $E096
  119           E099      ex_dspoff	= $E099
  120           E09C      ex_dmamod	= $E09C
  121           E09F      ex_sprdma	= $E09F
  122           E0A2      ex_satclr	= $E0A2
  123           E0A5      ex_sprput	= $E0A5
  124           E0A8      ex_setrcr	= $E0A8
  125           E0AB      ex_setred	= $E0AB
  126           E0AE      ex_setwrt	= $E0AE
  127           E0B1      ex_setdma	= $E0B1
  128           E0B4      ex_binbcd	= $E0B4
  129           E0B7      ex_bcdbin	= $E0B7
  130           E0BA      ex_rnd		= $E0BA
  131           E0DE      ex_memopen	= $E0DE
  132           E0E4      ex_colorcmd	= $E0E4
  133                     
  134           E0BD      ma_mul8u	= $E0BD
  135           E0C0      ma_mul8s	= $E0C0
  136           E0C3      ma_mul16u	= $E0C3
  137           E0C6      ma_div16s	= $E0C6
  138           E0C9      ma_div16u	= $E0C9
  139           E0CC      ma_sqrt		= $E0CC
  140           E0CF      ma_sin		= $E0CF
  141           E0D2      ma_cos		= $E0D2
  142           E0D5      ma_atni		= $E0D5
  143                     
  144           E0D8      psg_bios	= $E0D8
  145           E0DB      grp_bios	= $E0DB
  146           E0E1      psg_driver	= $E0E1
  147                     
  148                     
  149                     ; --------
  150                     ; This block defines aliases for library routines
  151                     ; that have their equivalent in the CD-ROM BIOS.
  152                     ;
  153                     
  154           0001      .if (CDROM)
  155           E0BD      mulu8		= ma_mul8u
  156           E0C3      mulu16		= ma_mul16u
  157           E05D      set_intvec	= ex_setvec
  158                     .endif
  159                     
  160                     ; --------
  161                     ; This block defines PSG BIOS function
  162                     ; number.
  163                     ;
  164                     
  165           0000      PSG_ON		= 0
  166           0001      PSG_OFF		= 1
  167           0002      PSG_INIT	= 2
  168           0003      PSG_BANK	= 3
  169           0004      PSG_TRACK	= 4
  170           0005      PSG_WAVE	= 5
  171           0006      PSG_ENV		= 6
  172           0007      PSG_FM		= 7
  173           0008      PSG_PE		= 8
  174           0009      PSG_PC		= 9
  175           000A      PSG_TEMPO	= 10
  176           000B      PSG_PLAY	= 11
  177           000C      PSG_MSTAT	= 12
  178           000D      PSG_SSTAT	= 13
  179           000E      PSG_MSTOP	= 14
  180           000F      PSG_SSTOP	= 15
  181           0010      PSG_ASTOP	= 16
  182           0011      PSG_MVOFF	= 17
  183           0012      PSG_CONT	= 18
  184           0013      PSG_FDOUT	= 19
  185           0014      PSG_DCNT	= 20
  186                     
  187                     
  188                     ; --------
  189                     ; This block defines GRP BIOS function
  190                     ; number.
  191                     ;
  192                     
  193           0000      VI_GINIT	= 0
  194           0001      VI_CASHCLR	= 1
  195           0002      VI_STRTADR	= 2
  196           0003      VI_GETADRS	= 3
  197           0004      VI_CLS		= 4
  198           0005      VI_PSET		= 5
  199           0006      VI_POINT	= 6
  200           0007      VI_LINE		= 7
  201           0008      VI_BOX		= 8
  202           0009      VI_BOXF		= 9
  203           000A      VI_FLOOD	= 10
  204           000B      VI_PAINT	= 11
  205           000C      VI_GWINDOW	= 12
  206           000D      VI_GFONT	= 13
  207           000E      VI_PUTFONT	= 14
  208           000F      VI_SYMBOL	= 15
  209                     
#[2]   startup.asm
   46                     
   47                     .else  		; ie HuCard
   75                     .endif	; CDROM
   76                     
   77           2244      		.org	$2244
   78  --:2244            scr_mode:	.ds 1	; screen mode and dimensions - set by <ex_scrmod>
   79  --:2245            scr_w:		.ds 1
   80  --:2246            scr_h:		.ds 1
   81                     
   82           2284      		.org	$2284
   83  --:2284            soft_reset:	.ds 2	; soft reset jump loc (run+select)
   84                     
   85                     		; include sound driver variables
   86                     
#[3]   sound.inc
   87                     		.include  "sound.inc"
    1                     ;
    2                     ; SOUND.INC - Included by STARTUP.ASM to customize the sound driver.
    3                     ;
    4                     ; A customized sound driver for HuCard or CDROM usage can create a
    5                     ; version of this file, and then have startup.asm use the new
    6                     ; definitions just by including the new sound driver's path
    7                     ; in the PCE_INCLUDE environment variable BEFORE the standard
    8                     ; "huc/include/pce" path.
    9                     ;
   10                     ; This default version is comptabile with the CDROM System Card usage.
   11                     ;
   12                     
   13                     ;---------------------------------------------------------------------------
   14                     ; tell startup.asm that we need the SOUND_BANK and to include sound.asm
   15                     
   16           0000      NEED_SOUND_BANK	= 0
   17           0000      NEED_SOUND_CODE	= 0
   18                     
   19                     ;---------------------------------------------------------------------------------------
   20                     ; This macro is invoked in HuC startup.asm after the RAM is cleared, and just before
   21                     ; interrupts are enabled.
   22                     
   23                     __sound_init	.macro
   24                     		.endm
   25                     
   26                     ;---------------------------------------------------------------------------------------
   27                     ; This macro is invoked in HuC startup.asm inside the vsync handler code.
   28                     
   29                     __sound_vsync	.macro
   30                     		.endm
   31                     
   32                     ;---------------------------------------------------------------------------------------
   33                     ; This macro is invoked in HuC startup.asm inside the timer handler code.
   34                     ;
   35                     ; N.B. HuC startup.asm only invokes this if NOT building for CDROM!!!
   36                     ;
   37                     
   38                     __sound_timer	.macro
   39                     		.endm
   40                     
   41                     ;---------------------------------------------------------------------------------------
   42                     ; this is the location to start allocating HuC's internal variables.
   43                     
   44           2680      		.org			$2680
#[2]   startup.asm
   88                     
   89                     		; sound.inc sets the starting location for these HuC variables
   90                     		;
   91                     		; this is normally $2680, but can be lower if a custom
   92                     		; sound driver is used that doesn't need all of the
   93                     		; standard System Card allocation of sound RAM.
   94                     
   95  --:2680            vsync_cnt:	.ds 1	; counter for 'wait_vsync' routine
   96                     
   97  --:2681            joybuf:		.ds 5	; 'delta' pad values collector
   98  --:2686            joyhook:	.ds 2	; 'read_joypad' routine hook
   99  --:2688            joycallback:	.ds 6	; joypad enhanced callback support
  100  --:268E            disp_cr:	.ds 1   ; display control
  101                     			; HuCard: 1 = on, 0 = off
  102                     			; CD-ROM: 2 = on, 1 = off, 0 = no change
  103  --:268F            clock_hh	.ds 1	; system clock, hours since startup (0-255)
  104  --:2690            clock_mm	.ds 1	; system clock, minutes since startup (0-59)
  105  --:2691            clock_ss	.ds 1	; system clock, seconds since startup (0-59)
  106  --:2692            clock_tt	.ds 1	; system clock, ticks (1/60th sec) since startup (0-59)
  107                     
  108  --:2693            joy6:		.ds 5	; second byte for 6-button joysticks
  109  --:2698            joytrg6:	.ds 5
  110  --:269D            joyold6:	.ds 5
  111  --:26A2            joybuf6:	.ds 5
  112                     
  113  --:26A7            joytmp:		.ds 5
  114  --:26AC            joytmp6:	.ds 5
  115                     
  116  --:26B1            color_queue_r:	.ds 1	; ring buffer index for read
  117  --:26B2            color_queue_w:	.ds 1	; ring buffer index for write
  118  --:26B3            color_index:	.ds 8	; ring buffer - palette index
  119  --:26BB            color_count:	.ds 8	; ring buffer - palette count
  120  --:26C3            color_bank:	.ds 8	; ring buffer - data bank
  121  --:26CB            color_addr_l:	.ds 8	; ring buffer - data addr lo
  122  --:26D3            color_addr_h:	.ds 8	; ring buffer - data addr hi
  123  --:26DB            color_tia:	.ds 8	; self-modifying RAM tia function
  124                     
  125           0001      .if (CDROM)
  126                     
  127  --:26E3            ovl_running	.ds   1 ; overlay # that is currently running
  128  --:26E4            cd_super	.ds   1 ; Major CDROM version #
  129  --:26E5            irq_storea	.ds   1	; CDROM IRQ-specific handling stuff
  130  --:26E6            irq_storeb	.ds   1
  131  --:26E7            ram_vsync_hndl	.ds   25
  132  --:2700            ram_hsync_hndl	.ds   25
  133                     
  134                     .endif	; (CDROM)
  135                     
  136                     ; ----
  137                     ; setup flexible boundaries for startup code
  138                     ; and user program's "main".
  139                     ;
  140           0000      		.rsset	0
  141           0000      START_BANK	.rs	0
  142           0000      LIB1_BANK	.rs	1
  143           0001      LIB2_BANK	.rs	1
  144           0000      .ifdef HAVE_LIB3
  146                     .endif
  147                     
  148           0000      .if (NEED_SOUND_BANK)
  150                     .endif ; defined in sound.inc if needed
  151                     
  152           0001      .ifdef HUC
  153           0001      FONT_BANK	.equ	LIB2_BANK
  154           0002      CONST_BANK	.rs	1
  155           0003      DATA_BANK	.rs	1
  156                     .else ; HUC
  159                     .endif	; HUC
  160                     
  161                     ; [ STARTUP CODE ]
  162                     
  163                     ; Let's prepare the secondary library banks first, for use later.
  164                     ; The reason, as you will see, is because code for a given function
  165                     ; which sits together in a file, may have things in zero-page,
  166                     ; bss, LIB1_BANK (ie. START_BANK), and LIB2_BANK.
  167                     ;
  168                     ; The assembler must know beforehand what address etc. to use as a basis.
  169                     ;
  170                     
  171           0000      .ifdef _PAD
  175                     .endif
  176                     
  177           E000      	.data
  178           0001      	.bank LIB2_BANK,"Base Library 2/Font"
  179           6000      	.org  $6000
#[3]   font.inc
  180                     	.include "font.inc"
    1                     ; 8x8 monochrome font(s)
    2                     
    3  01:6000            font_1:
    4  01:6000  00 00 00  	.db $00,$00,$00,$00,$00,$00,$00,$00	;SPACE
       01:6003  00 00 00  
       01:6006  00 00     
    5  01:6008  CC CC CC  	.db $cc,$cc,$cc,$88,$88,$00,$cc,$00	;!
       01:600B  88 88 00  
       01:600E  CC 00     
    6  01:6010  6C 6C D8  	.db $6c,$6c,$d8,$00,$00,$00,$00,$00	;"
       01:6013  00 00 00  
       01:6016  00 00     
    7  01:6018  6C FE 6C  	.db $6c,$fe,$6c,$6c,$6c,$fe,$6c,$00	;#
       01:601B  6C 6C FE  
       01:601E  6C 00     
    8  01:6020  10 38 40  	.db $10,$38,$40,$38,$04,$38,$10,$00	;$
       01:6023  38 04 38  
       01:6026  10 00     
    9  01:6028  42 A4 48  	.db $42,$a4,$48,$10,$24,$4a,$84,$00	;%
       01:602B  10 24 4A  
       01:602E  84 00     
   10  01:6030  20 50 20  	.db $20,$50,$20,$54,$88,$94,$62,$00	;&
       01:6033  54 88 94  
       01:6036  62 00     
   11  01:6038  18 30 60  	.db $18,$30,$60,$00,$00,$00,$00,$00	;'
       01:603B  00 00 00  
       01:603E  00 00     
   12  01:6040  18 30 60  	.db $18,$30,$60,$60,$60,$30,$18,$00	;(
       01:6043  60 60 30  
       01:6046  18 00     
   13  01:6048  30 18 0C  	.db $30,$18,$0c,$0c,$0c,$18,$30,$00	;)
       01:604B  0C 0C 18  
       01:604E  30 00     
   14  01:6050  54 38 7C  	.db $54,$38,$7c,$38,$54,$00,$00,$00	;*
       01:6053  38 54 00  
       01:6056  00 00     
   15  01:6058  00 10 10  	.db $00,$10,$10,$7c,$10,$10,$00,$00	;+
       01:605B  7C 10 10  
       01:605E  00 00     
   16  01:6060  00 00 00  	.db $00,$00,$00,$18,$18,$08,$10,$00	;,
       01:6063  18 18 08  
       01:6066  10 00     
   17  01:6068  00 00 00  	.db $00,$00,$00,$78,$00,$00,$00,$00	;-
       01:606B  78 00 00  
       01:606E  00 00     
   18  01:6070  00 00 00  	.db $00,$00,$00,$00,$60,$60,$00,$00	;.
       01:6073  00 60 60  
       01:6076  00 00     
   19  01:6078  06 0C 18  	.db $06,$0c,$18,$30,$60,$c0,$00,$00	;/
       01:607B  30 60 C0  
       01:607E  00 00     
   20                     
   21  01:6080  38 4C C6  	.db $38,$4c,$c6,$c6,$c6,$64,$38,$00	;0
       01:6083  C6 C6 64  
       01:6086  38 00     
   22  01:6088  18 78 18  	.db $18,$78,$18,$18,$18,$18,$7e,$00	;1
       01:608B  18 18 18  
       01:608E  7E 00     
   23  01:6090  7C C6 0E  	.db $7c,$c6,$0e,$3c,$78,$e0,$fe,$00	;2
       01:6093  3C 78 E0  
       01:6096  FE 00     
   24  01:6098  FE 0C 18  	.db $fe,$0c,$18,$7c,$06,$c6,$7c,$00	;3
       01:609B  7C 06 C6  
       01:609E  7C 00     
   25  01:60A0  3C 6C CC  	.db $3c,$6c,$cc,$cc,$cc,$fe,$0c,$00	;4
       01:60A3  CC CC FE  
       01:60A6  0C 00     
   26  01:60A8  FE C0 FC  	.db $fe,$c0,$fc,$06,$06,$c6,$7c,$00	;5
       01:60AB  06 06 C6  
       01:60AE  7C 00     
   27  01:60B0  3C 60 C0  	.db $3c,$60,$c0,$fc,$c6,$c6,$7c,$00	;6
       01:60B3  FC C6 C6  
       01:60B6  7C 00     
   28  01:60B8  FE C6 0C  	.db $fe,$c6,$0c,$18,$30,$30,$30,$00	;7
       01:60BB  18 30 30  
       01:60BE  30 00     
   29  01:60C0  7C C6 C6  	.db $7c,$c6,$c6,$7c,$c6,$c6,$7c,$00	;8
       01:60C3  7C C6 C6  
       01:60C6  7C 00     
   30  01:60C8  7C C6 C6  	.db $7c,$c6,$c6,$7e,$06,$0c,$78,$00	;9
       01:60CB  7E 06 0C  
       01:60CE  78 00     
   31  01:60D0  00 18 18  	.db $00,$18,$18,$00,$18,$18,$00,$00	;:
       01:60D3  00 18 18  
       01:60D6  00 00     
   32  01:60D8  00 18 18  	.db $00,$18,$18,$00,$18,$18,$30,$00	;;
       01:60DB  00 18 18  
       01:60DE  30 00     
   33  01:60E0  0C 18 30  	.db $0c,$18,$30,$60,$30,$18,$0c,$00	;<
       01:60E3  60 30 18  
       01:60E6  0C 00     
   34  01:60E8  00 00 7C  	.db $00,$00,$7c,$00,$7c,$00,$00,$00	;=
       01:60EB  00 7C 00  
       01:60EE  00 00     
   35  01:60F0  60 30 18  	.db $60,$30,$18,$0c,$18,$30,$60,$00	;>
       01:60F3  0C 18 30  
       01:60F6  60 00     
   36  01:60F8  7C C6 9E  	.db $7c,$c6,$9e,$38,$20,$00,$30,$00	;?
       01:60FB  38 20 00  
       01:60FE  30 00     
   37                     
   38  01:6100  3C 42 9A  	.db $3c,$42,$9a,$aa,$aa,$5c,$00,$00	;@
       01:6103  AA AA 5C  
       01:6106  00 00     
   39  01:6108  38 6C C6  	.db $38,$6c,$c6,$c6,$fe,$c6,$c6,$00	;A
       01:610B  C6 FE C6  
       01:610E  C6 00     
   40  01:6110  FC C6 C6  	.db $fc,$c6,$c6,$fc,$c6,$c6,$fc,$00	;B
       01:6113  FC C6 C6  
       01:6116  FC 00     
   41  01:6118  3C 66 C0  	.db $3c,$66,$c0,$c0,$c0,$66,$3c,$00	;C
       01:611B  C0 C0 66  
       01:611E  3C 00     
   42  01:6120  F8 CC C6  	.db $f8,$cc,$c6,$c6,$c6,$cc,$f8,$00	;D
       01:6123  C6 C6 CC  
       01:6126  F8 00     
   43  01:6128  FE C0 C0  	.db $fe,$c0,$c0,$fc,$c0,$c0,$fe,$00	;E
       01:612B  FC C0 C0  
       01:612E  FE 00     
   44  01:6130  FE C0 C0  	.db $fe,$c0,$c0,$fc,$c0,$c0,$c0,$00	;F
       01:6133  FC C0 C0  
       01:6136  C0 00     
   45  01:6138  3C 66 C0  	.db $3c,$66,$c0,$ce,$c6,$66,$3e,$00	;G
       01:613B  CE C6 66  
       01:613E  3E 00     
   46  01:6140  C6 C6 C6  	.db $c6,$c6,$c6,$fe,$c6,$c6,$c6,$00	;H
       01:6143  FE C6 C6  
       01:6146  C6 00     
   47  01:6148  7E 18 18  	.db $7e,$18,$18,$18,$18,$18,$7e,$00	;I
       01:614B  18 18 18  
       01:614E  7E 00     
   48  01:6150  06 06 06  	.db $06,$06,$06,$06,$06,$c6,$7c,$00	;J
       01:6153  06 06 C6  
       01:6156  7C 00     
   49  01:6158  C6 CC D8  	.db $c6,$cc,$d8,$f0,$d8,$cc,$c6,$00	;K
       01:615B  F0 D8 CC  
       01:615E  C6 00     
   50  01:6160  C0 C0 C0  	.db $c0,$c0,$c0,$c0,$c0,$c0,$fe,$00	;L
       01:6163  C0 C0 C0  
       01:6166  FE 00     
   51  01:6168  82 C6 EE  	.db $82,$c6,$ee,$fe,$d6,$c6,$c6,$00	;M
       01:616B  FE D6 C6  
       01:616E  C6 00     
   52  01:6170  86 C6 E6  	.db $86,$c6,$e6,$f6,$de,$ce,$c6,$00	;N
       01:6173  F6 DE CE  
       01:6176  C6 00     
   53  01:6178  7C C6 C6  	.db $7c,$c6,$c6,$c6,$c6,$c6,$7c,$00	;O
       01:617B  C6 C6 C6  
       01:617E  7C 00     
   54                     
   55  01:6180  FC C6 C6  	.db $fc,$c6,$c6,$c6,$fc,$c0,$c0,$00	;P
       01:6183  C6 FC C0  
       01:6186  C0 00     
   56  01:6188  7C C6 C6  	.db $7c,$c6,$c6,$c6,$de,$cc,$76,$00	;Q
       01:618B  C6 DE CC  
       01:618E  76 00     
   57  01:6190  FC C6 C6  	.db $fc,$c6,$c6,$fc,$d8,$cc,$c6,$00	;R
       01:6193  FC D8 CC  
       01:6196  C6 00     
   58  01:6198  7C C6 F0  	.db $7c,$c6,$f0,$7c,$1e,$c6,$7c,$00	;S
       01:619B  7C 1E C6  
       01:619E  7C 00     
   59  01:61A0  7E 18 18  	.db $7e,$18,$18,$18,$18,$18,$18,$00	;T
       01:61A3  18 18 18  
       01:61A6  18 00     
   60  01:61A8  C6 C6 C6  	.db $c6,$c6,$c6,$c6,$c6,$c6,$7c,$00	;U
       01:61AB  C6 C6 C6  
       01:61AE  7C 00     
   61  01:61B0  C6 C6 C6  	.db $c6,$c6,$c6,$c6,$c6,$6c,$38,$00	;V
       01:61B3  C6 C6 6C  
       01:61B6  38 00     
   62  01:61B8  C6 C6 C6  	.db $c6,$c6,$c6,$d6,$fe,$ee,$c6,$00	;W
       01:61BB  D6 FE EE  
       01:61BE  C6 00     
   63  01:61C0  C6 EE 7C  	.db $c6,$ee,$7c,$38,$7c,$ee,$c6,$00	;X
       01:61C3  38 7C EE  
       01:61C6  C6 00     
   64  01:61C8  66 66 66  	.db $66,$66,$66,$3c,$18,$18,$18,$00	;Y
       01:61CB  3C 18 18  
       01:61CE  18 00     
   65  01:61D0  FE 0E 1C  	.db $fe,$0e,$1c,$38,$70,$e0,$fe,$00	;Z
       01:61D3  38 70 E0  
       01:61D6  FE 00     
   66  01:61D8  78 60 60  	.db $78,$60,$60,$60,$60,$60,$78,$00	;[
       01:61DB  60 60 60  
       01:61DE  78 00     
   67  01:61E0  C0 60 30  	.db $c0,$60,$30,$18,$0c,$06,$00,$00	;\
       01:61E3  18 0C 06  
       01:61E6  00 00     
   68  01:61E8  3C 0C 0C  	.db $3c,$0c,$0c,$0c,$0c,$0c,$3c,$00	;]
       01:61EB  0C 0C 0C  
       01:61EE  3C 00     
   69  01:61F0  10 28 44  	.db $10,$28,$44,$00,$00,$00,$00,$00	;^
       01:61F3  00 00 00  
       01:61F6  00 00     
   70  01:61F8  00 00 00  	.db $00,$00,$00,$00,$00,$00,$fe,$00	;_
       01:61FB  00 00 00  
       01:61FE  FE 00     
   71                     
   72  01:6200  00 00 00  	.db $00,$00,$00,$00,$00,$00,$00,$00	; 
       01:6203  00 00 00  
       01:6206  00 00     
   73  01:6208  00 00 3C  	.db $00,$00,$3c,$06,$7e,$c6,$7e,$00	;a
       01:620B  06 7E C6  
       01:620E  7E 00     
   74  01:6210  C0 C0 FC  	.db $c0,$c0,$fc,$c6,$c6,$c6,$fc,$00	;b
       01:6213  C6 C6 C6  
       01:6216  FC 00     
   75  01:6218  00 00 7C  	.db $00,$00,$7c,$c6,$c0,$c6,$7c,$00	;c
       01:621B  C6 C0 C6  
       01:621E  7C 00     
   76  01:6220  06 06 7E  	.db $06,$06,$7e,$c6,$c6,$c6,$7e,$00	;d
       01:6223  C6 C6 C6  
       01:6226  7E 00     
   77  01:6228  00 00 7C  	.db $00,$00,$7c,$c6,$fc,$c0,$7e,$00	;e
       01:622B  C6 FC C0  
       01:622E  7E 00     
   78  01:6230  3E 60 60  	.db $3e,$60,$60,$f8,$60,$60,$60,$00	;f
       01:6233  F8 60 60  
       01:6236  60 00     
   79  01:6238  00 00 7C  	.db $00,$00,$7c,$c6,$c6,$7e,$06,$7c	;g
       01:623B  C6 C6 7E  
       01:623E  06 7C     
   80  01:6240  C0 C0 FC  	.db $c0,$c0,$fc,$c6,$c6,$c6,$c6,$00	;h
       01:6243  C6 C6 C6  
       01:6246  C6 00     
   81  01:6248  18 00 18  	.db $18,$00,$18,$18,$18,$18,$18,$00	;i
       01:624B  18 18 18  
       01:624E  18 00     
   82  01:6250  0C 0C 00  	.db $0c,$0c,$00,$0c,$0c,$0c,$0c,$78	;j
       01:6253  0C 0C 0C  
       01:6256  0C 78     
   83  01:6258  C0 C0 D8  	.db $c0,$c0,$d8,$f0,$e0,$f0,$d8,$00	;k
       01:625B  F0 E0 F0  
       01:625E  D8 00     
   84  01:6260  70 30 30  	.db $70,$30,$30,$30,$30,$30,$78,$00	;l
       01:6263  30 30 30  
       01:6266  78 00     
   85  01:6268  00 00 7C  	.db $00,$00,$7c,$d6,$d6,$d6,$d6,$00	;m
       01:626B  D6 D6 D6  
       01:626E  D6 00     
   86  01:6270  00 00 7C  	.db $00,$00,$7c,$66,$66,$66,$66,$00	;n
       01:6273  66 66 66  
       01:6276  66 00     
   87  01:6278  00 00 3C  	.db $00,$00,$3c,$66,$66,$66,$3c,$00	;o
       01:627B  66 66 66  
       01:627E  3C 00     
   88                     
   89  01:6280  00 00 7C  	.db $00,$00,$7c,$66,$66,$7c,$60,$60	;p
       01:6283  66 66 7C  
       01:6286  60 60     
   90  01:6288  00 00 3E  	.db $00,$00,$3e,$66,$66,$3e,$06,$06	;q
       01:628B  66 66 3E  
       01:628E  06 06     
   91  01:6290  00 00 D8  	.db $00,$00,$d8,$fc,$e0,$c0,$c0,$00	;r
       01:6293  FC E0 C0  
       01:6296  C0 00     
   92  01:6298  00 00 3C  	.db $00,$00,$3c,$60,$38,$0c,$78,$00	;s
       01:629B  60 38 0C  
       01:629E  78 00     
   93  01:62A0  30 30 78  	.db $30,$30,$78,$30,$30,$30,$1c,$00	;t
       01:62A3  30 30 30  
       01:62A6  1C 00     
   94  01:62A8  00 00 66  	.db $00,$00,$66,$66,$66,$66,$3e,$00	;u
       01:62AB  66 66 66  
       01:62AE  3E 00     
   95  01:62B0  00 00 C6  	.db $00,$00,$c6,$c6,$6c,$38,$10,$00	;v
       01:62B3  C6 6C 38  
       01:62B6  10 00     
   96  01:62B8  00 00 C6  	.db $00,$00,$c6,$d6,$d6,$d6,$6c,$00	;w
       01:62BB  D6 D6 D6  
       01:62BE  6C 00     
   97  01:62C0  00 00 C6  	.db $00,$00,$c6,$6c,$10,$6c,$c6,$00	;x
       01:62C3  6C 10 6C  
       01:62C6  C6 00     
   98  01:62C8  00 00 66  	.db $00,$00,$66,$66,$66,$3e,$06,$3c	;y
       01:62CB  66 66 3E  
       01:62CE  06 3C     
   99  01:62D0  00 00 FE  	.db $00,$00,$fe,$0c,$38,$60,$fe,$00	;z
       01:62D3  0C 38 60  
       01:62D6  FE 00     
  100  01:62D8  00 00 00  	.db $00,$00,$00,$00,$00,$00,$00,$00	;
       01:62DB  00 00 00  
       01:62DE  00 00     
  101  01:62E0  00 00 00  	.db $00,$00,$00,$00,$00,$00,$00,$00	;
       01:62E3  00 00 00  
       01:62E6  00 00     
  102  01:62E8  00 00 00  	.db $00,$00,$00,$00,$00,$00,$00,$00	;
       01:62EB  00 00 00  
       01:62EE  00 00     
  103  01:62F0  00 00 00  	.db $00,$00,$00,$00,$00,$00,$00,$00	;
       01:62F3  00 00 00  
       01:62F6  00 00     
  104  01:62F8  00 00 00  	.db $00,$00,$00,$00,$00,$00,$00,$00	;
       01:62FB  00 00 00  
       01:62FE  00 00     
  105                     
  106  01:6300            font_2:
  107  01:6300  00 00 00  	.db $00,$00,$00,$00,$00,$00,$00,$00	;SPACE
       01:6303  00 00 00  
       01:6306  00 00     
  108  01:6308  04 0C 0C  	.db $04,$0c,$0c,$08,$08,$00,$10,$00	;!
       01:630B  08 08 00  
       01:630E  10 00     
  109  01:6310  36 12 24  	.db $36,$12,$24,$00,$00,$00,$00,$00	;"
       01:6313  00 00 00  
       01:6316  00 00     
  110  01:6318  12 3F 12  	.db $12,$3f,$12,$22,$24,$7e,$24,$00	;#
       01:631B  22 24 7E  
       01:631E  24 00     
  111  01:6320  00 00 00  	.db $00,$00,$00,$00,$00,$00,$00,$00	;$
       01:6323  00 00 00  
       01:6326  00 00     
  112  01:6328  00 31 32  	.db $00,$31,$32,$04,$18,$26,$46,$00	;%
       01:632B  04 18 26  
       01:632E  46 00     
  113  01:6330  08 14 14  	.db $08,$14,$14,$38,$4a,$44,$3a,$00	;&
       01:6333  38 4A 44  
       01:6336  3A 00     
  114  01:6338  18 08 10  	.db $18,$08,$10,$00,$00,$00,$00,$00	;'
       01:633B  00 00 00  
       01:633E  00 00     
  115  01:6340  0C 10 20  	.db $0c,$10,$20,$20,$20,$10,$08,$00	;(
       01:6343  20 20 10  
       01:6346  08 00     
  116  01:6348  10 08 04  	.db $10,$08,$04,$04,$04,$08,$30,$00	;)
       01:634B  04 04 08  
       01:634E  30 00     
  117  01:6350  00 08 2A  	.db $00,$08,$2a,$1c,$1c,$2a,$08,$00	;*
       01:6353  1C 1C 2A  
       01:6356  08 00     
  118  01:6358  00 08 08  	.db $00,$08,$08,$3e,$08,$08,$00,$00	;+
       01:635B  3E 08 08  
       01:635E  00 00     
  119  01:6360  00 00 00  	.db $00,$00,$00,$00,$60,$60,$20,$40	;,
       01:6363  00 60 60  
       01:6366  20 40     
  120  01:6368  00 00 00  	.db $00,$00,$00,$1e,$00,$00,$00,$00	;-
       01:636B  1E 00 00  
       01:636E  00 00     
  121  01:6370  00 00 00  	.db $00,$00,$00,$00,$00,$60,$60,$00	;.
       01:6373  00 00 60  
       01:6376  60 00     
  122  01:6378  00 02 04  	.db $00,$02,$04,$08,$10,$20,$40,$00	;/
       01:637B  08 10 20  
       01:637E  40 00     
  123                     
  124  01:6380  1C 22 22  	.db $1c,$22,$22,$42,$42,$44,$38,$00	;0
       01:6383  42 42 44  
       01:6386  38 00     
  125  01:6388  0C 1C 04  	.db $0c,$1c,$04,$08,$08,$08,$3c,$00	;1
       01:638B  08 08 08  
       01:638E  3C 00     
  126  01:6390  1C 22 02  	.db $1c,$22,$02,$0c,$30,$40,$7c,$00	;2
       01:6393  0C 30 40  
       01:6396  7C 00     
  127  01:6398  1C 22 02  	.db $1c,$22,$02,$0c,$02,$44,$38,$00	;3
       01:639B  0C 02 44  
       01:639E  38 00     
  128  01:63A0  0E 12 24  	.db $0e,$12,$24,$44,$7f,$08,$08,$00	;4
       01:63A3  44 7F 08  
       01:63A6  08 00     
  129  01:63A8  1F 10 20  	.db $1f,$10,$20,$3c,$02,$42,$3c,$00	;5
       01:63AB  3C 02 42  
       01:63AE  3C 00     
  130  01:63B0  1E 21 20  	.db $1e,$21,$20,$7c,$42,$42,$3c,$00	;6
       01:63B3  7C 42 42  
       01:63B6  3C 00     
  131  01:63B8  3E 22 44  	.db $3e,$22,$44,$04,$08,$08,$10,$00	;7
       01:63BB  04 08 08  
       01:63BE  10 00     
  132  01:63C0  1C 22 22  	.db $1c,$22,$22,$3c,$42,$42,$3c,$00	;8
       01:63C3  3C 42 42  
       01:63C6  3C 00     
  133  01:63C8  1C 22 22  	.db $1c,$22,$22,$1e,$02,$44,$38,$00	;9
       01:63CB  1E 02 44  
       01:63CE  38 00     
  134  01:63D0  00 00 08  	.db $00,$00,$08,$00,$00,$00,$10,$00	;:
       01:63D3  00 00 00  
       01:63D6  10 00     
  135  01:63D8  00 00 08  	.db $00,$00,$08,$00,$00,$00,$10,$20	;;
       01:63DB  00 00 00  
       01:63DE  10 20     
  136  01:63E0  00 04 08  	.db $00,$04,$08,$10,$10,$08,$04,$00	;<
       01:63E3  10 10 08  
       01:63E6  04 00     
  137  01:63E8  00 00 00  	.db $00,$00,$00,$1e,$00,$1e,$00,$00	;=
       01:63EB  1E 00 1E  
       01:63EE  00 00     
  138  01:63F0  00 10 08  	.db $00,$10,$08,$04,$04,$08,$10,$00	;>
       01:63F3  04 04 08  
       01:63F6  10 00     
  139  01:63F8  1C 22 02  	.db $1c,$22,$02,$04,$08,$00,$10,$00	;?
       01:63FB  04 08 00  
       01:63FE  10 00     
  140                     
  141  01:6400  00 00 00  	.db $00,$00,$00,$00,$00,$00,$00,$00	;@
       01:6403  00 00 00  
       01:6406  00 00     
  142  01:6408  0E 12 12  	.db $0e,$12,$12,$22,$3e,$42,$42,$00	;A
       01:640B  22 3E 42  
       01:640E  42 00     
  143  01:6410  1C 12 22  	.db $1c,$12,$22,$3c,$22,$42,$7c,$00	;B
       01:6413  3C 22 42  
       01:6416  7C 00     
  144  01:6418  1C 22 22  	.db $1c,$22,$22,$40,$40,$44,$38,$00	;C
       01:641B  40 40 44  
       01:641E  38 00     
  145  01:6420  18 14 22  	.db $18,$14,$22,$22,$42,$44,$f8,$00	;D
       01:6423  22 42 44  
       01:6426  F8 00     
  146  01:6428  1E 10 20  	.db $1e,$10,$20,$3c,$20,$40,$7c,$00	;E
       01:642B  3C 20 40  
       01:642E  7C 00     
  147  01:6430  1E 10 20  	.db $1e,$10,$20,$3c,$20,$40,$40,$00	;F
       01:6433  3C 20 40  
       01:6436  40 00     
  148  01:6438  1C 22 20  	.db $1c,$22,$20,$40,$47,$44,$38,$00	;G
       01:643B  40 47 44  
       01:643E  38 00     
  149  01:6440  11 11 22  	.db $11,$11,$22,$3e,$22,$44,$44,$00	;H
       01:6443  3E 22 44  
       01:6446  44 00     
  150  01:6448  1E 08 08  	.db $1e,$08,$08,$10,$10,$20,$f0,$00	;I
       01:644B  10 10 20  
       01:644E  F0 00     
  151  01:6450  1E 04 04  	.db $1e,$04,$04,$08,$88,$90,$60,$00	;J
       01:6453  08 88 90  
       01:6456  60 00     
  152  01:6458  10 12 24  	.db $10,$12,$24,$38,$28,$44,$44,$00	;K
       01:645B  38 28 44  
       01:645E  44 00     
  153  01:6460  10 10 20  	.db $10,$10,$20,$20,$20,$40,$7c,$00	;L
       01:6463  20 20 40  
       01:6466  7C 00     
  154  01:6468  21 27 5A  	.db $21,$27,$5a,$52,$42,$84,$84,$00	;M
       01:646B  52 42 84  
       01:646E  84 00     
  155  01:6470  21 21 52  	.db $21,$21,$52,$52,$4a,$84,$84,$00	;N
       01:6473  52 4A 84  
       01:6476  84 00     
  156  01:6478  1C 22 22  	.db $1c,$22,$22,$42,$42,$44,$38,$00	;O
       01:647B  42 42 44  
       01:647E  38 00     
  157                     
  158  01:6480  1C 12 22  	.db $1c,$12,$22,$3c,$20,$40,$40,$00	;P
       01:6483  3C 20 40  
       01:6486  40 00     
  159  01:6488  1C 22 22  	.db $1c,$22,$22,$42,$4a,$44,$34,$02	;Q
       01:648B  42 4A 44  
       01:648E  34 02     
  160  01:6490  1C 12 22  	.db $1c,$12,$22,$3c,$28,$48,$46,$00	;R
       01:6493  3C 28 48  
       01:6496  46 00     
  161  01:6498  1C 22 20  	.db $1c,$22,$20,$18,$04,$44,$38,$00	;S
       01:649B  18 04 44  
       01:649E  38 00     
  162  01:64A0  3E 08 10  	.db $3e,$08,$10,$10,$10,$20,$20,$00	;T
       01:64A3  10 10 20  
       01:64A6  20 00     
  163  01:64A8  22 22 42  	.db $22,$22,$42,$44,$44,$44,$38,$00	;U
       01:64AB  44 44 44  
       01:64AE  38 00     
  164  01:64B0  42 44 44  	.db $42,$44,$44,$48,$50,$50,$60,$00	;V
       01:64B3  48 50 50  
       01:64B6  60 00     
  165  01:64B8  41 41 42  	.db $41,$41,$42,$52,$52,$6c,$44,$00	;W
       01:64BB  52 52 6C  
       01:64BE  44 00     
  166  01:64C0  22 24 18  	.db $22,$24,$18,$18,$28,$44,$44,$00	;X
       01:64C3  18 28 44  
       01:64C6  44 00     
  167  01:64C8  42 42 24  	.db $42,$42,$24,$18,$10,$20,$20,$00	;Y
       01:64CB  18 10 20  
       01:64CE  20 00     
  168  01:64D0  3E 02 04  	.db $3e,$02,$04,$18,$20,$40,$7c,$00	;Z
       01:64D3  18 20 40  
       01:64D6  7C 00     
  169  01:64D8  00 00 00  	.db $00,$00,$00,$00,$00,$00,$00,$00	;[
       01:64DB  00 00 00  
       01:64DE  00 00     
  170  01:64E0  00 00 00  	.db $00,$00,$00,$00,$00,$00,$00,$00	;\
       01:64E3  00 00 00  
       01:64E6  00 00     
  171  01:64E8  00 00 00  	.db $00,$00,$00,$00,$00,$00,$00,$00	;]
       01:64EB  00 00 00  
       01:64EE  00 00     
  172  01:64F0  00 00 00  	.db $00,$00,$00,$00,$00,$00,$00,$00	;^
       01:64F3  00 00 00  
       01:64F6  00 00     
  173  01:64F8  00 00 00  	.db $00,$00,$00,$00,$00,$00,$3e,$00	;_
       01:64FB  00 00 00  
       01:64FE  3E 00     
  174                     
  175  01:6500  00 10 18  	.db $00,$10,$18,$18,$00,$00,$00,$00	; 
       01:6503  18 00 00  
       01:6506  00 00     
  176  01:6508  00 1C 02  	.db $00,$1c,$02,$3c,$44,$48,$34,$00	;a
       01:650B  3C 44 48  
       01:650E  34 00     
  177  01:6510  00 08 08  	.db $00,$08,$08,$1c,$12,$22,$3c,$00	;b
       01:6513  1C 12 22  
       01:6516  3C 00     
  178  01:6518  00 00 1C  	.db $00,$00,$1c,$22,$40,$40,$38,$00	;c
       01:651B  22 40 40  
       01:651E  38 00     
  179  01:6520  00 02 02  	.db $00,$02,$02,$3c,$44,$48,$38,$00	;d
       01:6523  3C 44 48  
       01:6526  38 00     
  180  01:6528  00 00 1C  	.db $00,$00,$1c,$22,$7e,$40,$38,$00	;e
       01:652B  22 7E 40  
       01:652E  38 00     
  181  01:6530  00 06 08  	.db $00,$06,$08,$3c,$10,$20,$20,$00	;f
       01:6533  3C 10 20  
       01:6536  20 00     
  182  01:6538  00 00 3A  	.db $00,$00,$3a,$44,$44,$38,$08,$70	;g
       01:653B  44 44 38  
       01:653E  08 70     
  183  01:6540  00 08 08  	.db $00,$08,$08,$1c,$12,$22,$24,$00	;h
       01:6543  1C 12 22  
       01:6546  24 00     
  184  01:6548  00 04 00  	.db $00,$04,$00,$08,$08,$10,$10,$00	;i
       01:654B  08 08 10  
       01:654E  10 00     
  185  01:6550  00 02 00  	.db $00,$02,$00,$04,$44,$48,$38,$00	;j
       01:6553  04 44 48  
       01:6556  38 00     
  186  01:6558  00 10 12  	.db $00,$10,$12,$24,$38,$48,$46,$00	;k
       01:655B  24 38 48  
       01:655E  46 00     
  187  01:6560  00 0C 04  	.db $00,$0c,$04,$08,$08,$10,$10,$00	;l
       01:6563  08 08 10  
       01:6566  10 00     
  188  01:6568  00 00 2A  	.db $00,$00,$2a,$15,$25,$29,$4a,$00	;m
       01:656B  15 25 29  
       01:656E  4A 00     
  189  01:6570  00 00 2C  	.db $00,$00,$2c,$12,$12,$24,$26,$00	;n
       01:6573  12 12 24  
       01:6576  26 00     
  190  01:6578  00 00 0C  	.db $00,$00,$0c,$12,$22,$24,$18,$00	;o
       01:657B  12 22 24  
       01:657E  18 00     
  191                     
  192  01:6580  00 0E 09  	.db $00,$0e,$09,$11,$1e,$20,$20,$00	;p
       01:6583  11 1E 20  
       01:6586  20 00     
  193  01:6588  00 1E 22  	.db $00,$1e,$22,$24,$1c,$08,$08,$00	;q
       01:658B  24 1C 08  
       01:658E  08 00     
  194  01:6590  00 00 2C  	.db $00,$00,$2c,$12,$10,$20,$20,$00	;r
       01:6593  12 10 20  
       01:6596  20 00     
  195  01:6598  00 00 1C  	.db $00,$00,$1c,$22,$18,$44,$38,$00	;s
       01:659B  22 18 44  
       01:659E  38 00     
  196  01:65A0  00 08 3C  	.db $00,$08,$3c,$10,$20,$20,$18,$00	;t
       01:65A3  10 20 20  
       01:65A6  18 00     
  197  01:65A8  00 00 22  	.db $00,$00,$22,$42,$44,$48,$34,$00	;u
       01:65AB  42 44 48  
       01:65AE  34 00     
  198  01:65B0  00 00 22  	.db $00,$00,$22,$24,$28,$28,$10,$00	;v
       01:65B3  24 28 28  
       01:65B6  10 00     
  199  01:65B8  00 00 21  	.db $00,$00,$21,$41,$49,$5a,$2c,$00	;w
       01:65BB  41 49 5A  
       01:65BE  2C 00     
  200  01:65C0  00 00 11  	.db $00,$00,$11,$0a,$0c,$14,$22,$00	;x
       01:65C3  0A 0C 14  
       01:65C6  22 00     
  201  01:65C8  00 00 11  	.db $00,$00,$11,$21,$22,$1e,$04,$38	;y
       01:65CB  21 22 1E  
       01:65CE  04 38     
  202  01:65D0  00 00 3E  	.db $00,$00,$3e,$04,$18,$20,$7c,$00	;z
       01:65D3  04 18 20  
       01:65D6  7C 00     
  203  01:65D8  00 00 00  	.db $00,$00,$00,$00,$00,$00,$00,$00	;
       01:65DB  00 00 00  
       01:65DE  00 00     
  204  01:65E0  00 00 00  	.db $00,$00,$00,$00,$00,$00,$00,$00	;
       01:65E3  00 00 00  
       01:65E6  00 00     
  205  01:65E8  00 00 00  	.db $00,$00,$00,$00,$00,$00,$00,$00	;
       01:65EB  00 00 00  
       01:65EE  00 00     
  206  01:65F0  00 00 00  	.db $00,$00,$00,$00,$00,$00,$00,$00	;
       01:65F3  00 00 00  
       01:65F6  00 00     
  207  01:65F8  00 00 00  	.db $00,$00,$00,$00,$00,$00,$00,$00	;
       01:65FB  00 00 00  
       01:65FE  00 00     
#[2]   startup.asm
  181           E000      	.code
  182           0001      	.bank LIB2_BANK
  183           A600      	.org  $A600
  184                     
  185           0000      .ifdef HAVE_LIB3
  189                     .endif
  190                     
  191           6600      	.data
  192           0002      	.bank CONST_BANK,"Constants"
  193           4000      	.org  $4000
  194                     
  195           4000      	.data
  196           0003      	.bank DATA_BANK,"User Program"
  197           6000      	.org  $6000
  198                     
  199                     ;
  200                     ; place overlay array here
  201                     ; 100 entries, stored as 100
  202                     ; lo-bytes of the starting
  203                     ; sector num, followed by 100
  204                     ; hi-bytes for a 128MB range
  205                     ; all files are contiguous, so
  206                     ; the # sectors is calculated
  207                     ;
  208  03:6000            ovlarray:	.ds	200
  209                     
  210                     
  211           A600      	.code
  212           0000      	.bank START_BANK,"Base Library 1"
  213                     
  214                     ; A little introduction to the boot sequence:
  215                     ;
  216                     ; A HuCard has its origin at bank 0, and is mapped at $E000
  217                     ; It needs to grab the interrupt vectors at $FFF6 and implement
  218                     ; implement handlers for them
  219                     ;
  220                     ; A CDROM will load at bank $80 ($68 for SCD), and the initial
  221                     ; loader will be mapped at $4000.  The current MagicKit sequence
  222                     ; also maps $C000 to this same bank.  However, the initial boot
  223                     ; sequence will execute at $4070, proceeding to load additional
  224                     ; code and data, and then jump to a post-boot section called
  225                     ; 'init_go'.  This is the point at which the loader explicitly
  226                     ; relinquishes the $4000 segment.  It should be noted that there
  227                     ; are library subroutines loaded as part of this initial segment,
  228                     ; and those routines are located in the $C000 range as well.
  229                     ;
  230                     ; Sectors are loaded, up to and including the first "DATA_BANK",
  231                     ; where the overlay array is stored - so that the CDROM error
  232                     ; overlay can be located and executed in the event of a CDROM
  233                     ; system version mismatch (ie. playing SCD games on CDROM)
  234                     ;
  235                     ; A second entry point is defined for overlays that are not
  236                     ; being booted (ie. they are loaded and executed from another
  237                     ; overlay).  This entry point is at $4000, after the segments
  238                     ; have all found their natural loading spots (ie. segment $68
  239                     ; for Super CDROMs).  This entry point maps the necessary
  240                     ; segments and resets the stack, without clearing memory or
  241                     ; performing other setup chores, and then maps and executes
  242                     ; _main() to run the module.  The user has no choice regarding
  243                     ; this function, although he can pass values through the global
  244                     ; variables which main() can use to decide what to do next.
  245                     ;
  246                     ; An additional "Hook" area has now been defined at $402F,
  247                     ; which is used at initial load time, in case a SCD overlay
  248                     ; program is run on plain CDROM hardware, and the author
  249                     ; wishes to override the default text error message by
  250                     ; loading and executing a plain CDROM program instead
  251                     ;
  252                         ; ----
  253                         ; interrupt vectors
  254                     
  255           0000      .if !(CDROM)
  263                     .endif	; !(CDROM)
  264                     
  265                         ; ----
  266                         ; develo startup code
  267                     
  268           0000      .if (DEVELO)
  278                     .endif	; (DEVELO)
  279                     
  280                     
  281                     ; ----
  282                     ; reset
  283                     ; ----
  284                     ; things start here
  285                     ; ----
  286                     
  287                         ; ----
  288                         ; CDROM re-map library bank
  289                         ;
  290                     ;
  291                     ; overlay entry point
  292                     ;
  293                     ; assume MMR0, MMR1, MMR6, MMR7 are set.
  294                     ; set others & reset stack pointer
  295                     ;
  296           0001      .if (CDROM)
  297           C000      	.org $C000
  298                     
  299  00:C000            ovlentry:
  300                             ; current overlay number that is running
  301                             ; this is overwritten by the isolink prgram; the load
  302                             ; statement must be the first in the block
  303  00:C000  A9 01     	lda  #1
  304  00:C002  8D E3 26  	sta  ovl_running
  305                     
  306  00:C005  A9 82     	lda  #CONST_BANK+_bank_base
  307  00:C007  53 04     	tam  #2
  308  00:C009  A9 83     	lda  #DATA_BANK+_bank_base
  309  00:C00B  53 08     	tam  #3
  310  00:C00D  A9 85     	lda  #_call_bank
  311  00:C00F  53 10     	tam  #4
  312                     
  313           0001      .ifndef SMALL
  314                     	stw  #$4000,<__sp
       00:C011  A9 00     	lda	LOW_BYTE #$4000
       00:C013  85 00     	sta	LOW_BYTE <__sp
       00:C015  A9 40     	lda	HIGH_BYTE #$4000
       00:C017  85 01     	sta	HIGH_BYTE <__sp
  315                     .else
  317                     .endif
  318  00:C019  A2 FF     	ldx  #$ff
  319  00:C01B  9A        	txs
  320                     
  321           0000      .ifdef HAVE_INIT
  323                     .endif
  324                     
  325           0000      .ifdef LINK_malloc
  327                     .endif
  328                     
  329                     	map  _main
       00:C01C  A9 84     	lda	#bank(_main)	; addressable memory
       00:C01E  53 20     	tam	#page(_main)
  330  00:C020  20 00 A0  	jsr  _main
  331  00:C023  80 FE     	bra  *
  332                     
  333                     ;
  334                     ; CDROM error message alternate load entry point
  335                     ;
  336           402F      	.org  $402F
  337                     
  338  00:402F  00        cderr_override:		.db	0
  339  00:4030  00        cderr_overlay_num:	.db	0
  340                     
  341  00:4031            cdrom_err_load:
  342                     
  343                     	; since CDROM program will load into same area in RAM,
  344                     	; this load routine must be executed from scratch RAM
  345                     	; re-use the ram interrupt handler areas (not yet initialized)
  346                     
  347  00:4031  73 3B 40  	tii	.load_cd_ovl, ram_vsync_hndl, 64
       00:4034  E7 26 40  
       00:4037  00        
  348  00:4038  4C E7 26  	jmp	ram_vsync_hndl
  349                     
  350  00:403B            .load_cd_ovl:
  351  00:403B  AC 30 40  	ldy	cderr_overlay_num
  352  00:403E  A9 83     	lda	#DATA_BANK+$80
  353  00:4040  53 08     	tam	#3
  354  00:4042  B9 00 60  	lda	ovlarray,Y
  355  00:4045  BE 64 60  	ldx	ovlarray + 100,Y
  356  00:4048  64 FC     	stz	<__cl		; sector (offset from base of track)
  357  00:404A  86 FD     	stx	<__ch
  358  00:404C  85 FE     	sta	<__dl
  359  00:404E  38        	sec
  360  00:404F  49 FF     	eor	#$FF
  361  00:4051  79 01 60  	adc	ovlarray + 1,Y
  362  00:4054  85 F8     	sta	<__al		; # sectors
  363  00:4056  A9 80     	lda	#$80
  364  00:4058  85 FA     	sta	<__bl		; bank #
  365  00:405A  A9 03     	lda	#3
  366  00:405C  85 FF     	sta	<__dh		; MPR #
  367  00:405E  20 09 E0  	jsr	cd_read
  368  00:4061  C9 00     	cmp	#0
  369  00:4063  D0 07     	bne	.error
  370  00:4065  A9 80     	lda	#$80
  371  00:4067  53 04     	tam	#2
  372  00:4069  4C 70 40  	jmp	.boot
  373                     
  374  00:406C  4C 00 E0  .error:	jmp	cd_boot		; Can't load - reboot CDROM system card
  375                     	
  376                     
  377                     ;
  378                     ; Proper Boot-time entry point
  379                     ;
  380           4070      	.org  $4070
  381  00:4070            .boot:
  382  00:4070  9C 80 26  	stz   $2680		; clear program RAM
  383  00:4073  73 80 26  	tii   $2680,$2681,$197F
       00:4076  81 26 7F  
       00:4079  19        
  384                     
  385                     ;
  386                     ; Note: All CDROM boot loaders will load into MMR $80 region
  387                     ;       regardless of whether they are CD or SCD.
  388                     ;       Here, we will move the information to occupy
  389                     ;       base memory at MMR $68 if appropriate
  390                     ;
  391           0000      .if (CDROM = SUPER_CD)
  407                     .endif	; (CDROM = SUPER_CD)
  408                     
  409                     .else		; (ie. if HuCard...)
  425                     .endif	; (CDROM)
  426                     
  427                         ; ----
  428                         ; initialize the hardware
  429                     
  430           0001      .if (CDROM)
  431  00:407A  20 99 E0  	jsr   ex_dspoff
  432  00:407D  20 81 E0  	jsr   ex_rcroff
  433  00:4080  20 87 E0  	jsr   ex_irqoff
  434  00:4083  20 30 E0  	jsr   ad_reset
  435                     .else
  437                     .endif	; (CDROM)
  438                     
  439  00:4086  20 33 C5  	jsr   init_psg		; init sound
  440  00:4089  20 D4 C4  	jsr   init_vdc		; init video
  441           0000      .ifdef _SGX
  443                     .endif
  444  00:408C  A9 1F     	lda   #$1F		; init joypad
  445  00:408E  8D 27 22  	sta   joyena
  446                     
  447                         ; ----
  448                         ; initialize the sound driver
  449                     
  450                     	__sound_init
  451                     
  452                         ; ----
  453                         ; initialize interrupt vectors
  454                     
  455           0001      .if  (CDROM)
  456  00:4091  20 96 E0  	jsr	ex_dspon
  457  00:4094  20 7E E0  	jsr	ex_rcron
  458  00:4097  20 84 E0  	jsr	ex_irqon
  459  00:409A  9C 8E 26  	stz	disp_cr		; "no change"
  460                     .else
  492                     .endif	; (CDROM)
  493                     
  494                         ; ----
  495                         ; init TIA instruction in RAM (fast BLiTter to hardware)
  496                     
  497  00:409D  A9 E3     	lda   #$E3		; TIA instruction opcode
  498  00:409F  8D 34 27  	sta   ram_hdwr_tia
  499  00:40A2  A9 60     	lda   #$60		; RTS instruction opcode
  500  00:40A4  8D 3B 27  	sta   ram_hdwr_tia_rts
  501                     
  502                         ; ----
  503                         ; init random number generator
  504                     
  505  00:40A7  A9 01     	lda   #1
  506  00:40A9  20 8F DD  	jsr   wait_vsync	; wait for one frame & randomize rndseed2
  507                     	stw   #$03E7,<__cx	; set random seed
       00:40AC  A9 E7     	lda	LOW_BYTE #$03E7
       00:40AE  85 FC     	sta	LOW_BYTE <__cx	
       00:40B0  A9 03     	lda	HIGH_BYTE #$03E7
       00:40B2  85 FD     	sta	HIGH_BYTE <__cx	
  508                     	stw   rndseed2,<__dx
       00:40B4  AD AB 27  	lda	LOW_BYTE rndseed2
       00:40B7  85 FE     	sta	LOW_BYTE <__dx
       00:40B9  AD AC 27  	lda	HIGH_BYTE rndseed2
       00:40BC  85 FF     	sta	HIGH_BYTE <__dx
  509  00:40BE  20 F2 C6  	jsr   srand
  510                     
  511           0001      .if (CDROM)
  512           0000      .if (CDROM = SUPER_CD)
  519                     .endif	; (SUPER_CD)
  520                     
  521                         ; ----
  522                         ; load program
  523                         ; ----
  524                         ; CL/CH/DL = sector address
  525                         ; DH = load mode - bank mode ($6000-$7FFF)
  526                         ; BL = bank index
  527                         ; AL = number of sectors
  528                         ;
  529  00:40C1            loadprog:
  530  00:40C1  AD 01 C0  	lda   ovlentry+1	; current overlay (as written by ISOLINK)
  531  00:40C4  C9 01     	cmp   #1		; is it initial overlay ?
  532                     	lbne  init_go		; if not initial overlay, somebody else already
       00:40C6  F0 03     	beq	.x_00006
       00:40C8  4C 30 C1  	jmp	init_go		
       00:40CB            .x_00006
  533                     				; loaded us completely; do not try to load remainder
  534                     				; (ie. executing CDROM error overlay)
  535                     
  536  00:40CB  64 FC     	stz   <__cl		; initial boot doesn't load complete program;
  537  00:40CD  64 FD     	stz   <__ch		; prepare to load remainder
  538  00:40CF  A9 0A     	lda   #10		; 10th sector (0-1 are boot;
  539                     				; 2-9 are this library...)
  540  00:40D1  85 FE     	sta   <__dl
  541  00:40D3  A9 03     	lda   #3		; load mode (consecutive banks; use MPR 3)
  542  00:40D5  85 FF     	sta   <__dh
  543                     	stw   #(_bank_base+2),<__bx	; 2 banks are boot/base library
       00:40D7  A9 82     	lda	LOW_BYTE #(_bank_base+2)
       00:40D9  85 FA     	sta	LOW_BYTE <__bx	
       00:40DB  A9 00     	lda	HIGH_BYTE #(_bank_base+2)
       00:40DD  85 FB     	sta	HIGH_BYTE <__bx	
  544                     	stw   #(_nb_bank-2)*4,<__ax
       00:40DF  A9 10     	lda	LOW_BYTE #(_nb_bank-2)*4
       00:40E1  85 F8     	sta	LOW_BYTE <__ax
       00:40E3  A9 00     	lda	HIGH_BYTE #(_nb_bank-2)*4
       00:40E5  85 F9     	sta	HIGH_BYTE <__ax
  545  00:40E7  20 09 E0  	jsr   cd_read
  546  00:40EA  C9 00     	cmp   #$00
  547                     	lbeq  init_go
       00:40EC  D0 03     	bne	.x_00009
       00:40EE  4C 30 C1  	jmp	init_go
       00:40F1            .x_00009
  548                     
  549                     	; ----
  550  00:40F1  4C 00 E0  	jmp   cd_boot		; reset
  551                     
  552                     
  553                     ; This is the point in the CDROM loader where the code no longer
  554                     ; executes in the $4000 segment, in favour of using the $C000
  555                     ; segment (also used for the library subroutines)
  556                     
  557           C130             .org   $C130
  558                     
  559                     
  560                     ; These routines will be run from RAM @ $2000 so we
  561                     ; need to count bytes to determine how much to xfer
  562                     ; (The total is 24 bytes, but we copy 25)
  563                     
  564           0001      	.bank	LIB2_BANK
  565                     
  566  01:A600            vsync_irq_ramhndlr:
  567  01:A600  08        	php			; 1 byte
  568  01:A601  48        	pha			; 1
  569  01:A602  43 40     	tma   #6		; 2
  570  01:A604  8D E5 26  	sta   irq_storea	; 3
  571  01:A607  A9 80     	lda   #BANK(vsync_hndl) ; 2
  572  01:A609  53 40     	tam   #6		; 2
  573  01:A60B  68        	pla			; 1
  574  01:A60C  48        	pha			; 1
  575  01:A60D  20 FC C1  	jsr   vsync_hndl	; 3
  576  01:A610  AD E5 26  	lda   irq_storea	; 3
  577  01:A613  53 40     	tam   #6		; 2
  578  01:A615  68        	pla			; 1
  579  01:A616  28        	plp			; 1
  580  01:A617  60        	rts			; 1 = 24 bytes
  581                     
  582  01:A618            hsync_irq_ramhndlr:
  583  01:A618  08        	php			; 1 byte
  584  01:A619  48        	pha			; 1
  585  01:A61A  43 40     	tma   #6		; 2
  586  01:A61C  8D E6 26  	sta   irq_storeb	; 3
  587  01:A61F  A9 80     	lda   #BANK(hsync_hndl) ; 2
  588  01:A621  53 40     	tam   #6		; 2
  589  01:A623  68        	pla			; 1
  590  01:A624  48        	pha			; 1
  591  01:A625  20 6F C2  	jsr   hsync_hndl	; 3
  592  01:A628  AD E6 26  	lda   irq_storeb	; 3
  593  01:A62B  53 40     	tam   #6		; 2
  594  01:A62D  68        	pla			; 1
  595  01:A62E  28        	plp			; 1
  596  01:A62F  60        	rts			; 1 = 24 bytes
  597                     
  598           0000      	.bank	LIB1_BANK
  599                     
  600  00:C130            init_go:
  601                     
  602           0000      .if (CDROM = SUPER_CD)
  604                     .endif
  605                     
  606                     .endif	; (CDROM)
  607                     
  608                         ; ----
  609                         ; jump to main routine
  610                     
  611                         ; ----
  612                         ; load font
  613                     
  614           0001      .ifdef HUC
  615                     
  616           0001      .ifndef SMALL
  617                     	stw   #$4000,<__sp	; init stack ptr first
       00:C130  A9 00     	lda	LOW_BYTE #$4000
       00:C132  85 00     	sta	LOW_BYTE <__sp	
       00:C134  A9 40     	lda	HIGH_BYTE #$4000
       00:C136  85 01     	sta	HIGH_BYTE <__sp	
  618                     .else
  620                     .endif
  621                     
  622                     	stw   #FONT_VADDR,<__di	; Load Font @ VRAM addr
       00:C138  A9 00     	lda	LOW_BYTE #FONT_VADDR
       00:C13A  85 F0     	sta	LOW_BYTE <__di	
       00:C13C  A9 08     	lda	HIGH_BYTE #FONT_VADDR
       00:C13E  85 F1     	sta	HIGH_BYTE <__di	
  623                     
  624                     	;
  625                     	; this section of font loading was stolen
  626                     	; from _load_default_font because the default
  627                     	; FONT segment number is not yet guaranteed
  628                     	; if the SCD is being run on a plain CDROM system
  629                     	; so we need to trick the segment pointer
  630                     	; with a reliable one
  631                     	;
  632                           __ldw   <__di	; stolen from _load_default_font
                0000      .if (1 = 2)
                          .else
       00:C140  A6 F0     	ldx	<__di	
       00:C142  A5 F1     	lda	<__di	+1
                          .endif
  633                     			; because segment# default not reliable
  634                     
  635  00:C144  20 AD CD  	jsr   _set_font_addr		; set VRAM
  636                     
  637           0001      .if (CDROM)
  638                     	stb   #FONT_BANK+$80,<__bl	; guarantee FONT_BANK even if
       00:C147  A9 81     	lda	#FONT_BANK+$80
       00:C149  85 FA     	sta	<__bl	
  639                     					; SCD on regular CDROM system
  640                     .else
  642                     .endif
  643                     
  644                     	stb   #96,<__cl
       00:C14B  A9 60     	lda	#96
       00:C14D  85 FC     	sta	<__cl
  645                     	stb   font_color+1,<__ah
       00:C14F  AD B2 27  	lda	font_color+1
       00:C152  85 F9     	sta	<__ah
  646  00:C154  AD B1 27  	lda   font_color
  647  00:C157  D0 01     	bne   .fntld
  648  00:C159  1A        	inc   A
  649  00:C15A  85 F8     .fntld:	sta   <__al
  650  00:C15C  82        	clx
  651  00:C15D  BD 62 C3  	lda   font_table,X
  652  00:C160  85 EE     	sta   <__si
  653  00:C162  E8        	inx
  654  00:C163  BD 62 C3  	lda   font_table,X
  655  00:C166  85 EF     	sta   <__si+1
  656                     
  657                     
  658                     	; Now, load the font
  659                     	;
  660                     	;   Note for CDROM/Super CDROM:
  661                     	;
  662                     	; The 'REAL' mapping for the lib2_load_font function
  663                     	; maybe doesn't exist yet (we are executing from bank $80,
  664                     	; not from $68 if it's a Super CDROM)
  665                     	;
  666                     	; So we must map the version at bank ($80 + LIB2_BANK)
  667                     	; before executing it.  We remap the bank after completion,
  668                     	; 'just in case'
  669                     
  670           0001      .if  (CDROM)
  671  00:C168  43 20     	tma   #page(lib2_load_font)
  672  00:C16A  48        	pha
  673  00:C16B  A9 81     	lda   #LIB2_BANK+$80
  674  00:C16D  53 20     	tam   #page(lib2_load_font)
  675  00:C16F  20 AC A9  	jsr   lib2_load_font
  676  00:C172  68        	pla
  677  00:C173  53 20     	tam   #page(lib2_load_font)
  678                     .else
  680                     .endif
  681                     
  682                     	;
  683                     	; END stolen font-load
  684                     	;
  685                     
  686  00:C175  20 61 CD  	jsr   _cls
  687                     
  688  00:C178  9C 02 04  	stz  color_reg	; set color #0 = 0/0/0 rgb
  689  00:C17B  9C 03 04  	stz  color_reg+1
  690  00:C17E  9C 04 04  	stz  color_data
  691  00:C181  9C 05 04  	stz  color_data+1
  692                     
  693  00:C184  A9 01     	lda  #1		; set color #1 = 7/7/7 rgb
  694  00:C186  8D 02 04  	sta  color_reg
  695  00:C189  9C 03 04  	stz  color_reg+1
  696  00:C18C  A2 FF     	ldx  #$ff
  697  00:C18E  8E 04 04  	stx  color_data
  698  00:C191  8D 05 04  	sta  color_data+1
  699                     
  700                         ; ----
  701                         ; Super CDROM error message
  702                         ; ----
  703                     
  704           0001      .if (CDROM)
  705           0000      .if (CDROM = SUPER_CD)
  746                     .endif		; (CDROM = SUPER_CD)
  747                     .endif		; (CDROM)
  748                     
  749                     .endif		; (HUC)
  750                     
  751                     
  752           0001      .ifdef SUPPORT_MOUSE
  753  00:C194  20 D1 DA  	jsr  mousinit		; check existence of mouse
  754                     .endif	; SUPPORT_MOUSE
  755                     
  756           0001      .if  (CDROM)
  757                     
  758                     ; Now, install the RAM-based version of the
  759                     ; interrupt-handlers and activate them
  760                     
  761  00:C197  43 20     	tma   #page(vsync_irq_ramhndlr)
  762  00:C199  48        	pha
  763  00:C19A  A9 81     	lda   #bank(vsync_irq_ramhndlr)
  764  00:C19C  53 20     	tam   #page(vsync_irq_ramhndlr)
  765  00:C19E  73 00 A6  	tii   vsync_irq_ramhndlr,ram_vsync_hndl,25
       00:C1A1  E7 26 19  
       00:C1A4  00        
  766  00:C1A5  73 18 A6  	tii   hsync_irq_ramhndlr,ram_hsync_hndl,25
       00:C1A8  00 27 19  
       00:C1AB  00        
  767  00:C1AC  68        	pla
  768  00:C1AD  53 20     	tam   #page(vsync_irq_ramhndlr)
  769                     
  770                     	stw   #ram_vsync_hndl,vsync_hook	; set VSYNC handler
       00:C1AF  A9 E7     	lda	LOW_BYTE #ram_vsync_hndl
       00:C1B1  8D 08 22  	sta	LOW_BYTE vsync_hook	
       00:C1B4  A9 26     	lda	HIGH_BYTE #ram_vsync_hndl
       00:C1B6  8D 09 22  	sta	HIGH_BYTE vsync_hook	
  771  00:C1B9  C7 F5     	smb   #4,<irq_m		; enable new code
  772  00:C1BB  D7 F5     	smb   #5,<irq_m		; disable system card code
  773                     
  774                     	stw   #ram_hsync_hndl,hsync_hook	; set HSYNC handler
       00:C1BD  A9 00     	lda	LOW_BYTE #ram_hsync_hndl
       00:C1BF  8D 0A 22  	sta	LOW_BYTE hsync_hook	
       00:C1C2  A9 27     	lda	HIGH_BYTE #ram_hsync_hndl
       00:C1C4  8D 0B 22  	sta	HIGH_BYTE hsync_hook	
  775  00:C1C7  E7 F5     	smb   #6,<irq_m		; enable new code
  776  00:C1C9  F7 F5     	smb   #7,<irq_m		; disable system card code
  777                     
  778                     .endif	; (CDROM)
  779                     
  780           0001      .ifdef HUC
  781                         ; ----
  782                         ; Map the final stuff before executing main()
  783                         ; ----
  784                     
  785  00:C1CB  A9 82     	lda   #CONST_BANK+_bank_base	; map string constants bank
  786  00:C1CD  53 04     	tam   #2		; (ie. $4000-$5FFF)
  787  00:C1CF  A9 85     	lda   #_call_bank	; map call bank
  788  00:C1D1  53 10     	tam   #4		; (ie. $8000-$9FFF)
  789                     	; ---
  790           0001      	.if   (CDROM)
  791  00:C1D3  A9 01     	lda   #1		; first overlay to run at boot time
  792  00:C1D5  8D E3 26  	sta   ovl_running	; store for later use
  793                     	.endif
  794                     	; ---
  795  00:C1D8  9C 8F 26  	stz   clock_hh		; clear clock
  796  00:C1DB  9C 90 26  	stz   clock_mm
  797  00:C1DE  9C 91 26  	stz   clock_ss
  798  00:C1E1  9C 92 26  	stz   clock_tt
  799                     
  800           0000      .ifdef HAVE_INIT
  802                     .endif
  803                     
  804           0000      .ifdef LINK_malloc
  806                     .endif
  807                     
  808                     	map   _main
       00:C1E4  A9 84     	lda	#bank(_main)	; addressable memory
       00:C1E6  53 20     	tam	#page(_main)
  809  00:C1E8  20 00 A0  	jsr   _main 		; go!
  810  00:C1EB  80 FE     	bra   *
  811                     
  812                     .else	; HUC
  815                     .endif	; HUC
  816                     
  817                     ; XXX: if LINK_malloc or HAVE_INIT are defined the interrupt handlers start
  818                     ; a couple of bytes later.  When an overlay is loaded the handlers are not
  819                     ; relocated, causing a crash.  This hack makes sure the handlers are in the
  820                     ; same place in all cases.
  821           0001       .if (CDROM)
  822           0001       .ifndef HAVE_INIT
  823  00:C1ED  EA        	nop
  824  00:C1EE  EA        	nop
  825  00:C1EF  EA        	nop
  826  00:C1F0  EA        	nop
  827  00:C1F1  EA        	nop
  828  00:C1F2  EA        	nop
  829  00:C1F3  EA        	nop
  830                      .endif
  831           0001       .ifndef LINK_malloc
  832  00:C1F4  EA        	nop
  833  00:C1F5  EA        	nop
  834  00:C1F6  EA        	nop
  835                      .endif
  836                      .endif
  837                     
  838                     ; ----
  839                     ; system
  840                     ; ----
  841                     ; give back control to the Develo system
  842                     ; ----
  843                     
  844           0000      .if (DEVELO)
  881                     .endif	; (DEVELO)
  882                     
  883                     ; [INTERRUPT CODE]
  884                     
  885  00:C1F7            rts:
  886  00:C1F7  60        	rts
  887  00:C1F8            rti:
  888  00:C1F8  40        	rti
  889                     
  890                     ; ----
  891                     ; irq2
  892                     ; ----
  893                     ; IRQ2 interrupt handler
  894                     ; ----
  895                     
  896           0000      .if !(CDROM)
  902                     .endif	; !(CDROM)
  903                     
  904                     ; ----
  905                     ; irq1
  906                     ; ----
  907                     ; VDC interrupt handler
  908                     ; ----
  909                     
  910           0000      .if !(CDROM)
  959                     .endif	; !(CDROM)
  960                     
  961                     
  962                         ; ----
  963                         ; user routine hooks
  964                         ;
  965  00:C1F9            user_irq1:
  966  00:C1F9  6C 02 22  	jmp   [irq1_jmp]
  967                     
  968                     
  969                     ; ----
  970                     ; vsync_hndl
  971                     ; ----
  972                     ; Handle VSYNC interrupts
  973                     ; ----
  974  00:C1FC            vsync_hndl:
  975                     
  976           0000      .if  !(CDROM)
  984                     .else
  985                             ; The CD-ROM version only acts if the display state has changed
  986                             ; (disp_cr != 0).
  987  00:C1FC  AE 8E 26          ldx	disp_cr
  988  00:C1FF  F0 0E             beq	.l1
  989  00:C201  9C 8E 26          stz	disp_cr
  990  00:C204  CA                dex
  991  00:C205  F0 05             beq	.m1
  992  00:C207  20 96 E0          jsr	ex_dspon
  993  00:C20A  80 03             bra	.l1
  994  00:C20C  20 99 E0  .m1:	jsr	ex_dspoff
  995                     .endif
  996                     
  997  00:C20F  20 BC C3  .l1:	jsr   xfer_palette	; transfer queued palettes
  998                     
  999  00:C212  20 C0 C2  	jsr   rcr_init		; init display list
 1000                     
 1001  00:C215  03 07     .l2:	st0   #7		; scrolling
 1002                     	stw   bg_x1,video_data
       00:C217  AD 0C 22  	lda	LOW_BYTE bg_x1
       00:C21A  8D 02 00  	sta	LOW_BYTE video_data
       00:C21D  AD 0D 22  	lda	HIGH_BYTE bg_x1
       00:C220  8D 03 00  	sta	HIGH_BYTE video_data
 1003  00:C223  03 08     	st0   #8
 1004                     	stw   bg_y1,video_data
       00:C225  AD 10 22  	lda	LOW_BYTE bg_y1
       00:C228  8D 02 00  	sta	LOW_BYTE video_data
       00:C22B  AD 11 22  	lda	HIGH_BYTE bg_y1
       00:C22E  8D 03 00  	sta	HIGH_BYTE video_data
 1005                     
 1006                     	; --
 1007  00:C231  AD 92 26  	lda   clock_tt		; keep track of time
 1008  00:C234  1A        	inc   A
 1009  00:C235  C9 3C     	cmp   #60
 1010  00:C237  D0 1C     	bne   .lcltt
 1011  00:C239  AD 91 26  	lda   clock_ss
 1012  00:C23C  1A        	inc   A
 1013  00:C23D  C9 3C     	cmp   #60
 1014  00:C23F  D0 10     	bne   .lclss
 1015  00:C241  AD 90 26  	lda   clock_mm
 1016  00:C244  1A        	inc   A
 1017  00:C245  C9 3C     	cmp   #60
 1018  00:C247  D0 04     	bne   .lclmm
 1019  00:C249  EE 8F 26  	inc   clock_hh
 1020  00:C24C  62        	cla
 1021  00:C24D  8D 90 26  .lclmm:	sta   clock_mm
 1022  00:C250  62        	cla
 1023  00:C251  8D 91 26  .lclss:	sta   clock_ss
 1024  00:C254  62        	cla
 1025  00:C255  8D 92 26  .lcltt:	sta   clock_tt
 1026                     	; --
 1027                     
 1028           0001      .if  (CDROM)
 1029  00:C258  20 E4 E0  	jsr   ex_colorcmd
 1030                     	; XXX: Why call this every vsync, when it's called from rand()
 1031                     	; as needed anyway?
 1032  00:C25B  EE 49 22  	inc   rndseed
 1033  00:C25E  20 26 C7  	jsr   randomize
 1034                     .endif
 1035                     
 1036                     	; invoke the sound driver's vsync irq code
 1037                     
 1038                     	__sound_vsync
 1039                     
 1040           0001      .ifdef SUPPORT_MOUSE
 1041  00:C261  AD C4 29  	lda   msflag		; if mouse supported, and exists
 1042  00:C264  F0 05     	beq  .l3		; then read mouse instead of pad
 1043  00:C266  20 E3 DA  	jsr   mousread
 1044  00:C269  80 03     	bra  .out
 1045                     .endif	; SUPPORT_MOUSE
 1046                     
 1047  00:C26B  20 02 DE  .l3:	jsr   read_joypad	; else read joypad
 1048  00:C26E  60        .out:	rts
 1049                     
 1050                     
 1051                     ; ----
 1052                     ; hsync_hndl
 1053                     ; ----
 1054                     ; Handle HSYNC interrupts
 1055                     ; ----
 1056                         ; ----
 1057                         ; hsync scrolling handler
 1058                         ;
 1059  00:C26F            hsync_hndl:
 1060                     
 1061  00:C26F  AC 64 27  	ldy   s_idx
 1062  00:C272  10 13     	bpl  .r1
 1063                     	; --
 1064  00:C274  A5 F3     	lda  <vdc_crl
 1065  00:C276  29 3F     	and   #$3F
 1066  00:C278  85 F3     	sta  <vdc_crl
 1067  00:C27A  9C 64 27  	stz   s_idx
 1068  00:C27D  AE 9E 27  	ldx   s_list
 1069  00:C280  BD 8D 27  	lda   s_top,X
 1070  00:C283  20 28 C3  	jsr   rcr5
 1071  00:C286  60        	rts
 1072                     	; --
 1073  00:C287  BE 9E 27  .r1:	ldx   s_list,Y
 1074  00:C28A  A5 F3     	lda  <vdc_crl
 1075  00:C28C  29 3F     	and   #$3F
 1076  00:C28E  1D 85 27  	ora   s_cr,X
 1077  00:C291  85 F3     	sta  <vdc_crl
 1078                     	; --
 1079  00:C293  20 02 C3  	jsr   rcr_set
 1080                     	; --
 1081  00:C296  BD 8D 27  	lda   s_top,X
 1082  00:C299  C9 FF     	cmp   #$FF
 1083  00:C29B  F0 22     	beq  .out
 1084                     	; --
 1085  00:C29D  03 07     	st0   #7
 1086  00:C29F  BD 65 27  	lda   s_xl,X
 1087  00:C2A2  BC 6D 27  	ldy   s_xh,X
 1088  00:C2A5  8D 02 00  	sta   video_data_l
 1089  00:C2A8  8C 03 00  	sty   video_data_h
 1090  00:C2AB  03 08     	st0   #8
 1091  00:C2AD  BD 75 27  	lda   s_yl,X
 1092  00:C2B0  BC 7D 27  	ldy   s_yh,X
 1093                     	sub   #1
                0000      .if (1 = 2)			; from register A (handle
                          .else
       00:C2B3  38        	sec
       00:C2B4  E9 01     	sbc	#1
                          .endif
 1094  00:C2B6  B0 01     	bcs  .r2
 1095  00:C2B8  88        	dey
 1096  00:C2B9  8D 02 00  .r2:	sta   video_data_l
 1097  00:C2BC  8C 03 00  	sty   video_data_h
 1098  00:C2BF  60        .out:	rts
 1099                     
 1100                         ; ----
 1101                         ; init display list
 1102                         ;
 1103  00:C2C0            rcr_init:
 1104                     	maplibfunc   build_disp_list
       00:C2C0  A8        	tay
       00:C2C1  43 20     	tma	#page(build_disp_list)
       00:C2C3  48        	pha
       00:C2C4  A9 81     	lda	#bank(build_disp_list)
       00:C2C6  53 20     	tam	#page(build_disp_list)
       00:C2C8  98        	tya
       00:C2C9  20 DB AB  	jsr	build_disp_list
       00:C2CC  A8        	tay
       00:C2CD  68        	pla
       00:C2CE  53 20     	tam	#page(build_disp_list)
       00:C2D0  98        	tya
 1105  00:C2D1  B0 01     	bcs  .r3
 1106  00:C2D3  60        	rts
 1107                     	; --
 1108  00:C2D4  F7 F3     .r3:	smb   #7,<vdc_crl
 1109  00:C2D6  A9 FF     	lda   #$FF
 1110  00:C2D8  8D 64 27  	sta   s_idx
 1111  00:C2DB  AE 9E 27  	ldx   s_list
 1112  00:C2DE  BC 8D 27  	ldy   s_top,X
 1113  00:C2E1  C0 FF     	cpy   #$FF
 1114  00:C2E3  D0 43     	bne   rcr5
 1115                     	; --
 1116  00:C2E5  BC 65 27  	ldy   s_xl,X
 1117  00:C2E8  8C 0C 22  	sty   bg_x1
 1118  00:C2EB  BC 6D 27  	ldy   s_xh,X
 1119  00:C2EE  8C 0D 22  	sty   bg_x1+1
 1120  00:C2F1  BC 75 27  	ldy   s_yl,X
 1121  00:C2F4  8C 10 22  	sty   bg_y1
 1122  00:C2F7  BC 7D 27  	ldy   s_yh,X
 1123  00:C2FA  8C 11 22  	sty   bg_y1+1
 1124  00:C2FD  9C 64 27  	stz   s_idx
 1125  00:C300  80 26     	bra   rcr5
 1126                     
 1127                         ; ----
 1128                         ; program scanline interrupt
 1129                         ;
 1130  00:C302            rcr_set:
 1131  00:C302  C8        	iny
 1132  00:C303  8C 64 27  	sty   s_idx
 1133  00:C306  B9 9E 27  	lda   s_list,Y
 1134  00:C309  A8        	tay
 1135  00:C30A  B9 8D 27  	lda   s_top,Y
 1136  00:C30D  CD 42 27  	cmp   scr_height
 1137                     	bhs   rcr6
       00:C310  B0 26     	bcs	rcr6
 1138  00:C312  DD 96 27  	cmp   s_bottom,X
 1139                     	blo   rcr5
       00:C315  90 11     	bcc	rcr5
 1140                     	; --
 1141  00:C317  BD 96 27  	lda   s_bottom,X
 1142  00:C31A  3A        rcr4:	dec   A
 1143  00:C31B  48        	pha
 1144  00:C31C  A9 F0     	lda   #$F0
 1145  00:C31E  9D 96 27  	sta   s_bottom,X
 1146  00:C321  9E 85 27  	stz   s_cr,X
 1147  00:C324  CE 64 27  	dec   s_idx
 1148  00:C327  68        	pla
 1149                     	; --
 1150  00:C328  03 06     rcr5:	st0   #6		; set scanline counter
 1151                     	add   #64
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       00:C32A  18        	clc
       00:C32B  69 40     	adc	#64
                          .endif
 1152  00:C32D  8D 02 00  	sta   video_data_l
 1153  00:C330  62        	cla
 1154  00:C331  69 00     	adc   #0
 1155  00:C333  8D 03 00  	sta   video_data_h
 1156  00:C336  80 0E     	bra   __rcr_on
 1157                     	;--
 1158  00:C338  BD 96 27  rcr6:	lda   s_bottom,X
 1159  00:C33B  CD 42 27  	cmp   scr_height
 1160                     	blo   rcr4
       00:C33E  90 DA     	bcc	rcr4
 1161  00:C340  80 14     	bra   __rcr_off
 1162                     
 1163                     ; ----
 1164                     ; rcr_on
 1165                     ; ----
 1166                     ; enable scanline interrupt
 1167                     ; ----
 1168                     
 1169  00:C342            _rcr_on:
 1170  00:C342  A9 05      	lda   #5
 1171  00:C344  85 F7     	sta  <vdc_reg
 1172  00:C346            __rcr_on:
 1173  00:C346  03 05     	st0   #5
 1174  00:C348  A5 F3     	lda  <vdc_crl
 1175  00:C34A  09 04     	ora   #$04
 1176  00:C34C  85 F3     	sta  <vdc_crl
 1177  00:C34E  8D 02 00  	sta   video_data_l
 1178  00:C351  60        	rts
 1179                     
 1180                     ; ----
 1181                     ; rcr_off
 1182                     ; ----
 1183                     ; disable scanline interrupt
 1184                     ; ----
 1185                     
 1186  00:C352            _rcr_off:
 1187  00:C352  A9 05     	lda   #5
 1188  00:C354  85 F7     	sta  <vdc_reg
 1189  00:C356            __rcr_off:
 1190  00:C356  03 05     	st0   #5
 1191  00:C358  A5 F3     	lda  <vdc_crl
 1192  00:C35A  29 FB     	and   #$FB
 1193  00:C35C  85 F3     	sta  <vdc_crl
 1194  00:C35E  8D 02 00  	sta   video_data_l
 1195  00:C361  60        	rts
 1196                     
 1197                     
 1198                     
 1199                     ; ----
 1200                     ; timer
 1201                     ; ----
 1202                     ; timer interrupt handler
 1203                     ; ----
 1204                     
 1205           0000      .if  !(CDROM)
 1225                     .endif	; !(CDROM)
 1226                     
 1227                     ; ----
 1228                     ; nmi
 1229                     ; ----
 1230                     ; NMI interrupt handler
 1231                     ; ----
 1232                     
 1233           0000      .if  !(CDROM)
 1239                     .endif	; !(CDROM)
 1240                     
 1241                     
 1242                     ; [DATA]
 1243                     
 1244                     ; ----
 1245                     ; font
 1246                     ; ----
 1247                     
 1248           0001      .ifdef HUC
 1249  00:C362            font_table:
 1250  00:C362  00 60     	 .dw font_1
 1251  00:C364  00 63     	 .dw font_2
 1252  00:C366  00 60     	 .dw font_1
 1253  00:C368  00 60     	 .dw font_1
 1254                     .endif	; HUC
 1255                     
 1256                     
 1257                     ; [LIBRARY]
 1258                     
 1259                     ; ----
 1260                     ; standard library
 1261                     ; ----
 1262                     
#[3]   library.asm
 1263                     .include "library.asm"
    1                     ;
    2                     ; LIBRARY.ASM  -  MagicKit Standard Library
    3                     ;
    4                     ;
    5                     
    6                     ; IMPORTANT NOTE:
    7                     ; ----
    8                     ; almost all the library functions have been changed to automatically
    9                     ; handle bank mapping (you don't have to map data yourself anymore),
   10                     ; the change will be transparent to you if you were using only library
   11                     ; macros to call functions, but you will have to update your code
   12                     ; in case you were directly calling those functions!
   13                     
   14                     
   15                     ; ----
   16                     ; map_data
   17                     ; ----
   18                     ; map data in page 3-4 ($6000-$9FFF)
   19                     ; ----
   20                     ; IN :	_BL = data bank
   21                     ;	_SI = data address
   22                     ; ----
   23                     ; OUT:	_BX = old banks
   24                     ;	_SI = remapped data address
   25                     ; ----
   26                     
   27  00:C36A            map_data:
   28  00:C36A  A6 FA     	ldx	<__bl
   29                     
   30                     	; ----
   31                     	; save current bank mapping
   32                     	;
   33  00:C36C  43 08     	tma	#3
   34  00:C36E  85 FA     	sta	<__bl
   35  00:C370  43 10     	tma	#4
   36  00:C372  85 FB     	sta	<__bh
   37                     	; --
   38  00:C374  E0 FE     	cpx	#$FE
   39  00:C376  D0 03     	bne	.l1
   40                     	; --
   41  00:C378  86 EC     	stx	<__bp
   42  00:C37A  60        	rts
   43                     
   44                     	; ----
   45                     	; map new bank
   46                     	;
   47  00:C37B  64 EC     .l1:	stz	<__bp
   48                     	; --
   49  00:C37D  8A        	txa
   50  00:C37E  53 08     	tam	#3
   51  00:C380  1A        	inc	A
   52  00:C381  53 10     	tam	#4
   53                     
   54                     	; ----
   55                     	; remap data address to page 3
   56                     	;
   57  00:C383  A5 EF     	lda	<__si+1
   58  00:C385  29 1F     	and	#$1F
   59  00:C387  09 60     	ora	#$60
   60  00:C389  85 EF     	sta	<__si+1
   61  00:C38B  60        	rts
   62                     
   63                     
   64                     ; ----
   65                     ; unmap_data
   66                     ; ----
   67                     ; IN :	_BX = old banks
   68                     ; ----
   69                     
   70  00:C38C            unmap_data:
   71                     
   72  00:C38C  A5 FA     	lda	<__bl
   73  00:C38E  53 08     	tam	#3
   74  00:C390  A5 FB     	lda	<__bh
   75  00:C392  53 10     	tam	#4
   76  00:C394  60        	rts
   77                     
   78                     ; ----
   79                     ; remap_data
   80                     ; ----
   81                     
   82  00:C395            remap_data:
   83  00:C395  A5 EC     	lda	<__bp
   84  00:C397  D0 10     	bne	.l1
   85  00:C399  A5 EF     	lda	<__si+1
   86  00:C39B  10 0C     	bpl	.l1
   87                     	sub	#$20
                0000      .if (1 = 2)			; from register A (handle
                          .else
       00:C39D  38        	sec
       00:C39E  E9 20     	sbc	#$20
                          .endif
   88  00:C3A0  85 EF     	sta	<__si+1
   89  00:C3A2  43 10     	tma	#4
   90  00:C3A4  53 08     	tam	#3
   91  00:C3A6  1A        	inc	A
   92  00:C3A7  53 10     	tam	#4
   93  00:C3A9            .l1:
   94  00:C3A9  60        	rts
   95                     
   96                     
   97                     ; ----
   98                     ; load_palette
   99                     ; ----
  100                     ; initialize one or more sub-palette
  101                     ; ----
  102                     ; IN :	_AL = index of the first sub-palette (0-31)
  103                     ;	_BL = data bank
  104                     ;	_SI = address of data
  105                     ;	_CL = number of sub-palette to copy
  106                     ; ----
  107                     
  108           0001      .ifdef HUC
  109  00:C3AA            _load_palette.3:
  110                     .endif
  111  00:C3AA            load_palette:
  112                     	maplibfunc	lib2_load_palette
       00:C3AA  A8        	tay
       00:C3AB  43 20     	tma	#page(lib2_load_palette)
       00:C3AD  48        	pha
       00:C3AE  A9 81     	lda	#bank(lib2_load_palette)
       00:C3B0  53 20     	tam	#page(lib2_load_palette)
       00:C3B2  98        	tya
       00:C3B3  20 30 A6  	jsr	lib2_load_palette
       00:C3B6  A8        	tay
       00:C3B7  68        	pla
       00:C3B8  53 20     	tam	#page(lib2_load_palette)
       00:C3BA  98        	tya
  113  00:C3BB  60        	rts
  114                     
  115  00:C3BC            xfer_palette:
  116                     	maplibfunc	lib2_xfer_palette
       00:C3BC  A8        	tay
       00:C3BD  43 20     	tma	#page(lib2_xfer_palette)
       00:C3BF  48        	pha
       00:C3C0  A9 81     	lda	#bank(lib2_xfer_palette)
       00:C3C2  53 20     	tam	#page(lib2_xfer_palette)
       00:C3C4  98        	tya
       00:C3C5  20 5D A6  	jsr	lib2_xfer_palette
       00:C3C8  A8        	tay
       00:C3C9  68        	pla
       00:C3CA  53 20     	tam	#page(lib2_xfer_palette)
       00:C3CC  98        	tya
  117  00:C3CD  60        	rts
  118                     
  119           0001      	.bank	LIB2_BANK
  120  01:A630            lib2_load_palette:
  121  01:A630  AC B2 26  	ldy	color_queue_w
  122                     
  123  01:A633  A5 EE     	lda	<__si + 0
  124  01:A635  99 CB 26  	sta	color_addr_l,y
  125  01:A638  A5 EF     	lda	<__si + 1
  126  01:A63A  29 1F     	and	#$1F
  127  01:A63C  09 60     	ora	#$60
  128  01:A63E  99 D3 26  	sta	color_addr_h,y
  129  01:A641  A5 FA     	lda	<__bl
  130  01:A643  99 C3 26  	sta	color_bank,y
  131  01:A646  A5 F8     	lda	<__al
  132  01:A648  99 B3 26  	sta	color_index,y
  133  01:A64B  A5 FC     	lda	<__cl
  134  01:A64D  99 BB 26  	sta	color_count,y
  135                     
  136  01:A650  98        	tya
  137  01:A651  1A        	inc	a
  138  01:A652  29 07     	and	#7
  139  01:A654  CD B1 26  .wait:	cmp	color_queue_r
  140  01:A657  F0 FB     	beq	.wait
  141  01:A659  8D B2 26  	sta	color_queue_w
  142  01:A65C  60        	rts
  143                     
  144  01:A65D            lib2_xfer_palette:
  145  01:A65D  AC B1 26  	ldy	color_queue_r
  146  01:A660  CC B2 26  	cpy	color_queue_w
  147  01:A663  F0 5A     	beq	.done
  148                     
  149  01:A665  43 08     	tma3
  150  01:A667  48        	pha
  151  01:A668  43 10     	tma4
  152  01:A66A  48        	pha
  153                     
  154  01:A66B  73 C0 A6  	tii	.func, color_tia, 8
       01:A66E  DB 26 08  
       01:A671  00        
  155                     
  156  01:A672  B9 B3 26  .next:	lda	color_index,y
  157  01:A675  0A        	asl	a
  158  01:A676  0A        	asl	a
  159  01:A677  0A        	asl	a
  160  01:A678  0A        	asl	a
  161  01:A679  8D 02 04  	sta	color_reg_l
  162  01:A67C  62        	cla
  163  01:A67D  2A        	rol	a
  164  01:A67E  8D 03 04  	sta	color_reg_h
  165                     
  166  01:A681  B9 C3 26  	lda	color_bank,y
  167  01:A684  53 08     	tam3
  168  01:A686  1A        	inc	a
  169  01:A687  53 10     	tam4
  170  01:A689  B9 CB 26  	lda	color_addr_l,y
  171  01:A68C  8D DC 26  	sta	color_tia + 1
  172  01:A68F  B9 D3 26  	lda	color_addr_h,y
  173  01:A692  8D DD 26  	sta	color_tia + 2
  174                     
  175  01:A695  BE BB 26  	ldx	color_count,y
  176  01:A698  20 DB 26  .loop:	jsr	color_tia
  177  01:A69B  18        	clc
  178  01:A69C  A9 20     	lda	#32
  179  01:A69E  6D DC 26  	adc	color_tia + 1
  180  01:A6A1  8D DC 26  	sta	color_tia + 1
  181  01:A6A4  90 03     	bcc	.skip
  182  01:A6A6  EE DD 26  	inc	color_tia + 2
  183  01:A6A9  CA        .skip:	dex
  184  01:A6AA  D0 EC     	bne	.loop
  185                     
  186  01:A6AC  C8        	iny
  187  01:A6AD  98        	tya
  188  01:A6AE  29 07     	and	#7
  189  01:A6B0  A8        	tay
  190                     
  191  01:A6B1  CC B2 26  	cpy	color_queue_w
  192  01:A6B4  D0 BC     	bne	.next
  193  01:A6B6  8C B1 26  	sty	color_queue_r
  194                     
  195  01:A6B9  68        	pla
  196  01:A6BA  53 10     	tam4
  197  01:A6BC  68        	pla
  198  01:A6BD  53 08     	tam3
  199                     
  200  01:A6BF  60        .done:	rts
  201                     
  202  01:A6C0  E3 00 00  .func:	tia	0, color_data, 32
       01:A6C3  04 04 20  
       01:A6C6  00        
  203  01:A6C7  60        	rts
  204                     
  205           0000      	.bank	LIB1_BANK
  206                     
  207                     ; ----
  208                     ; load_bat
  209                     ; ----
  210                     ; transfer a BAT in VRAM
  211                     ; ----
  212                     ; IN :	_DI = VRAM base address
  213                     ;	_BL = BAT bank
  214                     ;	_SI = BAT memory location
  215                     ;	_CL = nb of column to copy
  216                     ;	_CH = nb of row
  217                     ; ----
  218                     
  219           0001      .ifdef HUC
  220  00:C3CE            _load_bat.4:
  221                     .endif
  222  00:C3CE            load_bat:
  223                     	maplibfunc	lib2_load_bat
       00:C3CE  A8        	tay
       00:C3CF  43 20     	tma	#page(lib2_load_bat)
       00:C3D1  48        	pha
       00:C3D2  A9 81     	lda	#bank(lib2_load_bat)
       00:C3D4  53 20     	tam	#page(lib2_load_bat)
       00:C3D6  98        	tya
       00:C3D7  20 C8 A6  	jsr	lib2_load_bat
       00:C3DA  A8        	tay
       00:C3DB  68        	pla
       00:C3DC  53 20     	tam	#page(lib2_load_bat)
       00:C3DE  98        	tya
  224  00:C3DF  60        	rts
  225                     
  226           0001      	.bank	LIB2_BANK
  227                     
  228  01:A6C8            lib2_load_bat:
  229                     
  230                     	; ----
  231                     	; map data
  232                     	;
  233  01:A6C8  20 6A C3  	jsr	map_data
  234                     
  235                     	; ----
  236                     	; copy BAT
  237                     	;
  238  01:A6CB  C2        	cly
  239                     	; --
  240  01:A6CC  20 98 C4  .l1:	jsr	set_write
  241  01:A6CF  A6 FC     	ldx	<__cl
  242                     	; --
  243  01:A6D1  B1 EE     .l2:	lda	[__si],Y
  244  01:A6D3  8D 02 00  	sta	video_data_l
  245  01:A6D6  C8        	iny
  246  01:A6D7  B1 EE     	lda	[__si],Y
  247  01:A6D9  8D 03 00  	sta	video_data_h
  248  01:A6DC  C8        	iny
  249  01:A6DD  D0 02     	bne	.l3
  250  01:A6DF  E6 EF     	inc	<__si+1
  251  01:A6E1  CA        .l3:	dex
  252  01:A6E2  D0 ED     	bne	.l2
  253                     	; --
  254  01:A6E4  20 95 C3  	jsr	remap_data
  255                     	; --
  256                     	addw	bat_width,<__di
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:A6E7  18        	clc
       01:A6E8  A5 F0     	lda	LOW_BYTE <__di
       01:A6EA  6D 3C 27  	adc	LOW_BYTE bat_width
       01:A6ED  85 F0     	sta	LOW_BYTE <__di
       01:A6EF  A5 F1     	lda	HIGH_BYTE <__di
       01:A6F1  6D 3D 27  	adc	HIGH_BYTE bat_width
       01:A6F4  85 F1     	sta	HIGH_BYTE <__di
                          .endif
  257  01:A6F6  C6 FD     	dec	<__ch
  258  01:A6F8  D0 D2     	bne	.l1
  259                     
  260                     	; ----
  261                     	; unmap data
  262                     	;
  263  01:A6FA  4C 8C C3  	jmp	unmap_data
  264                     
  265           0000      	.bank	LIB1_BANK
  266                     
  267                     ; ----
  268                     ; load_map_8/16
  269                     ; ----
  270                     ; transfer a tiled map in VRAM
  271                     ; ----
  272                     ; IN :	_AL = x screen coordinate (tile unit)
  273                     ;	_AH = y screen coordinate
  274                     ;	_CL = x start coordinate in the map
  275                     ;	_CH = y start coordinate
  276                     ;	_DL = nb of column to copy
  277                     ;	_DH = nb of row
  278                     ; ----
  279                     
  280           2719      	.bss
  281  --:2719            mapbank		.ds 1
  282  --:271A            mapaddr		.ds 2
  283  --:271C            mapwidth	.ds 2
  284  --:271E            mapheight	.ds 2
  285  --:2720            maptiletype	.ds 1
  286  --:2721            maptilebank	.ds 1
  287  --:2722            maptileaddr	.ds 2
  288  --:2724            maptilebase	.ds 2
  289  --:2726            mapnbtile	.ds 2
  290  --:2728            mapctablebank	.ds 1
  291  --:2729            mapctable	.ds 2
  292  --:272B            mapwrap		.ds 1
  293  --:272C            mapbat_ptr	.ds 2
  294  --:272E            mapbat_top_base .ds 2
  295  --:2730            mapbat_top	.ds 1
  296  --:2731            mapbat_bottom	.ds 1
  297  --:2732            mapbat_x	.ds 2
  298           C3E0      	.code
  299  00:C3E0            load_map:
  300  00:C3E0  AD 20 27  	lda	maptiletype
  301  00:C3E3  C9 08     	cmp	#8
  302  00:C3E5  F0 12     	beq	.l1
  303                     	; --
  304                     	maplibfunc	lib2_load_map_16
       00:C3E7  A8        	tay
       00:C3E8  43 20     	tma	#page(lib2_load_map_16)
       00:C3EA  48        	pha
       00:C3EB  A9 81     	lda	#bank(lib2_load_map_16)
       00:C3ED  53 20     	tam	#page(lib2_load_map_16)
       00:C3EF  98        	tya
       00:C3F0  20 FD A6  	jsr	lib2_load_map_16
       00:C3F3  A8        	tay
       00:C3F4  68        	pla
       00:C3F5  53 20     	tam	#page(lib2_load_map_16)
       00:C3F7  98        	tya
  305  00:C3F8  60        	rts
  306                     .l1:	maplibfunc	lib2_load_map_8
       00:C3F9  A8        	tay
       00:C3FA  43 20     	tma	#page(lib2_load_map_8)
       00:C3FC  48        	pha
       00:C3FD  A9 81     	lda	#bank(lib2_load_map_8)
       00:C3FF  53 20     	tam	#page(lib2_load_map_8)
       00:C401  98        	tya
       00:C402  20 FE A7  	jsr	lib2_load_map_8
       00:C405  A8        	tay
       00:C406  68        	pla
       00:C407  53 20     	tam	#page(lib2_load_map_8)
       00:C409  98        	tya
  307  00:C40A  60        	rts
  308                     
  309           0001      	.bank	LIB2_BANK
  310                     
  311  01:A6FD            lib2_load_map_16:
  312                     
  313                     	; ----
  314                     	; save bank mapping
  315                     	;
  316  01:A6FD  43 04     	tma	#2
  317  01:A6FF  48        	pha
  318  01:A700  43 08     	tma	#3
  319  01:A702  48        	pha
  320  01:A703  43 10     	tma	#4
  321  01:A705  48        	pha
  322                     
  323                     	; ----
  324                     	; init
  325                     	;
  326  01:A706  20 91 A8  	jsr	load_map_init
  327  01:A709  A5 FD     	lda	<__ch
  328  01:A70B  8D 33 27  	sta	mapbat_x+1
  329                     
  330                     	; ----
  331                     	; vertical loop
  332                     	;
  333  01:A70E  A4 F9     .l1:	ldy	<__ah
  334  01:A710  A5 FE     	lda	<__dl
  335  01:A712  85 F8     	sta	<__al
  336  01:A714  AD 33 27  	lda	mapbat_x+1
  337  01:A717  8D 32 27  	sta	mapbat_x
  338  01:A71A  80 43     	bra	.l5
  339                     
  340                     	; ----
  341                     	; horizontal loop
  342                     	;
  343  01:A71C  AD 32 27  .l2:	lda	mapbat_x	; bat wrapping
  344                     	add	#2
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       01:A71F  18        	clc
       01:A720  69 02     	adc	#2
                          .endif
  345  01:A722  2D 3F 27  	and	bat_hmask
  346  01:A725  8D 32 27  	sta	mapbat_x
  347  01:A728  D0 0B     	bne	.l3
  348                     	; --
  349  01:A72A  AD 3F 27  	lda	bat_hmask
  350  01:A72D  49 FF     	eor	#$ff
  351  01:A72F  25 F0     	and	<__di
  352  01:A731  85 F0     	sta	<__di
  353  01:A733  80 0C     	bra	.l4
  354  01:A735            .l3:
  355                     	incw	<__di
       01:A735  E6 F0     	inc	<__di		; value at stated memory
       01:A737  D0 02     	bne	.x_00036		; location
       01:A739  E6 F1     	inc	<__di+1
       01:A73B            .x_00036:
  356                     	incw	<__di
       01:A73B  E6 F0     	inc	<__di		; value at stated memory
       01:A73D  D0 02     	bne	.x_00037		; location
       01:A73F  E6 F1     	inc	<__di+1
       01:A741            .x_00037:
  357  01:A741            .l4:
  358  01:A741  C8        	iny
  359                     	; --
  360  01:A742  CC 1C 27  	cpy	mapwidth		; horizontal map wrapping
  361  01:A745  D0 18     	bne	.l5
  362  01:A747  C2        	cly
  363  01:A748  AE 2B 27  	ldx	mapwrap
  364  01:A74B  D0 12     	bne	.l5
  365  01:A74D  AC 1C 27  	ldy	mapwidth
  366  01:A750  AD 24 27  	lda	maptilebase
  367  01:A753  85 FC     	sta	<__cl
  368  01:A755  AD 25 27  	lda	maptilebase+1
  369  01:A758  12 EC     	ora	[__bp]
  370  01:A75A  85 FD     	sta	<__ch
  371  01:A75C  88        	dey
  372  01:A75D  80 1C     	bra	.l6
  373  01:A75F            .l5:
  374  01:A75F  B1 EE     	lda	[__si],Y		; get tile index
  375  01:A761  AA        	tax			; calculate BAT value (tile + palette)
  376  01:A762  02        	sxy
  377  01:A763  64 FD     	stz	<__ch
  378  01:A765  0A        	asl	A
  379  01:A766  26 FD     	rol	<__ch
  380  01:A768  0A        	asl	A
  381  01:A769  26 FD     	rol	<__ch
  382                     	add	maptilebase
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       01:A76B  18        	clc
       01:A76C  6D 24 27  	adc	maptilebase
                          .endif
  383  01:A76F  85 FC     	sta	<__cl
  384  01:A771  A5 FD     	lda	<__ch
  385  01:A773  6D 25 27  	adc	maptilebase+1
  386  01:A776  71 EC     	adc	[__bp],Y
  387  01:A778  85 FD     	sta	<__ch
  388  01:A77A  02        	sxy
  389  01:A77B            .l6:
  390                     	vreg	#0		; copy tile
       01:A77B  A9 00     	lda	#0		
       01:A77D  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:A77F  03 00     	st0	#0		
                          .else
                          .endif
  391                     	stw	<__di,video_data
       01:A781  A5 F0     	lda	LOW_BYTE <__di
       01:A783  8D 02 00  	sta	LOW_BYTE video_data
       01:A786  A5 F1     	lda	HIGH_BYTE <__di
       01:A788  8D 03 00  	sta	HIGH_BYTE video_data
  392                     	vreg	#2
       01:A78B  A9 02     	lda	#2
       01:A78D  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:A78F  03 02     	st0	#2
                          .else
                          .endif
  393                     	stw	<__cx,video_data
       01:A791  A5 FC     	lda	LOW_BYTE <__cx
       01:A793  8D 02 00  	sta	LOW_BYTE video_data
       01:A796  A5 FD     	lda	HIGH_BYTE <__cx
       01:A798  8D 03 00  	sta	HIGH_BYTE video_data
  394                     	incw	<__cx
       01:A79B  E6 FC     	inc	<__cx		; value at stated memory
       01:A79D  D0 02     	bne	.x_00043		; location
       01:A79F  E6 FD     	inc	<__cx+1
       01:A7A1            .x_00043:
  395                     	stw	<__cx,video_data
       01:A7A1  A5 FC     	lda	LOW_BYTE <__cx
       01:A7A3  8D 02 00  	sta	LOW_BYTE video_data
       01:A7A6  A5 FD     	lda	HIGH_BYTE <__cx
       01:A7A8  8D 03 00  	sta	HIGH_BYTE video_data
  396                     	incw	<__cx
       01:A7AB  E6 FC     	inc	<__cx		; value at stated memory
       01:A7AD  D0 02     	bne	.x_00045		; location
       01:A7AF  E6 FD     	inc	<__cx+1
       01:A7B1            .x_00045:
  397                     	vreg	#0
       01:A7B1  A9 00     	lda	#0
       01:A7B3  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:A7B5  03 00     	st0	#0
                          .else
                          .endif
  398                     	addw	bat_width,<__di,video_data
                0001      .if	(3 = 3)
                          	; 3-arg mode
                          	;
       01:A7B7  18        	clc
       01:A7B8  A5 F0     	lda	LOW_BYTE <__di
       01:A7BA  6D 3C 27  	adc	LOW_BYTE bat_width
       01:A7BD  8D 02 00  	sta	LOW_BYTE video_data
       01:A7C0  A5 F1     	lda	HIGH_BYTE <__di
       01:A7C2  6D 3D 27  	adc	HIGH_BYTE bat_width
       01:A7C5  8D 03 00  	sta	HIGH_BYTE video_data
                          .else
                          .endif
  399                     	vreg	#2
       01:A7C8  A9 02     	lda	#2
       01:A7CA  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:A7CC  03 02     	st0	#2
                          .else
                          .endif
  400                     	stw	<__cx,video_data
       01:A7CE  A5 FC     	lda	LOW_BYTE <__cx
       01:A7D0  8D 02 00  	sta	LOW_BYTE video_data
       01:A7D3  A5 FD     	lda	HIGH_BYTE <__cx
       01:A7D5  8D 03 00  	sta	HIGH_BYTE video_data
  401                     	incw	<__cx
       01:A7D8  E6 FC     	inc	<__cx		; value at stated memory
       01:A7DA  D0 02     	bne	.x_00050		; location
       01:A7DC  E6 FD     	inc	<__cx+1
       01:A7DE            .x_00050:
  402                     	stw	<__cx,video_data
       01:A7DE  A5 FC     	lda	LOW_BYTE <__cx
       01:A7E0  8D 02 00  	sta	LOW_BYTE video_data
       01:A7E3  A5 FD     	lda	HIGH_BYTE <__cx
       01:A7E5  8D 03 00  	sta	HIGH_BYTE video_data
  403                     
  404  01:A7E8  C6 F8     	dec	<__al		; next tile
  405                     	lbne	.l2
       01:A7EA  F0 03     	beq	.x_00052
       01:A7EC  4C 1C A7  	jmp	.l2
       01:A7EF            .x_00052
  406                     
  407                     	; ----
  408                     	; next line
  409                     	;
  410  01:A7EF  A2 02     	ldx	#2
  411  01:A7F1  20 1E A9  	jsr	load_map_next_line
  412  01:A7F4  C6 FF     	dec	<__dh
  413                     	lbne	.l1
       01:A7F6  F0 03     	beq	.x_00053
       01:A7F8  4C 0E A7  	jmp	.l1
       01:A7FB            .x_00053
  414                     
  415                     	; ----
  416                     	; restore bank mapping
  417                     	;
  418  01:A7FB  4C 87 A8  	jmp	load_map_exit
  419                     
  420  01:A7FE            lib2_load_map_8:
  421                     
  422                     	; ----
  423                     	; save bank mapping
  424                     	;
  425  01:A7FE  43 04     	tma	#2
  426  01:A800  48        	pha
  427  01:A801  43 08     	tma	#3
  428  01:A803  48        	pha
  429  01:A804  43 10     	tma	#4
  430  01:A806  48        	pha
  431                     
  432                     	; ----
  433                     	; init
  434                     	;
  435  01:A807  20 91 A8  	jsr	load_map_init
  436  01:A80A  80 05     	bra	.l2
  437                     
  438                     	; ----
  439                     	; vertical loop
  440                     	;
  441  01:A80C  A2 01     .l1:	ldx	#1
  442  01:A80E  20 1E A9  	jsr	load_map_next_line
  443                     	; --
  444  01:A811  A4 F9     .l2:	ldy	<__ah
  445  01:A813  A5 FE     	lda	<__dl
  446  01:A815  85 F8     	sta	<__al
  447  01:A817  A5 FD     	lda	<__ch
  448  01:A819  85 FC     	sta	<__cl
  449                     	vreg	#0		; set vram write ptr
       01:A81B  A9 00     	lda	#0		
       01:A81D  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:A81F  03 00     	st0	#0		
                          .else
                          .endif
  450                     	stw	<__di,video_data
       01:A821  A5 F0     	lda	LOW_BYTE <__di
       01:A823  8D 02 00  	sta	LOW_BYTE video_data
       01:A826  A5 F1     	lda	HIGH_BYTE <__di
       01:A828  8D 03 00  	sta	HIGH_BYTE video_data
  451                     	vreg	#2
       01:A82B  A9 02     	lda	#2
       01:A82D  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:A82F  03 02     	st0	#2
                          .else
                          .endif
  452  01:A831  80 38     	bra	.l5
  453                     
  454                     	; ----
  455                     	; horizontal loop
  456                     	;
  457  01:A833  A5 FC     .l3:	lda	<__cl		; bat wrapping
  458  01:A835  1A        	inc	A
  459  01:A836  2D 3F 27  	and	bat_hmask
  460  01:A839  85 FC     	sta	<__cl
  461  01:A83B  D0 1B     	bne	.l4
  462                     	; --
  463                     	vreg	#0
       01:A83D  A9 00     	lda	#0
       01:A83F  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:A841  03 00     	st0	#0
                          .else
                          .endif
  464  01:A843  AD 3F 27  	lda	bat_hmask
  465  01:A846  49 FF     	eor	#$ff
  466  01:A848  25 F0     	and	<__di
  467  01:A84A  8D 02 00  	sta	video_data_l
  468  01:A84D  A5 F1     	lda	<__di+1
  469  01:A84F  8D 03 00  	sta	video_data_h
  470                     	vreg	#2
       01:A852  A9 02     	lda	#2
       01:A854  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:A856  03 02     	st0	#2
                          .else
                          .endif
  471  01:A858            .l4:
  472  01:A858  C8        	iny			; next tile
  473                     	; --
  474  01:A859  CC 1C 27  	cpy	mapwidth		; map wrapping
  475  01:A85C  D0 0D     	bne	.l5
  476                     	; --
  477  01:A85E  C2        	cly
  478  01:A85F  AD 2B 27  	lda	mapwrap
  479  01:A862  D0 07     	bne	.l5
  480  01:A864  AC 1C 27  	ldy	mapwidth
  481  01:A867  88        	dey
  482  01:A868  62        	cla
  483  01:A869  80 02     	bra	.l6
  484  01:A86B            .l5:
  485  01:A86B  B1 EE     	lda	[__si],Y		; get tile index
  486  01:A86D  AA        .l6:	tax			; calculate BAT value (tile + palette)
  487  01:A86E  02        	sxy
  488                     	add	maptilebase
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       01:A86F  18        	clc
       01:A870  6D 24 27  	adc	maptilebase
                          .endif
  489  01:A873  8D 02 00  	sta	video_data_l
  490  01:A876  AD 25 27  	lda	maptilebase+1
  491  01:A879  71 EC     	adc	[__bp],Y
  492  01:A87B  8D 03 00  	sta	video_data_h
  493  01:A87E  02        	sxy
  494                     
  495  01:A87F  C6 F8     	dec	<__al
  496  01:A881  D0 B0     	bne	.l3
  497                     
  498                     	; ----
  499                     	; next line
  500                     	;
  501  01:A883  C6 FF     	dec	<__dh
  502  01:A885  D0 85     	bne	.l1
  503                     
  504                     	; ----
  505                     	; restore bank mapping
  506                     	;
  507  01:A887            load_map_exit:
  508  01:A887  68        	pla
  509  01:A888  53 10     	tam	#4
  510  01:A88A  68        	pla
  511  01:A88B  53 08     	tam	#3
  512  01:A88D  68        	pla
  513  01:A88E  53 04     	tam	#2
  514  01:A890  60        	rts
  515                     
  516                     
  517                     ; ----
  518                     ; load_map_init
  519                     ; ----
  520                     ; load_map sub routine
  521                     ; ----
  522                     ; OUT:	_DI = BAT address
  523                     ;	_SI = map address
  524                     ;	_BP = palette index table ptr
  525                     ;	_AH = map X pos
  526                     ;	_BH = map Y pos
  527                     ;	_CH = BAT X pos
  528                     ;	_BL = BAT Y pos
  529                     ; ----
  530                     
  531  01:A891            load_map_init:
  532                     
  533                     	; ----
  534                     	; calculate vram address
  535                     	;
  536  01:A891  A6 F8     	ldx	<__al
  537  01:A893  A5 F9     	lda	<__ah
  538  01:A895  AC 20 27  	ldy	maptiletype
  539  01:A898  C0 08     	cpy	#8
  540  01:A89A  F0 04     	beq	.l1
  541  01:A89C  0A        	asl	A
  542  01:A89D  22        	sax
  543  01:A89E  0A        	asl	A
  544  01:A89F  22        	sax
  545  01:A8A0  DA        .l1:	phx
  546  01:A8A1  48        	pha
  547  01:A8A2  20 AF C4  	jsr	calc_vram_addr
  548                     	stw	<__di,mapbat_ptr
       01:A8A5  A5 F0     	lda	LOW_BYTE <__di
       01:A8A7  8D 2C 27  	sta	LOW_BYTE mapbat_ptr
       01:A8AA  A5 F1     	lda	HIGH_BYTE <__di
       01:A8AC  8D 2D 27  	sta	HIGH_BYTE mapbat_ptr
  549                     
  550                     	; ----
  551                     	; calculate map address
  552                     	;
  553                     	stb	mapaddr,<__si
       01:A8AF  AD 1A 27  	lda	mapaddr
       01:A8B2  85 EE     	sta	<__si
  554  01:A8B4  AD 1B 27  	lda	mapaddr+1
  555  01:A8B7  29 1F     	and	#$1F
  556  01:A8B9  85 EF     	sta	<__si+1
  557                     	; --
  558  01:A8BB  A6 FC     	ldx	<__cl
  559  01:A8BD  86 F9     	stx	<__ah
  560  01:A8BF  A4 FD     	ldy	<__ch
  561  01:A8C1  84 FB     	sty	<__bh
  562                     	; --
  563  01:A8C3  AD 1D 27  	lda	mapwidth+1
  564  01:A8C6  F0 08     	beq	.l2
  565  01:A8C8  98        	tya
  566                     	add	<__si+1
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       01:A8C9  18        	clc
       01:A8CA  65 EF     	adc	<__si+1
                          .endif
  567  01:A8CC  85 EF     	sta	<__si+1
  568  01:A8CE  80 17     	bra	.l3
  569                     	; --
  570  01:A8D0  84 F8     .l2:	sty	<__al
  571  01:A8D2  AD 1C 27  	lda	mapwidth
  572  01:A8D5  85 FA     	sta	<__bl
  573  01:A8D7  20 BD E0  	jsr	mulu8
  574                     	addw	<__cx,<__si
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:A8DA  18        	clc
       01:A8DB  A5 EE     	lda	LOW_BYTE <__si
       01:A8DD  65 FC     	adc	LOW_BYTE <__cx
       01:A8DF  85 EE     	sta	LOW_BYTE <__si
       01:A8E1  A5 EF     	lda	HIGH_BYTE <__si
       01:A8E3  65 FD     	adc	HIGH_BYTE <__cx
       01:A8E5  85 EF     	sta	HIGH_BYTE <__si
                          .endif
  575                     
  576                     	; ----
  577                     	; calculate map bank
  578                     	;
  579  01:A8E7  2A        .l3:	rol	A
  580  01:A8E8  2A        	rol	A
  581  01:A8E9  2A        	rol	A
  582  01:A8EA  2A        	rol	A
  583  01:A8EB  29 0F     	and	#$0F
  584                     	add	mapbank
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       01:A8ED  18        	clc
       01:A8EE  6D 19 27  	adc	mapbank
                          .endif
  585                     
  586                     	; ----
  587                     	; map data
  588                     	;
  589  01:A8F1  53 08     	tam	#3
  590  01:A8F3  1A        	inc	A
  591  01:A8F4  53 10     	tam	#4
  592  01:A8F6  AD 28 27  	lda	mapctablebank
  593  01:A8F9  53 04     	tam	#2
  594                     
  595                     	; ----
  596                     	; adjust data addresses
  597                     	;
  598  01:A8FB  A5 EF     	lda	<__si+1		; tile ptr
  599  01:A8FD  29 1F     	and	#$1F
  600  01:A8FF  09 60     	ora	#$60
  601  01:A901  85 EF     	sta	<__si+1
  602                     	; --
  603                     	stb	mapctable,<__bp	; color table ptr
       01:A903  AD 29 27  	lda	mapctable
       01:A906  85 EC     	sta	<__bp	
  604  01:A908  AD 2A 27  	lda	mapctable+1
  605  01:A90B  29 1F     	and	#$1F
  606  01:A90D  09 40     	ora	#$40
  607  01:A90F  85 ED     	sta	<__bp+1
  608                     
  609                     	; ----
  610                     	; bat pos
  611                     	;
  612  01:A911  68        	pla
  613  01:A912  2D 40 27  	and	bat_vmask
  614  01:A915  85 FA     	sta	<__bl
  615  01:A917  68        	pla
  616  01:A918  2D 3F 27  	and	bat_hmask
  617  01:A91B  85 FD     	sta	<__ch
  618  01:A91D  60        	rts
  619                     
  620                     
  621                     ; ----
  622                     ; load_map_next_line
  623                     ; ----
  624                     ; load_map sub routine
  625                     ; ----
  626                     ; IN :	X = BAT line inc value (1-2)
  627                     ; ----
  628                     ; OUT:	_DI = BAT address
  629                     ;	_SI = map address
  630                     ; ----
  631                     ; USE:	_BL = BAT Y pos
  632                     ;	_BH = map Y pos
  633                     ;	_SI = map address
  634                     ; ----
  635                     
  636  01:A91E            load_map_next_line:
  637                     
  638                     	; ----
  639                     	; incremente vram address
  640                     	;
  641  01:A91E  8A        	txa
  642                     	add	<__bl
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       01:A91F  18        	clc
       01:A920  65 FA     	adc	<__bl
                          .endif
  643  01:A922  CD 31 27  	cmp	mapbat_bottom
  644                     	blo	.l1
       01:A925  90 22     	bcc	.l1
  645                     	; --
  646                     	sub	mapbat_bottom	; 1/ vram wrapping
                0000      .if (1 = 2)			; from register A (handle
                          .else
       01:A927  38        	sec
       01:A928  ED 31 27  	sbc	mapbat_bottom	
                          .endif
  647  01:A92B  AA        	tax
  648  01:A92C  E8        	inx
  649                     	add	mapbat_top
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       01:A92D  18        	clc
       01:A92E  6D 30 27  	adc	mapbat_top
                          .endif
  650  01:A931  85 FA     	sta	<__bl
  651  01:A933  AD 2C 27  	lda	mapbat_ptr
  652  01:A936  2D 3F 27  	and	bat_hmask
  653                     	add	mapbat_top_base
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       01:A939  18        	clc
       01:A93A  6D 2E 27  	adc	mapbat_top_base
                          .endif
  654  01:A93D  8D 2C 27  	sta	mapbat_ptr
  655  01:A940  62        	cla
  656  01:A941  6D 2F 27  	adc	mapbat_top_base+1
  657  01:A944  8D 2D 27  	sta	mapbat_ptr+1
  658  01:A947  80 13     	bra	.l3
  659                     	; --
  660  01:A949  85 FA     .l1:	sta	<__bl		; 2/ vram inc
  661  01:A94B  AD 3C 27  .l2:	lda	bat_width
  662                     	add	mapbat_ptr
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       01:A94E  18        	clc
       01:A94F  6D 2C 27  	adc	mapbat_ptr
                          .endif
  663  01:A952  8D 2C 27  	sta	mapbat_ptr
  664  01:A955  62        	cla
  665  01:A956  6D 2D 27  	adc	mapbat_ptr+1
  666  01:A959  8D 2D 27  	sta	mapbat_ptr+1
  667                     	; --
  668  01:A95C  CA        .l3:	dex
  669  01:A95D  D0 EC     	bne	.l2
  670                     	; --
  671                     	stw	mapbat_ptr,<__di
       01:A95F  AD 2C 27  	lda	LOW_BYTE mapbat_ptr
       01:A962  85 F0     	sta	LOW_BYTE <__di
       01:A964  AD 2D 27  	lda	HIGH_BYTE mapbat_ptr
       01:A967  85 F1     	sta	HIGH_BYTE <__di
  672                     
  673                     	; ----
  674                     	; increment map address
  675                     	;
  676  01:A969  E6 FB     	inc	<__bh
  677  01:A96B  A5 FB     	lda	<__bh
  678  01:A96D  CD 1E 27  	cmp	mapheight
  679  01:A970  D0 1A     	bne	.l4
  680                     	; --
  681  01:A972  AD 19 27  	lda	mapbank		; 1/ map wrapping
  682  01:A975  53 08     	tam	#3
  683  01:A977  1A        	inc	A
  684  01:A978  53 10     	tam	#4
  685                     	stb	mapaddr,<__si
       01:A97A  AD 1A 27  	lda	mapaddr
       01:A97D  85 EE     	sta	<__si
  686  01:A97F  AD 1B 27  	lda	mapaddr+1
  687  01:A982  29 1F     	and	#$1F
  688  01:A984  09 60     	ora	#$60
  689  01:A986  85 EF     	sta	<__si+1
  690  01:A988  64 FB     	stz	<__bh
  691  01:A98A  80 1F     	bra	.l5
  692                     	; --
  693                     .l4:	addw	mapwidth,<__si	; 2/ map inc
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:A98C  18        	clc
       01:A98D  A5 EE     	lda	LOW_BYTE <__si	
       01:A98F  6D 1C 27  	adc	LOW_BYTE mapwidth
       01:A992  85 EE     	sta	LOW_BYTE <__si	
       01:A994  A5 EF     	lda	HIGH_BYTE <__si	
       01:A996  6D 1D 27  	adc	HIGH_BYTE mapwidth
       01:A999  85 EF     	sta	HIGH_BYTE <__si	
                          .endif
  694  01:A99B  C9 80     	cmp	#$80
  695                     	blo	.l5
       01:A99D  90 0C     	bcc	.l5
  696                     	sub	#$20
                0000      .if (1 = 2)			; from register A (handle
                          .else
       01:A99F  38        	sec
       01:A9A0  E9 20     	sbc	#$20
                          .endif
  697  01:A9A2  85 EF     	sta	<__si+1
  698  01:A9A4  43 10     	tma	#4
  699  01:A9A6  53 08     	tam	#3
  700  01:A9A8  1A        	inc	A
  701  01:A9A9  53 10     	tam	#4
  702  01:A9AB            .l5:
  703  01:A9AB  60        	rts
  704                     
  705                     
  706           0000      	.bank	LIB1_BANK
  707                     
  708                     ; ----
  709                     ; load_font
  710                     ; ----
  711                     ; transfer a 8x8 monochrome font into VRAM, slow but can be useful
  712                     ; ----
  713                     ; IN :	_DI = VRAM base address
  714                     ;	_BL = font bank
  715                     ;	_SI = font memory location
  716                     ;	_AL = font color (0-15)
  717                     ;	_AH = bg color (0-15)
  718                     ;	_CL = number of characters to copy
  719                     ; ----
  720                     
  721  00:C40B            load_font:
  722                     	maplibfunc	lib2_load_font
       00:C40B  A8        	tay
       00:C40C  43 20     	tma	#page(lib2_load_font)
       00:C40E  48        	pha
       00:C40F  A9 81     	lda	#bank(lib2_load_font)
       00:C411  53 20     	tam	#page(lib2_load_font)
       00:C413  98        	tya
       00:C414  20 AC A9  	jsr	lib2_load_font
       00:C417  A8        	tay
       00:C418  68        	pla
       00:C419  53 20     	tam	#page(lib2_load_font)
       00:C41B  98        	tya
  723  00:C41C  60        	rts
  724                     
  725           0001      	.bank	LIB2_BANK
  726                     
  727                     	; ----
  728                     	; map data
  729                     	;
  730  01:A9AC            lib2_load_font:
  731  01:A9AC  20 6A C3  	jsr	map_data
  732  01:A9AF  20 98 C4  	jsr	set_write
  733                     
  734                     	; ----
  735                     	; init bg color
  736                     	;
  737  01:A9B2  A5 FC     	lda	<__cl
  738  01:A9B4  48        	pha
  739                     	; --
  740  01:A9B5  A2 03     	ldx	#3
  741  01:A9B7  62        .l1:	cla
  742  01:A9B8  46 F9     	lsr	<__ah
  743  01:A9BA  90 02     	bcc	.l2
  744  01:A9BC  A9 FF     	lda	#$FF
  745  01:A9BE  95 FC     .l2:	sta	<__cl,X
  746  01:A9C0  CA        	dex
  747  01:A9C1  10 F4     	bpl	.l1
  748                     
  749                     	; ----
  750                     	; character loop
  751                     	;
  752  01:A9C3  FA        	plx
  753  01:A9C4            .copy:
  754                     
  755                     	; ----
  756                     	; plane 1
  757                     	;
  758  01:A9C4  C2        	cly
  759  01:A9C5  8F F8 08  .p1:	bbs0	<__al,.p2
  760  01:A9C8  B1 EE     	lda	[__si],Y
  761  01:A9CA  49 FF     	eor	#$FF
  762  01:A9CC  25 FF     	and	<__dh
  763  01:A9CE  80 04     	bra	.p3
  764                     	; --
  765  01:A9D0  A5 FF     .p2:	lda	<__dh
  766  01:A9D2  11 EE     	ora	[__si],Y
  767  01:A9D4  8D 02 00  .p3:	sta	video_data_l
  768                     
  769                     	; ----
  770                     	; plane 2
  771                     	;
  772  01:A9D7  9F F8 08  	bbs1	<__al,.p4
  773  01:A9DA  B1 EE     	lda	[__si],Y
  774  01:A9DC  49 FF     	eor	#$FF
  775  01:A9DE  25 FE     	and	<__dl
  776  01:A9E0  80 04     	bra	.p5
  777                     	; --
  778  01:A9E2  A5 FE     .p4:	lda	<__dl
  779  01:A9E4  11 EE     	ora	[__si],Y
  780  01:A9E6  8D 03 00  .p5:	sta	video_data_h
  781                     	; --
  782  01:A9E9  C8        	iny
  783  01:A9EA  C0 08     	cpy	#8
  784  01:A9EC  D0 D7     	bne	.p1
  785                     
  786                     	; ----
  787                     	; plane 3
  788                     	;
  789  01:A9EE  C2        	cly
  790  01:A9EF  AF F8 08  .t1:	bbs2	<__al,.t2
  791  01:A9F2  B1 EE     	lda	[__si],Y
  792  01:A9F4  49 FF     	eor	#$FF
  793  01:A9F6  25 FD     	and	<__ch
  794  01:A9F8  80 04     	bra	.t3
  795                     	; --
  796  01:A9FA  A5 FD     .t2:	lda	<__ch
  797  01:A9FC  11 EE     	ora	[__si],Y
  798  01:A9FE  8D 02 00  .t3:	sta	video_data_l
  799                     
  800                     	; ----
  801                     	; plane 4
  802                     	;
  803  01:AA01  BF F8 08  	bbs3	<__al,.t4
  804  01:AA04  B1 EE     	lda	[__si],Y
  805  01:AA06  49 FF     	eor	#$FF
  806  01:AA08  25 FC     	and	<__cl
  807  01:AA0A  80 04     	bra	.t5
  808                     	; --
  809  01:AA0C  A5 FC     .t4:	lda	<__cl
  810  01:AA0E  11 EE     	ora	[__si],Y
  811  01:AA10  8D 03 00  .t5:	sta	video_data_h
  812                     	; --
  813  01:AA13  C8        	iny
  814  01:AA14  C0 08     	cpy	#8
  815  01:AA16  D0 D7     	bne	.t1
  816                     
  817                     	; ----
  818                     	; next character
  819                     	;
  820                     	addw	#8,<__si
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:AA18  18        	clc
       01:AA19  A5 EE     	lda	LOW_BYTE <__si
       01:AA1B  69 08     	adc	LOW_BYTE #8
       01:AA1D  85 EE     	sta	LOW_BYTE <__si
       01:AA1F  A5 EF     	lda	HIGH_BYTE <__si
       01:AA21  69 00     	adc	HIGH_BYTE #8
       01:AA23  85 EF     	sta	HIGH_BYTE <__si
                          .endif
  821                     	; --
  822  01:AA25  CA        	dex
  823  01:AA26  D0 9C     	bne	.copy
  824                     
  825                     	; ----
  826                     	; unmap data
  827                     	;
  828  01:AA28  4C 8C C3  	jmp	unmap_data
  829                     
  830                     	; ----
  831                     	; restore bank mapping
  832                     	;
  833           0000      	.bank	LIB1_BANK
  834                     
  835                     
  836                     ; ----
  837                     ; load_vram
  838                     ; ----
  839                     ; copy a block of memory to VRAM
  840                     ; ----
  841                     ; IN :	_DI = VRAM location
  842                     ;	_BL = data bank
  843                     ;	_SI = data memory location
  844                     ;	_CX = number of words to copy
  845                     ; ----
  846           2734      	.bss
  847                     
  848                     ; This actually places a 'TIA' command
  849                     ; into RAM, from which to execute
  850                     ; for BLiT to VRAM for SATB transfer
  851                     ; and other VRAM load functions
  852                     
  853  --:2734            ram_hdwr_tia		.ds	1
  854  --:2735            ram_hdwr_tia_src	.ds	2
  855  --:2737            ram_hdwr_tia_dest	.ds	2
  856  --:2739            ram_hdwr_tia_size	.ds	2
  857  --:273B            ram_hdwr_tia_rts	.ds	1
  858                     
  859           C41D      	.code
  860                     
  861           0001      .ifdef HUC
  862  00:C41D            _load_vram.3:
  863                     .endif
  864  00:C41D            load_vram:
  865                     
  866                     	; ----
  867                     	; map data
  868                     	;
  869  00:C41D  20 6A C3  	jsr	map_data
  870                     
  871                     	; ----
  872                     	; set vram address
  873                     	;
  874  00:C420  20 98 C4  	jsr	set_write
  875                     
  876                     	; ----
  877                     	; copy data
  878                     	;
  879  00:C423  A9 02     	lda	#<video_data
  880  00:C425  8D 37 27  	sta	ram_hdwr_tia_dest+0
  881  00:C428  9C 38 27  	stz	ram_hdwr_tia_dest+1
  882  00:C42B  A9 20     	lda	#$20
  883  00:C42D  8D 39 27  	sta	ram_hdwr_tia_size+0
  884  00:C430  9C 3A 27  	stz	ram_hdwr_tia_size+1
  885                     
  886  00:C433  A6 EE     	ldx	<__si+0
  887  00:C435  8E 35 27  	stx	ram_hdwr_tia_src+0
  888  00:C438  A4 EF     	ldy	<__si+1
  889  00:C43A  8C 36 27  	sty	ram_hdwr_tia_src+1
  890                     
  891  00:C43D  A5 FC     	lda	<__cl			; length in chunks
  892  00:C43F  46 FD     	lsr	<__ch
  893  00:C441  6A        	ror	a
  894  00:C442  46 FD     	lsr	<__ch
  895  00:C444  6A        	ror	a
  896  00:C445  46 FD     	lsr	<__ch
  897  00:C447  6A        	ror	a
  898  00:C448  46 FD     	lsr	<__ch
  899  00:C44A  6A        	ror	a
  900  00:C44B  22        	sax				; x=chunks-lo
  901  00:C44C  F0 1F     	beq	.l4			; a=source-lo, y=source-hi
  902                     
  903                     	; ----
  904                     	; copy data (32-byte chunks)
  905                     	;
  906  00:C44E  20 34 27  .l1:	jsr	ram_hdwr_tia		; transfer 32-bytes
  907                     
  908  00:C451  18        	clc				; increment source
  909  00:C452  69 20     	adc	#$20
  910  00:C454  8D 35 27  	sta	ram_hdwr_tia_src+0
  911  00:C457  90 11     	bcc	.l3
  912  00:C459  C8        	iny
  913                     
  914  00:C45A  10 0B     	bpl	.l2			; remap_data
  915  00:C45C  A8        	tay
  916  00:C45D  43 10     	tma4
  917  00:C45F  53 08     	tam3
  918  00:C461  1A        	inc	a
  919  00:C462  53 10     	tam4
  920  00:C464  98        	tya
  921  00:C465  A0 60     	ldy	#$60
  922  00:C467  8C 36 27  .l2:	sty	ram_hdwr_tia_src+1
  923                     
  924  00:C46A  CA        .l3:	dex
  925  00:C46B  D0 E1     	bne	.l1
  926  00:C46D  C6 FD     .l4:	dec	<__ch
  927  00:C46F  10 DD     	bpl	.l1
  928                     
  929                     	; ----
  930                     	; copy data (remainder)
  931                     	;
  932  00:C471  A5 FC     	lda	<__cl
  933  00:C473  29 0F     	and	#15
  934  00:C475  F0 07     	beq	.l5
  935                     
  936  00:C477  0A        	asl	a
  937  00:C478  8D 39 27  	sta	ram_hdwr_tia_size+0
  938  00:C47B  20 34 27  	jsr	ram_hdwr_tia		; transfer remainder
  939                     
  940                     	; ----
  941                     	; unmap data
  942                     	;
  943                     
  944  00:C47E  4C 8C C3  .l5:	jmp	unmap_data
  945                     
  946                     
  947                     ; ----
  948                     ; set_read
  949                     ; ----
  950                     ; set the VDC VRAM read pointer
  951                     ; ----
  952                     ; IN :	_DI = VRAM location
  953                     ; ----
  954                     
  955  00:C481            set_read:
  956                     	vreg	#$01
       00:C481  A9 01     	lda	#$01
       00:C483  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:C485  03 01     	st0	#$01
                          .else
                          .endif
  957  00:C487  A5 F0     	lda	<__di
  958  00:C489  8D 02 00  	sta	video_data_l
  959  00:C48C  A5 F1     	lda	<__di+1
  960  00:C48E  8D 03 00  	sta	video_data_h
  961                     	vreg	#$02
       00:C491  A9 02     	lda	#$02
       00:C493  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:C495  03 02     	st0	#$02
                          .else
                          .endif
  962  00:C497  60        	rts
  963                     
  964                     
  965                     ; ----
  966                     ; set_write
  967                     ; ----
  968                     ; set the VDC VRAM write pointer
  969                     ; ----
  970                     ; IN :	_DI = VRAM location
  971                     ; ----
  972                     
  973  00:C498            set_write:
  974                     	vreg	#$00
       00:C498  A9 00     	lda	#$00
       00:C49A  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:C49C  03 00     	st0	#$00
                          .else
                          .endif
  975  00:C49E  A5 F0     	lda	<__di
  976  00:C4A0  8D 02 00  	sta	video_data_l
  977  00:C4A3  A5 F1     	lda	<__di+1
  978  00:C4A5  8D 03 00  	sta	video_data_h
  979                     	vreg	#$02
       00:C4A8  A9 02     	lda	#$02
       00:C4AA  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:C4AC  03 02     	st0	#$02
                          .else
                          .endif
  980  00:C4AE  60        	rts
  981                     
  982                     
  983                     ; ----
  984                     ; calc_vram_addr
  985                     ; ----
  986                     ; calculate VRAM address
  987                     ; ----
  988                     ; IN :	X = x coordinates
  989                     ;	A = y	"
  990                     ; ----
  991                     ; OUT:	_DI = VRAM location
  992                     ; ----
  993                     
  994  00:C4AF            calc_vram_addr:
  995  00:C4AF  DA        	phx
  996  00:C4B0  2D 40 27  	and	bat_vmask
  997  00:C4B3  64 F0     	stz	<__di
  998  00:C4B5  AE 3C 27  	ldx	bat_width
  999  00:C4B8  E0 40     	cpx	#64
 1000  00:C4BA  F0 07     	beq	.s64
 1001  00:C4BC  E0 80     	cpx	#128
 1002  00:C4BE  F0 06     	beq	.s128
 1003                     	; --
 1004  00:C4C0  4A        .s32:	lsr	A
 1005  00:C4C1  66 F0     	ror	<__di
 1006                     	; --
 1007  00:C4C3  4A        .s64:	lsr	A
 1008  00:C4C4  66 F0     	ror	<__di
 1009                     	; --
 1010  00:C4C6  4A        .s128:	lsr	A
 1011  00:C4C7  66 F0     	ror	<__di
 1012  00:C4C9  85 F1     	sta	<__di+1
 1013                     	; --
 1014  00:C4CB  68        	pla
 1015  00:C4CC  2D 3F 27  	and	bat_hmask
 1016  00:C4CF  05 F0     	ora	<__di
 1017  00:C4D1  85 F0     	sta	<__di
 1018  00:C4D3  60        	rts
 1019                     
 1020                     ; ----
 1021                     ; HSR(xres)
 1022                     ; ----
 1023                     ; macros to calculate the value of the HSR VDC register
 1024                     ; ----
 1025                     ; IN :	xres, horizontal screen resolution
 1026                     ; ----
 1027                     
 1028                     HSR	.macro
 1029                     .if (\1 < 268)
 1030                     	; low res
 1031                     	.db $02
 1032                     	.db (18 - (\1 / 16))
 1033                     .else
 1034                     .if (\1 < 356)
 1035                     	; high res
 1036                     	.db $03
 1037                     	.db (25 - (\1 / 16))
 1038                     .else
 1039                     	; very high res
 1040                     	.db $05
 1041                     	.db (42 - (\1 / 16))
 1042                     .endif
 1043                     .endif
 1044                     .endm
 1045                     
 1046                     
 1047                     ; ----
 1048                     ; HDR(xres)
 1049                     ; ----
 1050                     ; macros to calculate the value of the HDR VDC register
 1051                     ; ----
 1052                     ; IN :	xres, horizontal screen resolution
 1053                     ; ----
 1054                     
 1055                     HDR	.macro
 1056                     	.db ((\1 / 8) - 1)
 1057                     .if (\1 < 268)
 1058                     	; low res
 1059                     	.db (38 - ((18 - (\1 / 16)) + (\1 / 8)))
 1060                     .else
 1061                     .if (\1 < 356)
 1062                     	; high res
 1063                     	.db (51 - ((25 - (\1 / 16)) + (\1 / 8)))
 1064                     .else
 1065                     	; high res
 1066                     	.db (82 - ((42 - (\1 / 16)) + (\1 / 8)))
 1067                     .endif
 1068                     .endif
 1069                     .endm
 1070                     
 1071                     
 1072                     ; ----
 1073                     ; init_vdc
 1074                     ; ----
 1075                     ; initialize the video controller
 1076                     ;  - 256x224 screen mode
 1077                     ;  - 64x32 virtual bgmap size
 1078                     ;  - display and sprites off
 1079                     ;  - interrupts disabled
 1080                     ;  - SATB at $7F00
 1081                     ;  - VRAM cleared
 1082                     ; ----
 1083                     
 1084           273C      	.bss
 1085  --:273C            bat_width	.ds 2
 1086  --:273E            bat_height	.ds 1
 1087  --:273F            bat_hmask	.ds 1
 1088  --:2740            bat_vmask	.ds 1
 1089  --:2741            scr_width	.ds 1
 1090  --:2742            scr_height	.ds 1
 1091                     
 1092           C4D4      	.code
 1093                     
 1094  00:C4D4            init_vdc:
 1095                     	maplibfunc lib2_init_vdc
       00:C4D4  A8        	tay
       00:C4D5  43 20     	tma	#page(lib2_init_vdc)
       00:C4D7  48        	pha
       00:C4D8  A9 81     	lda	#bank(lib2_init_vdc)
       00:C4DA  53 20     	tam	#page(lib2_init_vdc)
       00:C4DC  98        	tya
       00:C4DD  20 2B AA  	jsr	lib2_init_vdc
       00:C4E0  A8        	tay
       00:C4E1  68        	pla
       00:C4E2  53 20     	tam	#page(lib2_init_vdc)
       00:C4E4  98        	tya
 1096  00:C4E5  60        	rts
 1097                     
 1098           0001      	.bank	LIB2_BANK
 1099  01:AA2B            lib2_init_vdc:
 1100                     ; ----
 1101                     ; default screen resolution
 1102                     ;
 1103           0000      .ifndef xres
 1105                     .endif
 1106                     
 1107                     	; ----
 1108                     	; initialize the VDC registers
 1109                     	;
 1110                     	stw	#.table,<__si 	; register table address in 'si'
       01:AA2B  A9 D1     	lda	LOW_BYTE #.table
       01:AA2D  85 EE     	sta	LOW_BYTE <__si 	
       01:AA2F  A9 AA     	lda	HIGH_BYTE #.table
       01:AA31  85 EF     	sta	HIGH_BYTE <__si 	
 1111  01:AA33  C2        	cly
 1112  01:AA34  B1 EE     .l1:	lda	[__si],Y		; select the VDC register
 1113  01:AA36  C8        	iny
 1114  01:AA37  85 F7     	sta	<vdc_reg
 1115  01:AA39  8D 00 00  	sta	video_reg
 1116  01:AA3C  B1 EE     	lda	[__si],Y		; send the 16-bit data
 1117  01:AA3E  C8        	iny
 1118  01:AA3F  8D 02 00  	sta	video_data_l
 1119  01:AA42  B1 EE     	lda	[__si],Y
 1120  01:AA44  C8        	iny
 1121  01:AA45  8D 03 00  	sta	video_data_h
 1122  01:AA48  C0 24     	cpy	#36		; loop if not at the end of the
 1123  01:AA4A  D0 E8     	bne	.l1		; table
 1124                     
 1125                     	; ----
 1126                     	; set the screen mode
 1127                     	;
 1128           0001      .if (xres < 268)
 1129  01:AA4C  A9 04     	lda	#(0 | XRES_SOFT)
 1130                     .else
 1136                     .endif
 1137                     
 1138                     ; This stuff alters display position from HuCard position
 1139                     
 1140                     ;	.if (CDROM)
 1141                     ;
 1142                     ;	ldx	#xres/8
 1143                     ;	ldy	#30
 1144                     ;	jsr	ex_scrmod
 1145                     ;	lda	#$01
 1146                     ;	jsr	ex_scrsiz
 1147                     ;	lda	#0
 1148                     ;	jsr	ex_imode
 1149                     ;
 1150                     ;	.else
 1151                     
 1152                     	; pixel clock frequency
 1153  01:AA4E  8D 00 04  	sta	color_ctrl
 1154                     ;
 1155                     ;	.endif
 1156                     
 1157                     
 1158                     	; ----
 1159                     	; set the background & border colors to black
 1160                     	;
 1161                     	stw	#256,color_reg
       01:AA51  A9 00     	lda	LOW_BYTE #256
       01:AA53  8D 02 04  	sta	LOW_BYTE color_reg
       01:AA56  A9 01     	lda	HIGH_BYTE #256
       01:AA58  8D 03 04  	sta	HIGH_BYTE color_reg
 1162                     	stwz	color_data
       01:AA5B  9C 04 04  	stz	LOW_BYTE color_data
       01:AA5E  9C 05 04  	stz	HIGH_BYTE color_data
 1163                     	stwz	color_reg
       01:AA61  9C 02 04  	stz	LOW_BYTE color_reg
       01:AA64  9C 03 04  	stz	HIGH_BYTE color_reg
 1164                     	stwz	color_data
       01:AA67  9C 04 04  	stz	LOW_BYTE color_data
       01:AA6A  9C 05 04  	stz	HIGH_BYTE color_data
 1165                     
 1166           0001      .if (CDROM)
 1167                     
 1168                     	; ----
 1169                     	; reset scrolling position (0,0)
 1170                     	;
 1171                     	vreg	#7
       01:AA6D  A9 07     	lda	#7
       01:AA6F  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:AA71  03 07     	st0	#7
                          .else
                          .endif
 1172                     	stwz	video_data
       01:AA73  9C 02 00  	stz	LOW_BYTE video_data
       01:AA76  9C 03 00  	stz	HIGH_BYTE video_data
 1173                     	vreg	#8
       01:AA79  A9 08     	lda	#8
       01:AA7B  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:AA7D  03 08     	st0	#8
                          .else
                          .endif
 1174                     	stwz	video_data
       01:AA7F  9C 02 00  	stz	LOW_BYTE video_data
       01:AA82  9C 03 00  	stz	HIGH_BYTE video_data
 1175                     	stwz	bg_x1
       01:AA85  9C 0C 22  	stz	LOW_BYTE bg_x1
       01:AA88  9C 0D 22  	stz	HIGH_BYTE bg_x1
 1176                     	stwz	bg_y1
       01:AA8B  9C 10 22  	stz	LOW_BYTE bg_y1
       01:AA8E  9C 11 22  	stz	HIGH_BYTE bg_y1
 1177                     
 1178                     	; ----
 1179                     	; set SATB address
 1180                     	;
 1181                     	stw	#$7F00,satb_addr
       01:AA91  A9 00     	lda	LOW_BYTE #$7F00
       01:AA93  8D 14 22  	sta	LOW_BYTE satb_addr
       01:AA96  A9 7F     	lda	HIGH_BYTE #$7F00
       01:AA98  8D 15 22  	sta	HIGH_BYTE satb_addr
 1182  01:AA9B  20 9F E0  	jsr	ex_sprdma
 1183  01:AA9E  A9 10     	lda	#$10
 1184  01:AAA0  20 9C E0  	jsr	ex_dmamod
 1185                     
 1186                     .endif	; (CDROM)
 1187                     
 1188                     	; ----
 1189                     	; clear the video RAM
 1190                     	;
 1191  01:AAA3  03 00     	st0	#0
 1192  01:AAA5  13 00     	st1	#0
 1193  01:AAA7  23 00     	st2	#0
 1194  01:AAA9  03 02     	st0	#2
 1195                     
 1196  01:AAAB  A2 80     	ldx	#128
 1197  01:AAAD  C2        .l2:	cly
 1198  01:AAAE  13 00     .l3:	st1	#0
 1199  01:AAB0  23 00     	st2	#0
 1200  01:AAB2  88        	dey
 1201  01:AAB3  D0 F9     	bne	.l3
 1202  01:AAB5  CA        	dex
 1203  01:AAB6  D0 F5     	bne	.l2
 1204                     
 1205                     	; ----
 1206                     	; save screen infos
 1207                     	;
 1208                     	stw	#xres,scr_width	; resolution
       01:AAB8  A9 00     	lda	LOW_BYTE #xres
       01:AABA  8D 41 27  	sta	LOW_BYTE scr_width	
       01:AABD  A9 01     	lda	HIGH_BYTE #xres
       01:AABF  8D 42 27  	sta	HIGH_BYTE scr_width	
 1209                     	stw	#224,scr_height
       01:AAC2  A9 E0     	lda	LOW_BYTE #224
       01:AAC4  8D 42 27  	sta	LOW_BYTE scr_height
       01:AAC7  A9 00     	lda	HIGH_BYTE #224
       01:AAC9  8D 43 27  	sta	HIGH_BYTE scr_height
 1210                     	; --
 1211  01:AACC  A9 01     	lda	#BGMAP_SIZE_64x32	; virtual size
 1212  01:AACE  4C F8 C4  	jmp	set_bat_size
 1213                     
 1214                     	; ----
 1215                     	; VDC register table
 1216                     	;
 1217  01:AAD1            .table:
 1218           0000      .ifdef _SGX
 1220                     .endif
 1221  01:AAD1  05 00 00  	.db $05,$00,$00		; CR	control register
 1222  01:AAD4  06 00 00  	.db $06,$00,$00		; RCR	scanline interrupt counter
 1223  01:AAD7  07 00 00  	.db $07,$00,$00		; BXR	background horizontal scroll offset
 1224  01:AADA  08 00 00  	.db $08,$00,$00		; BYR        "     vertical     "      "
 1225  01:AADD  09 10 00  	.db $09,$10,$00		; MWR	size of the virtual screen
 1226  01:AAE0  0A        	.db $0A			; HSR +
 1227                     	HSR xres		;     |			[$02,$02]
                0001      .if (xres		 < 268)
                          	; low res
       01:AAE1  02        	.db $02
       01:AAE2  02        	.db (18 - (xres		 / 16))
                          .else
                          .endif
 1228  01:AAE3  0B        	.db $0B			; HDR | display size
 1229                     	HDR xres		;     | and synchro	[$1F,$04]
       01:AAE4  1F        	.db ((xres		 / 8) - 1)
                0001      .if (xres		 < 268)
                          	; low res
       01:AAE5  04        	.db (38 - ((18 - (xres		 / 16)) + (xres		 / 8)))
                          .else
                          .endif
 1230  01:AAE6  0C 02 17  	.db $0C,$02,$17		; VPR |
 1231  01:AAE9  0D DF 00  	.db $0D,$DF,$00		; VDW |
 1232  01:AAEC  0E 0C 00  	.db $0E,$0C,$00		; VCR +
 1233  01:AAEF  0F 10 00  	.db $0F,$10,$00		; DCR	DMA control register
 1234  01:AAF2  13 00 7F  	.db $13,$00,$7F		; SATB	address of the SATB
 1235           0000      	.bank	LIB1_BANK
 1236                     
 1237                     
 1238                     ; ----
 1239                     ; set_xres
 1240                     ; ----
 1241                     ; set horizontal display resolution
 1242                     ; ----
 1243                     ; IN :	_AX = new x resolution (ie. 320)
 1244                     ;	_CL = 'blur bit' for color register
 1245                     ; USES: _BX
 1246                     ; ----
 1247                     
 1248  00:C4E6            set_xres:
 1249                     	maplibfunc	lib2_set_xres
       00:C4E6  A8        	tay
       00:C4E7  43 20     	tma	#page(lib2_set_xres)
       00:C4E9  48        	pha
       00:C4EA  A9 81     	lda	#bank(lib2_set_xres)
       00:C4EC  53 20     	tam	#page(lib2_set_xres)
       00:C4EE  98        	tya
       00:C4EF  20 F5 AA  	jsr	lib2_set_xres
       00:C4F2  A8        	tay
       00:C4F3  68        	pla
       00:C4F4  53 20     	tam	#page(lib2_set_xres)
       00:C4F6  98        	tya
 1250  00:C4F7  60        	rts
 1251                     
 1252                     
 1253           0001      	.bank	LIB2_BANK
 1254                     
 1255           2743      	.bss
 1256  --:2743            vdc_blur	.ds 1	; blur bit
 1257  --:2744            hsw		.ds 1	; temporary parameters for calculating video registers
 1258  --:2745            hds		.ds 1
 1259  --:2746            hdw		.ds 1
 1260  --:2747            hde		.ds 1
 1261                     
 1262           AAF5      	.code
 1263                     
 1264  01:AAF5            lib2_set_xres:
 1265  01:AAF5  A9 20     	lda	#$20		; reset resource-usage flag
 1266  01:AAF7  04 F5     	tsb	<irq_m		; to skip joystick read portion of vsync
 1267                     				; (temporarily disable VSYNC processing)
 1268  01:AAF9  A5 F9     	lda	<__ah
 1269  01:AAFB  85 FB     	sta	<__bh
 1270  01:AAFD  A5 F8     	lda	<__al
 1271  01:AAFF  85 FA     	sta	<__bl		; bx now has x-res
 1272                     
 1273  01:AB01  46 FB     	lsr	<__bh
 1274  01:AB03  66 FA     	ror	<__bl
 1275  01:AB05  46 FB     	lsr	<__bh
 1276  01:AB07  66 FA     	ror	<__bl
 1277  01:AB09  46 FA     	lsr	<__bl		; bl now has x/8
 1278                     
 1279  01:AB0B  C2        	cly			; offset into numeric tables
 1280                     				; 0=low-res, 1=mid-res, 2=high-res
 1281                     
 1282  01:AB0C  A5 F9     	lda	<__ah
 1283  01:AB0E  F0 1E     	beq	.xres_calc	; < 256
 1284  01:AB10  C9 03     	cmp	#3
 1285                     	bhs	.xres_calc
       01:AB12  B0 1A     	bcs	.xres_calc
 1286                     
 1287                     	cmpw	#$10C,<__ax
       01:AB14  A5 F9     	lda	HIGH_BYTE <__ax
       01:AB16  C9 01     	cmp	HIGH_BYTE #$10C
       01:AB18  D0 04     	bne	.x_00102
       01:AB1A  A5 F8     	lda	LOW_BYTE <__ax
       01:AB1C  C9 0C     	cmp	LOW_BYTE #$10C
       01:AB1E            .x_00102:
 1288                     	blo	.xres_calc	; < 268
       01:AB1E  90 0E     	bcc	.xres_calc	
 1289                     
 1290  01:AB20  C8        	iny
 1291                     	cmpw	#$164,<__ax
       01:AB21  A5 F9     	lda	HIGH_BYTE <__ax
       01:AB23  C9 01     	cmp	HIGH_BYTE #$164
       01:AB25  D0 04     	bne	.x_00104
       01:AB27  A5 F8     	lda	LOW_BYTE <__ax
       01:AB29  C9 64     	cmp	LOW_BYTE #$164
       01:AB2B            .x_00104:
 1292                     	blo	.xres_calc	; < 356
       01:AB2B  90 01     	bcc	.xres_calc	
 1293                     
 1294  01:AB2D  C8        	iny			; 356 < x < 512
 1295                     
 1296  01:AB2E            .xres_calc:
 1297  01:AB2E  B9 8A AB  	lda	.vce_tab,Y
 1298  01:AB31  05 FC     	ora	<__cl
 1299  01:AB33  8D 00 04  	sta	color_ctrl	; dot-clock (x-resolution)
 1300                     
 1301  01:AB36  B9 8D AB  	lda	.hsw_tab,Y	; example calc's (using "low-res" numbers)
 1302  01:AB39  8D 44 27  	sta	hsw		; hsw = $2
 1303  01:AB3C  A5 FA     	lda	<__bl
 1304  01:AB3E  8D 45 27  	sta	hds		; hds = (x/8) temporarily
 1305  01:AB41  3A        	dec	A
 1306  01:AB42  8D 46 27  	sta	hdw		; hdw = (x/8)-1
 1307  01:AB45  4E 45 27  	lsr	hds		; hds = (x/16) temporarily
 1308                     
 1309  01:AB48  B9 90 AB  	lda	.hds_tab,Y
 1310                     	sub	hds
                0000      .if (1 = 2)			; from register A (handle
                          .else
       01:AB4B  38        	sec
       01:AB4C  ED 45 27  	sbc	hds
                          .endif
 1311  01:AB4F  8D 45 27  	sta	hds		; hds = 18 - (x/16)
 1312                     
 1313  01:AB52  B9 93 AB  	lda	.hde_tab,Y
 1314                     	sub	hds
                0000      .if (1 = 2)			; from register A (handle
                          .else
       01:AB55  38        	sec
       01:AB56  ED 45 27  	sbc	hds
                          .endif
 1315                     	sub	<__bl		; hde = (38 - ( (18-(x/16)) + (x/8) ))
                0000      .if (1 = 2)			; from register A (handle
                          .else
       01:AB59  38        	sec
       01:AB5A  E5 FA     	sbc	<__bl		
                          .endif
 1316  01:AB5C  8D 47 27  	sta	hde
 1317                     
 1318  01:AB5F            .xres_putit:
 1319  01:AB5F  A9 0A     	lda	#$0a
 1320  01:AB61  85 F7     	sta	<vdc_reg
 1321  01:AB63  8D 00 00  	sta	video_reg
 1322  01:AB66  AD 44 27  	lda	hsw
 1323  01:AB69  8D 02 00  	sta	video_data_l
 1324  01:AB6C  AD 45 27  	lda	hds
 1325  01:AB6F  8D 03 00  	sta	video_data_h
 1326                     
 1327  01:AB72  A9 0B     	lda	#$0b
 1328  01:AB74  85 F7     	sta	<vdc_reg
 1329  01:AB76  8D 00 00  	sta	video_reg
 1330  01:AB79  AD 46 27  	lda	hdw
 1331  01:AB7C  8D 02 00  	sta	video_data_l
 1332  01:AB7F  AD 47 27  	lda	hde
 1333  01:AB82  8D 03 00  	sta	video_data_h
 1334                     
 1335  01:AB85            .xres_err:
 1336  01:AB85  A9 20     	lda	#$20
 1337  01:AB87  14 F5     	trb	<irq_m		; re-enable VSYNC processing
 1338  01:AB89  60        	rts
 1339                     
 1340  01:AB8A  00 01 02  .vce_tab:	.db	0, 1, 2
 1341  01:AB8D  02 03 05  .hsw_tab:	.db	2, 3, 5
 1342  01:AB90  12 19 2A  .hds_tab:	.db	18,25,42
 1343  01:AB93  26 33 52  .hde_tab:	.db	38,51,82
 1344                     
 1345           0000      	.bank	LIB1_BANK	; restore bank context
 1346                     
 1347                     ; ----
 1348                     ; set_bat_size
 1349                     ; ----
 1350                     ; set bg map virtual size
 1351                     ; ----
 1352                     ; IN : A = new size (0-7)
 1353                     ; ----
 1354                     
 1355  00:C4F8            set_bat_size:
 1356  00:C4F8  29 07     	and	#$07
 1357  00:C4FA  48        	pha
 1358                     	; --
 1359           0001      .if (CDROM)
 1360  00:C4FB  20 69 E0  	jsr	ex_scrsiz
 1361  00:C4FE  FA        	plx
 1362                     .else
 1371                     .endif
 1372                     	; --
 1373  00:C4FF  BD 23 C5  	lda	.width,X
 1374  00:C502  8D 3C 27  	sta	bat_width
 1375  00:C505  9C 3D 27  	stz	bat_width+1
 1376  00:C508  3A        	dec	A
 1377  00:C509  8D 3F 27  	sta	bat_hmask
 1378                     	; --
 1379  00:C50C  BD 2B C5  	lda	.height,X
 1380  00:C50F  8D 3E 27  	sta	bat_height
 1381  00:C512  8D 31 27  	sta	mapbat_bottom
 1382  00:C515  9C 30 27  	stz	mapbat_top
 1383  00:C518  9C 2E 27  	stz	mapbat_top_base
 1384  00:C51B  9C 2F 27  	stz	mapbat_top_base+1
 1385  00:C51E  3A        	dec	A
 1386  00:C51F  8D 40 27  	sta	bat_vmask
 1387  00:C522  60        	rts
 1388                     
 1389  00:C523  20 40 80  .width:	.db $20,$40,$80,$80,$20,$40,$80,$80
       00:C526  80 20 40  
       00:C529  80 80     
 1390  00:C52B  20 20 20  .height: .db $20,$20,$20,$20,$40,$40,$40,$40
       00:C52E  20 40 40  
       00:C531  40 40     
 1391                     
 1392                     
 1393                     ; ----
 1394                     ; init_psg
 1395                     ; ----
 1396                     ; initialize the sound generator.
 1397                     ; ----
 1398                     
 1399  00:C533            init_psg:
 1400                     	maplibfunc lib2_init_psg
       00:C533  A8        	tay
       00:C534  43 20     	tma	#page(lib2_init_psg)
       00:C536  48        	pha
       00:C537  A9 81     	lda	#bank(lib2_init_psg)
       00:C539  53 20     	tam	#page(lib2_init_psg)
       00:C53B  98        	tya
       00:C53C  20 96 AB  	jsr	lib2_init_psg
       00:C53F  A8        	tay
       00:C540  68        	pla
       00:C541  53 20     	tam	#page(lib2_init_psg)
       00:C543  98        	tya
 1401  00:C544  60        	rts
 1402                     
 1403           0001      	.bank	LIB2_BANK
 1404  01:AB96            lib2_init_psg:
 1405  01:AB96  9C 01 08  	stz	psg_mainvol	; main volume to zero
 1406  01:AB99  9C 09 08  	stz	psg_lfoctrl	; disable the LFO
 1407                     
 1408  01:AB9C  A9 05     	lda	#5		; set volume to zero for each channel
 1409  01:AB9E  8D 00 08  .clear:	sta	psg_ch		; and disable them
 1410  01:ABA1  9C 04 08  	stz	psg_ctrl
 1411  01:ABA4  9C 05 08  	stz	psg_pan
 1412  01:ABA7  3A        	dec	A
 1413  01:ABA8  10 F4     	bpl	.clear
 1414                     
 1415  01:ABAA  A9 04     	lda	#4		; disable noise for channel 5 & 6
 1416  01:ABAC  8D 00 08  	sta	psg_ch
 1417  01:ABAF  9C 07 08  	stz	psg_noise
 1418  01:ABB2  A9 05     	lda	#5
 1419  01:ABB4  8D 00 08  	sta	psg_ch
 1420  01:ABB7  9C 07 08  	stz	psg_noise
 1421  01:ABBA  60        	rts
 1422           0000      	.bank	LIB1_BANK
 1423                     
 1424                     
 1425                     ; ----------------------------------
 1426                     ; Some simple copy/compare functions
 1427                     ; ----------------------------------
 1428                     
 1429                     ; ----
 1430                     ; char * _strncpy(char *dest [__di], char *src [__si], unsigned char count [acc])
 1431                     ; char * _strncat(char *dest [__di], char *src [__si], unsigned char count [acc])
 1432                     ; ----
 1433                     ; Copy/Concatenate a string to another string
 1434                     ; ----
 1435                     
 1436  00:C545  48        str_find_end:	pha
 1437  00:C546  B2 F0     .loop:		lda	[__di]
 1438  00:C548  F0 08     		beq	.found
 1439  00:C54A  E6 F0     		inc	<__di
 1440  00:C54C  D0 F8     		bne	.loop
 1441  00:C54E  E6 F1     		inc	<__di+1
 1442  00:C550  80 F4     		bra	.loop
 1443  00:C552  68        .found:		pla
 1444  00:C553  60        		rts
 1445                     
 1446  00:C554  44 EF     _strncat.3:     bsr	str_find_end
 1447                     
 1448  00:C556  8A        _strncpy.3:	txa
 1449  00:C557  49 FF     		eor	#$ff
 1450  00:C559  AA        		tax
 1451                     
 1452  00:C55A  C2        		cly
 1453  00:C55B  E8        .loop:		inx
 1454  00:C55C  F0 18     		beq	str_terminate
 1455  00:C55E  B1 EE     .copy:		lda	[__si],y
 1456  00:C560  F0 14     		beq	str_terminate
 1457  00:C562  91 F0     		sta	[__di],y
 1458  00:C564  C8        		iny
 1459  00:C565  D0 F4     		bne	.loop
 1460  00:C567  80 0C     		bra	str_overflow
 1461                     
 1462                     ; ----
 1463                     ; char * _strcat(char *dest [__di], char *src [__si])
 1464                     ; char * _strcpy(char *dest [__di], char *src [__si])
 1465                     ; ----
 1466                     ; Copy/Concatenate a string to another string
 1467                     ; ----
 1468                     
 1469  00:C569  44 DA     _strcat.2:	bsr	str_find_end
 1470                     
 1471  00:C56B  C2        _strcpy.2:	cly
 1472  00:C56C  B1 EE     .loop:		lda	[__si],y
 1473  00:C56E  91 F0     		sta	[__di],y
 1474  00:C570  F0 29     		beq	memstr_finish
 1475  00:C572  C8        		iny
 1476  00:C573  D0 F7     		bne	.loop
 1477  00:C575  88        str_overflow:	dey
 1478  00:C576  62        str_terminate:	cla
 1479  00:C577  91 F0     		sta	[__di],y
 1480  00:C579  80 20     		bra	memstr_finish
 1481                     
 1482                     ; ----
 1483                     ; char * _memcpy(char *dest [__di], char *src [__si], int count [acc])
 1484                     ; ----
 1485                     ; Copy memory
 1486                     ; ----
 1487                     
 1488  00:C57B            _mempcpy.3:
 1489  00:C57B  86 02     _memcpy.3:	stx	<__temp
 1490  00:C57D  C2        		cly
 1491  00:C57E  AA        		tax
 1492  00:C57F  F0 0E     		beq	.done_pages
 1493  00:C581  B1 EE     .copy_page:	lda	[__si],y
 1494  00:C583  91 F0     		sta	[__di],y
 1495  00:C585  C8        		iny
 1496                     ;		lda	[__si],y
 1497                     ;		sta	[__di],y
 1498                     ;		iny
 1499  00:C586  D0 F9     		bne	.copy_page
 1500  00:C588  E6 EF     		inc	<__si+1
 1501  00:C58A  E6 F1     		inc	<__di+1
 1502  00:C58C  CA        		dex
 1503  00:C58D  D0 F2     		bne	.copy_page
 1504                     
 1505                     ;.done_pages:	lsr	<__temp
 1506                     ;		ldx	<__temp
 1507                     ;		beq	memstr_finish
 1508                     ;		bcs	.copy_1byte
 1509                     ;		dex
 1510                     ;.copy_2bytes:	lda	[__si],y
 1511                     ;		sta	[__di],y
 1512                     ;		iny
 1513                     ;.copy_1byte:	lda	[__si],y
 1514                     ;		sta	[__di],y
 1515                     ;		iny
 1516                     ;		dex
 1517                     ;		bpl	.copy_2bytes
 1518                     ;.done_bytes:	bra	memstr_finish
 1519                     
 1520  00:C58F  A6 02     .done_pages:	ldx	<__temp
 1521  00:C591  F0 08     		beq	memstr_finish
 1522  00:C593  B1 EE     .copy_byte:	lda	[__si],y
 1523  00:C595  91 F0     		sta	[__di],y
 1524  00:C597  C8        		iny
 1525  00:C598  CA        		dex
 1526  00:C599  D0 F8     		bne	.copy_byte
 1527  00:C59B            .done_bytes: ;	bra	memstr_finish
 1528                     
 1529                     		; !!! WARNING : non-standard return value !!!
 1530                     		; it's actually a lot more useful to have these
 1531                     		; return a ptr to the end of the strcpy/strcat.
 1532                     
 1533  00:C59B  98        memstr_finish:	tya
 1534  00:C59C  18        		clc
 1535  00:C59D  65 F0     		adc	<__di
 1536  00:C59F  AA        		tax
 1537  00:C5A0  A5 F1     		lda	<__di+1
 1538  00:C5A2  90 01     		bcc	.exit
 1539  00:C5A4  1A        		inc	a
 1540  00:C5A5  60        .exit:		rts
 1541                     
 1542                     ; ----
 1543                     ; char * _memset(char *s [__di], int c [__bx], int n [acc])
 1544                     ; ----
 1545                     ; Set memory
 1546                     ; ----
 1547                     
 1548  00:C5A6  86 02     _memset.3:	stx	<__temp
 1549  00:C5A8  C2        		cly
 1550  00:C5A9  AA        		tax
 1551  00:C5AA  F0 0E     		beq	.done_pages
 1552  00:C5AC  A5 FA     		lda	<__bx
 1553  00:C5AE  91 F0     .set_page:	sta	[__di],y
 1554  00:C5B0  C8        		iny
 1555                     ;		sta	[__di],y
 1556                     ;		iny
 1557  00:C5B1  D0 FB     		bne	.set_page
 1558  00:C5B3  E6 EF     		inc	<__si+1
 1559  00:C5B5  E6 F1     		inc	<__di+1
 1560  00:C5B7  CA        		dex
 1561  00:C5B8  D0 F4     		bne	.set_page
 1562                     
 1563                     ;.done_pages:	lsr	<__temp
 1564                     ;		ldx	<__temp
 1565                     ;		beq	memstr_finish
 1566                     ;		bcs	.set_1byte
 1567                     ;		dex
 1568                     ;.set_2bytes:	sta	[__di],y
 1569                     ;		iny
 1570                     ;.set_1byte:	sta	[__di],y
 1571                     ;		iny
 1572                     ;		dex
 1573                     ;		bpl	.set_2bytes
 1574                     ;.done_bytes:	bra	memstr_finish
 1575                     
 1576  00:C5BA  A6 02     .done_pages:	ldx	<__temp
 1577  00:C5BC  F0 DD     		beq	memstr_finish
 1578  00:C5BE  A5 FA     		lda	<__bx
 1579  00:C5C0  91 F0     .set_byte:	sta	[__di],y
 1580  00:C5C2  C8        		iny
 1581  00:C5C3  CA        		dex
 1582  00:C5C4  D0 FA     		bne	.set_byte
 1583  00:C5C6  80 D3     .done_bytes:	bra	memstr_finish
 1584                     
 1585                     ; ----
 1586                     ; int _memcmp(char *dest [__di], char *src [__si], int count [acc])
 1587                     ; ----
 1588                     ; Compare memory
 1589                     ; ----
 1590                     
 1591  00:C5C8  49 FF     _memcmp.3:	eor	#$ff
 1592  00:C5CA  85 02     		sta	<__temp
 1593  00:C5CC  8A        		txa
 1594  00:C5CD  49 FF     		eor	#$ff
 1595  00:C5CF  AA        		tax
 1596  00:C5D0  C2        		cly
 1597  00:C5D1  E8        .loop:		inx
 1598  00:C5D2  F0 11     		beq	.page
 1599  00:C5D4  B1 F0     .test:		lda	[__di],y
 1600  00:C5D6  D1 EE     		cmp	[__si],y
 1601  00:C5D8  30 17     		bmi	cmp_minus
 1602  00:C5DA  D0 11     		bne	cmp_plus
 1603  00:C5DC  C8        		iny
 1604  00:C5DD  D0 F2     		bne	.loop
 1605  00:C5DF  E6 EF     		inc	<__si+1
 1606  00:C5E1  E6 F1     		inc	<__di+1
 1607  00:C5E3  80 EC     		bra	.loop
 1608  00:C5E5  E6 02     .page:		inc	<__temp
 1609  00:C5E7  D0 EB     		bne	.test
 1610                     ;		bra	cmp_same
 1611                     
 1612  00:C5E9  A2 00     cmp_same:	ldx	#$00
 1613  00:C5EB  62        		cla
 1614  00:C5EC  60        		rts
 1615                     
 1616  00:C5ED  A2 01     cmp_plus:	ldx	#$01
 1617  00:C5EF  62        		cla
 1618  00:C5F0  60        		rts
 1619                     
 1620  00:C5F1  A2 FF     cmp_minus:	ldx	#$FF
 1621  00:C5F3  8A        		txa
 1622  00:C5F4  60        		rts
 1623                     
 1624                     ; ----
 1625                     ; int _strcmp(char *dest [__di], char *src [__si])
 1626                     ; ----
 1627                     ; Compare strings
 1628                     ; ----
 1629                     
 1630  00:C5F5  C2        _strcmp.2:	cly
 1631  00:C5F6  B1 F0     .loop:		lda	[__di],y
 1632  00:C5F8  D1 EE     		cmp	[__si],y
 1633  00:C5FA  30 F5     		bmi	cmp_minus
 1634  00:C5FC  D0 EF     		bne	cmp_plus
 1635  00:C5FE  C9 00     		cmp	#0
 1636  00:C600  F0 E7     		beq	cmp_same
 1637  00:C602  C8        		iny
 1638  00:C603  D0 F1     		bne	.loop
 1639  00:C605  80 E2     		bra	cmp_same
 1640                     
 1641                     ; ----
 1642                     ; int _strncmp(char *dest [__di], char *src [__si], unsigned char count [acc])
 1643                     ; ----
 1644                     ; Compare strings
 1645                     ; ----
 1646                     
 1647  00:C607  8A        _strncmp.3:	txa
 1648  00:C608  49 FF     		eor	#$ff
 1649  00:C60A  AA        		tax
 1650  00:C60B  C2        		cly
 1651  00:C60C  E8        .loop:		inx
 1652  00:C60D  F0 DA     		beq	cmp_same
 1653  00:C60F  B1 F0     .test:		lda	[__di],y
 1654  00:C611  D1 EE     		cmp	[__si],y
 1655  00:C613  30 DC     		bmi	cmp_minus
 1656  00:C615  D0 D6     		bne	cmp_plus
 1657  00:C617  C9 00     		cmp	#0
 1658  00:C619  F0 CE     		beq	cmp_same
 1659  00:C61B  C8        		iny
 1660  00:C61C  D0 EE     		bne	.loop
 1661  00:C61E  80 C9     		bra	cmp_same
 1662                     
 1663                     ; ----
 1664                     ; unsigned char _strlen(char *src [__si])
 1665                     ; ----
 1666                     ; Strings length
 1667                     ; ----
 1668                     
 1669  00:C620  C2        _strlen.1:	cly
 1670  00:C621  B1 EE     .loop:		lda	[__si],y
 1671  00:C623  F0 03     		beq	.done
 1672  00:C625  C8        		iny
 1673  00:C626  D0 F9     		bne	.loop
 1674  00:C628  02        .done:		sxy
 1675  00:C629  62        		cla
 1676  00:C62A  60        		rts
 1677                     
 1678                     ; ----
 1679                     
 1680  00:C62B            ___builtin_ffs.1:
 1681                     	maplibfunc lib2____builtin_ffs.1
       00:C62B  A8        	tay
       00:C62C  43 20     	tma	#page(lib2____builtin_ffs.1)
       00:C62E  48        	pha
       00:C62F  A9 81     	lda	#bank(lib2____builtin_ffs.1)
       00:C631  53 20     	tam	#page(lib2____builtin_ffs.1)
       00:C633  98        	tya
       00:C634  20 BB AB  	jsr	lib2____builtin_ffs.1
       00:C637  A8        	tay
       00:C638  68        	pla
       00:C639  53 20     	tam	#page(lib2____builtin_ffs.1)
       00:C63B  98        	tya
 1682  00:C63C  60        	rts
 1683                     
 1684           0001      	.bank LIB2_BANK
 1685  01:ABBB            lib2____builtin_ffs.1:
 1686  01:ABBB  22        	sax
 1687  01:ABBC  A0 F8     	ldy #-8
 1688  01:ABBE  6A        .search_lo:	ror a
 1689  01:ABBF  B0 14     	bcs .found_in_lo
 1690  01:ABC1  C8        	iny
 1691  01:ABC2  D0 FA     	bne .search_lo
 1692  01:ABC4  8A        	txa
 1693  01:ABC5  A0 F8     	ldy #-8
 1694  01:ABC7  6A        .search_hi:	ror a
 1695  01:ABC8  B0 05     	bcs .found_in_hi
 1696  01:ABCA  C8        	iny
 1697  01:ABCB  D0 FA     	bne .search_hi
 1698  01:ABCD  82        	clx		; no bits set, return 0 (A is already 0)
 1699  01:ABCE  60        	rts
 1700  01:ABCF  98        .found_in_hi:tya		; found bit in the high byte
 1701  01:ABD0  69 10     	adc #16		; carry is set
 1702  01:ABD2  AA        	tax
 1703  01:ABD3  62        	cla		; return 17 + y
 1704  01:ABD4  60        	rts
 1705  01:ABD5  98        .found_in_lo:tya		; found bit in the low byte
 1706  01:ABD6  69 08     	adc #8		; carry is set
 1707  01:ABD8  AA        	tax
 1708  01:ABD9  62        	cla		; return 9 + y
 1709  01:ABDA  60        	rts
 1710           0000      	.bank LIB1_BANK
 1711                     
 1712  00:C63D            _mem_mapdatabanks:
 1713  00:C63D  A8        	tay		; y = new upper bank
 1714  00:C63E  43 10     	tma #DATA_BANK+1; a = old upper bank
 1715  00:C640  42        	say		; y = old upper bank, a = new upper bank
 1716  00:C641  53 10     	tam #DATA_BANK+1
 1717  00:C643            do_mapdatabank:
 1718  00:C643  43 08     	tma #DATA_BANK	; a = old lower bank
 1719  00:C645  22        	sax		; x = old lower bank, a = new lower bank
 1720  00:C646  53 08     	tam #DATA_BANK
 1721  00:C648  98        	tya		; a = old upper bank
 1722  00:C649  60        	rts
 1723  00:C64A            _mem_mapdatabank:
 1724  00:C64A  C2        	cly
 1725  00:C64B  80 F6     	bra do_mapdatabank
 1726                     
 1727  00:C64D            _timer_set:
 1728  00:C64D  8E 00 0C  	stx	timer_cnt
 1729  00:C650  60        	rts
 1730  00:C651            _timer_start:
 1731  00:C651  A9 01     	lda	#1
 1732  00:C653  8D 01 0C  	sta	timer_ctrl
 1733  00:C656  60        	rts
 1734  00:C657            _timer_stop:
 1735  00:C657  9C 01 0C  	stz	timer_ctrl
 1736  00:C65A  60        	rts
 1737  00:C65B            _timer_get:
 1738  00:C65B  AD 00 0C  	lda	timer_cnt
 1739  00:C65E  29 7F     	and	#$7f
 1740  00:C660  AA        	tax
 1741  00:C661  62        	cla
 1742  00:C662  60        	rts
 1743  00:C663            _irq_disable:
 1744  00:C663  8A        	txa
 1745  00:C664  78        	sei
 1746  00:C665  0D 02 14  	ora	irq_disable
 1747  00:C668  8D 02 14  	sta	irq_disable
 1748  00:C66B  58        	cli
 1749  00:C66C  60        	rts
 1750  00:C66D            _irq_enable:
 1751  00:C66D  8A        	txa
 1752  00:C66E  49 FF     	eor	#$ff
 1753  00:C670  78        	sei
 1754  00:C671  2D 02 14  	and	irq_disable
 1755  00:C674  8D 02 14  	sta	irq_disable
 1756  00:C677  58        	cli
 1757  00:C678  60        	rts
 1758                     
 1759  00:C679            _abort:
 1760  00:C679  E2        	.db 0xe2
 1761                     
 1762  00:C67A            _exit:
 1763  00:C67A  63        	.db 0x63
 1764                     
 1765  00:C67B            _dump_screen:
 1766  00:C67B  33        	.db 0x33
#[2]   startup.asm
#[3]   scroll.asm
 1264                     .include "scroll.asm"
    1                     ;
    2                     ; SCROLL.ASM  -  MagicKit Scrolling Library
    3                     ;
    4                     ;
    5                     
    6                     ; [ 28] user scrolling vars
    7           2748      	.bss
    8  --:2748            scroll_xl:	.ds 4	; x       |
    9  --:274C            scroll_xh:	.ds 4	;         |
   10  --:2750            scroll_yl:	.ds 4	; y       |
   11  --:2754            scroll_yh:	.ds 4	;         | scrolling table
   12  --:2758            scroll_top:	.ds 4	; top     |
   13  --:275C            scroll_bottom:	.ds 4	; bottom  |
   14  --:2760            scroll_cr:	.ds 4	; control |
   15                     
   16                     ; [ 69] display list
   17           2764      	.bss
   18  --:2764            s_idx		.ds 1
   19  --:2765            s_xl		.ds 8
   20  --:276D            s_xh		.ds 8
   21  --:2775            s_yl		.ds 8
   22  --:277D            s_yh		.ds 8
   23  --:2785            s_cr		.ds 8
   24  --:278D            s_top		.ds 9
   25  --:2796            s_bottom	.ds 8
   26  --:279E            s_list		.ds 8
   27  --:27A6            s_work		.ds 3
   28                     
   29           C67C      	.code
   30           0001      	.bank	LIB2_BANK
   31                     ; ----
   32                     ; build_display_list
   33                     ; ----
   34                     
   35  01:ABDB            build_disp_list:
   36                     	; ----
   37                     	; quick test
   38                     	;
   39  01:ABDB  AD 60 27  	lda	scroll_cr
   40  01:ABDE  0D 61 27  	ora	scroll_cr+1
   41  01:ABE1  0D 62 27  	ora	scroll_cr+2
   42  01:ABE4  0D 63 27  	ora	scroll_cr+3
   43  01:ABE7  29 01     	and	#$01
   44  01:ABE9  D0 02     	bne	.l0
   45                     	; --
   46  01:ABEB  18        	clc
   47  01:ABEC  60        	rts
   48                     
   49                     	; ----
   50                     	; parse user scroll list
   51                     	;
   52  01:ABED  82        .l0:	clx
   53  01:ABEE  C2        	cly
   54                     	; --
   55  01:ABEF  B9 60 27  .l1:	lda	scroll_cr,Y
   56  01:ABF2  29 01     	and	#$01
   57  01:ABF4  F0 38     	beq	.l2
   58  01:ABF6  B9 58 27  	lda	scroll_top,Y
   59  01:ABF9  CD 42 27  	cmp	scr_height
   60                     	bhs	.l2
       01:ABFC  B0 30     	bcs	.l2
   61  01:ABFE  3A        	dec a
   62  01:ABFF  20 95 AC  	jsr	.check_list
   63  01:AC02  B0 2A     	bcs	.l2
   64                     	; -- copy scanline
   65  01:AC04  9D 8D 27  	sta	s_top,X
   66  01:AC07  B9 5C 27  	lda	scroll_bottom,Y
   67  01:AC0A  9D 96 27  	sta	s_bottom,X
   68                     	; -- copy display control bits
   69  01:AC0D  B9 60 27  	lda	scroll_cr,Y
   70  01:AC10  29 C0     	and	#$C0
   71  01:AC12  9D 85 27  	sta	s_cr,X
   72                     	; -- copy bat coordinates
   73  01:AC15  B9 48 27  	lda	scroll_xl,Y
   74  01:AC18  9D 65 27  	sta	s_xl,X
   75  01:AC1B  B9 4C 27  	lda	scroll_xh,Y
   76  01:AC1E  9D 6D 27  	sta	s_xh,X
   77  01:AC21  B9 50 27  	lda	scroll_yl,Y
   78  01:AC24  9D 75 27  	sta	s_yl,X
   79  01:AC27  B9 54 27  	lda	scroll_yh,Y
   80  01:AC2A  9D 7D 27  	sta	s_yh,X
   81  01:AC2D  E8        	inx
   82  01:AC2E            .l2:
   83  01:AC2E  C8        	iny
   84  01:AC2F  C0 04     	cpy	#4
   85                     	blo	.l1
       01:AC31  90 BC     	bcc	.l1
   86                     
   87                     	; ----
   88                     	; init display list
   89                     	;
   90  01:AC33  A9 F0     	lda	#$F0
   91  01:AC35  9D 8D 27  	sta	s_top,X
   92  01:AC38  9D 96 27  	sta	s_bottom,X
   93  01:AC3B  E8        	inx
   94  01:AC3C  8E 64 27  	stx	s_idx
   95                     	; --
   96  01:AC3F  C2        	cly
   97  01:AC40  62        	cla
   98  01:AC41  99 9E 27  .l3:	sta	s_list,Y
   99  01:AC44  1A        	inc a
  100  01:AC45  C8        	iny
  101  01:AC46  CA        	dex
  102  01:AC47  D0 F8     	bne	.l3
  103                     
  104                     	; ----
  105                     	; sort display list
  106                     	;
  107  01:AC49  AD 64 27  	lda	s_idx
  108  01:AC4C  8D A6 27  	sta	s_work
  109  01:AC4F  80 39     	bra	.t4
  110  01:AC51            .t1:
  111  01:AC51  9C A7 27  	stz	s_work+1
  112  01:AC54  A0 01     	ldy	#1
  113  01:AC56            .t2:
  114  01:AC56  BE 9D 27  	ldx	s_list-1,Y
  115  01:AC59  BD 8D 27  	lda	s_top,X
  116  01:AC5C  1A        	inc a
  117  01:AC5D  8D A8 27  	sta	s_work+2
  118  01:AC60  BE 9E 27  	ldx	s_list,Y
  119  01:AC63  BD 8D 27  	lda	s_top,X
  120  01:AC66  1A        	inc a
  121  01:AC67  CD A8 27  	cmp	s_work+2
  122                     	bhs	.t3
       01:AC6A  B0 0D     	bcs	.t3
  123                     	; --
  124  01:AC6C  B9 9D 27  	lda	s_list-1,Y
  125  01:AC6F  99 9E 27  	sta	s_list,Y
  126  01:AC72  8A        	txa
  127  01:AC73  99 9D 27  	sta	s_list-1,Y
  128  01:AC76  EE A7 27  	inc	s_work+1
  129  01:AC79            .t3:
  130  01:AC79  C8        	iny
  131  01:AC7A  CC A6 27  	cpy	s_work
  132                     	blo	.t2
       01:AC7D  90 D7     	bcc	.t2
  133  01:AC7F  AD A7 27  	lda	s_work+1
  134  01:AC82  F0 0A     	beq	.t5
  135  01:AC84  CE A6 27  	dec	s_work
  136  01:AC87  AD A6 27  	lda	s_work
  137  01:AC8A  C9 02     .t4:	cmp	#2
  138                     	bhs	.t1
       01:AC8C  B0 C3     	bcs	.t1
  139  01:AC8E            .t5:
  140                     	; ----
  141                     	; return
  142                     	;
  143  01:AC8E  AD 64 27  	lda	s_idx
  144                     	add	#$FE
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       01:AC91  18        	clc
       01:AC92  69 FE     	adc	#$FE
                          .endif
  145  01:AC94  60        	rts
  146                     
  147                     	; ----
  148                     	; scan display list
  149                     	;
  150  01:AC95            .check_list:
  151  01:AC95  DA        	phx
  152  01:AC96  CA        .x1:	dex
  153  01:AC97  30 08     	bmi	.x2
  154  01:AC99  DD 8D 27  	cmp	s_top,X
  155  01:AC9C  D0 F8     	bne	.x1
  156  01:AC9E  FA        	plx
  157  01:AC9F  38        	sec
  158  01:ACA0  60        	rts
  159                     	; --
  160  01:ACA1  FA        .x2:	plx
  161  01:ACA2  18        	clc
  162  01:ACA3  60        	rts
  163                     
  164           0000      	.bank	LIB1_BANK	; restore context
#[2]   startup.asm
#[3]   math.asm
 1265                     .include "math.asm"
    1                     ;
    2                     ; MATH.ASM  -  MagicKit Standard Math Routines
    3                     ;
    4                     ;
    5                     
    6                     
    7                     ; ----
    8                     ; divu8
    9                     ; ----
   10                     ; 8-bit unsigned division
   11                     ; ----
   12                     ; OUT : _CL = _AL / _BL
   13                     ;	_DL = _AL % _BL
   14                     ; ----
   15                     
   16  00:C67C            divu8:
   17  00:C67C  A5 F8     	lda	<__al
   18  00:C67E  0A        	asl a
   19  00:C67F  85 FC     	sta	<__cl
   20  00:C681  62        	cla
   21  00:C682  A0 08     	ldy	#8
   22  00:C684            .l1:
   23  00:C684  2A        	rol a
   24  00:C685  C5 FA     	cmp	<__bl
   25  00:C687  90 02     	bcc	.l2
   26  00:C689  E5 FA     	sbc	<__bl
   27  00:C68B            .l2:
   28  00:C68B  26 FC     	rol	<__cl
   29  00:C68D  88        	dey
   30  00:C68E  D0 F4     	bne	.l1
   31                     
   32  00:C690  85 FE     	sta	<__dl
   33  00:C692  60        	rts
   34                     
   35                     
   36                     ; ----
   37                     ; divu10
   38                     ; ----
   39                     ; 16-bit unsigned division by 10
   40                     ; ----
   41                     ; OUT : _DX = _DX / 10
   42                     ;	A = _DX % 10
   43                     ; ----
   44                     
   45  00:C693            divu10:
   46  00:C693  A0 10     	ldy	#16
   47  00:C695  62        	cla
   48  00:C696  06 FE     	asl	<__dl
   49  00:C698  26 FF     	rol	<__dh
   50  00:C69A  2A        .l1:	rol	a
   51  00:C69B  C9 0A     	cmp	#10
   52                     	blo	.l2
       00:C69D  90 02     	bcc	.l2
   53  00:C69F  E9 0A     	sbc	#10
   54  00:C6A1  26 FE     .l2:	rol	<__dl
   55  00:C6A3  26 FF     	rol	<__dh
   56  00:C6A5  88        	dey
   57  00:C6A6  D0 F2     	bne	.l1
   58  00:C6A8  60        	rts
   59                     
   60                     
   61           0000      .if (!CDROM)
  124                     .endif ; (!CDROM)
  125                     
  126                     
  127                     ; ----
  128                     ; mulu32
  129                     ; ----
  130                     ; 32-bit unsigned multiplication
  131                     ; ----
  132                     ; OUT : _DX/CX = _BX/AX * _DX/CX
  133                     ; ----
  134                     
  135  00:C6A9            mulu32:
  136                     	stw	<__cx,<__si
       00:C6A9  A5 FC     	lda	LOW_BYTE <__cx
       00:C6AB  85 EE     	sta	LOW_BYTE <__si
       00:C6AD  A5 FD     	lda	HIGH_BYTE <__cx
       00:C6AF  85 EF     	sta	HIGH_BYTE <__si
  137                     	stw	<__dx,<__di
       00:C6B1  A5 FE     	lda	LOW_BYTE <__dx
       00:C6B3  85 F0     	sta	LOW_BYTE <__di
       00:C6B5  A5 FF     	lda	HIGH_BYTE <__dx
       00:C6B7  85 F1     	sta	HIGH_BYTE <__di
  138                     	stwz	<__cx
       00:C6B9  64 FC     	stz	LOW_BYTE <__cx
       00:C6BB  64 FD     	stz	HIGH_BYTE <__cx
  139                     	stwz	<__dx
       00:C6BD  64 FE     	stz	LOW_BYTE <__dx
       00:C6BF  64 FF     	stz	HIGH_BYTE <__dx
  140  00:C6C1  A0 20     	ldy	#32
  141  00:C6C3            .loop:
  142                     	aslw	<__cx
       00:C6C3  06 FC     	asl	<__cx		; word-sized value (at stated
       00:C6C5  26 FD     	rol	<__cx+1		; memory location)
  143                     	rolw	<__dx
       00:C6C7  26 FE     	rol	<__dx		; (at stated memory location)
       00:C6C9  26 FF     	rol	<__dx+1
  144                     	rolw	<__si
       00:C6CB  26 EE     	rol	<__si		; (at stated memory location)
       00:C6CD  26 EF     	rol	<__si+1
  145                     	rolw	<__di
       00:C6CF  26 F0     	rol	<__di		; (at stated memory location)
       00:C6D1  26 F1     	rol	<__di+1
  146  00:C6D3  90 19     	bcc	.next
  147                     
  148                     	addw	<__ax,<__cx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       00:C6D5  18        	clc
       00:C6D6  A5 FC     	lda	LOW_BYTE <__cx
       00:C6D8  65 F8     	adc	LOW_BYTE <__ax
       00:C6DA  85 FC     	sta	LOW_BYTE <__cx
       00:C6DC  A5 FD     	lda	HIGH_BYTE <__cx
       00:C6DE  65 F9     	adc	HIGH_BYTE <__ax
       00:C6E0  85 FD     	sta	HIGH_BYTE <__cx
                          .endif
  149                     	adcw	<__bx,<__dx
       00:C6E2  A5 FE     	lda	LOW_BYTE <__dx
       00:C6E4  65 FA     	adc	LOW_BYTE <__bx
       00:C6E6  85 FE     	sta	LOW_BYTE <__dx
       00:C6E8  A5 FF     	lda	HIGH_BYTE <__dx
       00:C6EA  65 FB     	adc	HIGH_BYTE <__bx
       00:C6EC  85 FF     	sta	HIGH_BYTE <__dx
  150  00:C6EE            .next:
  151  00:C6EE  88        	dey
  152  00:C6EF  D0 D2     	bne	.loop
  153  00:C6F1  60        	rts
  154                     
  155                     
  156                     ; ----
  157                     ; srand
  158                     ; ----
  159                     ; set random seed
  160                     ; ----
  161                     ; IN : _DX/CX = 32-bit seed
  162                     ; ----
  163                     
  164           27A9      	.bss
  165  --:27A9            rndptr		.ds 2
  166  --:27AB            rndseed2	.ds 2
  167  --:27AD            rndn1		.ds 1
  168  --:27AE            rndn2		.ds 1
  169                     
  170           C6F2      	.code
  171  00:C6F2            srand:
  172                     	stw	<__cx,rndptr
       00:C6F2  A5 FC     	lda	LOW_BYTE <__cx
       00:C6F4  8D A9 27  	sta	LOW_BYTE rndptr
       00:C6F7  A5 FD     	lda	HIGH_BYTE <__cx
       00:C6F9  8D AA 27  	sta	HIGH_BYTE rndptr
  173                     	stw	<__dx,rndn1
       00:C6FC  A5 FE     	lda	LOW_BYTE <__dx
       00:C6FE  8D AD 27  	sta	LOW_BYTE rndn1
       00:C701  A5 FF     	lda	HIGH_BYTE <__dx
       00:C703  8D AE 27  	sta	HIGH_BYTE rndn1
  174  00:C706  AD AA 27  	lda	rndptr+1
  175  00:C709  09 E0     	ora	#$e0
  176  00:C70B  8D AA 27  	sta	rndptr+1
  177  00:C70E  C9 F4     	cmp	#$f4
  178                     	blo	.exit
       00:C710  90 05     	bcc	.exit
  179  00:C712  A9 E0     	lda	#$e0
  180  00:C714  8D AA 27  	sta	rndptr+1
  181  00:C717            .exit:
  182  00:C717  60        	rts
  183                     
  184                     
  185                     ; ----
  186                     ; rand
  187                     ; ----
  188                     ; return 16-bit random number
  189                     ; ----
  190                     ; OUT: _DX
  191                     ; ----
  192                     
  193           200D      	.zp
  194  --:200D            rndzp	.ds	2
  195                     
  196           C718      	.code
  197  00:C718  20 26 C7  rand:	jsr	randomize
  198                     	stw	rndn1,<__dx
       00:C71B  AD AD 27  	lda	LOW_BYTE rndn1
       00:C71E  85 FE     	sta	LOW_BYTE <__dx
       00:C720  AD AE 27  	lda	HIGH_BYTE rndn1
       00:C723  85 FF     	sta	HIGH_BYTE <__dx
  199  00:C725  60        	rts
  200                     
  201  00:C726            randomize:
  202                     	stw	rndptr,<rndzp
       00:C726  AD A9 27  	lda	LOW_BYTE rndptr
       00:C729  85 0D     	sta	LOW_BYTE <rndzp
       00:C72B  AD AA 27  	lda	HIGH_BYTE rndptr
       00:C72E  85 0E     	sta	HIGH_BYTE <rndzp
  203                     
  204  00:C730  AD AD 27  	lda	rndn1	; rotate 3 bits right
  205  00:C733  AE AE 27  	ldx	rndn2
  206  00:C736  6A        	ror a
  207  00:C737  22        	sax
  208  00:C738  6A        	ror a
  209  00:C739  22        	sax
  210  00:C73A  6A        	ror a
  211  00:C73B  22        	sax
  212  00:C73C  6A        	ror a
  213  00:C73D  22        	sax
  214  00:C73E  6A        	ror a
  215  00:C73F  22        	sax
  216  00:C740  6A        	ror a
  217  00:C741  8E AD 27  	stx	rndn1
  218  00:C744  8D AE 27  	sta	rndn2
  219                     
  220                     	addw	#$05A2,rndn1 ; add #$05A2 to number
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       00:C747  18        	clc
       00:C748  AD AD 27  	lda	LOW_BYTE rndn1
       00:C74B  69 A2     	adc	LOW_BYTE #$05A2
       00:C74D  8D AD 27  	sta	LOW_BYTE rndn1
       00:C750  AD AE 27  	lda	HIGH_BYTE rndn1
       00:C753  69 05     	adc	HIGH_BYTE #$05A2
       00:C755  8D AE 27  	sta	HIGH_BYTE rndn1
                          .endif
  221                     
  222                     	incw	<rndzp	; eor with next 2 bytes of ROM
       00:C758  E6 0D     	inc	<rndzp			; value at stated memory
       00:C75A  D0 02     	bne	.x_00134		; location
       00:C75C  E6 0E     	inc	<rndzp	+1
       00:C75E            .x_00134:
  223  00:C75E  AD AE 27  	lda	rndn2
  224  00:C761  52 0D     	eor	[rndzp]
  225  00:C763  29 7F     	and	#$7f
  226  00:C765  8D AE 27  	sta	rndn2
  227                     
  228                     	incw	<rndzp
       00:C768  E6 0D     	inc	<rndzp		; value at stated memory
       00:C76A  D0 02     	bne	.x_00135		; location
       00:C76C  E6 0E     	inc	<rndzp+1
       00:C76E            .x_00135:
  229  00:C76E  AD AD 27  	lda	rndn1
  230  00:C771  52 0D     	eor	[rndzp]
  231  00:C773  8D AD 27  	sta	rndn1
  232                     
  233                     	incw	<rndzp		; don't use every consecutive byte
       00:C776  E6 0D     	inc	<rndzp				; value at stated memory
       00:C778  D0 02     	bne	.x_00136		; location
       00:C77A  E6 0E     	inc	<rndzp		+1
       00:C77C            .x_00136:
  234                     
  235  00:C77C  A5 0E     	lda	<rndzp+1	; reset pointer to $e000 if > $f400
  236  00:C77E  C9 F4     	cmp	#$f4
  237                     	blo	.l1
       00:C780  90 04     	bcc	.l1
  238  00:C782  A9 E0     	lda	#$e0
  239  00:C784  85 0E     	sta	<rndzp+1
  240  00:C786            .l1:
  241                     	stw	<rndzp,rndptr
       00:C786  A5 0D     	lda	LOW_BYTE <rndzp
       00:C788  8D A9 27  	sta	LOW_BYTE rndptr
       00:C78B  A5 0E     	lda	HIGH_BYTE <rndzp
       00:C78D  8D AA 27  	sta	HIGH_BYTE rndptr
  242  00:C790  60        	rts
  243                     
  244                     
  245                     ; ----
  246                     ; random
  247                     ; ----
  248                     ; return a random number in the interval 0 <= x < A
  249                     ; ----
  250                     ; IN :	A = range (1 - 128)
  251                     ; ----
  252                     ; OUT : A = random number
  253                     ; ----
  254                     ;
  255                     
  256  00:C791            random:
  257  00:C791  48        	pha
  258  00:C792  20 18 C7  	jsr	rand
  259  00:C795  68        	pla
  260                     	; ----
  261  00:C796  C9 80     	cmp	#128
  262                     	blo	.l1
       00:C798  90 05     	bcc	.l1
  263                     
  264  00:C79A  A5 FF     	lda	<__dh
  265  00:C79C  29 7F     	and	#$7f
  266  00:C79E  60        	rts
  267                     
  268  00:C79F            .l1:	; asl a
  269  00:C79F  85 F8     	sta	<__al
  270  00:C7A1  A5 FE     	lda	<__dl
  271  00:C7A3  85 FA     	sta	<__bl
  272  00:C7A5  20 BD E0  	jsr	mulu8
  273                     
  274  00:C7A8  A5 FD     	lda	<__ch
  275  00:C7AA  60        	rts
#[2]   startup.asm
 1266                     
 1267           0001      .ifdef HUC
 1268                     
#[3]   huc.asm
 1269                     .include "huc.asm"
    1                     ;
    2                     ; HUC.ASM  -  HuC Internal Library
    3                     ;
    4                     
    5                     ; ----
    6                     ; local variables
    7                     
    8           200F      		.zp
    9  --:200F            __sign:		.ds 1
   10  --:2010            __remain:	.ds 2
   11                     
   12           C7AB      		.code
   14                     
   15                     ; ----
   16                     ; eq
   17                     ; ----
   18                     ; test egality of two words
   19                     ; ----
   20                     ; IN :  First word on the C stack
   21                     ;	Another word in A:X
   22                     ; ----
   23                     ; OUT : word A:X equals 0 is the two args are egals
   24                     ;	else non nul
   25                     ; ----
   26                     ; REMARK : signed compatible
   27                     ; ----
   28                     
   29  00:C7AB            eq:
   30  00:C7AB  22        	sax
   31  00:C7AC  D2 00     	cmp [__stack]
   32  00:C7AE  D0 18     	bne eq_endno
   33                     
   34  00:C7B0  A0 01     	ldy #1
   35  00:C7B2  22        	sax
   36  00:C7B3  D1 00     	cmp [__stack],Y
   37  00:C7B5  D0 11     	bne eq_endno
   38                     
   39  00:C7B7            eq_endyes:
   40                     	__addmi	2,__stack	; don't push A/X; they are thrown away
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:C7B7  A8        	tay			; 2
       00:C7B8  18        	clc			; 2
       00:C7B9  A5 00     	lda	<__stack			; 4
       00:C7BB  69 02     	adc	#low(2)	; 2
       00:C7BD  85 00     	sta	<__stack			; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:C7BF  90 02     	bcc	.x00140		; 4(2)
       00:C7C1  E6 01     	inc	<__stack	+1		; 0(6)
       00:C7C3            .x00140:
                          .else
                          .endif
       00:C7C3  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
   41  00:C7C4  A2 01     	ldx #1
   42  00:C7C6  62        	cla
   43  00:C7C7  60        	rts
   44                     
   45  00:C7C8            eq_endno:
   46                     	__addmi	2,__stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:C7C8  A8        	tay			; 2
       00:C7C9  18        	clc			; 2
       00:C7CA  A5 00     	lda	<__stack		; 4
       00:C7CC  69 02     	adc	#low(2)	; 2
       00:C7CE  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:C7D0  90 02     	bcc	.x00141		; 4(2)
       00:C7D2  E6 01     	inc	<__stack+1		; 0(6)
       00:C7D4            .x00141:
                          .else
                          .endif
       00:C7D4  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
   47  00:C7D5  82        	clx
   48  00:C7D6  62        	cla
   49  00:C7D7  60        	rts
   50                     
   51  00:C7D8            eqb:
   52  00:C7D8  8A        	txa
   53  00:C7D9  D2 00     	cmp [__stack]
   54  00:C7DB  D0 EB     	bne eq_endno
   55  00:C7DD  80 D8     	bra eq_endyes
   56                     
   57                     ; streamlined version - uses zp ( <__temp ) instead of stack
   58                     ; returns A:X = 0 if false, 1 if true
   59                     
   60  00:C7DF            eqzp:
   61  00:C7DF  C5 03     	cmp	<__temp+1
   62  00:C7E1  D0 09     	bne	.x_ne
   63  00:C7E3  22        	sax
   64  00:C7E4  C5 02     	cmp	<__temp
   65  00:C7E6  D0 04     	bne	.x_ne
   66  00:C7E8  62        	cla
   67  00:C7E9  A2 01     	ldx	#1	; ensure Z flag not set
   68  00:C7EB  60        	rts
   69  00:C7EC            .x_ne:
   70  00:C7EC  62        	cla
   71  00:C7ED  82        	clx
   72  00:C7EE  60        	rts
   73                     
   74  00:C7EF            eqbzp:
   75  00:C7EF  8A        	txa
   76  00:C7F0  C5 02     	cmp	<__temp
   77  00:C7F2  62        	cla
   78  00:C7F3  D0 03     	bne	.x_ne
   79  00:C7F5  A2 01     	ldx	#1
   80  00:C7F7  60        	rts
   81  00:C7F8            .x_ne:
   82  00:C7F8  82        	clx
   83  00:C7F9  60        	rts
   84                     
   85                     ; ----
   86                     ; lt
   87                     ; ----
   88                     ; compare two words
   89                     ; ----
   90                     ; IN :  First word on the C stack
   91                     ;	Another word in A:X
   92                     ; ----
   93                     ; OUT : word A:X is non nul if pushed word is strictly lower than
   94                     ;	the word in A:X else nul
   95                     ; ----
   96                     
   97  00:C7FA            ltb:	; XXX: missing optimized byte version
   98  00:C7FA            lt:	; signed version
   99  00:C7FA  A0 01     	ldy #1
  100  00:C7FC  C9 80     	cmp #$80
  101  00:C7FE  B0 0A     	bcs lt_primary_minus
  102                     
  103                     	; if here, the A:X value is positive
  104                     
  105  00:C800  85 02     	sta <__temp
  106  00:C802  B1 00     	lda [__stack], Y
  107  00:C804  30 71     	bmi cmp_ok	; stack value is negative, so reply OK
  108                     
  109  00:C806  A5 02     	lda <__temp	; stack value is also positive, so just go for the unsigned version
  110  00:C808  80 1B     	bra ult_y1
  111                     
  112  00:C80A            lt_primary_minus:
  113                     
  114                     	; if here, the A:X value is negative
  115                     
  116  00:C80A  85 02     	sta <__temp
  117  00:C80C  B1 00     	lda [__stack], Y
  118  00:C80E  30 11     	bmi getA_ult ; stack value is also negative, so restore A val from
  119                     			; __temp and call ult
  120                     
  121  00:C810            cmp_false:
  122                     	__addmi	2,__stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:C810  A8        	tay			; 2
       00:C811  18        	clc			; 2
       00:C812  A5 00     	lda	<__stack		; 4
       00:C814  69 02     	adc	#low(2)	; 2
       00:C816  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:C818  90 02     	bcc	.x00142		; 4(2)
       00:C81A  E6 01     	inc	<__stack+1		; 0(6)
       00:C81C            .x00142:
                          .else
                          .endif
       00:C81C  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  123  00:C81D  A2 00     	ldx	#0
  124  00:C81F  62        	cla
  125  00:C820  60        	rts
  126                     
  127  00:C821            getA_ult:
  128  00:C821  A5 02     	lda <__temp
  129                     
  130  00:C823            ult:	; unsigned version
  131  00:C823  A0 01     	ldy #1	; false by default
  132                     
  133  00:C825            ult_y1: ; same thing but Y is assumed to be equal to 1
  134                     
  135  00:C825  D1 00     	cmp [__stack],Y
  136  00:C827  F0 04     	beq .lt_must_test_lobyte
  137  00:C829  B0 4C     	bcs cmp_ok
  138  00:C82B  80 07     	bra .lt_end ; hibyte of the reg var < hibyte of the pushed var
  139                     
  140  00:C82D            .lt_must_test_lobyte:
  141  00:C82D  22        	sax
  142  00:C82E  D2 00     	cmp [__stack]
  143  00:C830  F0 02     	beq .lt_end
  144  00:C832  B0 43     	bcs cmp_ok	; set result to true
  145                     	; lobyte of the reg var < lobyte of the pushed var
  146                     
  147  00:C834            .lt_end:
  148  00:C834  98        	tya		; __addmi does not preserve Y
  149                     	__addmi	2,__stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:C835  A8        	tay			; 2
       00:C836  18        	clc			; 2
       00:C837  A5 00     	lda	<__stack		; 4
       00:C839  69 02     	adc	#low(2)	; 2
       00:C83B  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:C83D  90 02     	bcc	.x00143		; 4(2)
       00:C83F  E6 01     	inc	<__stack+1		; 0(6)
       00:C841            .x00143:
                          .else
                          .endif
       00:C841  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  150                     			; if Y was 1, return A=X=0 -> false
  151  00:C842  49 FF     	eor #$ff	; if Y was 0, return A=0, X=1 -> true
  152  00:C844  1A        	inc a
  153  00:C845  1A        	inc a
  154  00:C846  AA        	tax
  155  00:C847  62        	cla
  156  00:C848  60        	rts
  157                     
  158  00:C849            ublt:	; unsigned version
  159  00:C849  8A        	txa
  160  00:C84A  D2 00     	cmp [__stack]
  161  00:C84C  F0 02     	beq .lt_end
  162  00:C84E  B0 27     	bcs cmp_ok	; set result to true
  163                     	; lobyte of the reg var < lobyte of the pushed var
  164                     
  165  00:C850            .lt_end:
  166                     	__addmi	2,__stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:C850  A8        	tay			; 2
       00:C851  18        	clc			; 2
       00:C852  A5 00     	lda	<__stack		; 4
       00:C854  69 02     	adc	#low(2)	; 2
       00:C856  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:C858  90 02     	bcc	.x00144		; 4(2)
       00:C85A  E6 01     	inc	<__stack+1		; 0(6)
       00:C85C            .x00144:
                          .else
                          .endif
       00:C85C  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  167  00:C85D  A2 00     	ldx	#0
  168  00:C85F  62        	cla
  169  00:C860  60        	rts
  170                     
  171                     
  172                     
  173                     ; ----
  174                     ; gt
  175                     ; ----
  176                     ; compare two words
  177                     ; ----
  178                     ; IN :  First word on the C stack
  179                     ;	Another word in A:X
  180                     ; ----
  181                     ; OUT : word A:X is non nul if pushed word is strictly greater than
  182                     ;	the word in A:X else nul
  183                     ; ----
  184                     
  185  00:C861            gtb:	; XXX: missing optimized byte version
  186  00:C861            gt:	; signed version of >
  187  00:C861  A0 01     	ldy #1
  188  00:C863  C9 80     	cmp #$80
  189  00:C865  B0 0A     	bcs .gt_primary_minus
  190                     
  191                     	; if here, the A:X value is positive
  192                     
  193  00:C867  85 02     	sta <__temp
  194  00:C869  B1 00     	lda [__stack], Y
  195  00:C86B  30 A3     	bmi cmp_false ; stack value is negative, so reply False
  196                     
  197  00:C86D  A5 02     	lda <__temp	; stack value is also positive, so just go for the unsigned version
  198  00:C86F  80 1B     	bra ugt_y1	; we spare one instruction, since we already have Y=1
  199                     
  200  00:C871            .gt_primary_minus:
  201                     
  202                     	; if here, the A:X value is negative
  203                     
  204  00:C871  85 02     	sta <__temp
  205  00:C873  B1 00     	lda [__stack], Y
  206  00:C875  30 11     	bmi getA_ugt ; stack value is also negative, so restore A val from
  207                     			; __temp and call ugt
  208                     
  209  00:C877            cmp_ok:
  210                     	__addmi	2,__stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:C877  A8        	tay			; 2
       00:C878  18        	clc			; 2
       00:C879  A5 00     	lda	<__stack		; 4
       00:C87B  69 02     	adc	#low(2)	; 2
       00:C87D  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:C87F  90 02     	bcc	.x00145		; 4(2)
       00:C881  E6 01     	inc	<__stack+1		; 0(6)
       00:C883            .x00145:
                          .else
                          .endif
       00:C883  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  211  00:C884  A2 01     	ldx #1
  212  00:C886  62        	cla
  213  00:C887  60        	rts
  214                     
  215  00:C888            getA_ugt:	; we grab back the value of A before entering the unsigned
  216                     		; version of >
  217  00:C888  A5 02     	lda <__temp
  218                     
  219  00:C88A            ugt:	; unsigned version of >
  220                     
  221  00:C88A  A0 01     	ldy #1
  222                     
  223  00:C88C            ugt_y1: ; unsigned version of >, assuming Y = 1
  224                     
  225  00:C88C  D1 00     	cmp [__stack],Y
  226  00:C88E  F0 05     	beq .gt_must_test_lobyte
  227  00:C890  B0 09     	bcs .gt_end ; hibyte of the reg var >= hibyte of the pushed var
  228  00:C892  C2        	cly
  229  00:C893  80 06     	bra .gt_end
  230                     
  231  00:C895            .gt_must_test_lobyte
  232  00:C895  22        	sax
  233  00:C896  D2 00     	cmp [__stack]
  234  00:C898  B0 01     	bcs .gt_end	; lobyte of the reg var >= lobyte of the pushed var
  235  00:C89A  C2        	cly
  236                     
  237  00:C89B            .gt_end:
  238  00:C89B  98        	tya
  239                     	__addmi	2,__stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:C89C  A8        	tay			; 2
       00:C89D  18        	clc			; 2
       00:C89E  A5 00     	lda	<__stack		; 4
       00:C8A0  69 02     	adc	#low(2)	; 2
       00:C8A2  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:C8A4  90 02     	bcc	.x00146		; 4(2)
       00:C8A6  E6 01     	inc	<__stack+1		; 0(6)
       00:C8A8            .x00146:
                          .else
                          .endif
       00:C8A8  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  240  00:C8A9  49 FF     	eor #$ff
  241  00:C8AB  1A        	inc a
  242  00:C8AC  1A        	inc a
  243  00:C8AD  AA        	tax
  244  00:C8AE  62        	cla
  245  00:C8AF  60        	rts
  246                     
  247  00:C8B0            ubgt:	; unsigned byte version of >
  248  00:C8B0  8A        	txa
  249  00:C8B1  D2 00     	cmp [__stack]
  250  00:C8B3  90 10     	bcc .gt_true
  251                     	__addmi	2,__stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:C8B5  A8        	tay			; 2
       00:C8B6  18        	clc			; 2
       00:C8B7  A5 00     	lda	<__stack		; 4
       00:C8B9  69 02     	adc	#low(2)	; 2
       00:C8BB  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:C8BD  90 02     	bcc	.x00147		; 4(2)
       00:C8BF  E6 01     	inc	<__stack+1		; 0(6)
       00:C8C1            .x00147:
                          .else
                          .endif
       00:C8C1  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  252  00:C8C2  82        	clx
  253  00:C8C3  62        	cla
  254  00:C8C4  60        	rts
  255  00:C8C5            .gt_true:
  256                     	__addmi	2,__stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:C8C5  A8        	tay			; 2
       00:C8C6  18        	clc			; 2
       00:C8C7  A5 00     	lda	<__stack		; 4
       00:C8C9  69 02     	adc	#low(2)	; 2
       00:C8CB  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:C8CD  90 02     	bcc	.x00148		; 4(2)
       00:C8CF  E6 01     	inc	<__stack+1		; 0(6)
       00:C8D1            .x00148:
                          .else
                          .endif
       00:C8D1  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  257  00:C8D2  A2 01     	ldx #1
  258  00:C8D4  62        	cla
  259  00:C8D5  60        	rts
  260                     
  261                     
  262                     ; ----
  263                     ; zero page versions of lt/gt/ult/ugt:
  264                     ; ----
  265                     
  266  00:C8D6            ltbzp:
  267  00:C8D6            ltzp:	; signed, zero page
  268  00:C8D6  85 04     	sta	<__temp+2
  269  00:C8D8  45 03     	eor	<__temp+1
  270  00:C8DA  10 0B     	bpl	.geta_ult
  271  00:C8DC  A5 04     	lda	<__temp+2
  272  00:C8DE  10 03     	bpl	.true
  273  00:C8E0  82        .false:	clx
  274  00:C8E1  62        	cla
  275  00:C8E2  60        	rts
  276  00:C8E3  A2 01     .true:	ldx	#1
  277  00:C8E5  62        	cla
  278  00:C8E6  60        	rts
  279  00:C8E7            .geta_ult:
  280  00:C8E7  A5 04     	lda	<__temp+2	; and fall through to unsigned test
  281                     
  282  00:C8E9  C5 03     ultzp:	cmp	<__temp+1
  283  00:C8EB  F0 06     	beq	.test_lo
  284  00:C8ED  90 0B     	bcc	.false
  285  00:C8EF  A2 01     .true:	ldx	#1
  286  00:C8F1  62        	cla
  287  00:C8F2  60        	rts
  288  00:C8F3            .test_lo:
  289  00:C8F3  22        	sax
  290  00:C8F4  C5 02     	cmp	<__temp
  291  00:C8F6  F0 02     	beq	.false
  292  00:C8F8  B0 F5     	bcs	.true
  293  00:C8FA  82        .false:	clx
  294  00:C8FB  62        	cla
  295  00:C8FC  60        	rts
  296                     
  297  00:C8FD            ubltzp:
  298  00:C8FD  8A        	txa
  299  00:C8FE  C5 02     	cmp	<__temp
  300  00:C900  62        	cla
  301  00:C901  F0 05     	beq	.false
  302  00:C903  90 03     	bcc	.false
  303  00:C905  A2 01     	ldx	#1
  304  00:C907  60        	rts
  305  00:C908  82        .false: clx
  306  00:C909  60        	rts
  307                     
  308                     ; ----
  309  00:C90A            gtbzp:
  310  00:C90A            gtzp:	; signed, zero page
  311  00:C90A  85 04     	sta	<__temp+2
  312  00:C90C  45 03     	eor	<__temp+1
  313  00:C90E  10 0B     	bpl	.geta_ugt
  314  00:C910  A5 04     	lda	<__temp+2
  315  00:C912  10 04     	bpl	.false
  316  00:C914  A2 01     .true:	ldx	#1
  317  00:C916  62        	cla
  318  00:C917  60        	rts
  319  00:C918  82        .false:	clx
  320  00:C919  62        	cla
  321  00:C91A  60        	rts
  322  00:C91B            .geta_ugt:
  323  00:C91B  A5 04     	lda	<__temp+2	; and fall through to unsigned test
  324                     
  325  00:C91D            ugtzp:
  326  00:C91D  C5 03     	cmp	<__temp+1
  327  00:C91F  F0 06     	beq	.test_lo
  328  00:C921  B0 0B     	bcs	.false
  329  00:C923  A2 01     .true:	ldx	#1
  330  00:C925  62        	cla
  331  00:C926  60        	rts
  332  00:C927            .test_lo:
  333  00:C927  22        	sax
  334  00:C928  C5 02     	cmp	<__temp
  335  00:C92A  F0 02     	beq	.false
  336  00:C92C  90 F5     	bcc	.true
  337  00:C92E  82        .false:	clx
  338  00:C92F  62        	cla
  339  00:C930  60        	rts
  340                     
  341  00:C931            ubgtzp:
  342  00:C931  8A        	txa
  343  00:C932  C5 02     	cmp	<__temp
  344  00:C934  62        	cla
  345  00:C935  F0 05     	beq	.false
  346  00:C937  B0 03     	bcs	.false
  347  00:C939  A2 01     	ldx	#1
  348  00:C93B  60        	rts
  349  00:C93C  82        .false:	clx
  350  00:C93D  60        	rts
  351                     
  352                     
  353                     ; ----
  354                     ; ge
  355                     ; ----
  356                     ; compare two signed words
  357                     ; ----
  358                     ; IN :  First word on the C stack
  359                     ;	Another word in A:X
  360                     ; ----
  361                     ; OUT : word A:X is non nul if pushed word is greater or egal to
  362                     ;	the word in A:X else nul
  363                     ; ----
  364                     
  365                     ; XXX: can these be optimized?
  366  00:C93E            ge:	; signed version of >
  367  00:C93E  20 FA C7  	jsr lt
  368  00:C941  22        	sax
  369  00:C942  3A        	dec a
  370  00:C943  3A        	dec a
  371  00:C944  49 FF     	eor #$ff
  372  00:C946  22        	sax
  373  00:C947  60        	rts
  374                     
  375  00:C948            geb:	; signed byte version of >
  376  00:C948  20 FA C7  	jsr ltb
  377  00:C94B  22        	sax
  378  00:C94C  3A        	dec a
  379  00:C94D  3A        	dec a
  380  00:C94E  49 FF     	eor #$ff
  381  00:C950  22        	sax
  382  00:C951  60        	rts
  383                     
  384  00:C952  20 D6 C8  gezp:	jsr	ltzp
  385  00:C955  22        	sax
  386  00:C956  3A        	dec a
  387  00:C957  3A        	dec a
  388  00:C958  49 FF     	eor	#$ff
  389  00:C95A  22        	sax
  390  00:C95B  60        	rts
  391                     
  392  00:C95C  20 D6 C8  gebzp:	jsr	ltbzp
  393  00:C95F  22        	sax
  394  00:C960  3A        	dec a
  395  00:C961  3A        	dec a
  396  00:C962  49 FF     	eor	#$ff
  397  00:C964  22        	sax
  398  00:C965  60        	rts
  399                     
  400                     ; ----
  401                     ; uge
  402                     ; ----
  403                     ; compare two unsigned signed words
  404                     ; ----
  405                     ; IN :  First word on the C stack
  406                     ;	Another word in A:X
  407                     ; ----
  408                     ; OUT : word A:X is non nul if pushed word is greater or egal to
  409                     ;	the word in A:X else nul
  410                     ; ----
  411                     
  412                     ; XXX: can these be optimized?
  413  00:C966            uge:	; unsigned version of >
  414  00:C966  20 23 C8  	jsr ult
  415  00:C969  22        	sax
  416  00:C96A  3A        	dec a
  417  00:C96B  3A        	dec a
  418  00:C96C  49 FF     	eor #$ff
  419  00:C96E  22        	sax
  420  00:C96F  60        	rts
  421                     
  422  00:C970            ubge:	; unsigned byte version of >
  423  00:C970  20 49 C8  	jsr ublt
  424  00:C973  22        	sax
  425  00:C974  3A        	dec a
  426  00:C975  3A        	dec a
  427  00:C976  49 FF     	eor #$ff
  428  00:C978  22        	sax
  429  00:C979  60        	rts
  430                     
  431  00:C97A  20 E9 C8  ugezp:	jsr	ultzp
  432  00:C97D  22        	sax
  433  00:C97E  3A        	dec a
  434  00:C97F  3A        	dec a
  435  00:C980  49 FF     	eor	#$ff
  436  00:C982  22        	sax
  437  00:C983  60        	rts
  438                     
  439  00:C984  20 FD C8  ubgezp:	jsr	ubltzp
  440  00:C987  22        	sax
  441  00:C988  3A        	dec a
  442  00:C989  3A        	dec a
  443  00:C98A  49 FF     	eor	#$ff
  444  00:C98C  22        	sax
  445  00:C98D  60        	rts
  446                     
  447                     ; ----
  448                     ; ne
  449                     ; ----
  450                     ; compare two words
  451                     ; ----
  452                     ; IN :  First word on the C stack
  453                     ;	Another word in A:X
  454                     ; ----
  455                     ; OUT : word A:X is non null if pushed word is different from
  456                     ;	the word in A:X else null
  457                     ; ----
  458                     ; REMARK : signed compatible
  459                     ; ----
  460                     
  461                     	; previous version called 'eq' as subroutine and returned
  462                     	; opposite value; should be fully implemented for speed
  463                     	; since '!=' is such a common operator
  464  00:C98E            ne:
  465  00:C98E  22        	sax
  466  00:C98F  D2 00     	cmp [__stack]
  467  00:C991  D0 17     	bne .ne_endne
  468                     
  469  00:C993  A0 01     	ldy #1
  470  00:C995  22        	sax
  471  00:C996  D1 00     	cmp [__stack],Y
  472  00:C998  D0 10     	bne .ne_endne
  473                     
  474  00:C99A            .ne_endeq:
  475                     	__addmi	2,__stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:C99A  A8        	tay			; 2
       00:C99B  18        	clc			; 2
       00:C99C  A5 00     	lda	<__stack		; 4
       00:C99E  69 02     	adc	#low(2)	; 2
       00:C9A0  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:C9A2  90 02     	bcc	.x00149		; 4(2)
       00:C9A4  E6 01     	inc	<__stack+1		; 0(6)
       00:C9A6            .x00149:
                          .else
                          .endif
       00:C9A6  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  476  00:C9A7  82        	clx
  477  00:C9A8  62        	cla
  478  00:C9A9  60        	rts
  479                     
  480  00:C9AA            .ne_endne:
  481                     	__addmi 2,__stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:C9AA  A8        	tay			; 2
       00:C9AB  18        	clc			; 2
       00:C9AC  A5 00     	lda	<__stack		; 4
       00:C9AE  69 02     	adc	#low(2)	; 2
       00:C9B0  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:C9B2  90 02     	bcc	.x00150		; 4(2)
       00:C9B4  E6 01     	inc	<__stack+1		; 0(6)
       00:C9B6            .x00150:
                          .else
                          .endif
       00:C9B6  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  482  00:C9B7  A2 01     	ldx	#1
  483  00:C9B9  62        	cla
  484  00:C9BA  60        	rts
  485                     
  486  00:C9BB            neb:
  487  00:C9BB  8A        	txa
  488  00:C9BC  D2 00     	cmp [__stack]
  489  00:C9BE  D0 10     	bne .ne_endne
  490                     
  491  00:C9C0            .ne_endeq:
  492                     	__addmi	2,__stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:C9C0  A8        	tay			; 2
       00:C9C1  18        	clc			; 2
       00:C9C2  A5 00     	lda	<__stack		; 4
       00:C9C4  69 02     	adc	#low(2)	; 2
       00:C9C6  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:C9C8  90 02     	bcc	.x00151		; 4(2)
       00:C9CA  E6 01     	inc	<__stack+1		; 0(6)
       00:C9CC            .x00151:
                          .else
                          .endif
       00:C9CC  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  493  00:C9CD  82        	clx
  494  00:C9CE  62        	cla
  495  00:C9CF  60        	rts
  496                     
  497  00:C9D0            .ne_endne:
  498                     	__addmi	2,__stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:C9D0  A8        	tay			; 2
       00:C9D1  18        	clc			; 2
       00:C9D2  A5 00     	lda	<__stack		; 4
       00:C9D4  69 02     	adc	#low(2)	; 2
       00:C9D6  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:C9D8  90 02     	bcc	.x00152		; 4(2)
       00:C9DA  E6 01     	inc	<__stack+1		; 0(6)
       00:C9DC            .x00152:
                          .else
                          .endif
       00:C9DC  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  499  00:C9DD  A2 01     	ldx	#1
  500  00:C9DF  62        	cla
  501  00:C9E0  60        	rts
  502                     
  503                     ; streamlined version - uses zp ( <__temp ) instead of stack
  504                     ; returns A:X = 0 if false, 1 if true
  505                     
  506  00:C9E1            nezp:
  507  00:C9E1  C5 03     	cmp	<__temp+1
  508  00:C9E3  D0 08     	bne	.x_ne
  509  00:C9E5  22        	sax
  510  00:C9E6  C5 02     	cmp	<__temp
  511  00:C9E8  D0 03     	bne	.x_ne
  512  00:C9EA  62        	cla
  513  00:C9EB  82        	clx
  514  00:C9EC  60        	rts
  515  00:C9ED            .x_ne:
  516  00:C9ED  62        	cla
  517  00:C9EE  A2 01     	ldx	#1	; ensure Z flag not set
  518  00:C9F0  60        	rts
  519                     
  520  00:C9F1            nebzp:
  521  00:C9F1  8A        	txa
  522  00:C9F2  C5 02     	cmp	<__temp
  523  00:C9F4  62        	cla
  524  00:C9F5  D0 02     	bne	.x_ne
  525  00:C9F7  82        	clx
  526  00:C9F8  60        	rts
  527  00:C9F9            .x_ne:
  528  00:C9F9  A2 01     	ldx	#1	; ensure Z flag not set
  529  00:C9FB  60        	rts
  530                     
  531                     ; ----
  532                     ; le
  533                     ; ----
  534                     ; compare two signed words
  535                     ; ----
  536                     ; IN :  First word on the C stack
  537                     ;	Another word in A:X
  538                     ; ----
  539                     ; OUT : word A:X is non nul if pushed word is lower or egal to
  540                     ;	the word in A:X else nul
  541                     ; ----
  542                     
  543                     ; XXX: can these be optimized?
  544  00:C9FC            le:	; signed version
  545  00:C9FC  20 61 C8  	jsr gt
  546  00:C9FF  22        	sax
  547  00:CA00  49 FF     	eor #$ff
  548  00:CA02  1A        	inc a
  549  00:CA03  1A        	inc a
  550  00:CA04  22        	sax
  551  00:CA05  60        	rts
  552                     
  553  00:CA06            leb:	; signed version
  554  00:CA06  20 61 C8  	jsr gtb
  555  00:CA09  22        	sax
  556  00:CA0A  49 FF     	eor #$ff
  557  00:CA0C  1A        	inc a		; assuming that A=1 if true
  558  00:CA0D  1A        	inc a
  559  00:CA0E  22        	sax
  560  00:CA0F  60        	rts
  561                     
  562  00:CA10  20 0A C9  lezp:	jsr	gtzp
  563  00:CA13  22        	sax
  564  00:CA14  49 FF     	eor	#$ff
  565  00:CA16  1A        	inc a
  566  00:CA17  1A        	inc a
  567  00:CA18  22        	sax
  568  00:CA19  60        	rts
  569                     
  570  00:CA1A  20 0A C9  lebzp:	jsr	gtbzp
  571  00:CA1D  22        	sax
  572  00:CA1E  49 FF     	eor	#$ff
  573  00:CA20  1A        	inc a
  574  00:CA21  1A        	inc a
  575  00:CA22  22        	sax
  576  00:CA23  60        	rts
  577                     
  578                     ; ----
  579                     ; ule
  580                     ; ----
  581                     ; compare two unsigned words
  582                     ; ----
  583                     ; IN :  First word on the C stack
  584                     ;	Another word in A:X
  585                     ; ----
  586                     ; OUT : word A:X is non nul if pushed word is lower or egal to
  587                     ;	the word in A:X else nul
  588                     ; ----
  589                     
  590                     ; XXX: can these be optimized?
  591  00:CA24            ule:	; unsigned version
  592  00:CA24  20 8A C8  	jsr ugt
  593  00:CA27  22        	sax
  594  00:CA28  49 FF     	eor #$ff
  595  00:CA2A  1A        	inc A	; assuming that A=1 if true
  596  00:CA2B  1A        	inc a
  597  00:CA2C  22        	sax
  598  00:CA2D  60        	rts
  599                     
  600  00:CA2E            uble:	; unsigned byte version
  601  00:CA2E  20 B0 C8  	jsr ubgt
  602  00:CA31  22        	sax
  603  00:CA32  49 FF     	eor #$ff
  604  00:CA34  1A        	inc A	; assuming that A=255 if true
  605  00:CA35  1A        	inc a
  606  00:CA36  22        	sax
  607  00:CA37  60        	rts
  608                     
  609  00:CA38  20 1D C9  ulezp:	jsr	ugtzp
  610  00:CA3B  22        	sax
  611  00:CA3C  49 FF     	eor	#$ff
  612  00:CA3E  1A        	inc a
  613  00:CA3F  1A        	inc a
  614  00:CA40  22        	sax
  615  00:CA41  60        	rts
  616                     
  617  00:CA42  20 31 C9  ublezp:	jsr	ubgtzp
  618  00:CA45  22        	sax
  619  00:CA46  49 FF     	eor	#$ff
  620  00:CA48  1A        	inc a
  621  00:CA49  1A        	inc a
  622  00:CA4A  22        	sax
  623  00:CA4B  60        	rts
  624                     
  625                     ; ----
  626                     ; asl
  627                     ; ----
  628                     ; shift the pushed word left by the register word
  629                     ; ----
  630                     ; IN :  First word on the C stack
  631                     ;	Another word in A:X
  632                     ; ----
  633                     ; OUT : Register word egals the previous pushed value
  634                     ;	shifted left by A:X
  635                     ; ----
  636                     ; REMARK :	only the lower byte of the right operand is taken in account
  637                     ;		signed compatible
  638                     ; ----
  639  00:CA4C            asl:
  640  00:CA4C  86 02     	stx <__temp
  641                     	__ldwp __stack
       00:CA4E  B2 00     	lda	[__stack]
       00:CA50  AA        	tax
       00:CA51  A0 01     	ldy	#1
       00:CA53  B1 00     	lda	[__stack],Y
  642  00:CA55  A4 02     	ldy <__temp
  643  00:CA57  F0 0C     	beq .asl_end
  644  00:CA59  85 02     	sta <__temp
  645  00:CA5B  22        	sax
  646                     
  647  00:CA5C            .asl_begin
  648  00:CA5C  0A        	asl a
  649  00:CA5D  26 02     	rol <__temp
  650  00:CA5F  88        	dey
  651  00:CA60  D0 FA     	bne .asl_begin
  652                     
  653  00:CA62  22        	sax
  654  00:CA63  A5 02     	lda <__temp
  655                     
  656  00:CA65            .asl_end
  657                     	__addmi	2,__stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:CA65  A8        	tay			; 2
       00:CA66  18        	clc			; 2
       00:CA67  A5 00     	lda	<__stack		; 4
       00:CA69  69 02     	adc	#low(2)	; 2
       00:CA6B  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:CA6D  90 02     	bcc	.x00154		; 4(2)
       00:CA6F  E6 01     	inc	<__stack+1		; 0(6)
       00:CA71            .x00154:
                          .else
                          .endif
       00:CA71  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  658  00:CA72  60        	rts
  659                     
  660  00:CA73            aslzp:
  661  00:CA73  F0 0C     	beq .asl_end
  662  00:CA75  85 02     	sta <__temp
  663  00:CA77  22        	sax
  664                     
  665  00:CA78            .asl_begin
  666  00:CA78  0A        	asl a
  667  00:CA79  26 02     	rol <__temp
  668  00:CA7B  88        	dey
  669  00:CA7C  D0 FA     	bne .asl_begin
  670                     
  671  00:CA7E  22        	sax
  672  00:CA7F  A5 02     	lda <__temp
  673  00:CA81            .asl_end
  674  00:CA81  60        	rts
  675                     
  676                     
  677                     ; ----
  678                     ; asr
  679                     ; ----
  680                     ; shift the pushed word right by the register word
  681                     ; ----
  682                     ; IN :  First word on the C stack
  683                     ;	Another word in A:X
  684                     ; ----
  685                     ; OUT : Register word egals the previous pushed value
  686                     ;	shifted right by A:X
  687                     ; ----
  688                     ; REMARK :	only the lower byte of the right operand is taken in account
  689                     ;		signed compatible
  690                     ; ----
  691  00:CA82            asr:
  692  00:CA82  86 02     	stx <__temp
  693                     	__ldwp __stack
       00:CA84  B2 00     	lda	[__stack]
       00:CA86  AA        	tax
       00:CA87  A0 01     	ldy	#1
       00:CA89  B1 00     	lda	[__stack],Y
  694  00:CA8B  A4 02     	ldy <__temp
  695  00:CA8D  F0 0E     	beq .asr_end
  696  00:CA8F  85 02     	sta <__temp
  697  00:CA91  22        	sax
  698                     
  699  00:CA92            .asr_begin
  700  00:CA92  E0 80     	cpx #$80
  701  00:CA94  66 02     	ror <__temp
  702  00:CA96  6A        	ror a
  703                     
  704  00:CA97  88        	dey
  705  00:CA98  D0 F8     	bne .asr_begin
  706                     
  707  00:CA9A  22        	sax
  708  00:CA9B  A5 02     	lda <__temp
  709                     
  710  00:CA9D            .asr_end
  711                     	__addmi	2,__stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:CA9D  A8        	tay			; 2
       00:CA9E  18        	clc			; 2
       00:CA9F  A5 00     	lda	<__stack		; 4
       00:CAA1  69 02     	adc	#low(2)	; 2
       00:CAA3  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:CAA5  90 02     	bcc	.x00156		; 4(2)
       00:CAA7  E6 01     	inc	<__stack+1		; 0(6)
       00:CAA9            .x00156:
                          .else
                          .endif
       00:CAA9  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  712  00:CAAA  60        	rts
  713                     
  714  00:CAAB            asrzp:
  715  00:CAAB  F0 0E     	beq .asr_end
  716  00:CAAD  85 02     	sta <__temp
  717  00:CAAF  22        	sax
  718                     
  719  00:CAB0            .asr_begin
  720  00:CAB0  E0 80     	cpx #$80
  721  00:CAB2  66 02     	ror <__temp
  722  00:CAB4  6A        	ror a
  723  00:CAB5  88        	dey
  724  00:CAB6  D0 F8     	bne .asr_begin
  725                     
  726  00:CAB8  22        	sax
  727  00:CAB9  A5 02     	lda <__temp
  728  00:CABB            .asr_end
  729  00:CABB  60        	rts
  730                     
  731  00:CABC            lsr:
  732  00:CABC  86 02     	stx <__temp
  733                     	__ldwp __stack
       00:CABE  B2 00     	lda	[__stack]
       00:CAC0  AA        	tax
       00:CAC1  A0 01     	ldy	#1
       00:CAC3  B1 00     	lda	[__stack],Y
  734  00:CAC5  A4 02     	ldy <__temp
  735  00:CAC7  F0 0C     	beq .lsr_end
  736  00:CAC9  85 02     	sta <__temp
  737  00:CACB  22        	sax
  738                     
  739  00:CACC            .lsr_begin
  740  00:CACC  46 02     	lsr <__temp
  741  00:CACE  6A        	ror a
  742  00:CACF  88        	dey
  743  00:CAD0  D0 FA     	bne .lsr_begin
  744                     
  745  00:CAD2  22        	sax
  746  00:CAD3  A5 02     	lda <__temp
  747                     
  748  00:CAD5            .lsr_end
  749                     	__addmi	2,__stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:CAD5  A8        	tay			; 2
       00:CAD6  18        	clc			; 2
       00:CAD7  A5 00     	lda	<__stack		; 4
       00:CAD9  69 02     	adc	#low(2)	; 2
       00:CADB  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:CADD  90 02     	bcc	.x00158		; 4(2)
       00:CADF  E6 01     	inc	<__stack+1		; 0(6)
       00:CAE1            .x00158:
                          .else
                          .endif
       00:CAE1  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  750  00:CAE2  60        	rts
  751                     
  752  00:CAE3            lsrzp:
  753  00:CAE3  F0 0C     	beq .lsr_end
  754  00:CAE5  85 02     	sta <__temp
  755  00:CAE7  22        	sax
  756                     
  757  00:CAE8            .lsr_begin
  758  00:CAE8  46 02     	lsr <__temp
  759  00:CAEA  6A        	ror a
  760  00:CAEB  88        	dey
  761  00:CAEC  D0 FA     	bne .lsr_begin
  762                     
  763  00:CAEE  22        	sax
  764  00:CAEF  A5 02     	lda <__temp
  765  00:CAF1            .lsr_end
  766  00:CAF1  60        	rts
  767                     
  768                     ; ----
  769                     ; smul
  770                     ; ----
  771                     ; multiply two SIGNED words
  772                     ; ----
  773                     ; IN :  First word on the C stack
  774                     ;	Another word in A:X
  775                     ; ----
  776                     ; OUT : Register word egals the previous pushed value
  777                     ;	multiplied by A:X
  778                     ; ----
  779                     
  780  00:CAF2            smul:
  781  00:CAF2  64 0F     	stz	<__sign	; until we call umul, sign keeps the sign parity
  782                     			; of operand
  783  00:CAF4  C9 80     	cmp	#$80
  784  00:CAF6  90 0D     	bcc	smul_no_invert_primary
  785                     
  786                     	__negw
       00:CAF8  22        	sax
       00:CAF9  49 FF     	eor	#$FF
       00:CAFB  18        	clc
       00:CAFC  69 01     	adc	#1
       00:CAFE  22        	sax
       00:CAFF  49 FF     	eor	#$FF
       00:CB01  69 00     	adc	#0
  787                     
  788  00:CB03  E6 0F     	inc	<__sign	; sign ++
  789                     
  790  00:CB05            smul_no_invert_primary:
  791  00:CB05  85 02     	sta	<__temp
  792  00:CB07  A0 01     	ldy	#1
  793  00:CB09  B1 00     	lda	[__stack],Y
  794  00:CB0B  C9 80     	cmp	#$80
  795  00:CB0D  90 1B     	bcc	smul_no_invert_secondary
  796                     
  797  00:CB0F  E6 0F     	inc	<__sign	; this time, no optimisation possible, IMHO :)
  798                     			; are you sure? :))
  799  00:CB11  86 03     	stx	<__temp+1
  800                     
  801  00:CB13  B2 00     	lda	[__stack]
  802  00:CB15  AA        	tax
  803  00:CB16  B1 00     	lda	[__stack],Y	; we assumed Y = 1 since we set it at the
  804                     				; beginning of smul_no_invert_primary
  805                     	__negw
       00:CB18  22        	sax
       00:CB19  49 FF     	eor	#$FF
       00:CB1B  18        	clc
       00:CB1C  69 01     	adc	#1
       00:CB1E  22        	sax
       00:CB1F  49 FF     	eor	#$FF
       00:CB21  69 00     	adc	#0
  806  00:CB23  91 00     	sta [__stack],Y
  807  00:CB25  22        	sax
  808  00:CB26  92 00     	sta [__stack]
  809                     
  810  00:CB28  A6 03     	ldx <__temp+1
  811                     
  812  00:CB2A            smul_no_invert_secondary:
  813  00:CB2A  A5 0F     	lda <__sign
  814  00:CB2C  48        	pha
  815  00:CB2D  A5 02     	lda <__temp	; saved at the beginning of smul_no_invert_primary
  816                     			; where we're sure we passed
  817                     
  818  00:CB2F  20 47 CB  	jsr umul
  819                     
  820  00:CB32  42        	say
  821  00:CB33  68        	pla
  822  00:CB34  29 01     	and #$01
  823  00:CB36  F0 0D     	beq smul_end
  824                     
  825  00:CB38  42        	say
  826                     	__negw
       00:CB39  22        	sax
       00:CB3A  49 FF     	eor	#$FF
       00:CB3C  18        	clc
       00:CB3D  69 01     	adc	#1
       00:CB3F  22        	sax
       00:CB40  49 FF     	eor	#$FF
       00:CB42  69 00     	adc	#0
  827  00:CB44  60        	rts
  828                     
  829  00:CB45            smul_end:
  830  00:CB45  42        	say
  831  00:CB46  60        	rts
  832                     
  833                     
  834                     ; ----
  835                     ; umul
  836                     ; ----
  837                     ; multiply two UNSIGNED words
  838                     ; ----
  839                     ; IN :  First word on the C stack
  840                     ;	Another word in A:X
  841                     ; ----
  842                     ; OUT : Register word egals the previous pushed value
  843                     ;       multiplied by A:X
  844                     ; ----
  845                     
  846  00:CB47            umul:
  847                     	__stw	<__temp+2 ; bx
       00:CB47  86 04     	stx	<__temp+2
       00:CB49  85 05     	sta	<__temp+2+1
  848                     	__ldwp	__stack
       00:CB4B  B2 00     	lda	[__stack]
       00:CB4D  AA        	tax
       00:CB4E  A0 01     	ldy	#1
       00:CB50  B1 00     	lda	[__stack],Y
  849                     	__stw	<__temp   ; ax
       00:CB52  86 02     	stx	<__temp
       00:CB54  85 03     	sta	<__temp+1
  850  00:CB56  20 6B CB  	  jsr	umul16
  851                     	__addmi	2,__stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:CB59  A8        	tay			; 2
       00:CB5A  18        	clc			; 2
       00:CB5B  A5 00     	lda	<__stack		; 4
       00:CB5D  69 02     	adc	#low(2)	; 2
       00:CB5F  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:CB61  90 02     	bcc	.x00165		; 4(2)
       00:CB63  E6 01     	inc	<__stack+1		; 0(6)
       00:CB65            .x00165:
                          .else
                          .endif
       00:CB65  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  852                     	__ldw	<__ptr
                0000      .if (1 = 2)
                          .else
       00:CB66  A6 06     	ldx	<__ptr
       00:CB68  A5 07     	lda	<__ptr+1
                          .endif
  853  00:CB6A  60        	  rts
  854                     
  855  00:CB6B            umul16:
  856  00:CB6B  A5 05     	  lda	<__temp+3
  857  00:CB6D  05 03     	  ora	<__temp+1
  858  00:CB6F  F0 21     	  beq	umul8
  859                     
  860                     	  stwz	<__ptr
       00:CB71  64 06     	stz	LOW_BYTE <__ptr
       00:CB73  64 07     	stz	HIGH_BYTE <__ptr
  861  00:CB75  A0 10     	  ldy	#16
  862                     
  863                     .l1:	  aslw	<__ptr
       00:CB77  06 06     	asl	<__ptr		; word-sized value (at stated
       00:CB79  26 07     	rol	<__ptr+1		; memory location)
  864                     	  aslw	<__temp+2
       00:CB7B  06 04     	asl	<__temp+2		; word-sized value (at stated
       00:CB7D  26 05     	rol	<__temp+2+1		; memory location)
  865  00:CB7F  90 0D     	  bcc	.l2
  866                     	  addw	<__temp,<__ptr
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       00:CB81  18        	clc
       00:CB82  A5 06     	lda	LOW_BYTE <__ptr
       00:CB84  65 02     	adc	LOW_BYTE <__temp
       00:CB86  85 06     	sta	LOW_BYTE <__ptr
       00:CB88  A5 07     	lda	HIGH_BYTE <__ptr
       00:CB8A  65 03     	adc	HIGH_BYTE <__temp
       00:CB8C  85 07     	sta	HIGH_BYTE <__ptr
                          .endif
  867  00:CB8E  88        .l2:	  dey
  868  00:CB8F  D0 E6     	  bne	.l1
  869                     
  870  00:CB91  60        	  rts
  871                     
  872  00:CB92            umul8:
  873  00:CB92  A5 04     	  lda	<__temp+2
  874  00:CB94  85 07     	  sta	<__ptr+1
  875  00:CB96  62        	  cla
  876  00:CB97  A0 08     	  ldy	#8
  877                     
  878  00:CB99  0A        .l1:	  asl	A
  879  00:CB9A  26 07     	  rol	<__ptr+1
  880  00:CB9C  90 07     	  bcc	.l2
  881                     	  add	<__temp
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       00:CB9E  18        	clc
       00:CB9F  65 02     	adc	<__temp
                          .endif
  882  00:CBA1  90 02     	  bcc	.l2
  883  00:CBA3  E6 07     	  inc	<__ptr+1
  884  00:CBA5  88        .l2:	  dey
  885  00:CBA6  D0 F1     	  bne	.l1
  886                     
  887  00:CBA8  85 06     	  sta	<__ptr
  888  00:CBAA  60        	  rts
  889                     
  890                     
  891                     ; ----
  892                     ; sdiv
  893                     ; ----
  894                     ; divide two SIGNED words
  895                     ; ----
  896                     ; IN :  First word on the C stack
  897                     ;       Another word in A:X
  898                     ; ----
  899                     ; OUT : Register word egals the previous pushed value
  900                     ;       divided by A:X
  901                     ; ----
  902                     
  903  00:CBAB            sdiv:
  904  00:CBAB  64 0F     	stz	<__sign	; until we call udiv, sign keeps the sign parity
  905                     			; of operand
  906  00:CBAD  C9 80     	cmp	#$80
  907  00:CBAF  90 0D     	bcc	sdiv_no_invert_primary
  908                     
  909                     	__negw
       00:CBB1  22        	sax
       00:CBB2  49 FF     	eor	#$FF
       00:CBB4  18        	clc
       00:CBB5  69 01     	adc	#1
       00:CBB7  22        	sax
       00:CBB8  49 FF     	eor	#$FF
       00:CBBA  69 00     	adc	#0
  910                     
  911  00:CBBC  E6 0F     	inc	<__sign	; sign ++
  912                     
  913  00:CBBE            sdiv_no_invert_primary:
  914  00:CBBE  85 02     	sta	<__temp
  915  00:CBC0  A0 01     	ldy	#1
  916  00:CBC2  B1 00     	lda	[__stack],Y
  917  00:CBC4  C9 80     	cmp	#$80
  918  00:CBC6  90 1B     	bcc	sdiv_no_invert_secondary
  919                     
  920  00:CBC8  E6 0F     	inc	<__sign
  921                     
  922  00:CBCA  86 03     	stx	<__temp+1
  923                     
  924  00:CBCC  B2 00     	lda	[__stack]
  925  00:CBCE  AA        	tax
  926  00:CBCF  B1 00     	lda	[__stack],Y	; we assumed Y = 1 since we set it at the beginning of
  927                     				; sdiv_no_invert_primary
  928                     	__negw
       00:CBD1  22        	sax
       00:CBD2  49 FF     	eor	#$FF
       00:CBD4  18        	clc
       00:CBD5  69 01     	adc	#1
       00:CBD7  22        	sax
       00:CBD8  49 FF     	eor	#$FF
       00:CBDA  69 00     	adc	#0
  929  00:CBDC  91 00     	sta	[__stack],Y
  930  00:CBDE  22        	sax
  931  00:CBDF  92 00     	sta	[__stack]
  932                     
  933  00:CBE1  A6 03     	ldx	<__temp+1
  934                     
  935  00:CBE3            sdiv_no_invert_secondary:
  936  00:CBE3  A5 0F     	lda	<__sign
  937  00:CBE5  48        	pha
  938  00:CBE6  A5 02     	lda	<__temp	; saved at the beginning of sdiv_no_invert_primary
  939                     			; where we're sure we passed
  940  00:CBE8  20 00 CC  	jsr	udiv
  941                     
  942  00:CBEB  42        	say
  943  00:CBEC  68        	pla
  944  00:CBED  29 01     	and	#$01
  945  00:CBEF  F0 0D     	beq	sdiv_end
  946                     
  947  00:CBF1  42        	say
  948                     	__negw
       00:CBF2  22        	sax
       00:CBF3  49 FF     	eor	#$FF
       00:CBF5  18        	clc
       00:CBF6  69 01     	adc	#1
       00:CBF8  22        	sax
       00:CBF9  49 FF     	eor	#$FF
       00:CBFB  69 00     	adc	#0
  949  00:CBFD  60        	rts
  950                     
  951  00:CBFE            sdiv_end:
  952  00:CBFE  42        	say
  953  00:CBFF  60        	rts
  954                     
  955                     
  956                     ; ----
  957                     ; udiv
  958                     ; ----
  959                     ; divide two UNSIGNED words
  960                     ; ----
  961                     ; IN :  First word on the C stack
  962                     ;       Another word in A:X
  963                     ; ----
  964                     ; OUT : Register word egals the previous pushed value
  965                     ;       divided by A:X
  966                     ; ----
  967                     
  968  00:CC00            udiv:
  969                     	__stw	<__ptr
       00:CC00  86 06     	stx	<__ptr
       00:CC02  85 07     	sta	<__ptr+1
  970                     	__ldwp	__stack
       00:CC04  B2 00     	lda	[__stack]
       00:CC06  AA        	tax
       00:CC07  A0 01     	ldy	#1
       00:CC09  B1 00     	lda	[__stack],Y
  971                     	__stw	<__temp
       00:CC0B  86 02     	stx	<__temp
       00:CC0D  85 03     	sta	<__temp+1
  972                     
  973  00:CC0F  A9 00     	lda	#0
  974  00:CC11  85 11     	sta	<__remain+1
  975  00:CC13  A0 10     	ldy	#16
  976  00:CC15  06 02     .sdiv_begin:	asl	<__temp
  977  00:CC17  26 03     	rol	<__temp+1
  978  00:CC19  2A        	rol	a
  979  00:CC1A  26 11     	rol	<__remain+1
  980  00:CC1C  48        	pha
  981  00:CC1D  C5 06     	cmp	<__ptr
  982  00:CC1F  A5 11     	lda	<__remain+1
  983  00:CC21  E5 07     	sbc	<__ptr+1
  984  00:CC23  90 08     	bcc	.sdiv_end
  985  00:CC25  85 11     	sta	<__remain+1
  986  00:CC27  68        	pla
  987  00:CC28  E5 06     	sbc	<__ptr
  988  00:CC2A  48        	pha
  989  00:CC2B  E6 02     	inc	<__temp
  990  00:CC2D  68        .sdiv_end:	pla
  991  00:CC2E  88        	dey
  992  00:CC2F  D0 E4     	bne	.sdiv_begin
  993  00:CC31  85 10     	sta	<__remain
  994                     
  995                     	__addmi	2,__stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:CC33  A8        	tay			; 2
       00:CC34  18        	clc			; 2
       00:CC35  A5 00     	lda	<__stack		; 4
       00:CC37  69 02     	adc	#low(2)	; 2
       00:CC39  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:CC3B  90 02     	bcc	.x00178		; 4(2)
       00:CC3D  E6 01     	inc	<__stack+1		; 0(6)
       00:CC3F            .x00178:
                          .else
                          .endif
       00:CC3F  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  996                     	__ldw	<__temp
                0000      .if (1 = 2)
                          .else
       00:CC40  A6 02     	ldx	<__temp
       00:CC42  A5 03     	lda	<__temp+1
                          .endif
  997                     
  998  00:CC44  60        	rts
  999                     
 1000                     
 1001                     ; ----
 1002                     ; smod
 1003                     ; ----
 1004                     ; give the integer remainder of the two words
 1005                     ; ----
 1006                     ; IN :  First word on the C stack
 1007                     ;       Another word in A:X
 1008                     ; ----
 1009                     ; OUT : Register word egals the remainder of the division of the
 1010                     ;       pushed value by A:X
 1011                     ; ----
 1012                     
 1013  00:CC45            smod:
 1014  00:CC45  64 0F     	stz	<__sign
 1015                     	__stw	<__ptr
       00:CC47  86 06     	stx	<__ptr
       00:CC49  85 07     	sta	<__ptr+1
 1016                     	__ldwp	__stack
       00:CC4B  B2 00     	lda	[__stack]
       00:CC4D  AA        	tax
       00:CC4E  A0 01     	ldy	#1
       00:CC50  B1 00     	lda	[__stack],Y
 1017  00:CC52  C9 80     	cmp	#$80
 1018  00:CC54  90 15     	bcc	.skip1
 1019  00:CC56  E6 0F     	inc	<__sign
 1020                     	__negw
       00:CC58  22        	sax
       00:CC59  49 FF     	eor	#$FF
       00:CC5B  18        	clc
       00:CC5C  69 01     	adc	#1
       00:CC5E  22        	sax
       00:CC5F  49 FF     	eor	#$FF
       00:CC61  69 00     	adc	#0
 1021                     	__stwp	__stack
       00:CC63  22        	sax
       00:CC64  92 00     	sta	[__stack]
       00:CC66  22        	sax
       00:CC67  A0 01     	ldy	#1
       00:CC69  91 00     	sta	[__stack],Y
 1022                     .skip1:	__ldw	<__ptr
                0000      .if (1 = 2)
                          .else
       00:CC6B  A6 06     	ldx	<__ptr
       00:CC6D  A5 07     	lda	<__ptr+1
                          .endif
 1023  00:CC6F  C9 80     	cmp	#$80
 1024  00:CC71  90 0B     	bcc	.skip2
 1025                     	__negw
       00:CC73  22        	sax
       00:CC74  49 FF     	eor	#$FF
       00:CC76  18        	clc
       00:CC77  69 01     	adc	#1
       00:CC79  22        	sax
       00:CC7A  49 FF     	eor	#$FF
       00:CC7C  69 00     	adc	#0
 1026  00:CC7E  20 91 CC  .skip2:	jsr	umod
 1027  00:CC81  A4 0F     	ldy	<__sign
 1028  00:CC83  F0 0B     	beq	.noinv
 1029                     	__negw
       00:CC85  22        	sax
       00:CC86  49 FF     	eor	#$FF
       00:CC88  18        	clc
       00:CC89  69 01     	adc	#1
       00:CC8B  22        	sax
       00:CC8C  49 FF     	eor	#$FF
       00:CC8E  69 00     	adc	#0
 1030  00:CC90  60        .noinv:	rts
 1031                     
 1032  00:CC91            umod:
 1033                     	__stw	<__ptr
       00:CC91  86 06     	stx	<__ptr
       00:CC93  85 07     	sta	<__ptr+1
 1034                     	__ldwp	__stack
       00:CC95  B2 00     	lda	[__stack]
       00:CC97  AA        	tax
       00:CC98  A0 01     	ldy	#1
       00:CC9A  B1 00     	lda	[__stack],Y
 1035                     	__stw	<__temp
       00:CC9C  86 02     	stx	<__temp
       00:CC9E  85 03     	sta	<__temp+1
 1036                     
 1037  00:CCA0  A9 00     	lda	#0
 1038  00:CCA2  85 11     	sta	<__remain+1
 1039  00:CCA4  A0 10     	ldy	#16
 1040  00:CCA6  06 02     .umod_begin:	asl	<__temp
 1041  00:CCA8  26 03     	rol	<__temp+1
 1042  00:CCAA  2A        	rol	a
 1043  00:CCAB  26 11     	rol	<__remain+1
 1044  00:CCAD  48        	pha
 1045  00:CCAE  C5 06     	cmp	<__ptr
 1046  00:CCB0  A5 11     	lda	<__remain+1
 1047  00:CCB2  E5 07     	sbc	<__ptr+1
 1048  00:CCB4  90 08     	bcc	.umod_end
 1049  00:CCB6  85 11     	sta	<__remain+1
 1050  00:CCB8  68        	pla
 1051  00:CCB9  E5 06     	sbc	<__ptr
 1052  00:CCBB  48        	pha
 1053  00:CCBC  E6 02     	inc	<__temp
 1054  00:CCBE  68        .umod_end:	pla
 1055  00:CCBF  88        	dey
 1056  00:CCC0  D0 E4     	bne	.umod_begin
 1057  00:CCC2  85 10     	sta	<__remain
 1058                     
 1059                     	__addmi	2,__stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:CCC4  A8        	tay			; 2
       00:CCC5  18        	clc			; 2
       00:CCC6  A5 00     	lda	<__stack		; 4
       00:CCC8  69 02     	adc	#low(2)	; 2
       00:CCCA  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:CCCC  90 02     	bcc	.x00190		; 4(2)
       00:CCCE  E6 01     	inc	<__stack+1		; 0(6)
       00:CCD0            .x00190:
                          .else
                          .endif
       00:CCD0  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
 1060                     	__ldw	<__remain
                0000      .if (1 = 2)
                          .else
       00:CCD1  A6 10     	ldx	<__remain
       00:CCD3  A5 11     	lda	<__remain+1
                          .endif
 1061                     
 1062  00:CCD5  60        	rts
 1063                     
 1064                     ; ----
 1065                     ; ___case
 1066                     ; ----
 1067                     ; implement a switch instruction in C
 1068                     ; ----
 1069                     ; IN :  primary register (A:X) contain the discriminant value
 1070                     ;       i.e. the one that will be checked against those indicated in the
 1071                     ;       various case instructions
 1072                     ;       On the stack, a pointer is passed
 1073                     ;       This is a pointer toward an array
 1074                     ;       Each item of this array is a 4 bytes long structure
 1075                     ;       The structure is the following :
 1076                     ;         WORD value_to_check
 1077                     ;         WORD label_to_jump_to
 1078                     ;       We have to parse the whole array in order to compare the primary
 1079                     ;       register with all the 'value_to_check' field. If we ever find that
 1080                     ;       the primary register is egal to such a value, we must jump to the
 1081                     ;       corresponding 'label_to_jump_to'.
 1082                     ;       The default value (which also means that we reached the end of the
 1083                     ;       array) can be recognized with its 'label_to_jump_to' field set to 0.
 1084                     ;       Then the 'value_to_check' field become the default label we have to
 1085                     ;       use for the rest of the execution.
 1086                     ; ----
 1087                     ; OUT : The execution goes to another place
 1088                     ; ----
 1089                     ; REMARK : Also use remain variable as a temporary value
 1090                     ; ----
 1091                     
 1092  00:CCD6            ___case:
 1093                     	__stw	<__remain		; store the value to check to
       00:CCD6  86 10     	stx	<__remain		
       00:CCD8  85 11     	sta	<__remain		+1
 1094                     	__ldwp	__stack
       00:CCDA  B2 00     	lda	[__stack]
       00:CCDC  AA        	tax
       00:CCDD  A0 01     	ldy	#1
       00:CCDF  B1 00     	lda	[__stack],Y
 1095                     	__stw	<__ptr		; __ptr contain the address of the array
       00:CCE1  86 06     	stx	<__ptr		
       00:CCE3  85 07     	sta	<__ptr		+1
 1096                     
 1097                     	__addmi	2,__stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:CCE5  A8        	tay			; 2
       00:CCE6  18        	clc			; 2
       00:CCE7  A5 00     	lda	<__stack		; 4
       00:CCE9  69 02     	adc	#low(2)	; 2
       00:CCEB  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:CCED  90 02     	bcc	.x00195		; 4(2)
       00:CCEF  E6 01     	inc	<__stack+1		; 0(6)
       00:CCF1            .x00195:
                          .else
                          .endif
       00:CCF1  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
 1098                     
 1099  00:CCF2  C2        	cly
 1100  00:CCF3  80 02     	bra	.begin_case
 1101                     
 1102  00:CCF5            .next_case_lo:
 1103  00:CCF5  C8        	iny
 1104  00:CCF6            .next_case_hi:
 1105  00:CCF6  C8        	iny
 1106  00:CCF7            .begin_case:
 1107  00:CCF7  C8        	iny			; skip func lo-byte
 1108  00:CCF8  B1 06     	lda	[__ptr],y	; test func hi-byte
 1109  00:CCFA  F0 1C     	beq	.case_default
 1110  00:CCFC  C8        	iny
 1111  00:CCFD  B1 06     	lda	[__ptr],y
 1112  00:CCFF  C5 10     	cmp	<__remain+0
 1113  00:CD01  D0 F2     	bne	.next_case_lo
 1114  00:CD03  C8        	iny
 1115  00:CD04  B1 06     	lda	[__ptr],y
 1116  00:CD06  C5 11     	cmp	<__remain+1
 1117  00:CD08  D0 EC     	bne	.next_case_hi
 1118  00:CD0A  88        	dey			; found match
 1119  00:CD0B  88        	dey
 1120  00:CD0C            .case_vector:
 1121  00:CD0C  B1 06     	lda	[__ptr],y	; read func hi-byte
 1122  00:CD0E  85 03     	sta	<__temp+1
 1123  00:CD10  88        	dey
 1124  00:CD11  B1 06     	lda	[__ptr],y	; read func lo-byte
 1125  00:CD13  85 02     	sta	<__temp+0
 1126  00:CD15  6C 02 20  	jmp	[__temp]
 1127  00:CD18            .case_default:
 1128  00:CD18  C8        	iny
 1129  00:CD19  C8        	iny
 1130  00:CD1A  80 F0     	bra	.case_vector
 1131                     
 1132                     
 1133                     ; ----
 1134                     ; hook
 1135                     ; ----
 1136                     ; indirect call to sub-routine
 1137                     ; ----
 1138                     ; IN :  sub-routine addr in __ptr
 1139                     ; ----
 1140                     
 1141  00:CD1C            hook:
 1142  00:CD1C  6C 06 20  	jmp	[__ptr]
 1143                     
 1144                     ; ----
 1145                     ; setvdc
 1146                     ; ----
 1147                     ; set a vdc register
 1148                     ; ----
 1149                     ; IN : - reg index on the C stack
 1150                     ;      - value in A:X
 1151                     ; ----
 1152                     
 1153  00:CD1F  A8        setvdc:	tay
 1154  00:CD20  B2 00     	lda	[__sp]
 1155  00:CD22  4A        	lsr	a
 1156  00:CD23  C9 09     	cmp	#$09
 1157  00:CD25  F0 19     	beq	.l3
 1158                     
 1159  00:CD27  85 F7     .l1:	sta	<vdc_reg
 1160  00:CD29  8D 00 00  	sta	video_reg
 1161  00:CD2C  8E 02 00  	stx	video_data_l
 1162  00:CD2F  8C 03 00  	sty	video_data_h
 1163                     .l2:	__addmi	2,__sp
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       00:CD32  A8        	tay			; 2
       00:CD33  18        	clc			; 2
       00:CD34  A5 00     	lda	<__sp		; 4
       00:CD36  69 02     	adc	#low(2)	; 2
       00:CD38  85 00     	sta	<__sp		; 4
                0001      .if (2 < 256) & (2 >= 0)
       00:CD3A  90 02     	bcc	.x00196		; 4(2)
       00:CD3C  E6 01     	inc	<__sp+1		; 0(6)
       00:CD3E            .x00196:
                          .else
                          .endif
       00:CD3E  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
 1164  00:CD3F  60        	rts
 1165                     	; -- reg $09
 1166  00:CD40  8A        .l3:	txa
 1167  00:CD41  29 70     	and	#$70
 1168  00:CD43  4A        	lsr	A
 1169  00:CD44  4A        	lsr	A
 1170  00:CD45  4A        	lsr	A
 1171  00:CD46  4A        	lsr	A
 1172  00:CD47  20 F8 C4  	jsr	set_bat_size
 1173  00:CD4A  80 E6     	bra	.l2
 1174                     
 1175                     ; ----
 1176                     ; getvdc
 1177                     ; ----
 1178                     ; get vdc register content
 1179                     ; ----
 1180                     ; IN : reg index in A:X
 1181                     ; ----
 1182                     ; OUT: vdc register in A:X
 1183                     ; ----
 1184                     
 1185  00:CD4C  E0 04     getvdc:	cpx	#4
 1186  00:CD4E  D0 0E     	bne	.l1
 1187  00:CD50  A9 02     	lda	#2
 1188  00:CD52  85 F7     	sta	<vdc_reg
 1189  00:CD54  8D 00 00  	sta	video_reg
 1190  00:CD57  AE 02 00  	ldx	video_data_l
 1191  00:CD5A  AD 03 00  	lda	video_data_h
 1192  00:CD5D  60        	rts
 1193  00:CD5E  82        .l1:    clx
 1194  00:CD5F  62        	cla
 1195  00:CD60  60        	rts
#[2]   startup.asm
#[3]   huc_gfx.asm
 1270                     .include "huc_gfx.asm"
    1                     ;
    2                     ; HUC_GFX.ASM  -  HuC Graphic Library
    3                     ;
    4                     
    5                     ; ----
    6                     ; local variables
    7                     
    8           2012      	.zp
    9  --:2012            spr_ptr		.ds 2
   10  --:2014            spr_max		.ds 1
   11  --:2015            spr_flag	.ds 1
   12                     
   13           27AF      	.bss
   14  --:27AF            _font_base	.ds 2
   15  --:27B1            font_color	.ds 2
   16  --:27B3            satb		.ds 512	; the local SATB
   17                     
   18  --:29B3            gfx_pal		.ds 1
   19                     
   20  --:29B4            line_currx	.ds 2
   21  --:29B6            line_curry	.ds 2
   22  --:29B8            line_deltax	.ds 2
   23  --:29BA            line_deltay	.ds 2
   24  --:29BC            line_error	.ds 2
   25  --:29BE            line_adjust	.ds 2
   26  --:29C0            line_xdir	.ds 1
   27  --:29C1            line_color	.ds 1
   28                     
   29                     
   30                     ; ----
   31                     ; library code
   32                     
   33           CD61      	 .code
   34                     
   35                     ; cls(int val [__dx])
   36                     ; ----
   37                     
   38  00:CD61            _cls:
   39                     	stw	_font_base,<__dx
       00:CD61  AD AF 27  	lda	LOW_BYTE _font_base
       00:CD64  85 FE     	sta	LOW_BYTE <__dx
       00:CD66  AD B0 27  	lda	HIGH_BYTE _font_base
       00:CD69  85 FF     	sta	HIGH_BYTE <__dx
   40  00:CD6B            _cls.1:
   41                     	setvwaddr $0
                          	stw	#$0,<__di
       00:CD6B  A9 00     	lda	LOW_BYTE #$0
       00:CD6D  85 F0     	sta	LOW_BYTE <__di
       00:CD6F  A9 00     	lda	HIGH_BYTE #$0
       00:CD71  85 F1     	sta	HIGH_BYTE <__di
       00:CD73  20 98 C4  	jsr	set_write
   42                     	; --
   43  00:CD76  AC 3E 27  	ldy	bat_height
   44  00:CD79  AE 3C 27  .l2:	ldx	bat_width
   45                     	; --
   46                     .l3:	stw	<__dx,video_data
       00:CD7C  A5 FE     	lda	LOW_BYTE <__dx
       00:CD7E  8D 02 00  	sta	LOW_BYTE video_data
       00:CD81  A5 FF     	lda	HIGH_BYTE <__dx
       00:CD83  8D 03 00  	sta	HIGH_BYTE video_data
   47  00:CD86  CA        	dex
   48  00:CD87  D0 F3     	bne	.l3
   49  00:CD89  88        	dey
   50  00:CD8A  D0 ED     	bne	.l2
   51  00:CD8C  60        	rts
   52                     
   53                     ; set_font_pal(int pal)
   54                     ; ----
   55                     
   56  00:CD8D            _set_font_pal:
   57  00:CD8D  8A        	txa
   58  00:CD8E  0A        	asl	A
   59  00:CD8F  0A        	asl	A
   60  00:CD90  0A        	asl	A
   61  00:CD91  0A        	asl	A
   62  00:CD92  85 02     	sta	<__temp
   63  00:CD94  AD B0 27  	lda	_font_base+1
   64  00:CD97  29 0F     	and	#$0F
   65  00:CD99  05 02     	ora	<__temp
   66  00:CD9B  8D B0 27  	sta	_font_base+1
   67  00:CD9E  60        	rts
   68                     
   69                     ; set_font_color(char color, char bg)
   70                     ; ----
   71                     
   72  00:CD9F            _set_font_color.2:
   73  00:CD9F  8A        	txa
   74  00:CDA0  29 0F     	and	#$F
   75  00:CDA2  8D B2 27  	sta	font_color+1
   76  00:CDA5  A5 F8     	lda	<__al
   77  00:CDA7  29 0F     	and	#$F
   78  00:CDA9  8D B1 27  	sta	font_color
   79  00:CDAC  60        	rts
   80                     
   81                     ; set_font_addr(int addr)
   82                     ; ----
   83                     
   84  00:CDAD            _set_font_addr:
   85                     	; --
   86  00:CDAD  8E AF 27  	stx	_font_base
   87  00:CDB0  4A        	lsr	A
   88  00:CDB1  6E AF 27  	ror	_font_base
   89  00:CDB4  4A        	lsr	A
   90  00:CDB5  6E AF 27  	ror	_font_base
   91  00:CDB8  4A        	lsr	A
   92  00:CDB9  6E AF 27  	ror	_font_base
   93  00:CDBC  4A        	lsr	A
   94  00:CDBD  6E AF 27  	ror	_font_base
   95  00:CDC0  85 F8     	sta	<__al
   96                     	; --
   97  00:CDC2  AD B0 27  	lda	_font_base+1
   98  00:CDC5  29 F0     	and	#$F0
   99  00:CDC7  05 F8     	ora	<__al
  100  00:CDC9  8D B0 27  	sta	_font_base+1
  101  00:CDCC  60        	rts
  102                     
  103                     ; get_font_pal()
  104                     ; ----
  105                     
  106  00:CDCD            _get_font_pal:
  107  00:CDCD  AD B0 27  	lda	_font_base+1
  108  00:CDD0  4A        	lsr	A
  109  00:CDD1  4A        	lsr	A
  110  00:CDD2  4A        	lsr	A
  111  00:CDD3  4A        	lsr	A
  112  00:CDD4  82        	clx
  113  00:CDD5  22        	sax
  114  00:CDD6  60        	rts
  115                     
  116                     ; get_font_addr()
  117                     ; ----
  118                     
  119  00:CDD7            _get_font_addr:
  120                     	; --
  121  00:CDD7  AD B0 27  	lda	_font_base+1
  122  00:CDDA  85 F8     	sta	<__al
  123  00:CDDC  AD AF 27  	lda	_font_base
  124  00:CDDF  0A        	asl	A
  125  00:CDE0  26 F8     	rol	<__al
  126  00:CDE2  0A        	asl	A
  127  00:CDE3  26 F8     	rol	<__al
  128  00:CDE5  0A        	asl	A
  129  00:CDE6  26 F8     	rol	<__al
  130  00:CDE8  0A        	asl	A
  131  00:CDE9  26 F8     	rol	<__al
  132  00:CDEB  A6 F8     	ldx	<__al
  133  00:CDED  22        	sax
  134  00:CDEE  60        	rts
  135                     
  136                     ; load_default_font(char num [__dl], int addr [__di])
  137                     ; ----
  138                     
  139  00:CDEF            _load_default_font:
  140                     	; --
  141  00:CDEF  64 FE     	stz	<__dl
  142                     
  143  00:CDF1            _load_default_font.1:
  144                     	; --
  145  00:CDF1  A2 FF     	ldx	#$FF
  146  00:CDF3  A9 FF     	lda	#$FF
  147  00:CDF5  20 AF C4  	jsr	calc_vram_addr
  148                     	incw	<__di
       00:CDF8  E6 F0     	inc	<__di		; value at stated memory
       00:CDFA  D0 02     	bne	.x_00201		; location
       00:CDFC  E6 F1     	inc	<__di+1
       00:CDFE            .x_00201:
  149                     
  150  00:CDFE            _load_default_font.2:
  151                     	; --
  152  00:CDFE  A5 F0     	lda	<__di
  153  00:CE00  05 F1     	ora	<__di+1
  154  00:CE02  D0 09     	bne	.l1
  155  00:CE04  20 D7 CD  	jsr	_get_font_addr
  156                     	__stw	<__di
       00:CE07  86 F0     	stx	<__di
       00:CE09  85 F1     	sta	<__di+1
  157  00:CE0B  80 07     	bra	.l2
  158                     	; --
  159                     .l1:	__ldw	<__di
                0000      .if (1 = 2)
                          .else
       00:CE0D  A6 F0     	ldx	<__di
       00:CE0F  A5 F1     	lda	<__di+1
                          .endif
  160  00:CE11  20 AD CD  	jsr	_set_font_addr
  161                     	; --
  162                     .l2:	stb	#FONT_BANK+_bank_base,<__bl
       00:CE14  A9 81     	lda	#FONT_BANK+_bank_base
       00:CE16  85 FA     	sta	<__bl
  163                     	stb	#96,<__cl
       00:CE18  A9 60     	lda	#96
       00:CE1A  85 FC     	sta	<__cl
  164                     	stb	font_color+1,<__ah
       00:CE1C  AD B2 27  	lda	font_color+1
       00:CE1F  85 F9     	sta	<__ah
  165  00:CE21  AD B1 27  	lda	font_color
  166  00:CE24  D0 01     	bne	.l3
  167  00:CE26  1A        	inc	A
  168  00:CE27  85 F8     .l3:	sta	<__al
  169  00:CE29  A5 FE     	lda	<__dl
  170  00:CE2B  29 03     	and	#$03
  171  00:CE2D  0A        	asl	A
  172  00:CE2E  AA        	tax
  173  00:CE2F  BD 62 C3  	lda	font_table,X
  174  00:CE32  85 EE     	sta	<__si
  175  00:CE34  E8        	inx
  176  00:CE35  BD 62 C3  	lda	font_table,X
  177  00:CE38  85 EF     	sta	<__si+1
  178  00:CE3A  4C 0B C4  	jmp	load_font
  179                     
  180                     ; load_font(farptr font [__bl:__si], char nb [__cl], int addr [__di])
  181                     ; ----
  182                     
  183  00:CE3D            _load_font.2:
  184                     	; --
  185  00:CE3D  A2 FF     	ldx	#$FF
  186  00:CE3F  A9 FF     	lda	#$FF
  187  00:CE41  20 AF C4  	jsr	calc_vram_addr
  188                     	incw	<__di
       00:CE44  E6 F0     	inc	<__di		; value at stated memory
       00:CE46  D0 02     	bne	.x_00207		; location
       00:CE48  E6 F1     	inc	<__di+1
       00:CE4A            .x_00207:
  189                     
  190  00:CE4A            _load_font.3:
  191                     	; --
  192  00:CE4A  A5 F0     	lda	<__di
  193  00:CE4C  05 F1     	ora	<__di+1
  194  00:CE4E  D0 09     	bne	.l1
  195  00:CE50  20 D7 CD  	jsr	_get_font_addr
  196                     	__stw	<__di
       00:CE53  86 F0     	stx	<__di
       00:CE55  85 F1     	sta	<__di+1
  197  00:CE57  80 07     	bra	.l2
  198                     	; --
  199                     .l1:	__ldw	<__di
                0000      .if (1 = 2)
                          .else
       00:CE59  A6 F0     	ldx	<__di
       00:CE5B  A5 F1     	lda	<__di+1
                          .endif
  200  00:CE5D  20 AD CD  	jsr	_set_font_addr
  201                     	; --
  202  00:CE60  A5 FC     .l2:	lda	<__cl
  203  00:CE62  64 FD     	stz	<__ch
  204  00:CE64  0A        	asl	A
  205  00:CE65  26 FD     	rol	<__ch
  206  00:CE67  0A        	asl	A
  207  00:CE68  26 FD     	rol	<__ch
  208  00:CE6A  0A        	asl	A
  209  00:CE6B  26 FD     	rol	<__ch
  210  00:CE6D  0A        	asl	A
  211  00:CE6E  26 FD     	rol	<__ch
  212  00:CE70  85 FC     	sta	<__cl
  213  00:CE72  4C 1D C4  	jmp	load_vram
  214                     
  215                     ; put_digit(char digit, int offset)
  216                     ; put_digit(char digit, char x, char y)
  217                     ; ----
  218                     
  219  00:CE75            _put_digit.3:
  220  00:CE75  A5 FC     	lda	<__cl
  221  00:CE77  20 98 CE  	jsr	_put.xy
  222  00:CE7A  80 03     	bra	_put_digit.main
  223  00:CE7C            _put_digit.2:
  224  00:CE7C  20 9F CE  	jsr	_put.vram
  225  00:CE7F            _put_digit.main:
  226  00:CE7F  A5 FE     	lda	<__dl
  227  00:CE81            _put_digit.sub:
  228  00:CE81  C9 0A     	cmp	#10
  229                     	blo	.l1
       00:CE83  90 03     	bcc	.l1
  230                     	add	#$07
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       00:CE85  18        	clc
       00:CE86  69 07     	adc	#$07
                          .endif
  231  00:CE88  69 10     .l1:	adc	#$10
  232  00:CE8A  6D AF 27  	adc	_font_base
  233  00:CE8D  8D 02 00  	sta	video_data_l
  234  00:CE90  62        	cla
  235  00:CE91  6D B0 27  	adc	_font_base+1
  236  00:CE94  8D 03 00  	sta	video_data_h
  237  00:CE97  60        	rts
  238  00:CE98            _put.xy:
  239  00:CE98  22        	sax
  240  00:CE99  20 AF C4  	jsr	calc_vram_addr
  241  00:CE9C  4C 98 C4  	jmp	set_write
  242  00:CE9F            _put.vram:
  243  00:CE9F  64 F7     	stz	<vdc_reg
  244  00:CEA1  9C 00 00  	stz	video_reg
  245  00:CEA4  8E 02 00  	stx	video_data_l
  246  00:CEA7  8D 03 00  	sta	video_data_h
  247                     	vreg	#$02
       00:CEAA  A9 02     	lda	#$02
       00:CEAC  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:CEAE  03 02     	st0	#$02
                          .else
                          .endif
  248  00:CEB0  60        	rts
  249                     
  250                     ; put_char(char character, int offset)
  251                     ; put_char(char character, char x, char y)
  252                     ; ----
  253                     
  254  00:CEB1            _put_char.3:
  255  00:CEB1  A5 FC     	lda	<__cl
  256  00:CEB3  20 98 CE  	jsr	_put.xy
  257  00:CEB6  80 03     	bra	_put_char.main
  258  00:CEB8            _put_char.2:
  259  00:CEB8  20 9F CE  	jsr	_put.vram
  260  00:CEBB            _put_char.main:
  261  00:CEBB  A5 FE     	lda	<__dl
  262                     	; --
  263  00:CEBD  C9 20     	cmp	#32
  264                     	bhs	.l1
       00:CEBF  B0 03     	bcs	.l1
  265  00:CEC1  A9 20     	lda	#32
  266  00:CEC3  38        	sec
  267  00:CEC4  E9 20     .l1:	sbc	#32
  268                     	add	_font_base
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       00:CEC6  18        	clc
       00:CEC7  6D AF 27  	adc	_font_base
                          .endif
  269  00:CECA  8D 02 00  	sta	video_data_l
  270  00:CECD  62        	cla
  271  00:CECE  6D B0 27  	adc	_font_base+1
  272  00:CED1  8D 03 00  	sta	video_data_h
  273  00:CED4  60        	rts
  274                     
  275                     ; put_raw(int character, int offset)
  276                     ; put_raw(int character, char x, char y)
  277                     ; ----
  278                     
  279  00:CED5            _put_raw.3:
  280  00:CED5  A5 FC     	lda	<__cl
  281  00:CED7  20 98 CE  	jsr	_put.xy
  282  00:CEDA  80 03     	bra	_put_raw.main
  283  00:CEDC            _put_raw.2:
  284  00:CEDC  20 9F CE  	jsr	_put.vram
  285  00:CEDF            _put_raw.main:
  286  00:CEDF  A5 FE     	lda	<__dl
  287  00:CEE1  8D 02 00  	sta	video_data_l
  288  00:CEE4  A5 FF     	lda	<__dh
  289  00:CEE6  8D 03 00  	sta	video_data_h
  290  00:CEE9  60        	rts
  291                     
  292                     ; put_number(int number, char n, int offset)
  293                     ; put_number(int number, char n, char x, char y)
  294                     ; ----
  295                     
  296                     
  297                     _put_number.3:	maplibfunc	lib2_put_number.3
       00:CEEA  A8        	tay
       00:CEEB  43 20     	tma	#page(lib2_put_number.3)
       00:CEED  48        	pha
       00:CEEE  A9 81     	lda	#bank(lib2_put_number.3)
       00:CEF0  53 20     	tam	#page(lib2_put_number.3)
       00:CEF2  98        	tya
       00:CEF3  20 F0 AC  	jsr	lib2_put_number.3
       00:CEF6  A8        	tay
       00:CEF7  68        	pla
       00:CEF8  53 20     	tam	#page(lib2_put_number.3)
       00:CEFA  98        	tya
  298  00:CEFB  60        		rts
  299                     
  300                     _put_number.4:	maplibfunc	lib2_put_number.4
       00:CEFC  A8        	tay
       00:CEFD  43 20     	tma	#page(lib2_put_number.4)
       00:CEFF  48        	pha
       00:CF00  A9 81     	lda	#bank(lib2_put_number.4)
       00:CF02  53 20     	tam	#page(lib2_put_number.4)
       00:CF04  98        	tya
       00:CF05  20 E9 AC  	jsr	lib2_put_number.4
       00:CF08  A8        	tay
       00:CF09  68        	pla
       00:CF0A  53 20     	tam	#page(lib2_put_number.4)
       00:CF0C  98        	tya
  301  00:CF0D  60        		rts
  302                     
  303                     
  304                     ; put_hex(int number, char n, int offset)
  305                     ; put_hex(int number, char n, char x, char y)
  306                     ; ----
  307                     
  308  00:CF0E            _put_hex.4:
  309  00:CF0E  A5 FA     	lda	<__bl
  310  00:CF10  20 98 CE  	jsr	_put.xy
  311  00:CF13  80 03     	bra	_put_hex.main
  312  00:CF15            _put_hex.3:
  313  00:CF15  20 9F CE  	jsr	_put.vram
  314  00:CF18            _put_hex.main:
  315  00:CF18  A6 FC     	ldx	<__cl
  316  00:CF1A  F0 12     	beq	.l3
  317  00:CF1C  E0 05     .l1:	cpx	#5
  318                     	blo	.l2
       00:CF1E  90 07     	bcc	.l2
  319  00:CF20  62        	cla
  320  00:CF21  20 81 CE  	jsr	_put_digit.sub
  321  00:CF24  CA        	dex
  322  00:CF25  80 F5     	bra	.l1
  323                     	; --
  324  00:CF27  8A        .l2:	txa
  325  00:CF28  3A        	dec	A
  326  00:CF29  0A        	asl	A
  327  00:CF2A  AA        	tax
  328  00:CF2B  7C 2F CF  	jmp	[.tbl,X]
  329  00:CF2E  60        .l3:	rts
  330                     	; --
  331  00:CF2F  50 CF     .tbl:	.dw	.h1,.h2,.h3,.h4
       00:CF31  47 CF     
       00:CF33  40 CF     
       00:CF35  37 CF     
  332                     	; --
  333  00:CF37  A5 FF     .h4:	lda	<__dh
  334  00:CF39  4A        	lsr	A
  335  00:CF3A  4A        	lsr	A
  336  00:CF3B  4A        	lsr	A
  337  00:CF3C  4A        	lsr	A
  338  00:CF3D  20 81 CE  	jsr	_put_digit.sub
  339                     	; --
  340  00:CF40  A5 FF     .h3:	lda	<__dh
  341  00:CF42  29 0F     	and	#$0F
  342  00:CF44  20 81 CE  	jsr	_put_digit.sub
  343                     	; --
  344  00:CF47  A5 FE     .h2:	lda	<__dl
  345  00:CF49  4A        	lsr	A
  346  00:CF4A  4A        	lsr	A
  347  00:CF4B  4A        	lsr	A
  348  00:CF4C  4A        	lsr	A
  349  00:CF4D  20 81 CE  	jsr	_put_digit.sub
  350                     	; --
  351  00:CF50  A5 FE     .h1:	lda	<__dl
  352  00:CF52  29 0F     	and	#$0F
  353  00:CF54  4C 81 CE  	jmp	_put_digit.sub
  354                     
  355                     ; put_string(char *string, int offset)
  356                     ; put_string(char *string, char x, char y)
  357                     ; ----
  358                     
  359  00:CF57            _put_string.3:
  360  00:CF57  A5 FA     	lda	<__bl
  361  00:CF59  20 98 CE  	jsr	_put.xy
  362  00:CF5C  80 03     	bra	_put_string.main
  363  00:CF5E            _put_string.2:
  364  00:CF5E  20 9F CE  	jsr	_put.vram
  365  00:CF61            _put_string.main:
  366  00:CF61  80 1D     	bra	.l3
  367                     	; --
  368  00:CF63  C9 20     .l1:	cmp	#32
  369                     	bhs	.l2
       00:CF65  B0 03     	bcs	.l2
  370  00:CF67  A9 20     	lda	#32
  371  00:CF69  38        	sec
  372  00:CF6A  E9 20     .l2:	sbc	#32
  373                     	add	_font_base
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       00:CF6C  18        	clc
       00:CF6D  6D AF 27  	adc	_font_base
                          .endif
  374  00:CF70  8D 02 00  	sta	video_data_l
  375  00:CF73  62        	cla
  376  00:CF74  6D B0 27  	adc	_font_base+1
  377  00:CF77  8D 03 00  	sta	video_data_h
  378                     	incw	<__si
       00:CF7A  E6 EE     	inc	<__si		; value at stated memory
       00:CF7C  D0 02     	bne	.x_00220		; location
       00:CF7E  E6 EF     	inc	<__si+1
       00:CF80            .x_00220:
  379  00:CF80  B2 EE     .l3:	lda	[__si]
  380  00:CF82  D0 DF     	bne	.l1
  381  00:CF84  60        	rts
  382                     
  383                     ; vsync()
  384                     ; vsync(char nb_frame)
  385                     ; ----
  386                     
  387  00:CF85            _vsync:
  388  00:CF85  62        	cla
  389  00:CF86  4C 8F DD  	jmp	wait_vsync
  390                     
  391  00:CF89            _vsync.1:
  392  00:CF89  8A        	txa
  393  00:CF8A  4C 8F DD  	jmp	wait_vsync
  394                     
  395                     ; vreg(char reg)
  396                     ; vreg(char reg, int data)
  397                     ; ----
  398                     
  399  00:CF8D            _vreg.1:
  400  00:CF8D  86 F7     	stx	<vdc_reg
  401  00:CF8F  8E 00 00  	stx	video_reg
  402  00:CF92  60        	rts
  403                     
  404  00:CF93            _vreg.2:
  405  00:CF93  A4 F8     	ldy	<__al
  406  00:CF95  84 F7     	sty	<vdc_reg
  407  00:CF97  8C 00 00  	sty	video_reg
  408  00:CF9A  8E 02 00  	stx	video_data
  409  00:CF9D  8D 03 00  	sta	video_data+1
  410  00:CFA0  60        	rts
  411                     
  412                     ; vram_addr(char x [__al], char y)
  413                     ; ----
  414                     
  415  00:CFA1            _vram_addr.2:
  416  00:CFA1  A5 F8     	lda	<__al
  417  00:CFA3  22        	sax
  418  00:CFA4  20 AF C4  	jsr	calc_vram_addr
  419                     	__ldw	<__di
                0000      .if (1 = 2)
                          .else
       00:CFA7  A6 F0     	ldx	<__di
       00:CFA9  A5 F1     	lda	<__di+1
                          .endif
  420  00:CFAB  60        	rts
  421                     
  422                     ; scan_map_table(int *tbl [__si], int *x [__ax], int *y [__cx])
  423                     ; ----
  424                     ; tbl,
  425                     ; x,
  426                     ; y,
  427                     ; ----
  428                     
  429  00:CFAC            _scan_map_table.3:
  430                     
  431  00:CFAC  A0 01     	ldy	#1
  432  00:CFAE  B2 F8     	lda	[__ax]
  433  00:CFB0  85 FA     	sta	<__bl
  434  00:CFB2  B1 F8     	lda	[__ax],Y
  435  00:CFB4  85 FB     	sta	<__bh
  436  00:CFB6  B2 FC     	lda	[__cx]
  437  00:CFB8  85 FE     	sta	<__dl
  438  00:CFBA  B1 FC     	lda	[__cx],Y
  439  00:CFBC  85 FF     	sta	<__dh
  440                     	; --
  441                     	addw	#4,<__si
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       00:CFBE  18        	clc
       00:CFBF  A5 EE     	lda	LOW_BYTE <__si
       00:CFC1  69 04     	adc	LOW_BYTE #4
       00:CFC3  85 EE     	sta	LOW_BYTE <__si
       00:CFC5  A5 EF     	lda	HIGH_BYTE <__si
       00:CFC7  69 00     	adc	HIGH_BYTE #4
       00:CFC9  85 EF     	sta	HIGH_BYTE <__si
                          .endif
  442                     
  443                     	; ----
  444                     	; check bounds
  445                     	;
  446                     	; -- bottom
  447  00:CFCB  A0 07     .l1:	ldy	#7
  448  00:CFCD  B1 EE     	lda	[__si],Y
  449  00:CFCF  C5 FF     	cmp	<__dh
  450                     	blo	.x1
       00:CFD1  90 3B     	bcc	.x1
  451  00:CFD3  D0 07     	bne	.l2
  452  00:CFD5  88        	dey
  453  00:CFD6  B1 EE     	lda	[__si],Y
  454  00:CFD8  C5 FE     	cmp	<__dl
  455                     	blo	.x1
       00:CFDA  90 32     	bcc	.x1
  456                     	; -- top
  457  00:CFDC  A0 03     .l2:	ldy	#3
  458  00:CFDE  A5 FF     	lda	<__dh
  459  00:CFE0  D1 EE     	cmp	[__si],Y
  460                     	blo	.x1
       00:CFE2  90 2A     	bcc	.x1
  461  00:CFE4  D0 07     	bne	.l3
  462  00:CFE6  88        	dey
  463  00:CFE7  A5 FE     	lda	<__dl
  464  00:CFE9  D1 EE     	cmp	[__si],Y
  465                     	blo	.x1
       00:CFEB  90 21     	bcc	.x1
  466                     	; -- right
  467  00:CFED  A0 05     .l3:	ldy	#5
  468  00:CFEF  B1 EE     	lda	[__si],Y
  469  00:CFF1  C5 FB     	cmp	<__bh
  470                     	blo	.x1
       00:CFF3  90 19     	bcc	.x1
  471  00:CFF5  D0 07     	bne	.l4
  472  00:CFF7  88        	dey
  473  00:CFF8  B1 EE     	lda	[__si],Y
  474  00:CFFA  C5 FA     	cmp	<__bl
  475                     	blo	.x1
       00:CFFC  90 10     	bcc	.x1
  476                     	; -- left
  477  00:CFFE  A0 01     .l4:	ldy	#1
  478  00:D000  A5 FB     	lda	<__bh
  479  00:D002  D1 EE     	cmp	[__si],Y
  480                     	blo	.x1
       00:D004  90 08     	bcc	.x1
  481  00:D006  D0 20     	bne	.x2
  482  00:D008  A5 FA     	lda	<__bl
  483  00:D00A  D2 EE     	cmp	[__si]
  484                     	bhs	.x2
       00:D00C  B0 1A     	bcs	.x2
  485                     
  486                     	; ----
  487                     	; next
  488                     	;
  489                     .x1:	addw	#12,<__si
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       00:D00E  18        	clc
       00:D00F  A5 EE     	lda	LOW_BYTE <__si
       00:D011  69 0C     	adc	LOW_BYTE #12
       00:D013  85 EE     	sta	LOW_BYTE <__si
       00:D015  A5 EF     	lda	HIGH_BYTE <__si
       00:D017  69 00     	adc	HIGH_BYTE #12
       00:D019  85 EF     	sta	HIGH_BYTE <__si
                          .endif
  490  00:D01B  A0 01     	ldy	#1
  491  00:D01D  B2 EE     	lda	[__si]
  492  00:D01F  31 EE     	and	[__si],Y
  493  00:D021  C9 FF     	cmp	#$FF
  494  00:D023  D0 A6     	bne	.l1
  495                     
  496                     	; ----
  497                     	; didn't find map...
  498                     	;
  499  00:D025  82        	clx
  500  00:D026  62        	cla
  501  00:D027  60        	rts
  502                     
  503                     	; ----
  504                     	; found map!
  505                     	;
  506  00:D028  A0 01     .x2:	ldy	#1
  507  00:D02A  A5 FA     	lda	<__bl
  508                     	sub	[__si]
                0000      .if (1 = 2)			; from register A (handle
                          .else
       00:D02C  38        	sec
       00:D02D  F2 EE     	sbc	[__si]
                          .endif
  509  00:D02F  92 F8     	sta	[__ax]
  510  00:D031  A5 FB     	lda	<__bh
  511  00:D033  F1 EE     	sbc	[__si],Y
  512  00:D035  91 F8     	sta	[__ax],Y
  513                     	; --
  514  00:D037  C8        	iny
  515  00:D038  A5 FE     	lda	<__dl
  516                     	sub	[__si],Y
                0000      .if (1 = 2)			; from register A (handle
                          .else
       00:D03A  38        	sec
       00:D03B  F1 EE     	sbc	[__si],Y
                          .endif
  517  00:D03D  92 FC     	sta	[__cx]
  518  00:D03F  C8        	iny
  519  00:D040  A5 FF     	lda	<__dh
  520  00:D042  F1 EE     	sbc	[__si],Y
  521  00:D044  A0 01     	ldy	#1
  522  00:D046  91 FC     	sta	[__cx],Y
  523                     	; --
  524                     	__ldw	<__si
                0000      .if (1 = 2)
                          .else
       00:D048  A6 EE     	ldx	<__si
       00:D04A  A5 EF     	lda	<__si+1
                          .endif
  525  00:D04C  60        	rts
  526                     
  527                     ; set_map_data(int *ptr)
  528                     ; set_map_data(char *map [__bl:__si], int w [__ax], int h)
  529                     ; set_map_data(char *map [__bl:__si], int w [__ax], int h [__dx], char wrap)
  530                     ; ----
  531                     ; map,	map base address
  532                     ; w,	map width
  533                     ; h,	map height
  534                     ; wrap, wrap flag (1 = wrap, 0 = do not wrap)
  535                     ; ----
  536                     
  537  00:D04D            _set_map_data.1:
  538                     	__stw	<__si
       00:D04D  86 EE     	stx	<__si
       00:D04F  85 EF     	sta	<__si+1
  539  00:D051  05 EE     	ora	<__si
  540  00:D053  F0 54     	beq	.l1
  541                     	; -- calculate width
  542  00:D055  A0 04 B1  	lda	[__si].4
       00:D058  EE        
  543                     	sub	[__si]
                0000      .if (1 = 2)			; from register A (handle
                          .else
       00:D059  38        	sec
       00:D05A  F2 EE     	sbc	[__si]
                          .endif
  544  00:D05C  8D 1C 27  	sta	mapwidth
  545  00:D05F  A0 05 B1  	lda	[__si].5
       00:D062  EE        
  546  00:D063  A0 01 F1  	sbc	[__si].1
       00:D066  EE        
  547  00:D067  8D 1D 27  	sta	mapwidth+1
  548                     	incw	mapwidth
       00:D06A  EE 1C 27  	inc	mapwidth		; value at stated memory
       00:D06D  D0 03     	bne	.x_00237		; location
       00:D06F  EE 1D 27  	inc	mapwidth+1
       00:D072            .x_00237:
  549                     	; -- calculate height
  550  00:D072  A0 06 B1  	lda	[__si].6
       00:D075  EE        
  551                     	sub	[__si].2
                0000      .if (1 = 2)			; from register A (handle
                          .else
       00:D076  38        	sec
       00:D077  A0 02 F1  	sbc	[__si].2
       00:D07A  EE        
                          .endif
  552  00:D07B  8D 1E 27  	sta	mapheight
  553  00:D07E  A0 07 B1  	lda	[__si].7
       00:D081  EE        
  554  00:D082  A0 03 F1  	sbc	[__si].3
       00:D085  EE        
  555  00:D086  8D 1F 27  	sta	mapheight+1
  556                     	incw	mapheight
       00:D089  EE 1E 27  	inc	mapheight		; value at stated memory
       00:D08C  D0 03     	bne	.x_00239		; location
       00:D08E  EE 1F 27  	inc	mapheight+1
       00:D091            .x_00239:
  557                     	; -- get map bank
  558  00:D091  A0 08 B1  	lda	[__si].8
       00:D094  EE        
  559  00:D095  8D 19 27  	sta	mapbank
  560                     	; -- get map addr
  561  00:D098  A0 0A B1  	lda	[__si].10
       00:D09B  EE        
  562  00:D09C  8D 1A 27  	sta	mapaddr
  563  00:D09F  C8        	iny
  564  00:D0A0  B2 EE     	lda	[__si]
  565  00:D0A2  8D 1B 27  	sta	mapaddr+1
  566                     	; -- no wrap
  567  00:D0A5  9C 2B 27  	stz	mapwrap
  568  00:D0A8  60        	rts
  569                     	; -- null pointer
  570                     .l1:	stwz	mapwidth
       00:D0A9  9C 1C 27  	stz	LOW_BYTE mapwidth
       00:D0AC  9C 1D 27  	stz	HIGH_BYTE mapwidth
  571                     	stwz	mapheight
       00:D0AF  9C 1E 27  	stz	LOW_BYTE mapheight
       00:D0B2  9C 1F 27  	stz	HIGH_BYTE mapheight
  572  00:D0B5  9C 19 27  	stz	mapbank
  573                     	stwz	mapaddr
       00:D0B8  9C 1A 27  	stz	LOW_BYTE mapaddr
       00:D0BB  9C 1B 27  	stz	HIGH_BYTE mapaddr
  574  00:D0BE  9C 2B 27  	stz	mapwrap
  575  00:D0C1  60        	rts
  576  00:D0C2            _set_map_data.4:
  577  00:D0C2  8E 2B 27  	stx	mapwrap
  578                     	__ldw	<__dx
                0000      .if (1 = 2)
                          .else
       00:D0C5  A6 FE     	ldx	<__dx
       00:D0C7  A5 FF     	lda	<__dx+1
                          .endif
  579  00:D0C9  80 06     	bra	_set_map_data.main
  580  00:D0CB            _set_map_data.3:
  581  00:D0CB  9C 2B 27  	stz	mapwrap
  582  00:D0CE  EE 2B 27  	inc	mapwrap
  583  00:D0D1            _set_map_data.main:
  584                     	__stw	mapheight
       00:D0D1  8E 1E 27  	stx	mapheight
       00:D0D4  8D 1F 27  	sta	mapheight+1
  585                     	stw	<__ax,mapwidth
       00:D0D7  A5 F8     	lda	LOW_BYTE <__ax
       00:D0D9  8D 1C 27  	sta	LOW_BYTE mapwidth
       00:D0DC  A5 F9     	lda	HIGH_BYTE <__ax
       00:D0DE  8D 1D 27  	sta	HIGH_BYTE mapwidth
  586                     	stb	<__bl,mapbank
       00:D0E1  A5 FA     	lda	<__bl
       00:D0E3  8D 19 27  	sta	mapbank
  587                     	stw	<__si,mapaddr
       00:D0E6  A5 EE     	lda	LOW_BYTE <__si
       00:D0E8  8D 1A 27  	sta	LOW_BYTE mapaddr
       00:D0EB  A5 EF     	lda	HIGH_BYTE <__si
       00:D0ED  8D 1B 27  	sta	HIGH_BYTE mapaddr
  588  00:D0F0  60        	rts
  589                     
  590                     ; get_map_width()
  591                     ; ----
  592                     
  593  00:D0F1            _get_map_width:
  594                     	__ldw	mapwidth
                0000      .if (1 = 2)
                          .else
       00:D0F1  AE 1C 27  	ldx	mapwidth
       00:D0F4  AD 1D 27  	lda	mapwidth+1
                          .endif
  595  00:D0F7  60        	rts
  596                     
  597                     ; get_map_height()
  598                     ; ----
  599                     
  600  00:D0F8            _get_map_height:
  601                     	__ldw	mapheight
                0000      .if (1 = 2)
                          .else
       00:D0F8  AE 1E 27  	ldx	mapheight
       00:D0FB  AD 1F 27  	lda	mapheight+1
                          .endif
  602  00:D0FE  60        	rts
  603                     
  604                     ; set_tile_data(char *tile_ex [__di])
  605                     ; set_tile_data(char *tile [__bl:__si], int nb_tile [__cx], char *ptable [__al:__dx], char type [__ah])
  606                     ; ----
  607                     ; tile,	tile base index
  608                     ; nb_tile, number of tile
  609                     ; ptable,	tile palette table address
  610                     ; type, tile type (8 or 16)
  611                     ; ----
  612                     
  613  00:D0FF            _set_tile_data.1:
  614  00:D0FF  C2        	cly
  615  00:D100  B1 F0 C8  	lda	[__di],Y++
  616  00:D103  8D 26 27  	sta	mapnbtile
  617  00:D106  B1 F0 C8  	lda	[__di],Y++
  618  00:D109  8D 27 27  	sta	mapnbtile+1
  619  00:D10C  B1 F0 C8  	lda	[__di],Y++
  620  00:D10F  8D 20 27  	sta	maptiletype
  621  00:D112  C8        	iny
  622  00:D113  B1 F0 C8  	lda	[__di],Y++
  623  00:D116  8D 21 27  	sta	maptilebank
  624  00:D119  C8        	iny
  625  00:D11A  B1 F0 C8  	lda	[__di],Y++
  626  00:D11D  8D 22 27  	sta	maptileaddr
  627  00:D120  B1 F0 C8  	lda	[__di],Y++
  628  00:D123  8D 23 27  	sta	maptileaddr+1
  629  00:D126  A9 82     	lda	#(CONST_BANK+_bank_base)
  630  00:D128  8D 28 27  	sta	mapctablebank
  631  00:D12B  B1 F0 C8  	lda	[__di],Y++
  632  00:D12E  8D 29 27  	sta	mapctable
  633  00:D131  B1 F0     	lda	[__di],Y
  634  00:D133  8D 2A 27  	sta	mapctable+1
  635  00:D136  60        	rts
  636  00:D137            _set_tile_data.4:
  637                     	stb	<__bl,maptilebank
       00:D137  A5 FA     	lda	<__bl
       00:D139  8D 21 27  	sta	maptilebank
  638                     	stw	<__si,maptileaddr
       00:D13C  A5 EE     	lda	LOW_BYTE <__si
       00:D13E  8D 22 27  	sta	LOW_BYTE maptileaddr
       00:D141  A5 EF     	lda	HIGH_BYTE <__si
       00:D143  8D 23 27  	sta	HIGH_BYTE maptileaddr
  639                     	stw	<__cx,mapnbtile
       00:D146  A5 FC     	lda	LOW_BYTE <__cx
       00:D148  8D 26 27  	sta	LOW_BYTE mapnbtile
       00:D14B  A5 FD     	lda	HIGH_BYTE <__cx
       00:D14D  8D 27 27  	sta	HIGH_BYTE mapnbtile
  640                     	stb	<__al,mapctablebank
       00:D150  A5 F8     	lda	<__al
       00:D152  8D 28 27  	sta	mapctablebank
  641                     	stw	<__dx,mapctable
       00:D155  A5 FE     	lda	LOW_BYTE <__dx
       00:D157  8D 29 27  	sta	LOW_BYTE mapctable
       00:D15A  A5 FF     	lda	HIGH_BYTE <__dx
       00:D15C  8D 2A 27  	sta	HIGH_BYTE mapctable
  642                     	stb	<__ah,maptiletype
       00:D15F  A5 F9     	lda	<__ah
       00:D161  8D 20 27  	sta	maptiletype
  643  00:D164  60        	rts
  644                     
  645                     ; load_tile(int addr)
  646                     ; ----
  647                     
  648  00:D165            _load_tile:
  649                     	__stw	<__di
       00:D165  86 F0     	stx	<__di
       00:D167  85 F1     	sta	<__di+1
  650  00:D169  86 F8     	stx	<__al
  651  00:D16B  4A        	lsr	A
  652  00:D16C  66 F8     	ror	<__al
  653  00:D16E  4A        	lsr	A
  654  00:D16F  66 F8     	ror	<__al
  655  00:D171  4A        	lsr	A
  656  00:D172  66 F8     	ror	<__al
  657  00:D174  4A        	lsr	A
  658  00:D175  66 F8     	ror	<__al
  659  00:D177  8D 25 27  	sta		maptilebase+1
  660                     	stb	<__al,maptilebase
       00:D17A  A5 F8     	lda	<__al
       00:D17C  8D 24 27  	sta	maptilebase
  661                     	; --
  662                     	stw	mapnbtile,<__cx
       00:D17F  AD 26 27  	lda	LOW_BYTE mapnbtile
       00:D182  85 FC     	sta	LOW_BYTE <__cx
       00:D184  AD 27 27  	lda	HIGH_BYTE mapnbtile
       00:D187  85 FD     	sta	HIGH_BYTE <__cx
  663  00:D189  A2 04     	ldx	#4
  664  00:D18B  AD 20 27  	lda	maptiletype
  665  00:D18E  C9 08     	cmp	#8
  666  00:D190  F0 02     	beq	.l1
  667  00:D192  A2 06     	ldx	#6
  668  00:D194  06 FC     .l1:	asl	<__cl
  669  00:D196  26 FD     	rol	<__ch
  670  00:D198  CA        	dex
  671  00:D199  D0 F9     	bne	.l1
  672                     	; --
  673                     	stb	maptilebank,<__bl
       00:D19B  AD 21 27  	lda	maptilebank
       00:D19E  85 FA     	sta	<__bl
  674                     	stw	maptileaddr,<__si
       00:D1A0  AD 22 27  	lda	LOW_BYTE maptileaddr
       00:D1A3  85 EE     	sta	LOW_BYTE <__si
       00:D1A5  AD 23 27  	lda	HIGH_BYTE maptileaddr
       00:D1A8  85 EF     	sta	HIGH_BYTE <__si
  675  00:D1AA  4C 1D C4  	jmp	load_vram
  676                     
  677                     ; load_map(char x [__al], char y [__ah], int mx, int my, char w [__dl], char h [__dh])
  678                     ; ----
  679                     
  680  00:D1AD            _load_map.6:
  681                     
  682                     	tstw	mapwidth
       00:D1AD  AD 1C 27  	lda	mapwidth		; value at stated memory
       00:D1B0  0D 1D 27  	ora	mapwidth+1		; location is zero
  683  00:D1B3  F0 7C     	beq	.l6
  684                     	tstw	mapheight
       00:D1B5  AD 1E 27  	lda	mapheight		; value at stated memory
       00:D1B8  0D 1F 27  	ora	mapheight+1		; location is zero
  685  00:D1BB  F0 74     	beq	.l6
  686                     
  687                     	; ----
  688                     	; adjust map y coordinate
  689                     	;
  690  00:D1BD  A5 FB     	lda	<__bh
  691  00:D1BF  30 1F     	bmi	.l2
  692                     .l1:	cmpw	mapheight,<__bx
       00:D1C1  A5 FB     	lda	HIGH_BYTE <__bx
       00:D1C3  CD 1F 27  	cmp	HIGH_BYTE mapheight
       00:D1C6  D0 05     	bne	.x_00263
       00:D1C8  A5 FA     	lda	LOW_BYTE <__bx
       00:D1CA  CD 1E 27  	cmp	LOW_BYTE mapheight
       00:D1CD            .x_00263:
  693                     	blo	.l3
       00:D1CD  90 26     	bcc	.l3
  694                     	subw	mapheight,<__bx
       00:D1CF  38        	sec
       00:D1D0  A5 FA     	lda	LOW_BYTE <__bx
       00:D1D2  ED 1E 27  	sbc	LOW_BYTE mapheight
       00:D1D5  85 FA     	sta	LOW_BYTE <__bx
       00:D1D7  A5 FB     	lda	HIGH_BYTE <__bx
       00:D1D9  ED 1F 27  	sbc	HIGH_BYTE mapheight
       00:D1DC  85 FB     	sta	HIGH_BYTE <__bx
  695  00:D1DE  80 E1     	bra	.l1
  696                     	; --
  697  00:D1E0  A5 FB     .l2:	lda	<__bh
  698  00:D1E2  10 11     	bpl	.l3
  699                     	addw	mapheight,<__bx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       00:D1E4  18        	clc
       00:D1E5  A5 FA     	lda	LOW_BYTE <__bx
       00:D1E7  6D 1E 27  	adc	LOW_BYTE mapheight
       00:D1EA  85 FA     	sta	LOW_BYTE <__bx
       00:D1EC  A5 FB     	lda	HIGH_BYTE <__bx
       00:D1EE  6D 1F 27  	adc	HIGH_BYTE mapheight
       00:D1F1  85 FB     	sta	HIGH_BYTE <__bx
                          .endif
  700  00:D1F3  80 EB     	bra	.l2
  701                     
  702                     	; ----
  703                     	; adjust map x coordinate
  704                     	;
  705                     .l3:	stb	<__bl,<__ch
       00:D1F5  A5 FA     	lda	<__bl
       00:D1F7  85 FD     	sta	<__ch
  706  00:D1F9  A5 F1     	lda	<__di+1
  707  00:D1FB  30 1F     	bmi	.l5
  708                     .l4:	cmpw	mapwidth,<__di
       00:D1FD  A5 F1     	lda	HIGH_BYTE <__di
       00:D1FF  CD 1D 27  	cmp	HIGH_BYTE mapwidth
       00:D202  D0 05     	bne	.x_00268
       00:D204  A5 F0     	lda	LOW_BYTE <__di
       00:D206  CD 1C 27  	cmp	LOW_BYTE mapwidth
       00:D209            .x_00268:
  709                     	blo	.l7
       00:D209  90 27     	bcc	.l7
  710                     	subw	mapwidth,<__di
       00:D20B  38        	sec
       00:D20C  A5 F0     	lda	LOW_BYTE <__di
       00:D20E  ED 1C 27  	sbc	LOW_BYTE mapwidth
       00:D211  85 F0     	sta	LOW_BYTE <__di
       00:D213  A5 F1     	lda	HIGH_BYTE <__di
       00:D215  ED 1D 27  	sbc	HIGH_BYTE mapwidth
       00:D218  85 F1     	sta	HIGH_BYTE <__di
  711  00:D21A  80 E1     	bra	.l4
  712                     	; --
  713  00:D21C  A5 F1     .l5:	lda	<__di+1
  714  00:D21E  10 12     	bpl	.l7
  715                     	addw	mapwidth,<__di
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       00:D220  18        	clc
       00:D221  A5 F0     	lda	LOW_BYTE <__di
       00:D223  6D 1C 27  	adc	LOW_BYTE mapwidth
       00:D226  85 F0     	sta	LOW_BYTE <__di
       00:D228  A5 F1     	lda	HIGH_BYTE <__di
       00:D22A  6D 1D 27  	adc	HIGH_BYTE mapwidth
       00:D22D  85 F1     	sta	HIGH_BYTE <__di
                          .endif
  716  00:D22F  80 EB     	bra	.l5
  717                     
  718                     	; ----
  719                     	; exit
  720                     	;
  721  00:D231  60        .l6:	rts
  722                     
  723                     	; ----
  724                     	; ok
  725                     	;
  726                     .l7:	stb	<__di,<__cl
       00:D232  A5 F0     	lda	<__di
       00:D234  85 FC     	sta	<__cl
  727  00:D236  4C E0 C3  	jmp	load_map
  728                     
  729                     ; spr_set(char num)
  730                     ; ----
  731                     ; load SI with the offset of the sprite to change
  732                     ; SI = satb + 8 * sprite_number
  733                     ; ----
  734                     
  735  00:D239            _spr_set:
  736  00:D239  E0 40     	cpx	#64
  737                     	bhs	.l2
       00:D23B  B0 19     	bcs	.l2
  738  00:D23D  8A        	txa
  739  00:D23E  E8        	inx
  740  00:D23F  E4 14     	cpx	<spr_max
  741                     	blo	.l1
       00:D241  90 02     	bcc	.l1
  742  00:D243  86 14     	stx	<spr_max
  743                     	; --
  744  00:D245  64 13     .l1:	stz	<spr_ptr+1
  745  00:D247  0A        	asl	A
  746  00:D248  0A        	asl	A
  747  00:D249  0A        	asl	A
  748  00:D24A  26 13     	rol	<spr_ptr+1
  749  00:D24C  69 B3     	adc	#low(satb)
  750  00:D24E  85 12     	sta	<spr_ptr
  751  00:D250  A5 13     	lda	<spr_ptr+1
  752  00:D252  69 27     	adc	#high(satb)
  753  00:D254  85 13     	sta	<spr_ptr+1
  754  00:D256  60        .l2:	rts
  755                     
  756                     ; spr_hide(char num)
  757                     ; ----
  758                     
  759                     	; -- hide current sprite
  760  00:D257            _spr_hide:
  761  00:D257  A0 01     	ldy	#1
  762  00:D259  B1 12     	lda	[spr_ptr],Y
  763  00:D25B  09 02     	ora	#$02
  764  00:D25D  91 12     	sta	[spr_ptr],Y
  765  00:D25F  60        	rts
  766                     
  767  00:D260            _spr_hide.1:
  768                     	; -- hide sprite number #
  769  00:D260  E0 40     	cpx	#64
  770                     	bhs	.l1
       00:D262  B0 09     	bcs	.l1
  771  00:D264  20 6E D2  	jsr	_spr_hide.sub
  772  00:D267  B1 06     	lda	[__ptr],Y
  773  00:D269  09 02     	ora	#$02
  774  00:D26B  91 06     	sta	[__ptr],Y
  775  00:D26D  60        .l1:	rts
  776                     
  777                     	; -- calc satb ptr
  778  00:D26E            _spr_hide.sub:
  779  00:D26E  8A        	txa
  780  00:D26F  64 07     	stz	<__ptr+1
  781  00:D271  0A        	asl	A
  782  00:D272  0A        	asl	A
  783  00:D273  0A        	asl	A
  784  00:D274  26 07     	rol	<__ptr+1
  785  00:D276  69 B3     	adc	#low(satb)
  786  00:D278  85 06     	sta	<__ptr
  787  00:D27A  A5 07     	lda	<__ptr+1
  788  00:D27C  69 27     	adc	#high(satb)
  789  00:D27E  85 07     	sta	<__ptr+1
  790  00:D280  A0 01     	ldy	#1
  791  00:D282  60        	rts
  792                     
  793                     ; spr_show(char num)
  794                     ; ----
  795                     
  796                     	; -- hide current sprite
  797  00:D283            _spr_show:
  798  00:D283  A0 01     	ldy	#1
  799  00:D285  B1 12     	lda	[spr_ptr],Y
  800  00:D287  29 01     	and	#$01
  801  00:D289  91 12     	sta	[spr_ptr],Y
  802  00:D28B  60        	rts
  803                     
  804  00:D28C            _spr_show.1:
  805                     	; -- hide sprite number #
  806  00:D28C  E0 40     	cpx	#64
  807                     	bhs	.l1
       00:D28E  B0 09     	bcs	.l1
  808  00:D290  20 6E D2  	jsr	_spr_hide.sub
  809  00:D293  B1 06     	lda	[__ptr],Y
  810  00:D295  29 01     	and	#$01
  811  00:D297  91 06     	sta	[__ptr],Y
  812  00:D299  60        .l1:	rts
  813                     
  814                     ; spr_x(int value)
  815                     ; ----
  816                     
  817  00:D29A            _spr_x:
  818  00:D29A  A0 02     	ldy	#2
  819  00:D29C  22        	sax
  820                     	add	#32
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       00:D29D  18        	clc
       00:D29E  69 20     	adc	#32
                          .endif
  821  00:D2A0  91 12     	sta	[spr_ptr],Y
  822  00:D2A2  22        	sax
  823  00:D2A3  69 00     	adc	#0
  824  00:D2A5  C8        	iny
  825  00:D2A6  91 12     	sta	[spr_ptr],Y
  826  00:D2A8  60        	rts
  827                     
  828  00:D2A9            _spr_get_x:
  829  00:D2A9  A0 02     	ldy	#2
  830  00:D2AB  B1 12     	lda	[spr_ptr],Y
  831                     	sub	#32
                0000      .if (1 = 2)			; from register A (handle
                          .else
       00:D2AD  38        	sec
       00:D2AE  E9 20     	sbc	#32
                          .endif
  832  00:D2B0  AA        	tax
  833  00:D2B1  C8        	iny
  834  00:D2B2  B1 12     	lda	[spr_ptr],Y
  835  00:D2B4  E9 00     	sbc	#0
  836  00:D2B6  60        	rts
  837                     
  838                     ; spr_y(int value)
  839                     ; ----
  840                     
  841  00:D2B7            _spr_y:
  842  00:D2B7  22        	sax
  843                     	add	#64
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       00:D2B8  18        	clc
       00:D2B9  69 40     	adc	#64
                          .endif
  844  00:D2BB  92 12     	sta	[spr_ptr]
  845  00:D2BD  22        	sax
  846  00:D2BE  69 00     	adc	#0
  847  00:D2C0  29 01     	and	#$01
  848  00:D2C2  A0 01     	ldy	#1
  849  00:D2C4  91 12     	sta	[spr_ptr],Y
  850  00:D2C6  60        	rts
  851                     
  852  00:D2C7            _spr_get_y:
  853  00:D2C7  B2 12     	lda	[spr_ptr]
  854                     	sub	#64
                0000      .if (1 = 2)			; from register A (handle
                          .else
       00:D2C9  38        	sec
       00:D2CA  E9 40     	sbc	#64
                          .endif
  855  00:D2CC  AA        	tax
  856  00:D2CD  A0 01     	ldy	#1
  857  00:D2CF  B1 12     	lda	[spr_ptr],Y
  858  00:D2D1  E9 00     	sbc	#0
  859  00:D2D3  60        	rts
  860                     
  861                     ; spr_pattern(int vaddr)
  862                     ; ----
  863                     
  864  00:D2D4            _spr_pattern:
  865  00:D2D4  85 02     	sta	<__temp
  866  00:D2D6  8A        	txa
  867  00:D2D7  0A        	asl	A
  868  00:D2D8  26 02     	rol	<__temp
  869  00:D2DA  2A        	rol	A
  870  00:D2DB  26 02     	rol	<__temp
  871  00:D2DD  2A        	rol	A
  872  00:D2DE  26 02     	rol	<__temp
  873  00:D2E0  2A        	rol	A
  874  00:D2E1  29 07     	and	#$7
  875  00:D2E3  A0 05     	ldy	#5
  876  00:D2E5  91 12     	sta	[spr_ptr],Y
  877  00:D2E7  A5 02     	lda	<__temp
  878  00:D2E9  88        	dey
  879  00:D2EA  91 12     	sta	[spr_ptr],Y
  880  00:D2EC  60        	rts
  881                     
  882  00:D2ED            _spr_get_pattern:
  883  00:D2ED  A0 04     	ldy	#4
  884  00:D2EF  B1 12     	lda	[spr_ptr],Y
  885  00:D2F1  85 02     	sta	<__temp
  886  00:D2F3  C8        	iny
  887  00:D2F4  B1 12     	lda	[spr_ptr],Y
  888  00:D2F6  4A        	lsr	A
  889  00:D2F7  66 02     	ror	<__temp
  890  00:D2F9  6A        	ror	A
  891  00:D2FA  66 02     	ror	<__temp
  892  00:D2FC  6A        	ror	A
  893  00:D2FD  66 02     	ror	<__temp
  894  00:D2FF  6A        	ror	A
  895  00:D300  29 E0     	and	#$E0
  896  00:D302  AA        	tax
  897  00:D303  A5 02     	lda	<__temp
  898  00:D305  60        	rts
  899                     
  900                     ; spr_ctrl(char mask [__al], char value)
  901                     ; ----
  902                     
  903  00:D306            _spr_ctrl.2:
  904  00:D306  8A        	txa
  905  00:D307  25 F8     	and	<__al
  906  00:D309  85 02     	sta	<__temp
  907  00:D30B  A5 F8     	lda	<__al
  908  00:D30D  49 FF     	eor	#$FF
  909  00:D30F  A0 07     	ldy	#7
  910  00:D311  31 12     	and	[spr_ptr],Y
  911  00:D313  05 02     	ora	<__temp
  912  00:D315  91 12     	sta	[spr_ptr],Y
  913  00:D317  60        	rts
  914                     
  915                     ; spr_pal(char pal)
  916                     ; ----
  917                     
  918  00:D318            _spr_pal:
  919  00:D318  8A        	txa
  920  00:D319  29 0F     	and	#$0F
  921  00:D31B  85 02     	sta	<__temp
  922  00:D31D  A0 06     	ldy	#6
  923  00:D31F  B1 12     	lda	[spr_ptr],Y
  924  00:D321  29 F0     	and	#$F0
  925  00:D323  05 02     	ora	<__temp
  926  00:D325  91 12     	sta	[spr_ptr],Y
  927  00:D327  60        	rts
  928                     
  929  00:D328            _spr_get_pal:
  930  00:D328  A0 06     	ldy	#6
  931  00:D32A  B1 12     	lda	[spr_ptr],Y
  932  00:D32C  29 0F     	and	#$0F
  933  00:D32E  AA        	tax
  934  00:D32F  62        	cla
  935  00:D330  60        	rts
  936                     
  937                     ; spr_pri(char pri)
  938                     ; ----
  939                     
  940  00:D331            _spr_pri:
  941  00:D331  A0 06     	ldy	#6
  942  00:D333  B1 12     	lda	[spr_ptr],Y
  943  00:D335  29 7F     	and	#$7F
  944  00:D337  E0 00     	cpx	#$00
  945  00:D339  F0 02     	beq	.l1
  946  00:D33B  09 80     	ora	#$80
  947  00:D33D            .l1:
  948  00:D33D  91 12     	sta	[spr_ptr],Y
  949  00:D33F  60        	rts
  950                     
  951                     ; satb_update()
  952                     ; satb_update(char max)
  953                     ; ----
  954                     
  955  00:D340            _satb_update:
  956  00:D340  A6 14     	ldx	<spr_max
  957  00:D342  80 08     	bra	satb_update
  958                     
  959  00:D344            _satb_update.1:
  960  00:D344  A5 15     	lda	<spr_flag
  961  00:D346  F0 04     	beq	satb_update
  962  00:D348  64 15     	stz	<spr_flag
  963  00:D34A  A2 40     	ldx	#64
  964                     
  965  00:D34C            satb_update:
  966  00:D34C  E0 00     	cpx	#0
  967  00:D34E  F0 50     	beq	.l4
  968                     	; --
  969  00:D350  86 F8     	stx	<__al	; number of sprites
  970  00:D352  8A        	txa
  971  00:D353  3A        	dec	A	; round up to the next group of 4 sprites
  972  00:D354  4A        	lsr	A
  973  00:D355  4A        	lsr	A
  974  00:D356  1A        	inc	A
  975  00:D357  85 FC     	sta	<__cl
  976                     
  977                     ; Use TIA, but BLiT 16 words at a time (32 bytes)
  978                     ; Because interrupt must not deferred too much
  979                     ;
  980                     	stw	#32, ram_hdwr_tia_size
       00:D359  A9 20     	lda	LOW_BYTE #32
       00:D35B  8D 39 27  	sta	LOW_BYTE ram_hdwr_tia_size
       00:D35E  A9 00     	lda	HIGH_BYTE #32
       00:D360  8D 3A 27  	sta	HIGH_BYTE ram_hdwr_tia_size
  981                     	stw	#video_data, ram_hdwr_tia_dest
       00:D363  A9 02     	lda	LOW_BYTE #video_data
       00:D365  8D 37 27  	sta	LOW_BYTE ram_hdwr_tia_dest
       00:D368  A9 00     	lda	HIGH_BYTE #video_data
       00:D36A  8D 38 27  	sta	HIGH_BYTE ram_hdwr_tia_dest
  982                     	stw	#satb, <__si
       00:D36D  A9 B3     	lda	LOW_BYTE #satb
       00:D36F  85 EE     	sta	LOW_BYTE <__si
       00:D371  A9 27     	lda	HIGH_BYTE #satb
       00:D373  85 EF     	sta	HIGH_BYTE <__si
  983                     
  984                     	stw	#$7F00, <__di
       00:D375  A9 00     	lda	LOW_BYTE #$7F00
       00:D377  85 F0     	sta	LOW_BYTE <__di
       00:D379  A9 7F     	lda	HIGH_BYTE #$7F00
       00:D37B  85 F1     	sta	HIGH_BYTE <__di
  985  00:D37D  20 98 C4  	jsr	set_write
  986                     
  987                     .l3a:	stw	<__si, ram_hdwr_tia_src
       00:D380  A5 EE     	lda	LOW_BYTE <__si
       00:D382  8D 35 27  	sta	LOW_BYTE ram_hdwr_tia_src
       00:D385  A5 EF     	lda	HIGH_BYTE <__si
       00:D387  8D 36 27  	sta	HIGH_BYTE ram_hdwr_tia_src
  988  00:D38A  20 34 27  	jsr	ram_hdwr_tia
  989                     	addw	#32,<__si
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       00:D38D  18        	clc
       00:D38E  A5 EE     	lda	LOW_BYTE <__si
       00:D390  69 20     	adc	LOW_BYTE #32
       00:D392  85 EE     	sta	LOW_BYTE <__si
       00:D394  A5 EF     	lda	HIGH_BYTE <__si
       00:D396  69 00     	adc	HIGH_BYTE #32
       00:D398  85 EF     	sta	HIGH_BYTE <__si
                          .endif
  990  00:D39A  C6 FC     	dec	<__cl
  991  00:D39C  D0 E2     	bne	.l3a
  992                     
  993                     ;.l3:	stx	<__al
  994                     ;	stw	#satb,<__si
  995                     ;	stb	#BANK(satb),<__bl
  996                     ;	stw	#$7F00,<__di
  997                     ;	txa
  998                     ;	stz	<__ch
  999                     ;	asl	A
 1000                     ;	asl	A
 1001                     ;	rol	<__ch
 1002                     ;	sta	<__cl
 1003                     ;	jsr	load_vram
 1004                     
 1005                     	; --
 1006  00:D39E  A6 F8     	ldx	<__al
 1007  00:D3A0  62        .l4:	cla
 1008  00:D3A1  60        	rts
 1009                     
 1010                     ; init_satb()
 1011                     ; reset_satb()
 1012                     ; ----
 1013                     
 1014  00:D3A2            _reset_satb:
 1015  00:D3A2            _init_satb:
 1016  00:D3A2  82        	clx
 1017  00:D3A3  62        	cla
 1018  00:D3A4  9E B3 27  .l1:	stz	satb,X
 1019  00:D3A7  9E B3 28  	stz	satb+256,X
 1020  00:D3AA  E8        	inx
 1021  00:D3AB  D0 F7     	bne	.l1
 1022                     	; --
 1023  00:D3AD  A0 01     	ldy	#1
 1024  00:D3AF  84 15     	sty	<spr_flag
 1025  00:D3B1  64 14     	stz	<spr_max
 1026  00:D3B3  60        	rts
 1027                     
 1028                     ; get_color(int index [color_reg])
 1029                     ; ----
 1030                     ; index: index in the palette (0-511)
 1031                     ; ----
 1032                     
 1033  00:D3B4            _get_color.1:
 1034  00:D3B4  AE 04 04  	ldx	color_data_l
 1035  00:D3B7  AD 05 04  	lda	color_data_h
 1036  00:D3BA  29 01     	and	#$01
 1037  00:D3BC  60        	rts
 1038                     
 1039                     ; set_color(int index [color_reg], int color [color_data])
 1040                     ; ----
 1041                     ; set one palette entry to the specified color
 1042                     ; ----
 1043                     ; index: index in the palette (0-511)
 1044                     ; color: color value,	GREEN:	bit 6-8
 1045                     ;			RED:	bit 3-5
 1046                     ;			BLUE:	bit 0-2
 1047                     ; ----
 1048                     ; NOTE : inlined
 1049                     ; ----
 1050                     
 1051                     ; fade_color(int color [__ax], char level)
 1052                     ; fade_color(int index [color_reg], int color [__ax], char level)
 1053                     ; ----
 1054                     ; set one palette entry to the specified color
 1055                     ; ----
 1056                     ; index: index in the palette (0-511)
 1057                     ; color: color value,	GREEN:	bit 6-8
 1058                     ;			RED:	bit 3-5
 1059                     ;			BLUE:	bit 0-2
 1060                     ; level: level of fading (0 = black, 8 = full)
 1061                     ; ----
 1062                     
 1063  00:D3BD            _fade_color.2:
 1064  00:D3BD            _fade_color.3:
 1065  00:D3BD  E0 00     	cpx	#0
 1066  00:D3BF  F0 38     	beq	.l4
 1067  00:D3C1  E0 08     	cpx	#8
 1068                     	bhs	.l5
       00:D3C3  B0 37     	bcs	.l5
 1069                     	; -- fading
 1070  00:D3C5  A0 03     	ldy	#3
 1071  00:D3C7  86 FA     	stx	<__bl
 1072                     	stwz	<__dx
       00:D3C9  64 FE     	stz	LOW_BYTE <__dx
       00:D3CB  64 FF     	stz	HIGH_BYTE <__dx
 1073  00:D3CD  46 FA     .l1:	lsr	<__bl
 1074  00:D3CF  90 0D     	bcc	.l2
 1075                     	addw	<__ax,<__dx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       00:D3D1  18        	clc
       00:D3D2  A5 FE     	lda	LOW_BYTE <__dx
       00:D3D4  65 F8     	adc	LOW_BYTE <__ax
       00:D3D6  85 FE     	sta	LOW_BYTE <__dx
       00:D3D8  A5 FF     	lda	HIGH_BYTE <__dx
       00:D3DA  65 F9     	adc	HIGH_BYTE <__ax
       00:D3DC  85 FF     	sta	HIGH_BYTE <__dx
                          .endif
 1076                     .l2:	aslw	<__ax
       00:D3DE  06 F8     	asl	<__ax		; word-sized value (at stated
       00:D3E0  26 F9     	rol	<__ax+1		; memory location)
 1077  00:D3E2  88        	dey
 1078  00:D3E3  D0 E8     	bne	.l1
 1079  00:D3E5  A5 FF     	lda	<__dh
 1080  00:D3E7  4A        	lsr	A
 1081  00:D3E8  66 FE     	ror	<__dl
 1082  00:D3EA  4A        	lsr	A
 1083  00:D3EB  66 FE     	ror	<__dl
 1084  00:D3ED  4A        	lsr	A
 1085  00:D3EE  66 FE     	ror	<__dl
 1086                     	; -- set color
 1087  00:D3F0  A6 FE     	ldx	<__dl
 1088  00:D3F2  8E 04 04  .l3:	stx	color_data_l
 1089  00:D3F5  8D 05 04  	sta	color_data_h
 1090  00:D3F8  60        	rts
 1091                     	; -- black
 1092  00:D3F9  62        .l4:	cla
 1093  00:D3FA  80 F6     	bra	.l3
 1094                     	; -- full
 1095  00:D3FC  A6 F8     .l5:	ldx	<__al
 1096  00:D3FE  A5 F9     	lda	<__ah
 1097  00:D400  80 F0     	bra	.l3
 1098                     
 1099                     ; set_color_rgb(int index [color_reg], char r [__al], char g [__ah], char b)
 1100                     ; ----
 1101                     ; set one palette entry to the specified color
 1102                     ; ----
 1103                     ; index: index in the palette (0-511)
 1104                     ; r:	red	RED:	bit 3-5
 1105                     ; g:	green	GREEN:	bit 6-8
 1106                     ; b:	blue	BLUE:	bit 0-2
 1107                     ; ----
 1108                     
 1109  00:D402            _set_color_rgb.4:
 1110  00:D402  8A        	txa
 1111  00:D403  29 07     	and	#$7
 1112  00:D405  85 02     	sta	<__temp
 1113  00:D407  A5 F8     	lda	<__al
 1114  00:D409  0A        	asl	A
 1115  00:D40A  0A        	asl	A
 1116  00:D40B  0A        	asl	A
 1117  00:D40C  05 02     	ora	<__temp
 1118  00:D40E  0A        	asl	A
 1119  00:D40F  0A        	asl	A
 1120  00:D410  85 02     	sta	<__temp
 1121  00:D412  A5 F9     	lda	<__ah
 1122  00:D414  4A        	lsr	A
 1123  00:D415  66 02     	ror	<__temp
 1124  00:D417  4A        	lsr	A
 1125  00:D418  66 02     	ror	<__temp
 1126  00:D41A  A6 02     	ldx	<__temp
 1127  00:D41C  8E 04 04  	stx	color_data_l
 1128  00:D41F  8D 05 04  	sta	color_data_h
 1129  00:D422  60        	rts
 1130                     
 1131                     ; put_tile(int tile_num [__dx], int position)
 1132                     ; put_tile(int tile_num [__dx], char x [__al], char y)
 1133                     ; ----
 1134                     ; draw a single 8x8 or 16x16 tile at a given position
 1135                     ; ----
 1136                     ; pattern:	vram address of the tile pattern
 1137                     ; position:	position on screen where to put the tile
 1138                     ; ----
 1139                     
 1140  00:D423            _put_tile.3:
 1141  00:D423  A5 F8     	lda	<__al
 1142  00:D425  AC 20 27  	ldy	maptiletype
 1143  00:D428  C0 08     	cpy	#8
 1144  00:D42A  F0 08     	beq	.l1
 1145                     	; --
 1146  00:D42C  0A        	asl	A
 1147  00:D42D  22        	sax
 1148  00:D42E  0A        	asl	A
 1149  00:D42F  20 AF C4  	jsr	calc_vram_addr
 1150  00:D432  80 42     	bra	_put_tile_16
 1151                     	; --
 1152  00:D434  22        .l1:	sax
 1153  00:D435  20 AF C4  	jsr	calc_vram_addr
 1154  00:D438  80 0B     	bra	_put_tile_8
 1155  00:D43A            _put_tile.2:
 1156                     	__stw	<__di
       00:D43A  86 F0     	stx	<__di
       00:D43C  85 F1     	sta	<__di+1
 1157  00:D43E  AC 20 27  	ldy	maptiletype
 1158  00:D441  C0 08     	cpy	#8
 1159  00:D443  D0 31     	bne	_put_tile_16
 1160  00:D445            _put_tile_8:
 1161  00:D445  20 98 C4  	jsr	set_write
 1162                     	; -- calculate tile vram address
 1163  00:D448  43 04     	tma	#2
 1164  00:D44A  48        	pha
 1165  00:D44B  AD 28 27  	lda	mapctablebank
 1166  00:D44E  53 04     	tam	#2
 1167                     	stb	mapctable,<__bx
       00:D450  AD 29 27  	lda	mapctable
       00:D453  85 FA     	sta	<__bx
 1168  00:D455  AD 2A 27  	lda	mapctable+1
 1169  00:D458  29 1F     	and	#$1F
 1170  00:D45A  09 40     	ora	#$40
 1171  00:D45C  85 FB     	sta	<__bx+1
 1172  00:D45E  A5 FE     	lda	<__dl
 1173  00:D460  A8        	tay
 1174                     	add	maptilebase
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       00:D461  18        	clc
       00:D462  6D 24 27  	adc	maptilebase
                          .endif
 1175  00:D465  AA        	tax
 1176  00:D466  62        	cla
 1177  00:D467  6D 25 27  	adc	maptilebase+1
 1178  00:D46A  71 FA     	adc	[__bx],Y
 1179                     	; -- copy tile
 1180  00:D46C  8E 02 00  	stx	video_data_l
 1181  00:D46F  8D 03 00  	sta	video_data_h
 1182  00:D472  68        	pla
 1183  00:D473  53 04     	tam	#2
 1184  00:D475  60        	rts
 1185  00:D476            _put_tile_16:
 1186  00:D476  20 98 C4  	jsr	set_write
 1187                     	; -- calculate tile vram address
 1188  00:D479  43 04     	tma	#2
 1189  00:D47B  48        	pha
 1190  00:D47C  AD 28 27  	lda	mapctablebank
 1191  00:D47F  53 04     	tam	#2
 1192                     	stb	mapctable,<__bx
       00:D481  AD 29 27  	lda	mapctable
       00:D484  85 FA     	sta	<__bx
 1193  00:D486  AD 2A 27  	lda	mapctable+1
 1194  00:D489  29 1F     	and	#$1F
 1195  00:D48B  09 40     	ora	#$40
 1196  00:D48D  85 FB     	sta	<__bx+1
 1197  00:D48F  64 FF     	stz	<__dh
 1198  00:D491  A5 FE     	lda	<__dl
 1199  00:D493  A8        	tay
 1200  00:D494  0A        	asl	A
 1201  00:D495  26 FF     	rol	<__dh
 1202  00:D497  0A        	asl	A
 1203  00:D498  26 FF     	rol	<__dh
 1204                     	add	maptilebase
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       00:D49A  18        	clc
       00:D49B  6D 24 27  	adc	maptilebase
                          .endif
 1205  00:D49E  85 FE     	sta	<__dl
 1206  00:D4A0  A5 FF     	lda	<__dh
 1207  00:D4A2  6D 25 27  	adc	maptilebase+1
 1208  00:D4A5  71 FA     	adc	[__bx],Y
 1209  00:D4A7  85 FF     	sta	<__dh
 1210                     	; -- copy tile
 1211                     	stw	<__dx,video_data
       00:D4A9  A5 FE     	lda	LOW_BYTE <__dx
       00:D4AB  8D 02 00  	sta	LOW_BYTE video_data
       00:D4AE  A5 FF     	lda	HIGH_BYTE <__dx
       00:D4B0  8D 03 00  	sta	HIGH_BYTE video_data
 1212                     	incw	<__dx
       00:D4B3  E6 FE     	inc	<__dx		; value at stated memory
       00:D4B5  D0 02     	bne	.x_00297		; location
       00:D4B7  E6 FF     	inc	<__dx+1
       00:D4B9            .x_00297:
 1213                     	stw	<__dx,video_data
       00:D4B9  A5 FE     	lda	LOW_BYTE <__dx
       00:D4BB  8D 02 00  	sta	LOW_BYTE video_data
       00:D4BE  A5 FF     	lda	HIGH_BYTE <__dx
       00:D4C0  8D 03 00  	sta	HIGH_BYTE video_data
 1214                     	incw	<__dx
       00:D4C3  E6 FE     	inc	<__dx		; value at stated memory
       00:D4C5  D0 02     	bne	.x_00299		; location
       00:D4C7  E6 FF     	inc	<__dx+1
       00:D4C9            .x_00299:
 1215                     	vreg	#0
       00:D4C9  A9 00     	lda	#0
       00:D4CB  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:D4CD  03 00     	st0	#0
                          .else
                          .endif
 1216                     	addw	bat_width,<__di,video_data
                0001      .if	(3 = 3)
                          	; 3-arg mode
                          	;
       00:D4CF  18        	clc
       00:D4D0  A5 F0     	lda	LOW_BYTE <__di
       00:D4D2  6D 3C 27  	adc	LOW_BYTE bat_width
       00:D4D5  8D 02 00  	sta	LOW_BYTE video_data
       00:D4D8  A5 F1     	lda	HIGH_BYTE <__di
       00:D4DA  6D 3D 27  	adc	HIGH_BYTE bat_width
       00:D4DD  8D 03 00  	sta	HIGH_BYTE video_data
                          .else
                          .endif
 1217                     	vreg	#2
       00:D4E0  A9 02     	lda	#2
       00:D4E2  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:D4E4  03 02     	st0	#2
                          .else
                          .endif
 1218                     	stw	<__dx,video_data
       00:D4E6  A5 FE     	lda	LOW_BYTE <__dx
       00:D4E8  8D 02 00  	sta	LOW_BYTE video_data
       00:D4EB  A5 FF     	lda	HIGH_BYTE <__dx
       00:D4ED  8D 03 00  	sta	HIGH_BYTE video_data
 1219                     	incw	<__dx
       00:D4F0  E6 FE     	inc	<__dx		; value at stated memory
       00:D4F2  D0 02     	bne	.x_00304		; location
       00:D4F4  E6 FF     	inc	<__dx+1
       00:D4F6            .x_00304:
 1220                     	stw	<__dx,video_data
       00:D4F6  A5 FE     	lda	LOW_BYTE <__dx
       00:D4F8  8D 02 00  	sta	LOW_BYTE video_data
       00:D4FB  A5 FF     	lda	HIGH_BYTE <__dx
       00:D4FD  8D 03 00  	sta	HIGH_BYTE video_data
 1221  00:D500  68        	pla
 1222  00:D501  53 04     	tam	#2
 1223  00:D503  60        	rts
 1224                     
 1225                     ; map_get_tile(char x [__dl], char y)
 1226                     ; map_put_tile(char x [__dl], char y [__dh], char tile)
 1227                     ; ----
 1228                     
 1229  00:D504            _map_get_tile.2:
 1230  00:D504  86 FF     	stx	<__dh
 1231  00:D506  20 16 D5  	jsr	_map_calc_tile_addr
 1232                     	; --
 1233  00:D509  B2 FC     	lda	[__cx]
 1234  00:D50B  AA        	tax
 1235  00:D50C  62        	cla
 1236  00:D50D  60        	rts
 1237                     
 1238  00:D50E            _map_put_tile.3:
 1239  00:D50E  DA        	phx
 1240  00:D50F  20 16 D5  	jsr	_map_calc_tile_addr
 1241  00:D512  68        	pla
 1242  00:D513  92 FC     	sta	[__cx]
 1243  00:D515  60        	rts
 1244                     
 1245                     ; map_calc_tile_addr(char x [__dl], char y [__dh])
 1246                     ; ----
 1247  00:D516            _map_calc_tile_addr:
 1248  00:D516  A6 FF     	ldx	<__dh
 1249  00:D518  AD 1D 27  	lda	mapwidth+1
 1250  00:D51B  F0 08     	beq	.l1
 1251  00:D51D  86 FD     	stx	<__ch
 1252  00:D51F  A5 FE     	lda	<__dl
 1253  00:D521  85 FC     	sta	<__cl
 1254  00:D523  80 13     	bra	.l2
 1255                     	; --
 1256  00:D525  86 F8     .l1:	stx	<__al
 1257  00:D527  AD 1C 27  	lda	mapwidth
 1258  00:D52A  85 FA     	sta	<__bl
 1259  00:D52C  20 BD E0  	jsr	mulu8
 1260                     	; --
 1261  00:D52F  A5 FC     	lda	<__cl
 1262                     	add	<__dl
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       00:D531  18        	clc
       00:D532  65 FE     	adc	<__dl
                          .endif
 1263  00:D534  90 02     	bcc	.l2
 1264  00:D536  E6 FD     	inc	<__ch
 1265                     	; --
 1266                     .l2:	add	mapaddr
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       00:D538  18        	clc
       00:D539  6D 1A 27  	adc	mapaddr
                          .endif
 1267  00:D53C  85 FC     	sta	<__cl
 1268  00:D53E  AD 1B 27  	lda	mapaddr+1
 1269  00:D541  29 1F     	and	#$1F
 1270  00:D543  65 FD     	adc	<__ch
 1271  00:D545  AA        	tax
 1272                     	; --
 1273                     ;	rol	A
 1274                     ;	rol	A
 1275                     ;	rol	A
 1276                     ;	rol	A
 1277  00:D546  4A        	lsr	A
 1278  00:D547  4A        	lsr	A
 1279  00:D548  4A        	lsr	A
 1280  00:D549  4A        	lsr	A
 1281  00:D54A  4A        	lsr	A
 1282  00:D54B  29 0F     	and	#$0F
 1283                     	add	mapbank
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       00:D54D  18        	clc
       00:D54E  6D 19 27  	adc	mapbank
                          .endif
 1284  00:D551  53 08     	tam	#3
 1285                     	; --
 1286  00:D553  8A        	txa
 1287  00:D554  29 1F     	and	#$1F
 1288  00:D556  09 60     	ora	#$60
 1289  00:D558  85 FD     	sta	<__ch
 1290  00:D55A  A6 FC     	ldx	<__cl
 1291  00:D55C  60        	rts
 1292                     
 1293                     ; scroll(char num, int x, int y, char top, char bottom, char disp)
 1294                     ; ----
 1295                     ; set screen scrolling
 1296                     ; ----
 1297                     
 1298  00:D55D            _scroll:
 1299  00:D55D  A0 08     	ldy	#8
 1300  00:D55F  B1 00     	lda	[__sp],Y
 1301  00:D561  29 03     	and	#$03
 1302                     	; --
 1303  00:D563  22        	sax
 1304  00:D564  29 C0     	and	#$C0
 1305  00:D566  09 01     	ora	#$01
 1306  00:D568  9D 60 27  	sta	scroll_cr,X
 1307  00:D56B  B2 00     	lda	[__sp]
 1308  00:D56D  1A        	inc	A
 1309  00:D56E  9D 5C 27  	sta	scroll_bottom,X
 1310  00:D571  A0 02     	ldy	#2
 1311  00:D573  B1 00     	lda	[__sp],Y
 1312  00:D575  9D 58 27  	sta	scroll_top,X
 1313  00:D578  A0 04     	ldy	#4
 1314  00:D57A  B1 00     	lda	[__sp],Y
 1315  00:D57C  9D 50 27  	sta	scroll_yl,X
 1316  00:D57F  C8        	iny
 1317  00:D580  B1 00     	lda	[__sp],Y
 1318  00:D582  9D 54 27  	sta	scroll_yh,X
 1319  00:D585  C8        	iny
 1320  00:D586  B1 00     	lda	[__sp],Y
 1321  00:D588  9D 48 27  	sta	scroll_xl,X
 1322  00:D58B  C8        	iny
 1323  00:D58C  B1 00     	lda	[__sp],Y
 1324  00:D58E  9D 4C 27  	sta	scroll_xh,X
 1325                     	__addmi	#10,__sp
                0000      .if (#10 = 1)
                          .else
                0000      .if (#10 = -1)
                          .else
       00:D591  A8        	tay			; 2
       00:D592  18        	clc			; 2
       00:D593  A5 00     	lda	<__sp		; 4
       00:D595  69 0A     	adc	#low(#10)	; 2
       00:D597  85 00     	sta	<__sp		; 4
                0001      .if (#10 < 256) & (#10 >= 0)
       00:D599  90 02     	bcc	.x00309		; 4(2)
       00:D59B  E6 01     	inc	<__sp+1		; 0(6)
       00:D59D            .x00309:
                          .else
                          .endif
       00:D59D  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
 1326  00:D59E  60        	rts
 1327                     
 1328                     ; scroll_disable(char num)
 1329                     ; ----
 1330                     ; disable screen scrolling for a scroll region
 1331                     ; ----
 1332                     
 1333  00:D59F            _scroll_disable:
 1334  00:D59F  BD 60 27  	lda	scroll_cr,X
 1335  00:D5A2  29 FE     	and	#$fe
 1336  00:D5A4  9D 60 27  	sta	scroll_cr,X
 1337  00:D5A7  60        	rts
 1338                     
 1339                     ; set_screen_size(char size)
 1340                     ; ----
 1341                     ; set screen virtual size
 1342                     ; ----
 1343                     
 1344  00:D5A8            _set_screen_size:
 1345  00:D5A8  8A        	txa
 1346  00:D5A9  4C F8 C4  	jmp	set_bat_size
 1347                     
 1348                     ; set_xres(int xres)
 1349                     ; ----
 1350                     ; set horizontal display resolution
 1351                     ; ----
 1352                     
 1353  00:D5AC            _set_xres.1:
 1354  00:D5AC  A9 04     	lda	#XRES_SOFT
 1355  00:D5AE  85 FC     	sta	<__cl
 1356  00:D5B0            _set_xres.2:
 1357  00:D5B0  20 E6 C4  	jsr	set_xres
 1358  00:D5B3  A6 F8     	ldx	<__al
 1359  00:D5B5  A5 F9     	lda	<__ah
 1360  00:D5B7  60        	rts
 1361                     
 1362                     
 1363                     ; ------------------------
 1364                     ; Graphics functions
 1365                     ; ------------------------
 1366                     
 1367                     ; readvram
 1368                     ; ----
 1369                     ; leftover from asm library
 1370                     ; needed for 'a = vram[n]'
 1371                     ; semantic
 1372                     ; ----
 1373  00:D5B8            readvram:
 1374  00:D5B8  A0 01     	ldy	#1
 1375  00:D5BA  84 F7     	sty	<vdc_reg
 1376  00:D5BC  8C 00 00  	sty	video_reg
 1377  00:D5BF  8E 02 00  	stx	video_data_l
 1378  00:D5C2  8D 03 00  	sta	video_data_h
 1379                     	vreg	#$02
       00:D5C5  A9 02     	lda	#$02
       00:D5C7  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:D5C9  03 02     	st0	#$02
                          .else
                          .endif
 1380  00:D5CB  AE 02 00  	ldx	video_data_l
 1381  00:D5CE  AD 03 00  	lda	video_data_h
 1382  00:D5D1  60        	rts
 1383                     
 1384                     
 1385                     ; writevram
 1386                     ; ----
 1387                     ; leftover from asm library
 1388                     ; needed for 'vram[n] = a'
 1389                     ; semantic
 1390                     ; ----
 1391  00:D5D2            writevram:
 1392  00:D5D2  A8        	tay
 1393  00:D5D3  64 F7     	stz	<vdc_reg
 1394  00:D5D5  9C 00 00  	stz	video_reg
 1395  00:D5D8  B2 00     	lda	[__sp]
 1396  00:D5DA  8D 02 00  	sta	video_data_l
 1397                     	incw	<__sp
       00:D5DD  E6 00     	inc	<__sp		; value at stated memory
       00:D5DF  D0 02     	bne	.x_00311		; location
       00:D5E1  E6 01     	inc	<__sp+1
       00:D5E3            .x_00311:
 1398  00:D5E3  B2 00     	lda	[__sp]
 1399  00:D5E5  8D 03 00  	sta	video_data_h
 1400                     	incw	<__sp
       00:D5E8  E6 00     	inc	<__sp		; value at stated memory
       00:D5EA  D0 02     	bne	.x_00312		; location
       00:D5EC  E6 01     	inc	<__sp+1
       00:D5EE            .x_00312:
 1401                     	vreg	#2
       00:D5EE  A9 02     	lda	#2
       00:D5F0  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       00:D5F2  03 02     	st0	#2
                          .else
                          .endif
 1402  00:D5F4  8E 02 00  	stx	video_data_l
 1403  00:D5F7  8C 03 00  	sty	video_data_h
 1404  00:D5FA  60        	rts
 1405                     
 1406                     
 1407                     ; gfx_setbgpal(char pal)
 1408                     ; ----
 1409                     ; set default major palette for gfx_* func's
 1410                     ; ----
 1411                     
 1412  00:D5FB            _gfx_setbgpal:
 1413  00:D5FB  8A        	txa
 1414  00:D5FC  0A        	asl	A
 1415  00:D5FD  0A        	asl	A
 1416  00:D5FE  0A        	asl	A
 1417  00:D5FF  0A        	asl	A
 1418  00:D600  8D B3 29  	sta	gfx_pal
 1419  00:D603  60        	rts
 1420                     
 1421                     
 1422                     ; gfx_init(int start_vram_addr)
 1423                     ; ----
 1424                     ; initialize graphics mode
 1425                     ; - points graphics map to tiles at start_vram_addr
 1426                     ; ----
 1427                     
 1428  00:D604            _gfx_init:
 1429                     	maplibfunc lib2_gfx_init
       00:D604  A8        	tay
       00:D605  43 20     	tma	#page(lib2_gfx_init)
       00:D607  48        	pha
       00:D608  A9 81     	lda	#bank(lib2_gfx_init)
       00:D60A  53 20     	tam	#page(lib2_gfx_init)
       00:D60C  98        	tya
       00:D60D  20 A4 AC  	jsr	lib2_gfx_init
       00:D610  A8        	tay
       00:D611  68        	pla
       00:D612  53 20     	tam	#page(lib2_gfx_init)
       00:D614  98        	tya
 1430  00:D615  60        	rts
 1431                     
 1432           0001      	.bank LIB2_BANK
 1433  01:ACA4            lib2_gfx_init:
 1434                     	__stw	<__dx	; vram addr
       01:ACA4  86 FE     	stx	<__dx	
       01:ACA6  85 FF     	sta	<__dx	+1
 1435                     
 1436                     	lsrw	<__dx	; shift address to make char pattern
       01:ACA8  46 FF     	lsr	<__dx	+1		; value (at stated memory
       01:ACAA  66 FE     	ror	<__dx			; location)
 1437                     	lsrw	<__dx
       01:ACAC  46 FF     	lsr	<__dx+1		; value (at stated memory
       01:ACAE  66 FE     	ror	<__dx		; location)
 1438                     	lsrw	<__dx
       01:ACB0  46 FF     	lsr	<__dx+1		; value (at stated memory
       01:ACB2  66 FE     	ror	<__dx		; location)
 1439                     	lsrw	<__dx
       01:ACB4  46 FF     	lsr	<__dx+1		; value (at stated memory
       01:ACB6  66 FE     	ror	<__dx		; location)
 1440  01:ACB8  A5 FF     	lda	<__dx+1
 1441  01:ACBA  29 0F     	and	#$0f
 1442  01:ACBC  0D B3 29  	ora	gfx_pal	; and add major palette info
 1443  01:ACBF  85 FF     	sta	<__dx+1
 1444                     
 1445                     	setvwaddr $0
                          	stw	#$0,<__di
       01:ACC1  A9 00     	lda	LOW_BYTE #$0
       01:ACC3  85 F0     	sta	LOW_BYTE <__di
       01:ACC5  A9 00     	lda	HIGH_BYTE #$0
       01:ACC7  85 F1     	sta	HIGH_BYTE <__di
       01:ACC9  20 98 C4  	jsr	set_write
 1446                     	; --
 1447  01:ACCC  AC 3E 27  	ldy	bat_height
 1448  01:ACCF  AE 3C 27  .l2:	ldx	bat_width
 1449                     	; --
 1450                     .l3:	stw	<__dx,video_data
       01:ACD2  A5 FE     	lda	LOW_BYTE <__dx
       01:ACD4  8D 02 00  	sta	LOW_BYTE video_data
       01:ACD7  A5 FF     	lda	HIGH_BYTE <__dx
       01:ACD9  8D 03 00  	sta	HIGH_BYTE video_data
 1451                     	incw	<__dx
       01:ACDC  E6 FE     	inc	<__dx		; value at stated memory
       01:ACDE  D0 02     	bne	.x_00323		; location
       01:ACE0  E6 FF     	inc	<__dx+1
       01:ACE2            .x_00323:
 1452  01:ACE2  CA        	dex
 1453  01:ACE3  D0 ED     	bne	.l3
 1454  01:ACE5  88        	dey
 1455  01:ACE6  D0 E7     	bne	.l2
 1456  01:ACE8  60        	rts
 1457           0000      	.bank LIB1_BANK
 1458                     
 1459                     ; gfx_clear(int start_vram_addr)
 1460                     ; ----
 1461                     ; Clear the values in the graphics tiles
 1462                     ; - places zeroes in graphics tiles at start_vram_addr
 1463                     ; ----
 1464                     
 1465  00:D616            _gfx_clear:
 1466                     	__stw	<__di		; start_vram_addr
       00:D616  86 F0     	stx	<__di		
       00:D618  85 F1     	sta	<__di		+1
 1467  00:D61A  20 98 C4  	jsr	set_write	; setup VRAM addr for writing
 1468                     
 1469  00:D61D  AD 3E 27  	lda	bat_height
 1470  00:D620  85 FA     	sta	<__bl		; loop for all lines
 1471  00:D622  AE 3C 27  .l2:	ldx	bat_width	; loop for all characters
 1472  00:D625  A0 08     .l3:	ldy	#8		; loop for 16 words
 1473                     .l4:	stw	#0,video_data	; unrolled a bit (8 iterations
       00:D627  A9 00     	lda	LOW_BYTE #0
       00:D629  8D 02 00  	sta	LOW_BYTE video_data	
       00:D62C  A9 00     	lda	HIGH_BYTE #0
       00:D62E  8D 03 00  	sta	HIGH_BYTE video_data	
 1474                     	stw	#0,video_data	; @ 2 words each iteration)
       00:D631  A9 00     	lda	LOW_BYTE #0
       00:D633  8D 02 00  	sta	LOW_BYTE video_data	
       00:D636  A9 00     	lda	HIGH_BYTE #0
       00:D638  8D 03 00  	sta	HIGH_BYTE video_data	
 1475  00:D63B  88        	dey
 1476  00:D63C  D0 E9     	bne	.l4
 1477  00:D63E  CA        	dex
 1478  00:D63F  D0 E4     	bne	.l3
 1479  00:D641  C6 FA     	dec	<__bl
 1480  00:D643  D0 DD     	bne	.l2
 1481  00:D645  60        	rts
 1482                     
 1483                     
 1484                     ; gfx_plot(int x [__bx] int y [__cx] char color [reg acc])
 1485                     ; ----
 1486                     ; Plot a point at location (x,y) in color
 1487                     ; ----
 1488                     
 1489  00:D646            _gfx_plot.3:
 1490                     	maplibfunc	lib2_gfx_plot.3
       00:D646  A8        	tay
       00:D647  43 20     	tma	#page(lib2_gfx_plot.3)
       00:D649  48        	pha
       00:D64A  A9 81     	lda	#bank(lib2_gfx_plot.3)
       00:D64C  53 20     	tam	#page(lib2_gfx_plot.3)
       00:D64E  98        	tya
       00:D64F  20 CC AF  	jsr	lib2_gfx_plot.3
       00:D652  A8        	tay
       00:D653  68        	pla
       00:D654  53 20     	tam	#page(lib2_gfx_plot.3)
       00:D656  98        	tya
 1491  00:D657  60        	rts
 1492                     
 1493                     
 1494                     ; gfx_point(int x [__bx], int y [__cx])
 1495                     ; ----
 1496                     ; Returns color of point at location (x,y)
 1497                     ; ----
 1498                     
 1499  00:D658            _gfx_point.2:
 1500                     	maplibfunc	lib2_gfx_point.2
       00:D658  A8        	tay
       00:D659  43 20     	tma	#page(lib2_gfx_point.2)
       00:D65B  48        	pha
       00:D65C  A9 81     	lda	#bank(lib2_gfx_point.2)
       00:D65E  53 20     	tam	#page(lib2_gfx_point.2)
       00:D660  98        	tya
       00:D661  20 87 B0  	jsr	lib2_gfx_point.2
       00:D664  A8        	tay
       00:D665  68        	pla
       00:D666  53 20     	tam	#page(lib2_gfx_point.2)
       00:D668  98        	tya
 1501  00:D669  60        	rts
 1502                     
 1503                     
 1504                     ; gfx_line(int x1 [__bx], int y1 [__cx], int x2 [__si], int y2 [__bp], char color [reg acc])
 1505                     ; ----
 1506                     ; Plot a line from location (x1,y1) to location (x2,y2) in color
 1507                     ; ----
 1508                     
 1509  00:D66A            _gfx_line.5:
 1510                     	maplibfunc	lib2_gfx_line.5
       00:D66A  A8        	tay
       00:D66B  43 20     	tma	#page(lib2_gfx_line.5)
       00:D66D  48        	pha
       00:D66E  A9 81     	lda	#bank(lib2_gfx_line.5)
       00:D670  53 20     	tam	#page(lib2_gfx_line.5)
       00:D672  98        	tya
       00:D673  20 42 AD  	jsr	lib2_gfx_line.5
       00:D676  A8        	tay
       00:D677  68        	pla
       00:D678  53 20     	tam	#page(lib2_gfx_line.5)
       00:D67A  98        	tya
 1511  00:D67B  60        	rts
 1512                     
 1513                     ;---------------------------------
 1514                     
 1515                     ;
 1516                     ; Change to context LIB2_BANK for these functions
 1517                     ; because they are larger than LIB1_BANK functions
 1518                     ; should be
 1519                     ;
 1520                     
 1521           0001      	.bank	LIB2_BANK
 1522                     
 1523                     ; put_number(int number, char n, int offset)
 1524                     ; put_number(int number, char n, char x, char y)
 1525                     ; ----
 1526                     
 1527  01:ACE9            lib2_put_number.4:
 1528  01:ACE9  A5 FA     	lda	<__bl
 1529  01:ACEB  20 98 CE  	jsr	_put.xy
 1530  01:ACEE  80 03     	bra	putnum.main
 1531  01:ACF0            lib2_put_number.3:
 1532  01:ACF0  20 9F CE  	jsr	_put.vram
 1533  01:ACF3            putnum.main:
 1534  01:ACF3  A6 FC     	ldx	<__cl
 1535                     	; --
 1536  01:ACF5  64 F8     	stz	<__al ; sign flag
 1537  01:ACF7  CA        	dex
 1538  01:ACF8  E0 10     	cpx	#16
 1539                     	bhs	.l5
       01:ACFA  B0 45     	bcs	.l5
 1540                     	; --
 1541  01:ACFC  A5 FF     	lda	<__dh ; check sign
 1542  01:ACFE  10 0F     	bpl	.l1
 1543                     	negw	<__dx ; negate
       01:AD00  62        	cla			; (at stated memory location)
                          	sub	<__dx		; 2's complement
                0000      .if (1 = 2)			; from register A (handle
                          .else
       01:AD01  38        	sec
       01:AD02  E5 FE     	sbc	<__dx		
                          .endif
       01:AD04  85 FE     	sta	<__dx
       01:AD06  62        	cla
       01:AD07  E5 FF     	sbc	<__dx+1
       01:AD09  85 FF     	sta	<__dx+1
 1544  01:AD0B  A9 01     	lda	#1
 1545  01:AD0D  85 F8     	sta	<__al
 1546                     	; --
 1547  01:AD0F  20 93 C6  .l1:	jsr	divu10
 1548  01:AD12  09 10     	ora	#$10
 1549  01:AD14  48        	pha
 1550  01:AD15  CA        	dex
 1551  01:AD16  30 15     	bmi	.l3
 1552                     	tstw	<__dx
       01:AD18  A5 FE     	lda	<__dx		; value at stated memory
       01:AD1A  05 FF     	ora	<__dx+1		; location is zero
 1553  01:AD1C  D0 F1     	bne	.l1
 1554                     	; --
 1555  01:AD1E  A5 F8     	lda	<__al
 1556  01:AD20  F0 07     	beq	.l2
 1557  01:AD22  A9 0D     	lda	#$0D
 1558  01:AD24  48        	pha
 1559  01:AD25  CA        	dex
 1560  01:AD26  30 05     	bmi	.l3
 1561                     	; --
 1562  01:AD28  62        	cla
 1563  01:AD29  48        .l2:	pha
 1564  01:AD2A  CA        	dex
 1565  01:AD2B  10 FC     	bpl	.l2
 1566                     	; --
 1567  01:AD2D  A6 FC     .l3:	ldx	<__cl
 1568  01:AD2F  68        .l4:	pla
 1569                     	add	_font_base
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       01:AD30  18        	clc
       01:AD31  6D AF 27  	adc	_font_base
                          .endif
 1570  01:AD34  8D 02 00  	sta	video_data_l
 1571  01:AD37  62        	cla
 1572  01:AD38  6D B0 27  	adc	_font_base+1
 1573  01:AD3B  8D 03 00  	sta	video_data_h
 1574  01:AD3E  CA        	dex
 1575  01:AD3F  D0 EE     	bne	.l4
 1576  01:AD41  60        .l5:	rts
 1577                     
 1578                     
 1579                     ; gfx_line(int x1 [__bx], int y1 [__cx], int x2 [__si], int y2 [__bp], char color [reg acc])
 1580                     ; ----
 1581                     ; Plot a line from location (x1,y1) to locations (x2,y2) in color
 1582                     ; ----
 1583  01:AD42            lib2_gfx_line.5:		; Bresenham line drawing algorithm
 1584  01:AD42  8E C1 29  	stx	line_color
 1585                     
 1586                     	cmpw	<__cx,<__bp	; make y always ascending by swapping
       01:AD45  A5 ED     	lda	HIGH_BYTE <__bp	
       01:AD47  C5 FD     	cmp	HIGH_BYTE <__cx
       01:AD49  D0 04     	bne	.x_00335
       01:AD4B  A5 EC     	lda	LOW_BYTE <__bp	
       01:AD4D  C5 FC     	cmp	LOW_BYTE <__cx
       01:AD4F            .x_00335:
 1587                     	bhs	.l1		; co-ordinates
       01:AD4F  B0 26     	bcs	.l1		
 1588                     				; jump over swap if bp > cx
 1589                     
 1590                     	stw	<__bp,line_curry	; swap coordinates
       01:AD51  A5 EC     	lda	LOW_BYTE <__bp
       01:AD53  8D B6 29  	sta	LOW_BYTE line_curry	
       01:AD56  A5 ED     	lda	HIGH_BYTE <__bp
       01:AD58  8D B7 29  	sta	HIGH_BYTE line_curry	
 1591                     	stw	<__cx,<__bp
       01:AD5B  A5 FC     	lda	LOW_BYTE <__cx
       01:AD5D  85 EC     	sta	LOW_BYTE <__bp
       01:AD5F  A5 FD     	lda	HIGH_BYTE <__cx
       01:AD61  85 ED     	sta	HIGH_BYTE <__bp
 1592                     	stw	<__si,line_currx
       01:AD63  A5 EE     	lda	LOW_BYTE <__si
       01:AD65  8D B4 29  	sta	LOW_BYTE line_currx
       01:AD68  A5 EF     	lda	HIGH_BYTE <__si
       01:AD6A  8D B5 29  	sta	HIGH_BYTE line_currx
 1593                     	stw	<__bx,<__si
       01:AD6D  A5 FA     	lda	LOW_BYTE <__bx
       01:AD6F  85 EE     	sta	LOW_BYTE <__si
       01:AD71  A5 FB     	lda	HIGH_BYTE <__bx
       01:AD73  85 EF     	sta	HIGH_BYTE <__si
 1594                     
 1595  01:AD75  80 14     	bra	.l2
 1596                     
 1597                     .l1:	stw	<__bx,line_currx
       01:AD77  A5 FA     	lda	LOW_BYTE <__bx
       01:AD79  8D B4 29  	sta	LOW_BYTE line_currx
       01:AD7C  A5 FB     	lda	HIGH_BYTE <__bx
       01:AD7E  8D B5 29  	sta	HIGH_BYTE line_currx
 1598                     	stw	<__cx,line_curry
       01:AD81  A5 FC     	lda	LOW_BYTE <__cx
       01:AD83  8D B6 29  	sta	LOW_BYTE line_curry
       01:AD86  A5 FD     	lda	HIGH_BYTE <__cx
       01:AD88  8D B7 29  	sta	HIGH_BYTE line_curry
 1599                     
 1600                     ; now:
 1601                     ;	line_currx and line_curry are start point
 1602                     ;	<__si and <__bp are end point
 1603                     ;	<__bx and <__cx are 'dont care'
 1604                     
 1605  01:AD8B            .l2:
 1606  01:AD8B  A5 EC     	lda	LOW_BYTE  <__bp
 1607                     	sub	LOW_BYTE  line_curry
                0000      .if (1 = 2)			; from register A (handle
                          .else
       01:AD8D  38        	sec
       01:AD8E  ED B6 29  	sbc	LOW_BYTE  line_curry
                          .endif
 1608  01:AD91  8D BA 29  	sta	LOW_BYTE  line_deltay
 1609  01:AD94  A5 ED     	lda	HIGH_BYTE <__bp
 1610  01:AD96  ED B7 29  	sbc	HIGH_BYTE line_curry
 1611  01:AD99  8D BB 29  	sta	HIGH_BYTE line_deltay
 1612                     
 1613  01:AD9C  A5 EE     	lda	LOW_BYTE  <__si
 1614                     	sub	LOW_BYTE  line_currx
                0000      .if (1 = 2)			; from register A (handle
                          .else
       01:AD9E  38        	sec
       01:AD9F  ED B4 29  	sbc	LOW_BYTE  line_currx
                          .endif
 1615  01:ADA2  8D B8 29  	sta	LOW_BYTE  line_deltax
 1616  01:ADA5  A5 EF     	lda	HIGH_BYTE <__si
 1617  01:ADA7  ED B5 29  	sbc	HIGH_BYTE line_currx
 1618  01:ADAA  8D B9 29  	sta	HIGH_BYTE line_deltax
 1619                     
 1620  01:ADAD  9C C0 29  	stz	line_xdir	; 0 = positive
 1621                     
 1622  01:ADB0  AD B9 29  	lda	HIGH_BYTE line_deltax
 1623  01:ADB3  10 14     	bpl	.l3
 1624                     
 1625  01:ADB5  A9 01     	lda	#1
 1626  01:ADB7  8D C0 29  	sta	line_xdir	; 1 = negative
 1627                     	negw	line_deltax
       01:ADBA  62        	cla			; (at stated memory location)
                          	sub	line_deltax		; 2's complement
                0000      .if (1 = 2)			; from register A (handle
                          .else
       01:ADBB  38        	sec
       01:ADBC  ED B8 29  	sbc	line_deltax		
                          .endif
       01:ADBF  8D B8 29  	sta	line_deltax
       01:ADC2  62        	cla
       01:ADC3  ED B9 29  	sbc	line_deltax+1
       01:ADC6  8D B9 29  	sta	line_deltax+1
 1628                     
 1629                     ; now:
 1630                     ;	line_deltay is difference from end to start (positive)
 1631                     ;	line_deltax is difference from end to start (positive)
 1632                     ;	line_xdir shows whether to apply deltax positive or negative
 1633                     
 1634                     
 1635  01:ADC9            .l3:
 1636                     	cmpw	line_deltax,line_deltay
       01:ADC9  AD BB 29  	lda	HIGH_BYTE line_deltay
       01:ADCC  CD B9 29  	cmp	HIGH_BYTE line_deltax
       01:ADCF  D0 06     	bne	.x_00347
       01:ADD1  AD BA 29  	lda	LOW_BYTE line_deltay
       01:ADD4  CD B8 29  	cmp	LOW_BYTE line_deltax
       01:ADD7            .x_00347:
 1637                     	lbhs	.ybiglp		; jump if deltay > |deltax|
       01:ADD7  90 03     	bcc	.x_00348
       01:ADD9  4C D5 AE  	jmp	.ybiglp		
       01:ADDC            .x_00348
 1638                     
 1639  01:ADDC            .xbiglp:
 1640                     	__ldw	line_deltay
                0000      .if (1 = 2)
                          .else
       01:ADDC  AE BA 29  	ldx	line_deltay
       01:ADDF  AD BB 29  	lda	line_deltay+1
                          .endif
 1641                     	__aslw
       01:ADE2  22        	sax
       01:ADE3  0A        	asl	A
       01:ADE4  22        	sax
       01:ADE5  2A        	rol	A
 1642                     	__stw	line_adjust
       01:ADE6  8E BE 29  	stx	line_adjust
       01:ADE9  8D BF 29  	sta	line_adjust+1
 1643                     	__stw	line_error
       01:ADEC  8E BC 29  	stx	line_error
       01:ADEF  8D BD 29  	sta	line_error+1
 1644                     
 1645                     	subw	line_deltax,line_adjust
       01:ADF2  38        	sec
       01:ADF3  AD BE 29  	lda	LOW_BYTE line_adjust
       01:ADF6  ED B8 29  	sbc	LOW_BYTE line_deltax
       01:ADF9  8D BE 29  	sta	LOW_BYTE line_adjust
       01:ADFC  AD BF 29  	lda	HIGH_BYTE line_adjust
       01:ADFF  ED B9 29  	sbc	HIGH_BYTE line_deltax
       01:AE02  8D BF 29  	sta	HIGH_BYTE line_adjust
 1646                     	subw	line_deltax,line_adjust
       01:AE05  38        	sec
       01:AE06  AD BE 29  	lda	LOW_BYTE line_adjust
       01:AE09  ED B8 29  	sbc	LOW_BYTE line_deltax
       01:AE0C  8D BE 29  	sta	LOW_BYTE line_adjust
       01:AE0F  AD BF 29  	lda	HIGH_BYTE line_adjust
       01:AE12  ED B9 29  	sbc	HIGH_BYTE line_deltax
       01:AE15  8D BF 29  	sta	HIGH_BYTE line_adjust
 1647                     
 1648                     	subw	line_deltax,line_error
       01:AE18  38        	sec
       01:AE19  AD BC 29  	lda	LOW_BYTE line_error
       01:AE1C  ED B8 29  	sbc	LOW_BYTE line_deltax
       01:AE1F  8D BC 29  	sta	LOW_BYTE line_error
       01:AE22  AD BD 29  	lda	HIGH_BYTE line_error
       01:AE25  ED B9 29  	sbc	HIGH_BYTE line_deltax
       01:AE28  8D BD 29  	sta	HIGH_BYTE line_error
 1649                     
 1650                     	incw	line_deltax		; used as counter - get both endpoints
       01:AE2B  EE B8 29  	inc	line_deltax				; value at stated memory
       01:AE2E  D0 03     	bne	.x_00356		; location
       01:AE30  EE B9 29  	inc	line_deltax		+1
       01:AE33            .x_00356:
 1651                     
 1652  01:AE33            .xlp1:
 1653                     	stw	line_currx,<__bx	; draw pixel
       01:AE33  AD B4 29  	lda	LOW_BYTE line_currx
       01:AE36  85 FA     	sta	LOW_BYTE <__bx	
       01:AE38  AD B5 29  	lda	HIGH_BYTE line_currx
       01:AE3B  85 FB     	sta	HIGH_BYTE <__bx	
 1654                     	stw	line_curry,<__cx
       01:AE3D  AD B6 29  	lda	LOW_BYTE line_curry
       01:AE40  85 FC     	sta	LOW_BYTE <__cx
       01:AE42  AD B7 29  	lda	HIGH_BYTE line_curry
       01:AE45  85 FD     	sta	HIGH_BYTE <__cx
 1655  01:AE47  AE C1 29  	ldx	line_color
 1656  01:AE4A  62        	cla
 1657  01:AE4B  20 CC AF  	jsr	lib2_gfx_plot.3
 1658                     
 1659                     	decw	line_deltax		; dec counter
       01:AE4E  38        	sec			; value at stated memory
       01:AE4F  AD B8 29  	lda	line_deltax				; location
       01:AE52  E9 01     	sbc	#1
       01:AE54  8D B8 29  	sta	line_deltax		
       01:AE57  AD B9 29  	lda	line_deltax		+1
       01:AE5A  E9 00     	sbc	#0
       01:AE5C  8D B9 29  	sta	line_deltax		+1
 1660                     	tstw	line_deltax
       01:AE5F  AD B8 29  	lda	line_deltax		; value at stated memory
       01:AE62  0D B9 29  	ora	line_deltax+1		; location is zero
 1661                     	lbeq	.out
       01:AE65  D0 03     	bne	.x_00361
       01:AE67  4C CB AF  	jmp	.out
       01:AE6A            .x_00361
 1662                     
 1663  01:AE6A  AD C0 29  	lda	line_xdir		; adjust currx
 1664  01:AE6D  F0 13     	beq	.xlppos
 1665                     
 1666                     	decw	line_currx
       01:AE6F  38        	sec			; value at stated memory
       01:AE70  AD B4 29  	lda	line_currx		; location
       01:AE73  E9 01     	sbc	#1
       01:AE75  8D B4 29  	sta	line_currx
       01:AE78  AD B5 29  	lda	line_currx+1
       01:AE7B  E9 00     	sbc	#0
       01:AE7D  8D B5 29  	sta	line_currx+1
 1667  01:AE80  80 08     	bra	.xlp2
 1668                     
 1669                     .xlppos:	incw	line_currx
       01:AE82  EE B4 29  	inc	line_currx		; value at stated memory
       01:AE85  D0 03     	bne	.x_00363		; location
       01:AE87  EE B5 29  	inc	line_currx+1
       01:AE8A            .x_00363:
 1670                     
 1671  01:AE8A            .xlp2:
 1672  01:AE8A  AD BD 29  	lda	HIGH_BYTE line_error
 1673  01:AE8D  30 1D     	bmi	.xlp3
 1674                     
 1675                     	addw	line_adjust,line_error
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:AE8F  18        	clc
       01:AE90  AD BC 29  	lda	LOW_BYTE line_error
       01:AE93  6D BE 29  	adc	LOW_BYTE line_adjust
       01:AE96  8D BC 29  	sta	LOW_BYTE line_error
       01:AE99  AD BD 29  	lda	HIGH_BYTE line_error
       01:AE9C  6D BF 29  	adc	HIGH_BYTE line_adjust
       01:AE9F  8D BD 29  	sta	HIGH_BYTE line_error
                          .endif
 1676                     	incw	line_curry
       01:AEA2  EE B6 29  	inc	line_curry		; value at stated memory
       01:AEA5  D0 03     	bne	.x_00365		; location
       01:AEA7  EE B7 29  	inc	line_curry+1
       01:AEAA            .x_00365:
 1677  01:AEAA  80 87     	bra	.xlp1
 1678  01:AEAC            .xlp3:
 1679                     	addw	line_deltay,line_error
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:AEAC  18        	clc
       01:AEAD  AD BC 29  	lda	LOW_BYTE line_error
       01:AEB0  6D BA 29  	adc	LOW_BYTE line_deltay
       01:AEB3  8D BC 29  	sta	LOW_BYTE line_error
       01:AEB6  AD BD 29  	lda	HIGH_BYTE line_error
       01:AEB9  6D BB 29  	adc	HIGH_BYTE line_deltay
       01:AEBC  8D BD 29  	sta	HIGH_BYTE line_error
                          .endif
 1680                     	addw	line_deltay,line_error
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:AEBF  18        	clc
       01:AEC0  AD BC 29  	lda	LOW_BYTE line_error
       01:AEC3  6D BA 29  	adc	LOW_BYTE line_deltay
       01:AEC6  8D BC 29  	sta	LOW_BYTE line_error
       01:AEC9  AD BD 29  	lda	HIGH_BYTE line_error
       01:AECC  6D BB 29  	adc	HIGH_BYTE line_deltay
       01:AECF  8D BD 29  	sta	HIGH_BYTE line_error
                          .endif
 1681  01:AED2  4C 33 AE  	jmp	.xlp1
 1682                     
 1683  01:AED5            .ybiglp:
 1684                     	__ldw	line_deltax
                0000      .if (1 = 2)
                          .else
       01:AED5  AE B8 29  	ldx	line_deltax
       01:AED8  AD B9 29  	lda	line_deltax+1
                          .endif
 1685                     	__aslw
       01:AEDB  22        	sax
       01:AEDC  0A        	asl	A
       01:AEDD  22        	sax
       01:AEDE  2A        	rol	A
 1686                     	__stw	line_adjust
       01:AEDF  8E BE 29  	stx	line_adjust
       01:AEE2  8D BF 29  	sta	line_adjust+1
 1687                     	__stw	line_error
       01:AEE5  8E BC 29  	stx	line_error
       01:AEE8  8D BD 29  	sta	line_error+1
 1688                     
 1689                     	subw	line_deltay,line_adjust
       01:AEEB  38        	sec
       01:AEEC  AD BE 29  	lda	LOW_BYTE line_adjust
       01:AEEF  ED BA 29  	sbc	LOW_BYTE line_deltay
       01:AEF2  8D BE 29  	sta	LOW_BYTE line_adjust
       01:AEF5  AD BF 29  	lda	HIGH_BYTE line_adjust
       01:AEF8  ED BB 29  	sbc	HIGH_BYTE line_deltay
       01:AEFB  8D BF 29  	sta	HIGH_BYTE line_adjust
 1690                     	subw	line_deltay,line_adjust
       01:AEFE  38        	sec
       01:AEFF  AD BE 29  	lda	LOW_BYTE line_adjust
       01:AF02  ED BA 29  	sbc	LOW_BYTE line_deltay
       01:AF05  8D BE 29  	sta	LOW_BYTE line_adjust
       01:AF08  AD BF 29  	lda	HIGH_BYTE line_adjust
       01:AF0B  ED BB 29  	sbc	HIGH_BYTE line_deltay
       01:AF0E  8D BF 29  	sta	HIGH_BYTE line_adjust
 1691                     
 1692                     	subw	line_deltay,line_error
       01:AF11  38        	sec
       01:AF12  AD BC 29  	lda	LOW_BYTE line_error
       01:AF15  ED BA 29  	sbc	LOW_BYTE line_deltay
       01:AF18  8D BC 29  	sta	LOW_BYTE line_error
       01:AF1B  AD BD 29  	lda	HIGH_BYTE line_error
       01:AF1E  ED BB 29  	sbc	HIGH_BYTE line_deltay
       01:AF21  8D BD 29  	sta	HIGH_BYTE line_error
 1693                     
 1694                     	incw	line_deltay		; used as counter - get both endpoints
       01:AF24  EE BA 29  	inc	line_deltay				; value at stated memory
       01:AF27  D0 03     	bne	.x_00375		; location
       01:AF29  EE BB 29  	inc	line_deltay		+1
       01:AF2C            .x_00375:
 1695                     
 1696  01:AF2C            .ylp1:
 1697                     	stw	line_currx,<__bx	; draw pixel
       01:AF2C  AD B4 29  	lda	LOW_BYTE line_currx
       01:AF2F  85 FA     	sta	LOW_BYTE <__bx	
       01:AF31  AD B5 29  	lda	HIGH_BYTE line_currx
       01:AF34  85 FB     	sta	HIGH_BYTE <__bx	
 1698                     	stw	line_curry,<__cx
       01:AF36  AD B6 29  	lda	LOW_BYTE line_curry
       01:AF39  85 FC     	sta	LOW_BYTE <__cx
       01:AF3B  AD B7 29  	lda	HIGH_BYTE line_curry
       01:AF3E  85 FD     	sta	HIGH_BYTE <__cx
 1699  01:AF40  AE C1 29  	ldx	line_color
 1700  01:AF43  62        	cla
 1701  01:AF44  20 CC AF  	jsr	lib2_gfx_plot.3
 1702                     
 1703                     	decw	line_deltay		; dec counter
       01:AF47  38        	sec			; value at stated memory
       01:AF48  AD BA 29  	lda	line_deltay				; location
       01:AF4B  E9 01     	sbc	#1
       01:AF4D  8D BA 29  	sta	line_deltay		
       01:AF50  AD BB 29  	lda	line_deltay		+1
       01:AF53  E9 00     	sbc	#0
       01:AF55  8D BB 29  	sta	line_deltay		+1
 1704                     	tstw	line_deltay
       01:AF58  AD BA 29  	lda	line_deltay		; value at stated memory
       01:AF5B  0D BB 29  	ora	line_deltay+1		; location is zero
 1705  01:AF5E  F0 6B     	beq	.out
 1706                     
 1707                     	incw	line_curry
       01:AF60  EE B6 29  	inc	line_curry		; value at stated memory
       01:AF63  D0 03     	bne	.x_00380		; location
       01:AF65  EE B7 29  	inc	line_curry+1
       01:AF68            .x_00380:
 1708                     
 1709  01:AF68  AD BD 29  	lda	HIGH_BYTE line_error
 1710  01:AF6B  30 35     	bmi	.ylp2
 1711                     
 1712                     	addw	line_adjust,line_error
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:AF6D  18        	clc
       01:AF6E  AD BC 29  	lda	LOW_BYTE line_error
       01:AF71  6D BE 29  	adc	LOW_BYTE line_adjust
       01:AF74  8D BC 29  	sta	LOW_BYTE line_error
       01:AF77  AD BD 29  	lda	HIGH_BYTE line_error
       01:AF7A  6D BF 29  	adc	HIGH_BYTE line_adjust
       01:AF7D  8D BD 29  	sta	HIGH_BYTE line_error
                          .endif
 1713  01:AF80  AD C0 29  	lda	line_xdir
 1714  01:AF83  F0 13     	beq	.ylppos
 1715                     
 1716                     	decw	line_currx
       01:AF85  38        	sec			; value at stated memory
       01:AF86  AD B4 29  	lda	line_currx		; location
       01:AF89  E9 01     	sbc	#1
       01:AF8B  8D B4 29  	sta	line_currx
       01:AF8E  AD B5 29  	lda	line_currx+1
       01:AF91  E9 00     	sbc	#0
       01:AF93  8D B5 29  	sta	line_currx+1
 1717  01:AF96  80 94     	bra	.ylp1
 1718                     
 1719  01:AF98            .ylppos:
 1720                     	incw	line_currx
       01:AF98  EE B4 29  	inc	line_currx		; value at stated memory
       01:AF9B  D0 03     	bne	.x_00383		; location
       01:AF9D  EE B5 29  	inc	line_currx+1
       01:AFA0            .x_00383:
 1721  01:AFA0  80 8A     	bra	.ylp1
 1722                     
 1723  01:AFA2            .ylp2:
 1724                     	addw	line_deltax,line_error
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:AFA2  18        	clc
       01:AFA3  AD BC 29  	lda	LOW_BYTE line_error
       01:AFA6  6D B8 29  	adc	LOW_BYTE line_deltax
       01:AFA9  8D BC 29  	sta	LOW_BYTE line_error
       01:AFAC  AD BD 29  	lda	HIGH_BYTE line_error
       01:AFAF  6D B9 29  	adc	HIGH_BYTE line_deltax
       01:AFB2  8D BD 29  	sta	HIGH_BYTE line_error
                          .endif
 1725                     	addw	line_deltax,line_error
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:AFB5  18        	clc
       01:AFB6  AD BC 29  	lda	LOW_BYTE line_error
       01:AFB9  6D B8 29  	adc	LOW_BYTE line_deltax
       01:AFBC  8D BC 29  	sta	LOW_BYTE line_error
       01:AFBF  AD BD 29  	lda	HIGH_BYTE line_error
       01:AFC2  6D B9 29  	adc	HIGH_BYTE line_deltax
       01:AFC5  8D BD 29  	sta	HIGH_BYTE line_error
                          .endif
 1726  01:AFC8  4C 2C AF  	jmp	.ylp1
 1727                     
 1728  01:AFCB            .out:
 1729  01:AFCB  60        	rts
 1730                     
 1731                     
 1732                     ; gfx_plot(int x [__bx], int y [__cx], char color [reg acc])
 1733                     ; ----
 1734                     ; Plot a point at location (x,y) in color
 1735                     ; ----
 1736                     
 1737  01:AFCC            lib2_gfx_plot.3:
 1738  01:AFCC  86 FE     	stx	<__dl		; color
 1739  01:AFCE  20 DD B0  	jsr	gfx_getaddr
 1740                     
 1741                     	; same as vm_rawread - save 21 cycles by inlining
 1742                     	;
 1743                     	vreg	#1		; video read register
       01:AFD1  A9 01     	lda	#1		
       01:AFD3  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:AFD5  03 01     	st0	#1		
                          .else
                          .endif
 1744                     	stw	<__cx,video_data	; VRAM address
       01:AFD7  A5 FC     	lda	LOW_BYTE <__cx
       01:AFD9  8D 02 00  	sta	LOW_BYTE video_data	
       01:AFDC  A5 FD     	lda	HIGH_BYTE <__cx
       01:AFDE  8D 03 00  	sta	HIGH_BYTE video_data	
 1745                     	vreg	#2		; set R/W memory mode
       01:AFE1  A9 02     	lda	#2		
       01:AFE3  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:AFE5  03 02     	st0	#2		
                          .else
                          .endif
 1746                     	__ldw	video_data
                0000      .if (1 = 2)
                          .else
       01:AFE7  AE 02 00  	ldx	video_data
       01:AFEA  AD 03 00  	lda	video_data+1
                          .endif
 1747                     	;
 1748                     	; end inline
 1749                     
 1750  01:AFED  A4 F8     	ldy	<__al		; bit offset
 1751  01:AFEF  1F FE 05  	bbr1	<__dl,.l1
 1752  01:AFF2  19 CD B0  	ora	gfx_bittbl,Y	; set bit
 1753  01:AFF5  80 03     	bra	.l1a
 1754  01:AFF7  39 D5 B0  .l1:	and	gfx_bittbl2,Y	; else mask bit
 1755  01:AFFA            .l1a:
 1756  01:AFFA  22        	sax
 1757  01:AFFB  0F FE 05  	bbr0	<__dl,.l2
 1758  01:AFFE  19 CD B0  	ora	gfx_bittbl,Y	; set bit
 1759  01:B001  80 03     	bra	.l2a
 1760  01:B003  39 D5 B0  .l2:	and	gfx_bittbl2,Y	; else mask bit
 1761  01:B006            .l2a:
 1762                     	; same as vm_rawwrite - save >14 cycles by inlining
 1763                     	;
 1764  01:B006  DA        	phx
 1765  01:B007  AA        	tax
 1766                     	vreg	#0		; video write register
       01:B008  A9 00     	lda	#0		
       01:B00A  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:B00C  03 00     	st0	#0		
                          .else
                          .endif
 1767                     	stw	<__cx,video_data	; VRAM address
       01:B00E  A5 FC     	lda	LOW_BYTE <__cx
       01:B010  8D 02 00  	sta	LOW_BYTE video_data	
       01:B013  A5 FD     	lda	HIGH_BYTE <__cx
       01:B015  8D 03 00  	sta	HIGH_BYTE video_data	
 1768                     	vreg	#2		; set R/W memory mode
       01:B018  A9 02     	lda	#2		
       01:B01A  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:B01C  03 02     	st0	#2		
                          .else
                          .endif
 1769  01:B01E  68        	pla
 1770                     	__stw	video_data	; write
       01:B01F  8E 02 00  	stx	video_data	
       01:B022  8D 03 00  	sta	video_data	+1
 1771                     	;
 1772                     	; end inline
 1773                     
 1774                     	addw	#8,<__cx		; other half of pixel
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:B025  18        	clc
       01:B026  A5 FC     	lda	LOW_BYTE <__cx		
       01:B028  69 08     	adc	LOW_BYTE #8
       01:B02A  85 FC     	sta	LOW_BYTE <__cx		
       01:B02C  A5 FD     	lda	HIGH_BYTE <__cx		
       01:B02E  69 00     	adc	HIGH_BYTE #8
       01:B030  85 FD     	sta	HIGH_BYTE <__cx		
                          .endif
 1775                     
 1776                     	; same as vm_rawread - save 21 cycles by inlining
 1777                     	;
 1778                     	vreg	#1		; video read register
       01:B032  A9 01     	lda	#1		
       01:B034  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:B036  03 01     	st0	#1		
                          .else
                          .endif
 1779                     	stw	<__cx,video_data	; VRAM address
       01:B038  A5 FC     	lda	LOW_BYTE <__cx
       01:B03A  8D 02 00  	sta	LOW_BYTE video_data	
       01:B03D  A5 FD     	lda	HIGH_BYTE <__cx
       01:B03F  8D 03 00  	sta	HIGH_BYTE video_data	
 1780                     	vreg	#2		; set R/W memory mode
       01:B042  A9 02     	lda	#2		
       01:B044  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:B046  03 02     	st0	#2		
                          .else
                          .endif
 1781                     	__ldw	video_data
                0000      .if (1 = 2)
                          .else
       01:B048  AE 02 00  	ldx	video_data
       01:B04B  AD 03 00  	lda	video_data+1
                          .endif
 1782                     	;
 1783                     	; end inline
 1784                     
 1785  01:B04E  A4 F8     	ldy	<__al		; bit offset
 1786  01:B050  3F FE 05  	bbr3	<__dl,.l3
 1787  01:B053  19 CD B0  	ora	gfx_bittbl,Y	; set bit
 1788  01:B056  80 03     	bra	.l3a
 1789  01:B058  39 D5 B0  .l3:	and	gfx_bittbl2,Y	; else mask bit
 1790  01:B05B            .l3a:
 1791  01:B05B  22        	sax
 1792  01:B05C  2F FE 05  	bbr2	<__dl,.l4
 1793  01:B05F  19 CD B0  	ora	gfx_bittbl,Y	; set bit
 1794  01:B062  80 03     	bra	.l4a
 1795  01:B064  39 D5 B0  .l4:	and	gfx_bittbl2,Y	; mask bit
 1796  01:B067            .l4a:
 1797                     	; same as vm_rawwrite - save >14 cycles by inlining
 1798                     	;
 1799  01:B067  DA        	phx
 1800  01:B068  AA        	tax
 1801                     	vreg	#0		; video write register
       01:B069  A9 00     	lda	#0		
       01:B06B  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:B06D  03 00     	st0	#0		
                          .else
                          .endif
 1802                     	stw	<__cx,video_data	; VRAM address
       01:B06F  A5 FC     	lda	LOW_BYTE <__cx
       01:B071  8D 02 00  	sta	LOW_BYTE video_data	
       01:B074  A5 FD     	lda	HIGH_BYTE <__cx
       01:B076  8D 03 00  	sta	HIGH_BYTE video_data	
 1803                     	vreg	#2		; set R/W memory mode
       01:B079  A9 02     	lda	#2		
       01:B07B  85 F7     	sta	<vdc_reg
                0001      .if (2 = ARG_IMMED)
       01:B07D  03 02     	st0	#2		
                          .else
                          .endif
 1804  01:B07F  68        	pla
 1805                     	__stw	video_data	; write
       01:B080  8E 02 00  	stx	video_data	
       01:B083  8D 03 00  	sta	video_data	+1
 1806                     	;
 1807                     	; end inline
 1808                     
 1809  01:B086  60        	rts
 1810                     
 1811                     
 1812                     ; gfx_point(int x [__bx], int y [__cx])
 1813                     ; ----
 1814                     ; Returns color of point at location (x,y)
 1815                     ; ----
 1816                     
 1817  01:B087            lib2_gfx_point.2:
 1818  01:B087  20 DD B0  	jsr	gfx_getaddr
 1819  01:B08A  64 F9     	stz	<__ah		; will be color
 1820                     	__ldw	<__cx		; VRAM address
                0000      .if (1 = 2)
                          .else
       01:B08C  A6 FC     	ldx	<__cx		
       01:B08E  A5 FD     	lda	<__cx		+1
                          .endif
 1821  01:B090  20 B8 D5  	jsr	readvram
 1822                     
 1823  01:B093  A4 F8     	ldy	<__al		; bit offset
 1824  01:B095  39 CD B0  	and	gfx_bittbl,Y
 1825  01:B098  F0 02     	beq	.l1
 1826  01:B09A  97 F9     	smb1	<__ah
 1827  01:B09C  8A        .l1:	txa
 1828  01:B09D  39 CD B0  	and	gfx_bittbl,Y
 1829  01:B0A0  F0 02     	beq	.l2
 1830  01:B0A2  87 F9     	smb0	<__ah
 1831  01:B0A4            .l2:
 1832                     	addw	#8,<__cx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:B0A4  18        	clc
       01:B0A5  A5 FC     	lda	LOW_BYTE <__cx
       01:B0A7  69 08     	adc	LOW_BYTE #8
       01:B0A9  85 FC     	sta	LOW_BYTE <__cx
       01:B0AB  A5 FD     	lda	HIGH_BYTE <__cx
       01:B0AD  69 00     	adc	HIGH_BYTE #8
       01:B0AF  85 FD     	sta	HIGH_BYTE <__cx
                          .endif
 1833                     	__ldw	<__cx		; VRAM address part 2
                0000      .if (1 = 2)
                          .else
       01:B0B1  A6 FC     	ldx	<__cx		
       01:B0B3  A5 FD     	lda	<__cx		+1
                          .endif
 1834  01:B0B5  20 B8 D5  	jsr	readvram
 1835                     
 1836  01:B0B8  A4 F8     	ldy	<__al
 1837  01:B0BA  39 CD B0  	and	gfx_bittbl,Y
 1838  01:B0BD  F0 02     	beq	.l3
 1839  01:B0BF  B7 F9     	smb3	<__ah
 1840  01:B0C1  8A        .l3:	txa
 1841  01:B0C2  39 CD B0  	and	gfx_bittbl,Y
 1842  01:B0C5  F0 02     	beq	.l4
 1843  01:B0C7  A7 F9     	smb2	<__ah
 1844  01:B0C9            .l4:
 1845  01:B0C9  A6 F9     	ldx	<__ah
 1846  01:B0CB  62        	cla
 1847  01:B0CC  60        	rts
 1848                     
 1849                     
 1850  01:B0CD            gfx_bittbl:
 1851  01:B0CD  80 40 20  	.db	$80,$40,$20,$10,$08,$04,$02,$01
       01:B0D0  10 08 04  
       01:B0D3  02 01     
 1852  01:B0D5            gfx_bittbl2:
 1853  01:B0D5  7F BF DF  	.db	$7f,$bf,$df,$ef,$f7,$fb,$fd,$fe
       01:B0D8  EF F7 FB  
       01:B0DB  FD FE     
 1854                     
 1855                     
 1856                     ; gfx_getaddr
 1857                     ; ----
 1858                     ; Utility routine to switch x/y pixel
 1859                     ; co-ordinates into VRAM addr and bit #
 1860                     ; ----
 1861                     
 1862  01:B0DD            gfx_getaddr:
 1863  01:B0DD  A5 FC     	lda	<__cl
 1864  01:B0DF  29 07     	and	#7
 1865  01:B0E1  85 F8     	sta	<__al	; al = lines from tile base
 1866                     
 1867  01:B0E3  A5 FA     	lda	<__bl
 1868  01:B0E5  29 07     	and	#7
 1869  01:B0E7  48        	pha		; = bit offset
 1870                     
 1871                     	__ldw	<__bx
                0000      .if (1 = 2)
                          .else
       01:B0E8  A6 FA     	ldx	<__bx
       01:B0EA  A5 FB     	lda	<__bx+1
                          .endif
 1872                     	__lsrw		; should be only 2 bits in MSB are possible
       01:B0EC  4A        	lsr	A
       01:B0ED  22        	sax
       01:B0EE  6A        	ror	A
       01:B0EF  22        	sax
 1873                     	__lsrw		; but we'll shift 3 times anyway
       01:B0F0  4A        	lsr	A
       01:B0F1  22        	sax
       01:B0F2  6A        	ror	A
       01:B0F3  22        	sax
 1874                     	__lsrw
       01:B0F4  4A        	lsr	A
       01:B0F5  22        	sax
       01:B0F6  6A        	ror	A
       01:B0F7  22        	sax
 1875  01:B0F8  DA        	phx		; X = character column
 1876                     
 1877                     	__ldw	<__cx
                0000      .if (1 = 2)
                          .else
       01:B0F9  A6 FC     	ldx	<__cx
       01:B0FB  A5 FD     	lda	<__cx+1
                          .endif
 1878                     	__lsrw		; should be only 2 bits in MSB are possible
       01:B0FD  4A        	lsr	A
       01:B0FE  22        	sax
       01:B0FF  6A        	ror	A
       01:B100  22        	sax
 1879                     	__lsrw		; but we'll shift 3 times anyway
       01:B101  4A        	lsr	A
       01:B102  22        	sax
       01:B103  6A        	ror	A
       01:B104  22        	sax
 1880                     	__lsrw
       01:B105  4A        	lsr	A
       01:B106  22        	sax
       01:B107  6A        	ror	A
       01:B108  22        	sax
 1881  01:B109  8A        	txa		; A = character row
 1882                     
 1883  01:B10A  FA        	plx
 1884  01:B10B  20 AF C4  	jsr	calc_vram_addr
 1885                     
 1886                     	__ldw	<__di		; to get BAT addr
                0000      .if (1 = 2)
                          .else
       01:B10E  A6 F0     	ldx	<__di		
       01:B110  A5 F1     	lda	<__di		+1
                          .endif
 1887  01:B112  20 B8 D5  	jsr	readvram	; read BAT value
 1888                     	__aslw			; change into VRAM tile addr
       01:B115  22        	sax
       01:B116  0A        	asl	A
       01:B117  22        	sax
       01:B118  2A        	rol	A
 1889                     	__aslw
       01:B119  22        	sax
       01:B11A  0A        	asl	A
       01:B11B  22        	sax
       01:B11C  2A        	rol	A
 1890                     	__aslw
       01:B11D  22        	sax
       01:B11E  0A        	asl	A
       01:B11F  22        	sax
       01:B120  2A        	rol	A
 1891                     	__aslw			; cx = VRAM addr start of tile
       01:B121  22        	sax
       01:B122  0A        	asl	A
       01:B123  22        	sax
       01:B124  2A        	rol	A
 1892                     
 1893  01:B125  22        	sax
 1894  01:B126  18        	clc			; add row within tile
 1895  01:B127  65 F8     	adc	<__al
 1896  01:B129  22        	sax
 1897  01:B12A  69 00     	adc	#0
 1898                     	__stw	<__cx
       01:B12C  86 FC     	stx	<__cx
       01:B12E  85 FD     	sta	<__cx+1
 1899                     
 1900  01:B130  68        	pla
 1901  01:B131  85 F8     	sta	<__al		; al = bit offset
 1902                     
 1903  01:B133  60        	rts
 1904                     
 1905                     ; Change back to original LIB1_BANK context
 1906                     
 1907           0000      	.bank	LIB1_BANK
 1908                     
 1909  00:D67C            _set_map_tile_type:
 1910  00:D67C  8E 20 27  	stx	maptiletype
 1911  00:D67F  60        	rts
 1912                     
 1913  00:D680            _set_map_tile_base:
 1914                     	__lsrwi 4
                0000      .if (4 = 1)
                          .else
                0000      .if (4 = 2)
                          .else
                0000      .if (4 = 8)
                          .else
       00:D680  A0 04     	ldy	#4
       00:D682  20 E3 CA  	jsr	lsrzp
                          .endif
                          .endif
                          .endif
 1915  00:D685  8E 24 27  	stx	maptilebase
 1916  00:D688  8D 25 27  	sta	maptilebase+1
 1917  00:D68B  60        	rts
 1918                     
 1919  00:D68C            _set_map_pals.1:
 1920                     	stb	<__bl, mapctablebank
       00:D68C  A5 FA     	lda	<__bl
       00:D68E  8D 28 27  	sta	mapctablebank
 1921                     	stw	<__si, mapctable
       00:D691  A5 EE     	lda	LOW_BYTE <__si
       00:D693  8D 29 27  	sta	LOW_BYTE mapctable
       00:D696  A5 EF     	lda	HIGH_BYTE <__si
       00:D698  8D 2A 27  	sta	HIGH_BYTE mapctable
 1922  00:D69B  60        	rts
#[2]   startup.asm
 1271                     
 1272           0000      .ifdef _AC
 1274                     .endif
 1275                     
 1276           0000      .ifdef _SGX
 1278                     .endif
 1279                     
#[3]   huc_math.asm
 1280                     .include "huc_math.asm"
    1                     ;
    2                     ; HUC_MATH.ASM  -  HuC Math Library
    3                     ;
    4                     
    5                     ; abs(int val)
    6                     ; ---
    7                     
    8  00:D69C            _abs:
    9  00:D69C  A8        	tay
   10  00:D69D  10 0B     	bpl	.l1
   11  00:D69F  22        	sax
   12  00:D6A0  49 FF     	eor	#$FF
   13                     	add	#1
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       00:D6A2  18        	clc
       00:D6A3  69 01     	adc	#1
                          .endif
   14  00:D6A5  22        	sax
   15  00:D6A6  49 FF     	eor	#$FF
   16  00:D6A8  69 00     	adc	#0
   17  00:D6AA            .l1:
   18  00:D6AA  60        	rts
   19                     
   20                     ; mov32(void *dst [__di], void *src)
   21                     ; ----
   22                     
   23  00:D6AB            _mov32.2:
   24                     	__stw	<__si
       00:D6AB  86 EE     	stx	<__si
       00:D6AD  85 EF     	sta	<__si+1
   25  00:D6AF            _mov32.sub:
   26  00:D6AF  A0 03     	ldy	#3
   27  00:D6B1  B1 EE     .l1:	lda	[__si],Y
   28  00:D6B3  91 F0     	sta	[__di],Y
   29  00:D6B5  88        	dey
   30  00:D6B6  10 F9     	bpl	.l1
   31  00:D6B8  60        	rts
   32                     
   33                     ; add32(void *dst [__di], void *src) /* ax|bx */
   34                     ; ----
   35                     
   36  00:D6B9            _add32.2:
   37                     	__stw	<__si
       00:D6B9  86 EE     	stx	<__si
       00:D6BB  85 EF     	sta	<__si+1
   38  00:D6BD  18        	clc
   39  00:D6BE  C2        	cly
   40  00:D6BF  A2 04     	ldx	#4
   41  00:D6C1  B1 F0     .l1:	lda	[__di],Y
   42  00:D6C3  71 EE     	adc	[__si],Y
   43  00:D6C5  91 F0     	sta	[__di],Y
   44  00:D6C7  C8        	iny
   45  00:D6C8  CA        	dex
   46  00:D6C9  D0 F6     	bne	.l1
   47  00:D6CB  60        	rts
   48                     
   49                     ; sub32(void *dst [__di], void *src)
   50                     ; ----
   51                     
   52  00:D6CC            _sub32.2:
   53                     	__stw	<__si
       00:D6CC  86 EE     	stx	<__si
       00:D6CE  85 EF     	sta	<__si+1
   54  00:D6D0  38        	sec
   55  00:D6D1  C2        	cly
   56  00:D6D2  A2 04     	ldx	#4
   57  00:D6D4  B1 F0     .l1:	lda	[__di],Y
   58  00:D6D6  F1 EE     	sbc	[__si],Y
   59  00:D6D8  91 F0     	sta	[__di],Y
   60  00:D6DA  C8        	iny
   61  00:D6DB  CA        	dex
   62  00:D6DC  D0 F6     	bne	.l1
   63  00:D6DE  60        	rts
   64                     
   65                     ; mul32(void *dst [__bp], void *src)
   66                     ; ----
   67                     
   68  00:D6DF            _mul32.2:
   69                     	__stw	<__si
       00:D6DF  86 EE     	stx	<__si
       00:D6E1  85 EF     	sta	<__si+1
   70                     	stw	#__ax,<__di
       00:D6E3  A9 F8     	lda	LOW_BYTE #__ax
       00:D6E5  85 F0     	sta	LOW_BYTE <__di
       00:D6E7  A9 20     	lda	HIGH_BYTE #__ax
       00:D6E9  85 F1     	sta	HIGH_BYTE <__di
   71  00:D6EB  20 AF D6  	jsr	_mov32.sub
   72                     	stw	<__bp,<__si
       00:D6EE  A5 EC     	lda	LOW_BYTE <__bp
       00:D6F0  85 EE     	sta	LOW_BYTE <__si
       00:D6F2  A5 ED     	lda	HIGH_BYTE <__bp
       00:D6F4  85 EF     	sta	HIGH_BYTE <__si
   73                     	stw	#__cx,<__di
       00:D6F6  A9 FC     	lda	LOW_BYTE #__cx
       00:D6F8  85 F0     	sta	LOW_BYTE <__di
       00:D6FA  A9 20     	lda	HIGH_BYTE #__cx
       00:D6FC  85 F1     	sta	HIGH_BYTE <__di
   74  00:D6FE  20 AF D6  	jsr	_mov32.sub
   75  00:D701  20 A9 C6  	jsr	mulu32
   76                     	stw	<__bp,<__di
       00:D704  A5 EC     	lda	LOW_BYTE <__bp
       00:D706  85 F0     	sta	LOW_BYTE <__di
       00:D708  A5 ED     	lda	HIGH_BYTE <__bp
       00:D70A  85 F1     	sta	HIGH_BYTE <__di
   77                     	stw	#__cx,<__si
       00:D70C  A9 FC     	lda	LOW_BYTE #__cx
       00:D70E  85 EE     	sta	LOW_BYTE <__si
       00:D710  A9 20     	lda	HIGH_BYTE #__cx
       00:D712  85 EF     	sta	HIGH_BYTE <__si
   78  00:D714  4C AF D6  	jmp	_mov32.sub
   79                     
   80                     ; div32(void *dst [__di], void *src)
   81                     ; ----
   82                     
   83  00:D717            _div32.2:
   84  00:D717  60        	rts
   85                     
   86                     ; com32(void *dst)
   87                     ; ----
   88                     
   89  00:D718            _com32.1:
   90                     	__stw	<__di
       00:D718  86 F0     	stx	<__di
       00:D71A  85 F1     	sta	<__di+1
   91  00:D71C  A0 03     	ldy	#3
   92  00:D71E  B1 F0     .l1:	lda	[__di],Y
   93  00:D720  49 FF     	eor	#$FF
   94  00:D722  91 F0     	sta	[__di],Y
   95  00:D724  88        	dey
   96  00:D725  10 F7     	bpl	.l1
   97  00:D727  60        	rts
   98                     	
   99                     ; cmp32(void *dst [__di], void *src)
  100                     ; ----
  101                     
  102  00:D728            _cmp32.2:
  103                     	__stw	<__si
       00:D728  86 EE     	stx	<__si
       00:D72A  85 EF     	sta	<__si+1
  104  00:D72C  A0 03     	ldy	#3
  105  00:D72E  B1 F0     .l1:	lda	[__di],Y
  106  00:D730  D1 EE     	cmp	[__si],Y
  107  00:D732  D0 06     	bne	.l2
  108  00:D734  88        	dey
  109  00:D735  10 F7     	bpl	.l1
  110                     	; --
  111  00:D737  82        	clx
  112  00:D738  62        	cla
  113  00:D739  60        	rts
  114                     	; --
  115                     .l2:	blo	.l3
       00:D73A  90 04     	bcc	.l3
  116  00:D73C  A2 01     	ldx	#$01
  117  00:D73E  62        	cla
  118  00:D73F  60        	rts
  119                     	; --
  120  00:D740  A2 FF     .l3:	ldx	#$FF
  121  00:D742  8A        	txa
  122  00:D743  60        	rts
  123                     
  124                     
  125           0000      .ifdef BCD
  290                     .endif ; BCD
#[2]   startup.asm
#[3]   huc_bram.asm
 1281                     .include "huc_bram.asm"
    1                     ;
    2                     ; HUC_BRAM.ASM  -  HuC Backup RAM Library
    3                     ;
    4                     
    5           29C2      	.bss
    6  --:29C2            bm_mpr4:	.ds 1
    7  --:29C3            bm_error:	.ds 1
    8           D744      	.code
    9                     
   10                     ; NOTE: the BRAM format is as follows:
   11                     ;
   12                     ; BRAM bank header (0x10 bytes):
   13                     ; ------------------------------
   14                     ; - Header tag (4 bytes) = 'HUBM'
   15                     ;
   16                     ; - Pointer to 1st byte after BRAM (2 byte int)
   17                     ;   Note: relative to 0x8000 segment, hex example: 00 88 ($8800)
   18                     ;
   19                     ; - Pointer to next available BRAM slot (2 byte int)
   20                     ;   Note: relative to 0x8000 segment, hex example: 22 80 ($8022)
   21                     ;
   22                     ; - Zeroes (8 bytes)
   23                     ;
   24                     ; BRAM Entry Header (0x10 bytes):
   25                     ; -------------------------------
   26                     ; - Size of entry (2 bytes), hex example: 12 00 ($0012)
   27                     ;   This size includes the 0x10 bytes used by this header information
   28                     ;
   29                     ; - Checksum (2 bytes)
   30                     ;   This number added to the data should total to 0
   31                     ;
   32                     ; - Name (12 bytes)
   33                     ;   This subdivides into:
   34                     ;   - Unique ID (2 bytes); I have only ever seen 00 00 in this entry
   35                     ;     However, it appears to be an integral part of the name
   36                     ;   - ASCII Name (10 bytes)
   37                     ;     This should be padded with spaces
   38                     ;
   39                     ; BRAM Entry:
   40                     ; -----------
   41                     ; - Miscellaneous data, size described by header parameters
   42                     ;
   43                     ; BRAM Entry Trailer (0x02 bytes):
   44                     ; --------------------------------
   45                     ; - Zeores (2 bytes)
   46                     ;   Technically, this trailer is "not used", but rather a terminator
   47                     ;   to the linked list.  The BRAM bank header points at it by the
   48                     ;   'next available slot' pointer
   49                     ;
   50                     
   51                     
   52                     ; bm_check()
   53                     ; ---
   54                     ; Determine whether BRAM exists on this system
   55                     ; without damaging contents on BRAM
   56                     ;
   57                     
   58  00:D744            _bm_check:
   59  00:D744  20 75 D9  	jsr	_bm_unlock
   60                     
   61                     	stw	#$8000,<__di	; test area at $8000
       00:D747  A9 00     	lda	LOW_BYTE #$8000
       00:D749  85 F0     	sta	LOW_BYTE <__di	
       00:D74B  A9 80     	lda	HIGH_BYTE #$8000
       00:D74D  85 F1     	sta	HIGH_BYTE <__di	
   62  00:D74F  20 65 D7  	jsr	_bm_testram
   63                     
   64                     	; -- result
   65  00:D752  20 63 D9  	jsr	_bm_disable
   66  00:D755  E0 00     	cpx	#0
   67  00:D757  D0 08     	bne	.err
   68                     	; -- ok
   69  00:D759  9C C3 29  	stz	bm_error
   70  00:D75C  A2 01     	ldx	#1
   71  00:D75E  62        	cla
   72  00:D75F  18        	clc
   73  00:D760  60        	rts
   74                     	; -- no bram
   75  00:D761  82        .err:	clx
   76  00:D762  62        	cla
   77  00:D763  38        	sec
   78  00:D764  60        	rts
   79                     
   80                     
   81                     ; bm_testram
   82                     ; ---
   83                     ; internal function to test whether BRAM exists at a location
   84                     ; input  = di (pointer to memory area to test)
   85                     ; output = register x (# errors)
   86                     ;
   87                     
   88  00:D765            _bm_testram:
   89                     	; -- swap bits
   90  00:D765  A0 07     	ldy	#7
   91  00:D767  B1 F0     .l1:	lda	[__di],Y
   92  00:D769  49 FF     	eor	#$FF
   93  00:D76B  99 F8 20  	sta	__ax,Y
   94  00:D76E  91 F0     	sta	[__di],Y
   95  00:D770  88        	dey
   96  00:D771  10 F4     	bpl	.l1
   97                     	; -- cmp
   98  00:D773  82        	clx
   99  00:D774  A0 07     	ldy	#7
  100  00:D776  B9 F8 20  .l2:	lda	__ax,Y
  101  00:D779  D1 F0     	cmp	[__di],Y
  102  00:D77B  F0 01     	beq	.l3
  103  00:D77D  E8        	inx
  104  00:D77E  49 FF     .l3:	eor	#$FF
  105  00:D780  91 F0     	sta	[__di],Y
  106  00:D782  88        	dey
  107  00:D783  10 F1     	bpl	.l2
  108                     
  109  00:D785  60        	rts
  110                     
  111                     
  112                     ; bm_format()
  113                     ; ---
  114                     ; If BRAM is already formatted (*_PROPERLY_*), return OK
  115                     ; Otherwise, set header info, and set limit of BRAM to
  116                     ; maximum amount of memory available on this hardware
  117                     ;
  118                     
  119  00:D786            _bm_format:
  120  00:D786  20 51 D9  	jsr	_bm_enable
  121  00:D789  90 30     	bcc	.ok
  122                     	; -- format
  123  00:D78B  A2 07     	ldx	#7
  124  00:D78D  BD DD D8  .l1:	lda	_bm_id,X
  125  00:D790  9D 00 80  	sta	$8000,X
  126  00:D793  CA        	dex
  127  00:D794  10 F7     	bpl	.l1
  128  00:D796  9C 10 80  	stz	$8010
  129  00:D799  9C 11 80  	stz	$8011
  130                     
  131                     	stw	#$8000,<__di	; test area at $8000
       00:D79C  A9 00     	lda	LOW_BYTE #$8000
       00:D79E  85 F0     	sta	LOW_BYTE <__di	
       00:D7A0  A9 80     	lda	HIGH_BYTE #$8000
       00:D7A2  85 F1     	sta	HIGH_BYTE <__di	
  132  00:D7A4  20 65 D7  .l2:	jsr	_bm_testram
  133  00:D7A7  E0 00     	cpx	#0
  134  00:D7A9  D0 0B     	bne	.setsz
  135  00:D7AB  A5 F1     	lda	<__di+1
  136  00:D7AD  C9 A0     	cmp	#$A0		; and keep going until either
  137  00:D7AF  F0 05     	beq	.setsz		; (a) bad memory, or
  138  00:D7B1  1A        	inc	A		; (b) next bank
  139  00:D7B2  85 F1     	sta	<__di+1
  140  00:D7B4  80 EE     	bra	.l2
  141                     
  142  00:D7B6  A5 F1     .setsz:	lda	<__di+1
  143  00:D7B8  8D 05 80  	sta	$8005
  144                     
  145                     	; -- ok
  146  00:D7BB  20 63 D9  .ok:	jsr	_bm_disable
  147  00:D7BE  9C C3 29  	stz	bm_error
  148  00:D7C1  82        	clx
  149  00:D7C2  62        	cla
  150  00:D7C3  18        	clc
  151  00:D7C4  60        	rts
  152                     
  153                     
  154                     ; bm_free()
  155                     ; ---
  156                     ; Returns (int) number of user bytes available in BRAM
  157                     ; BRAM header entry and trailer overhead is already deducted
  158                     ;
  159                     
  160  00:D7C5            _bm_free:
  161  00:D7C5  20 51 D9  	jsr	_bm_enable
  162  00:D7C8  B0 3A     	bcs	.err
  163                     	; -- calculate free space
  164                     	stw	$8004,<__cx
       00:D7CA  AD 04 80  	lda	LOW_BYTE $8004
       00:D7CD  85 FC     	sta	LOW_BYTE <__cx
       00:D7CF  AD 05 80  	lda	HIGH_BYTE $8004
       00:D7D2  85 FD     	sta	HIGH_BYTE <__cx
  165                     	subw	$8006,<__cx
       00:D7D4  38        	sec
       00:D7D5  A5 FC     	lda	LOW_BYTE <__cx
       00:D7D7  ED 06 80  	sbc	LOW_BYTE $8006
       00:D7DA  85 FC     	sta	LOW_BYTE <__cx
       00:D7DC  A5 FD     	lda	HIGH_BYTE <__cx
       00:D7DE  ED 07 80  	sbc	HIGH_BYTE $8006
       00:D7E1  85 FD     	sta	HIGH_BYTE <__cx
  166                     	subw	#$12,<__cx
       00:D7E3  38        	sec
       00:D7E4  A5 FC     	lda	LOW_BYTE <__cx
       00:D7E6  E9 12     	sbc	LOW_BYTE #$12
       00:D7E8  85 FC     	sta	LOW_BYTE <__cx
       00:D7EA  A5 FD     	lda	HIGH_BYTE <__cx
       00:D7EC  E9 00     	sbc	HIGH_BYTE #$12
       00:D7EE  85 FD     	sta	HIGH_BYTE <__cx
  167  00:D7F0  A5 FD     	lda	<__ch
  168  00:D7F2  10 04     	bpl	.ok
  169                     	stwz	<__cx
       00:D7F4  64 FC     	stz	LOW_BYTE <__cx
       00:D7F6  64 FD     	stz	HIGH_BYTE <__cx
  170                     	; -- ok
  171  00:D7F8  20 63 D9  .ok:	jsr	_bm_disable
  172  00:D7FB  9C C3 29  	stz	bm_error
  173                     	__ldw	<__cx
                0000      .if (1 = 2)
                          .else
       00:D7FE  A6 FC     	ldx	<__cx
       00:D800  A5 FD     	lda	<__cx+1
                          .endif
  174  00:D802  18        	clc
  175  00:D803  60        	rts
  176                     	; -- error, bram not formatted
  177  00:D804  8D C3 29  .err:	sta	bm_error
  178  00:D807  20 63 D9  	jsr	_bm_disable
  179  00:D80A  A9 FF     	lda	#$FF
  180  00:D80C  AA        	tax
  181  00:D80D  38        	sec
  182  00:D80E  60        	rts
  183                     
  184                     
  185                     ; bm_size()
  186                     ; ---
  187                     ; Returns (int) number of bytes in BRAM - should normally
  188                     ; be 2K, but can be as large as 8KB
  189                     
  190  00:D80F            _bm_size:
  191  00:D80F  20 51 D9  	jsr	_bm_enable
  192  00:D812  B0 33     	bcs	.err
  193                     	; -- calculate free space
  194                     	stw	$8004,<__cx
       00:D814  AD 04 80  	lda	LOW_BYTE $8004
       00:D817  85 FC     	sta	LOW_BYTE <__cx
       00:D819  AD 05 80  	lda	HIGH_BYTE $8004
       00:D81C  85 FD     	sta	HIGH_BYTE <__cx
  195                     	subw	#$8000,<__cx
       00:D81E  38        	sec
       00:D81F  A5 FC     	lda	LOW_BYTE <__cx
       00:D821  E9 00     	sbc	LOW_BYTE #$8000
       00:D823  85 FC     	sta	LOW_BYTE <__cx
       00:D825  A5 FD     	lda	HIGH_BYTE <__cx
       00:D827  E9 80     	sbc	HIGH_BYTE #$8000
       00:D829  85 FD     	sta	HIGH_BYTE <__cx
  196  00:D82B  A5 FD     	lda	<__ch
  197  00:D82D  C9 21     	cmp	#$21
  198  00:D82F  B0 14     	bcs	.err1
  199  00:D831  A5 FD     	lda	<__ch
  200  00:D833  10 04     	bpl	.ok
  201                     	stwz	<__cx
       00:D835  64 FC     	stz	LOW_BYTE <__cx
       00:D837  64 FD     	stz	HIGH_BYTE <__cx
  202                     	; -- ok
  203  00:D839  20 63 D9  .ok:	jsr	_bm_disable
  204  00:D83C  9C C3 29  	stz	bm_error
  205                     	__ldw	<__cx
                0000      .if (1 = 2)
                          .else
       00:D83F  A6 FC     	ldx	<__cx
       00:D841  A5 FD     	lda	<__cx+1
                          .endif
  206  00:D843  18        	clc
  207  00:D844  60        	rts
  208                     	; -- error, bram not formatted
  209  00:D845  A9 FF     .err1:	lda	#$ff
  210  00:D847  8D C3 29  .err:	sta	bm_error
  211  00:D84A  20 63 D9  	jsr	_bm_disable
  212  00:D84D  A9 FF     	lda	#$FF
  213  00:D84F  AA        	tax
  214  00:D850  38        	sec
  215  00:D851  60        	rts
  216                     
  217                     
  218                     ; bm_rawread(int location)
  219                     ; ---
  220                     ; Similar to peek(), but for BRAM
  221                     ; Automatically handles mapping of memory ; and address range
  222                     ;
  223  00:D852            _bm_rawread:
  224                     	__stw	<__bx
       00:D852  86 FA     	stx	<__bx
       00:D854  85 FB     	sta	<__bx+1
  225  00:D856  A5 FB     	lda	<__bh
  226  00:D858  29 1F     	and	#$1F
  227  00:D85A  09 80     	ora	#$80
  228  00:D85C  85 FB     	sta	<__bh
  229  00:D85E  20 51 D9  	jsr	_bm_enable
  230  00:D861  B0 0C     	bcs	.err
  231  00:D863  B2 FA     	lda	[__bx]
  232  00:D865  22        	sax
  233  00:D866  9C C3 29  	stz	bm_error
  234  00:D869  20 63 D9  	jsr	_bm_disable
  235  00:D86C  62        	cla
  236  00:D86D  18        	clc
  237  00:D86E  60        	rts
  238  00:D86F  8D C3 29  .err:	sta	bm_error
  239  00:D872  20 63 D9  	jsr	_bm_disable
  240  00:D875  38        	sec
  241  00:D876  60        	rts
  242                     
  243                     
  244                     ; bm_rawwrite(int location [__bx], char val [reg acc])
  245                     ; ---
  246                     ; Similar to peek(), but for BRAM
  247                     ; Automatically handles mapping of memory ; and address range
  248                     ;
  249  00:D877            _bm_rawwrite.2:
  250                     	__stw	<__ax
       00:D877  86 F8     	stx	<__ax
       00:D879  85 F9     	sta	<__ax+1
  251  00:D87B  A5 FB     	lda	<__bh
  252  00:D87D  29 1F     	and	#$1F
  253  00:D87F  09 80     	ora	#$80
  254  00:D881  85 FB     	sta	<__bh
  255  00:D883  20 51 D9  	jsr	_bm_enable
  256  00:D886  B0 0E     	bcs	.err
  257  00:D888  A5 F8     	lda	<__al
  258  00:D88A  92 FA     	sta	[__bx]
  259  00:D88C  9C C3 29  	stz	bm_error
  260  00:D88F  20 63 D9  	jsr	_bm_disable
  261  00:D892  62        	cla
  262  00:D893  82        	clx
  263  00:D894  18        	clc
  264  00:D895  60        	rts
  265  00:D896  8D C3 29  .err:	sta	bm_error
  266  00:D899  20 63 D9  	jsr	_bm_disable
  267  00:D89C  38        	sec
  268  00:D89D  60        	rts
  269                     
  270                     
  271                     ; bm_exist(char *name)
  272                     ; ---
  273                     ; Check for existence of BRAM file with a matching name
  274                     ; Note: name is 12 bytes; first 2 bytes are a uniqueness value
  275                     ;       (should be zeroes), and the next10 bytes are ASCII name
  276                     ;       with trailing spaces as padding
  277                     ;
  278                     
  279  00:D89E            _bm_exist:
  280                     	__stw	<__bx
       00:D89E  86 FA     	stx	<__bx
       00:D8A0  85 FB     	sta	<__bx+1
  281  00:D8A2  20 3F D9  	jsr	_bm_open
  282  00:D8A5  B0 0A     	bcs	.l1
  283  00:D8A7  20 63 D9  	jsr	_bm_disable
  284  00:D8AA  A2 01     	ldx	#1
  285  00:D8AC  AD C3 29  	lda	bm_error
  286  00:D8AF  F0 02     	beq	.noerr
  287  00:D8B1  82        .l1:	clx
  288  00:D8B2  62        	cla
  289  00:D8B3  60        .noerr:	rts
  290                     
  291                     
  292                     ; bm_sizeof(char *name)
  293                     ; ---
  294                     ; Return the size of the user data in a RAM file with the given name
  295                     ; Note: name is 12 bytes; first 2 bytes are a uniqueness value
  296                     ;       (should be zeroes), and the next10 bytes are ASCII name
  297                     ;       with trailing spaces as padding
  298                     ;
  299                     
  300  00:D8B4            _bm_sizeof:
  301                     	__stw	<__bx
       00:D8B4  86 FA     	stx	<__bx
       00:D8B6  85 FB     	sta	<__bx+1
  302  00:D8B8  20 3F D9  	jsr	_bm_open
  303  00:D8BB  B0 18     	bcs	.l1
  304                     	subw	#$10,<__cx
       00:D8BD  38        	sec
       00:D8BE  A5 FC     	lda	LOW_BYTE <__cx
       00:D8C0  E9 10     	sbc	LOW_BYTE #$10
       00:D8C2  85 FC     	sta	LOW_BYTE <__cx
       00:D8C4  A5 FD     	lda	HIGH_BYTE <__cx
       00:D8C6  E9 00     	sbc	HIGH_BYTE #$10
       00:D8C8  85 FD     	sta	HIGH_BYTE <__cx
  305  00:D8CA  20 63 D9  	jsr	_bm_disable
  306  00:D8CD  9C C3 29  	stz	bm_error
  307  00:D8D0  A6 FC     	ldx	<__cl
  308  00:D8D2  A5 FD     	lda	<__ch
  309  00:D8D4  60        	rts
  310  00:D8D5  82        .l1:	clx
  311  00:D8D6  62        	cla
  312  00:D8D7  60        	rts
  313                     
  314                     
  315                     ; bm_errno()
  316                     ; ---
  317                     ; Return error type
  318                     ;
  319                     
  320  00:D8D8            _bm_errno:
  321  00:D8D8  AE C3 29  	ldx	bm_error
  322  00:D8DB  62        	cla
  323  00:D8DC  60        	rts
  324                     
  325                     
  326  00:D8DD            _bm_id:
  327  00:D8DD  48 55 42  	.db	$48,$55,$42,$4D
       00:D8E0  4D        
  328  00:D8E1  00 88 10  	.db	$00,$88,$10,$80
       00:D8E4  80        
  329                     
  330                     
  331                     ; ------------------------
  332                     
  333                     ; bm_getptr(int ptr [__bp], char *namebuf [reg acc])
  334                     ; ---
  335                     ; Given a pointer with the BRAM, obtain the name of the entry
  336                     ; and the pointer to the next entry
  337                     ; Use BRAM_START for first entry
  338                     ;
  339                     
  340  00:D8E5            _bm_getptr.2:
  341                     	maplibfunc	lib2_bm_getptr.2
       00:D8E5  A8        	tay
       00:D8E6  43 20     	tma	#page(lib2_bm_getptr.2)
       00:D8E8  48        	pha
       00:D8E9  A9 81     	lda	#bank(lib2_bm_getptr.2)
       00:D8EB  53 20     	tam	#page(lib2_bm_getptr.2)
       00:D8ED  98        	tya
       00:D8EE  20 34 B1  	jsr	lib2_bm_getptr.2
       00:D8F1  A8        	tay
       00:D8F2  68        	pla
       00:D8F3  53 20     	tam	#page(lib2_bm_getptr.2)
       00:D8F5  98        	tya
  342  00:D8F6  60        	rts
  343                     
  344                     
  345                     ; bm_delete(char *namebuf)
  346                     ; ---
  347                     ; Delete the entry specified by the name provided
  348                     ;
  349                     
  350  00:D8F7            _bm_delete:
  351                     	maplibfunc	lib2_bm_delete
       00:D8F7  A8        	tay
       00:D8F8  43 20     	tma	#page(lib2_bm_delete)
       00:D8FA  48        	pha
       00:D8FB  A9 81     	lda	#bank(lib2_bm_delete)
       00:D8FD  53 20     	tam	#page(lib2_bm_delete)
       00:D8FF  98        	tya
       00:D900  20 8A B1  	jsr	lib2_bm_delete
       00:D903  A8        	tay
       00:D904  68        	pla
       00:D905  53 20     	tam	#page(lib2_bm_delete)
       00:D907  98        	tya
  352  00:D908  60        	rts
  353                     
  354                     
  355                     ; bm_read(char *buf [__di], char *name [__bx], int offset [__bp], int nb)
  356                     ; ---
  357                     ; Given a name of a file, grab some info from the file
  358                     ;
  359                     
  360  00:D909            _bm_read.4:
  361                     	maplibfunc	lib2_bm_read.4
       00:D909  A8        	tay
       00:D90A  43 20     	tma	#page(lib2_bm_read.4)
       00:D90C  48        	pha
       00:D90D  A9 81     	lda	#bank(lib2_bm_read.4)
       00:D90F  53 20     	tam	#page(lib2_bm_read.4)
       00:D911  98        	tya
       00:D912  20 E9 B1  	jsr	lib2_bm_read.4
       00:D915  A8        	tay
       00:D916  68        	pla
       00:D917  53 20     	tam	#page(lib2_bm_read.4)
       00:D919  98        	tya
  362  00:D91A  60        	rts
  363                     
  364                     
  365                     ; bm_write(char *buf [__di], char *name [__bx], int offset [__bp], int nb)
  366                     ; ---
  367                     ; Given the name of a BRAM file, update some info inside of it
  368                     ;
  369                     
  370  00:D91B            _bm_write.4:
  371                     	maplibfunc	lib2_bm_write.4
       00:D91B  A8        	tay
       00:D91C  43 20     	tma	#page(lib2_bm_write.4)
       00:D91E  48        	pha
       00:D91F  A9 81     	lda	#bank(lib2_bm_write.4)
       00:D921  53 20     	tam	#page(lib2_bm_write.4)
       00:D923  98        	tya
       00:D924  20 38 B2  	jsr	lib2_bm_write.4
       00:D927  A8        	tay
       00:D928  68        	pla
       00:D929  53 20     	tam	#page(lib2_bm_write.4)
       00:D92B  98        	tya
  372  00:D92C  60        	rts
  373                     
  374                     
  375                     ; bm_create(char *name [__bx], int size)
  376                     ; ---
  377                     ; Create a new BRAM file, given the name and size
  378                     
  379  00:D92D            _bm_create.2:
  380                     	maplibfunc	lib2_bm_create.2
       00:D92D  A8        	tay
       00:D92E  43 20     	tma	#page(lib2_bm_create.2)
       00:D930  48        	pha
       00:D931  A9 81     	lda	#bank(lib2_bm_create.2)
       00:D933  53 20     	tam	#page(lib2_bm_create.2)
       00:D935  98        	tya
       00:D936  20 77 B2  	jsr	lib2_bm_create.2
       00:D939  A8        	tay
       00:D93A  68        	pla
       00:D93B  53 20     	tam	#page(lib2_bm_create.2)
       00:D93D  98        	tya
  381  00:D93E  60        	rts
  382                     
  383                     
  384                     ; bm_open(char *name [__bx])
  385                     ; ---
  386                     ; Internal function to obtain access to a named file
  387                     
  388  00:D93F            _bm_open:
  389                     	maplibfunc	lib2_bm_open
       00:D93F  A8        	tay
       00:D940  43 20     	tma	#page(lib2_bm_open)
       00:D942  48        	pha
       00:D943  A9 81     	lda	#bank(lib2_bm_open)
       00:D945  53 20     	tam	#page(lib2_bm_open)
       00:D947  98        	tya
       00:D948  20 37 B3  	jsr	lib2_bm_open
       00:D94B  A8        	tay
       00:D94C  68        	pla
       00:D94D  53 20     	tam	#page(lib2_bm_open)
       00:D94F  98        	tya
  390  00:D950  60        	rts
  391                     
  392                     
  393                     ; bm_enable()
  394                     ; ---
  395                     ; Internal function to enable the BRAM area and do a quick check
  396                     
  397  00:D951            _bm_enable:
  398                     	maplibfunc	lib2_bm_enable
       00:D951  A8        	tay
       00:D952  43 20     	tma	#page(lib2_bm_enable)
       00:D954  48        	pha
       00:D955  A9 81     	lda	#bank(lib2_bm_enable)
       00:D957  53 20     	tam	#page(lib2_bm_enable)
       00:D959  98        	tya
       00:D95A  20 BA B3  	jsr	lib2_bm_enable
       00:D95D  A8        	tay
       00:D95E  68        	pla
       00:D95F  53 20     	tam	#page(lib2_bm_enable)
       00:D961  98        	tya
  399  00:D962  60        	rts
  400                     
  401                     
  402                     ; bm_disable()
  403                     ; ---
  404                     ; This internal function handles the fixup of BRAM segment/locking
  405                     
  406  00:D963            _bm_disable:
  407                     	maplibfunc	lib2_bm_disable
       00:D963  A8        	tay
       00:D964  43 20     	tma	#page(lib2_bm_disable)
       00:D966  48        	pha
       00:D967  A9 81     	lda	#bank(lib2_bm_disable)
       00:D969  53 20     	tam	#page(lib2_bm_disable)
       00:D96B  98        	tya
       00:D96C  20 EC B3  	jsr	lib2_bm_disable
       00:D96F  A8        	tay
       00:D970  68        	pla
       00:D971  53 20     	tam	#page(lib2_bm_disable)
       00:D973  98        	tya
  408  00:D974  60        	rts
  409                     
  410                     
  411                     ; bm_unlock()
  412                     ; ---
  413                     ; This internal function handles only the map/unlock of the BRAM area
  414                     
  415  00:D975            _bm_unlock:
  416                     	maplibfunc	lib2_bm_unlock
       00:D975  A8        	tay
       00:D976  43 20     	tma	#page(lib2_bm_unlock)
       00:D978  48        	pha
       00:D979  A9 81     	lda	#bank(lib2_bm_unlock)
       00:D97B  53 20     	tam	#page(lib2_bm_unlock)
       00:D97D  98        	tya
       00:D97E  20 D1 B3  	jsr	lib2_bm_unlock
       00:D981  A8        	tay
       00:D982  68        	pla
       00:D983  53 20     	tam	#page(lib2_bm_unlock)
       00:D985  98        	tya
  417  00:D986  60        	rts
  418                     
  419                     
  420                     ; ---------------
  421                     
  422                     ;
  423                     ; From here, we have the implementation of various
  424                     ; BRAM routines in LIB2_BANK rather than LIB1_BANK
  425                     ; for reasons of speed and size
  426                     ;
  427                     ; Their external linkages will have specified above
  428                     ; and be begin with an underscore.  The private
  429                     ; definitions will not have an underscore
  430                     ;
  431                     
  432           0001      	.bank	LIB2_BANK
  433                     
  434                     ; bm_getptr(int ptr [__bp], char *namebuf [reg acc])
  435                     ; ---
  436                     ; Given a pointer with the BRAM, obtain the name of the entry
  437                     ; and the pointer to the next entry
  438                     ; Use BRAM_START for first entry
  439                     ;
  440                     
  441  01:B134            lib2_bm_getptr.2:
  442                     	__stw	<__di		; namebuf is destination of a copy
       01:B134  86 F0     	stx	<__di		
       01:B136  85 F1     	sta	<__di		+1
  443  01:B138  20 BA B3  	jsr	lib2_bm_enable
  444  01:B13B  B0 43     	bcs	.x2
  445                     
  446                     	tstw	<__bp		; error - 0 input
       01:B13D  A5 EC     	lda	<__bp				; value at stated memory
       01:B13F  05 ED     	ora	<__bp		+1		; location is zero
  447  01:B141  F0 3D     	beq	.x2
  448  01:B143  B2 EC     	lda	[__bp]
  449  01:B145  85 FC     	sta	<__cl
  450  01:B147  A0 01     	ldy	#1
  451  01:B149  B1 EC     	lda	[__bp],Y
  452  01:B14B  85 FD     	sta	<__ch		; <__cx is length of entry
  453                     	tstw	<__cx
       01:B14D  A5 FC     	lda	<__cx		; value at stated memory
       01:B14F  05 FD     	ora	<__cx+1		; location is zero
  454  01:B151  F0 2C     	beq	.empty
  455                     
  456                     	addw	#4,<__bp,<__si	; <__si is now ptr to name of current entry
                0001      .if	(3 = 3)
                          	; 3-arg mode
                          	;
       01:B153  18        	clc
       01:B154  A5 EC     	lda	LOW_BYTE <__bp
       01:B156  69 04     	adc	LOW_BYTE #4
       01:B158  85 EE     	sta	LOW_BYTE <__si	
       01:B15A  A5 ED     	lda	HIGH_BYTE <__bp
       01:B15C  69 00     	adc	HIGH_BYTE #4
       01:B15E  85 EF     	sta	HIGH_BYTE <__si	
                          .else
                          .endif
  457  01:B160  62        	cla
  458  01:B161  A2 0C     	ldx	#12
  459  01:B163  20 7B C5  	jsr	_memcpy.3	; copy 12 bytes of name to namebuf
  460                     	addw	<__cx,<__bp,<__ax	; next pointer
                0001      .if	(3 = 3)
                          	; 3-arg mode
                          	;
       01:B166  18        	clc
       01:B167  A5 EC     	lda	LOW_BYTE <__bp
       01:B169  65 FC     	adc	LOW_BYTE <__cx
       01:B16B  85 F8     	sta	LOW_BYTE <__ax	
       01:B16D  A5 ED     	lda	HIGH_BYTE <__bp
       01:B16F  65 FD     	adc	HIGH_BYTE <__cx
       01:B171  85 F9     	sta	HIGH_BYTE <__ax	
                          .else
                          .endif
  461  01:B173  20 EC B3  	jsr	lib2_bm_disable
  462  01:B176  9C C3 29  	stz	bm_error
  463  01:B179  A5 F9     	lda	<__ah
  464  01:B17B  A6 F8     	ldx	<__al
  465  01:B17D  18        	clc
  466  01:B17E  60        	rts
  467                     
  468  01:B17F  62        .empty:	cla
  469                     
  470                     	; -- error, bram not formatted
  471  01:B180  8D C3 29  .x2:	sta	bm_error
  472  01:B183  20 EC B3  	jsr	lib2_bm_disable
  473  01:B186  62        	cla
  474  01:B187  82        	clx
  475  01:B188  38        	sec
  476  01:B189  60        	rts
  477                     
  478                     
  479                     ; bm_delete(char *namebuf)
  480                     ; ---
  481                     ; Delete the entry specified by the name provided
  482                     ;
  483                     
  484  01:B18A            lib2_bm_delete:
  485                     	__stw	<__ax
       01:B18A  86 F8     	stx	<__ax
       01:B18C  85 F9     	sta	<__ax+1
  486  01:B18E  20 37 B3  	jsr	lib2_bm_open
  487  01:B191  B0 55     	bcs	.out
  488                     	stw	$8006,<__bx	; ptr to end
       01:B193  AD 06 80  	lda	LOW_BYTE $8006
       01:B196  85 FA     	sta	LOW_BYTE <__bx	
       01:B198  AD 07 80  	lda	HIGH_BYTE $8006
       01:B19B  85 FB     	sta	HIGH_BYTE <__bx	
  489                     	stw	<__si,<__di	; setup currptr as dest
       01:B19D  A5 EE     	lda	LOW_BYTE <__si
       01:B19F  85 F0     	sta	LOW_BYTE <__di	
       01:B1A1  A5 EF     	lda	HIGH_BYTE <__si
       01:B1A3  85 F1     	sta	HIGH_BYTE <__di	
  490                     	stw	<__dx,<__si	; setup nextptr as src
       01:B1A5  A5 FE     	lda	LOW_BYTE <__dx
       01:B1A7  85 EE     	sta	LOW_BYTE <__si	
       01:B1A9  A5 FF     	lda	HIGH_BYTE <__dx
       01:B1AB  85 EF     	sta	HIGH_BYTE <__si	
  491                     	subw	<__dx,<__bx	; #bytes = end-next + 2
       01:B1AD  38        	sec
       01:B1AE  A5 FA     	lda	LOW_BYTE <__bx	
       01:B1B0  E5 FE     	sbc	LOW_BYTE <__dx
       01:B1B2  85 FA     	sta	LOW_BYTE <__bx	
       01:B1B4  A5 FB     	lda	HIGH_BYTE <__bx	
       01:B1B6  E5 FF     	sbc	HIGH_BYTE <__dx
       01:B1B8  85 FB     	sta	HIGH_BYTE <__bx	
  492                     	addw	#2,<__bx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:B1BA  18        	clc
       01:B1BB  A5 FA     	lda	LOW_BYTE <__bx
       01:B1BD  69 02     	adc	LOW_BYTE #2
       01:B1BF  85 FA     	sta	LOW_BYTE <__bx
       01:B1C1  A5 FB     	lda	HIGH_BYTE <__bx
       01:B1C3  69 00     	adc	HIGH_BYTE #2
       01:B1C5  85 FB     	sta	HIGH_BYTE <__bx
                          .endif
  493                     	subw	<__cx,$8006	; adjust ptr to end
       01:B1C7  38        	sec
       01:B1C8  AD 06 80  	lda	LOW_BYTE $8006	
       01:B1CB  E5 FC     	sbc	LOW_BYTE <__cx
       01:B1CD  8D 06 80  	sta	LOW_BYTE $8006	
       01:B1D0  AD 07 80  	lda	HIGH_BYTE $8006	
       01:B1D3  E5 FD     	sbc	HIGH_BYTE <__cx
       01:B1D5  8D 07 80  	sta	HIGH_BYTE $8006	
  494  01:B1D8  A5 FB     	lda	<__bh
  495  01:B1DA  A6 FA     	ldx	<__bl
  496  01:B1DC  20 7B C5  	jsr	_memcpy.3
  497  01:B1DF  20 EC B3  	jsr	lib2_bm_disable
  498  01:B1E2  9C C3 29  	stz	bm_error
  499  01:B1E5  82        	clx
  500  01:B1E6  62        	cla
  501  01:B1E7  18        	clc
  502  01:B1E8  60        .out:	rts
  503                     
  504                     
  505                     ; bm_read(char *buf [__di], char *name [__bx], int offset [__bp], int nb)
  506                     ; ---
  507                     ; Given a name of a file, grab some info from the file
  508                     ;
  509                     
  510  01:B1E9            lib2_bm_read.4:
  511                     	__stw	<__ax
       01:B1E9  86 F8     	stx	<__ax
       01:B1EB  85 F9     	sta	<__ax+1
  512                     	; -- open file
  513  01:B1ED  20 37 B3  	jsr	lib2_bm_open
  514  01:B1F0  B0 45     	bcs	.x2
  515                     	; -- checksum test
  516  01:B1F2  20 F7 B3  	jsr	lib2_bm_checksum
  517  01:B1F5  A0 02     	ldy	#2
  518  01:B1F7  B1 EE     	lda	[__si],Y
  519                     	add	<__dl
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       01:B1F9  18        	clc
       01:B1FA  65 FE     	adc	<__dl
                          .endif
  520  01:B1FC  85 FE     	sta	<__dl
  521  01:B1FE  C8        	iny
  522  01:B1FF  B1 EE     	lda	[__si],Y
  523  01:B201  65 FF     	adc	<__dh
  524  01:B203  05 FE     	ora	<__dl
  525  01:B205  D0 25     	bne	.x1
  526                     	; -- setup ptr
  527  01:B207  20 2D B4  	jsr	lib2_bm_setup_ptr
  528  01:B20A  B0 14     	bcs	.ok
  529                     	; -- read
  530  01:B20C  C2        	cly
  531  01:B20D  B1 FE     .l1:	lda	[__dx],Y
  532  01:B20F  91 F0     	sta	[__di],Y
  533  01:B211  C8        	iny
  534  01:B212  D0 04     	bne	.l2
  535  01:B214  E6 FF     	inc	<__dx+1
  536  01:B216  E6 F1     	inc	<__di+1
  537  01:B218  C6 FC     .l2:	dec	<__cl
  538  01:B21A  D0 F1     	bne	.l1
  539  01:B21C  C6 FD     	dec	<__ch
  540  01:B21E  10 ED     	bpl	.l1
  541                     	; -- ok
  542  01:B220  20 EC B3  .ok:	jsr	lib2_bm_disable
  543  01:B223  9C C3 29  	stz	bm_error
  544                     	__ldw	<__ax
                0000      .if (1 = 2)
                          .else
       01:B226  A6 F8     	ldx	<__ax
       01:B228  A5 F9     	lda	<__ax+1
                          .endif
  545  01:B22A  18        	clc
  546  01:B22B  60        	rts
  547                     	; -- error, bad file checksum
  548  01:B22C  A9 02     .x1:	lda	#2
  549  01:B22E  8D C3 29  	sta	bm_error
  550  01:B231  20 EC B3  	jsr	lib2_bm_disable
  551  01:B234  82        	clx
  552  01:B235  62        	cla
  553  01:B236  38        	sec
  554  01:B237  60        .x2:	rts
  555                     
  556                     
  557                     ; bm_write(char *buf [__di], char *name [__bx], int offset [__bp], int nb)
  558                     ; ---
  559                     ; Given the name of a BRAM file, update some info inside of it
  560                     ;
  561                     
  562  01:B238            lib2_bm_write.4:
  563                     	__stw	<__ax
       01:B238  86 F8     	stx	<__ax
       01:B23A  85 F9     	sta	<__ax+1
  564                     	; -- open file
  565  01:B23C  20 37 B3  	jsr	lib2_bm_open
  566  01:B23F  B0 35     	bcs	.x1
  567                     	; -- setup ptr
  568  01:B241  20 2D B4  	jsr	lib2_bm_setup_ptr
  569  01:B244  B0 25     	bcs	.ok
  570                     	; -- write data
  571  01:B246  C2        	cly
  572  01:B247  B1 F0     .l1:	lda	[__di],Y
  573  01:B249  91 FE     	sta	[__dx],Y
  574  01:B24B  C8        	iny
  575  01:B24C  D0 04     	bne	.l2
  576  01:B24E  E6 FF     	inc	<__dx+1
  577  01:B250  E6 F1     	inc	<__di+1
  578  01:B252  C6 FC     .l2:	dec	<__cl
  579  01:B254  D0 F1     	bne	.l1
  580  01:B256  C6 FD     	dec	<__ch
  581  01:B258  10 ED     	bpl	.l1
  582                     	; -- update checksum
  583  01:B25A  20 F7 B3  	jsr	lib2_bm_checksum
  584  01:B25D  A0 02     	ldy	#2
  585  01:B25F  62        	cla
  586                     	sub	<__dl
                0000      .if (1 = 2)			; from register A (handle
                          .else
       01:B260  38        	sec
       01:B261  E5 FE     	sbc	<__dl
                          .endif
  587  01:B263  91 EE     	sta	[__si],Y
  588  01:B265  C8        	iny
  589  01:B266  62        	cla
  590  01:B267  E5 FF     	sbc	<__dh
  591  01:B269  91 EE     	sta	[__si],Y
  592                     	; -- ok
  593  01:B26B  20 EC B3  .ok:	jsr	lib2_bm_disable
  594  01:B26E  9C C3 29  	stz	bm_error
  595                     	__ldw	<__ax
                0000      .if (1 = 2)
                          .else
       01:B271  A6 F8     	ldx	<__ax
       01:B273  A5 F9     	lda	<__ax+1
                          .endif
  596  01:B275  18        	clc
  597  01:B276  60        .x1:	rts
  598                     
  599                     
  600                     ; bm_create(char *name [__bx], int size)
  601                     ; ---
  602                     ; Create a new BRAM file, given the name and size
  603                     
  604  01:B277            lib2_bm_create.2:
  605                     	__stw	<__ax
       01:B277  86 F8     	stx	<__ax
       01:B279  85 F9     	sta	<__ax+1
  606  01:B27B  20 BA B3  	jsr	lib2_bm_enable
  607  01:B27E  90 10     	bcc	.go
  608  01:B280  80 02     	bra	.x2
  609                     	; -- error, not enough ram
  610  01:B282  A9 05     .x1:	lda	#5
  611                     	; -- error, bram not formatted
  612  01:B284  8D C3 29  .x2:	sta	bm_error
  613  01:B287  20 EC B3  	jsr	lib2_bm_disable
  614  01:B28A  AE C3 29  	ldx	bm_error
  615  01:B28D  62        	cla
  616  01:B28E  38        	sec
  617  01:B28F  60        	rts
  618                     	; -- check free space
  619                     .go:	addw	#$12,$8006,<__dx
                0001      .if	(3 = 3)
                          	; 3-arg mode
                          	;
       01:B290  18        	clc
       01:B291  AD 06 80  	lda	LOW_BYTE $8006
       01:B294  69 12     	adc	LOW_BYTE #$12
       01:B296  85 FE     	sta	LOW_BYTE <__dx
       01:B298  AD 07 80  	lda	HIGH_BYTE $8006
       01:B29B  69 00     	adc	HIGH_BYTE #$12
       01:B29D  85 FF     	sta	HIGH_BYTE <__dx
                          .else
                          .endif
  620                     	addw	<__ax,<__dx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:B29F  18        	clc
       01:B2A0  A5 FE     	lda	LOW_BYTE <__dx
       01:B2A2  65 F8     	adc	LOW_BYTE <__ax
       01:B2A4  85 FE     	sta	LOW_BYTE <__dx
       01:B2A6  A5 FF     	lda	HIGH_BYTE <__dx
       01:B2A8  65 F9     	adc	HIGH_BYTE <__ax
       01:B2AA  85 FF     	sta	HIGH_BYTE <__dx
                          .endif
  621                     	cmpw	<__dx,$8004
       01:B2AC  AD 05 80  	lda	HIGH_BYTE $8004
       01:B2AF  C5 FF     	cmp	HIGH_BYTE <__dx
       01:B2B1  D0 05     	bne	.x_00482
       01:B2B3  AD 04 80  	lda	LOW_BYTE $8004
       01:B2B6  C5 FE     	cmp	LOW_BYTE <__dx
       01:B2B8            .x_00482:
  622                     	blo	.x1
       01:B2B8  90 C8     	bcc	.x1
  623                     	; -- create file
  624                     	stw	$8006,<__si
       01:B2BA  AD 06 80  	lda	LOW_BYTE $8006
       01:B2BD  85 EE     	sta	LOW_BYTE <__si
       01:B2BF  AD 07 80  	lda	HIGH_BYTE $8006
       01:B2C2  85 EF     	sta	HIGH_BYTE <__si
  625  01:B2C4  A0 01     	ldy	#1
  626  01:B2C6  A5 F8     	lda	<__al
  627                     	add	#$10
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       01:B2C8  18        	clc
       01:B2C9  69 10     	adc	#$10
                          .endif
  628  01:B2CB  92 EE     	sta	[__si]
  629  01:B2CD  A5 F9     	lda	<__ah
  630  01:B2CF  69 00     	adc	#$00
  631  01:B2D1  91 EE     	sta	[__si],Y
  632                     	; --
  633  01:B2D3  AD 06 80  	lda	$8006
  634                     	add	[__si]
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       01:B2D6  18        	clc
       01:B2D7  72 EE     	adc	[__si]
                          .endif
  635  01:B2D9  85 FE     	sta	<__dl
  636  01:B2DB  8D 06 80  	sta	$8006
  637  01:B2DE  AD 07 80  	lda	$8007
  638  01:B2E1  71 EE     	adc	[__si],Y
  639  01:B2E3  85 FF     	sta	<__dh
  640  01:B2E5  8D 07 80  	sta	$8007
  641  01:B2E8  62        	cla
  642  01:B2E9  92 FE     	sta	[__dx]
  643  01:B2EB  91 FE     	sta	[__dx],Y
  644                     	; -- copy name
  645  01:B2ED  82        	clx
  646  01:B2EE  A0 04     	ldy	#4
  647  01:B2F0  02        .l1:	sxy
  648  01:B2F1  B1 FA     	lda	[__bx],Y
  649  01:B2F3  02        	sxy
  650  01:B2F4  91 EE     	sta	[__si],Y
  651  01:B2F6  C8        	iny
  652  01:B2F7  E8        	inx
  653  01:B2F8  E0 0C     	cpx	#12
  654  01:B2FA  D0 F4     	bne	.l1
  655                     	; -- clear file
  656  01:B2FC  A5 F8     	lda	<__al
  657  01:B2FE  05 F9     	ora	<__ah
  658  01:B300  F0 1A     	beq	.sum
  659                     	stw	<__si,<__bx
       01:B302  A5 EE     	lda	LOW_BYTE <__si
       01:B304  85 FA     	sta	LOW_BYTE <__bx
       01:B306  A5 EF     	lda	HIGH_BYTE <__si
       01:B308  85 FB     	sta	HIGH_BYTE <__bx
  660  01:B30A  A0 10     	ldy	#16
  661  01:B30C  62        	cla
  662  01:B30D  91 FA     .l2:	sta	[__bx],Y
  663  01:B30F  C8        	iny
  664  01:B310  D0 02     	bne	.l3
  665  01:B312  E6 FB     	inc	<__bh
  666  01:B314  C6 F8     .l3:	dec	<__al
  667  01:B316  D0 F5     	bne	.l2
  668  01:B318  C6 F9     	dec	<__ah
  669  01:B31A  10 F1     	bpl	.l2
  670                     	; -- update checksum
  671  01:B31C  20 F7 B3  .sum:	jsr	lib2_bm_checksum
  672  01:B31F  A0 02     	ldy	#2
  673  01:B321  62        	cla
  674                     	sub	<__dl
                0000      .if (1 = 2)			; from register A (handle
                          .else
       01:B322  38        	sec
       01:B323  E5 FE     	sbc	<__dl
                          .endif
  675  01:B325  91 EE     	sta	[__si],Y
  676  01:B327  C8        	iny
  677  01:B328  62        	cla
  678  01:B329  E5 FF     	sbc	<__dh
  679  01:B32B  91 EE     	sta	[__si],Y
  680                     	; -- ok
  681  01:B32D  20 EC B3  .ok:	jsr	lib2_bm_disable
  682  01:B330  9C C3 29  	stz	bm_error
  683  01:B333  82        	clx
  684  01:B334  62        	cla
  685  01:B335  18        	clc
  686  01:B336  60        	rts
  687                     
  688                     
  689                     ; bm_open(char *name [__bx])
  690                     ; ---
  691                     ; Internal function to obtain access to a named file
  692                     
  693  01:B337            lib2_bm_open:
  694  01:B337  20 BA B3  	jsr	lib2_bm_enable
  695  01:B33A  B0 6E     	bcs	.x2
  696                     	; -- get dir entry
  697                     	stw	#$8010,<__si
       01:B33C  A9 10     	lda	LOW_BYTE #$8010
       01:B33E  85 EE     	sta	LOW_BYTE <__si
       01:B340  A9 80     	lda	HIGH_BYTE #$8010
       01:B342  85 EF     	sta	HIGH_BYTE <__si
  698  01:B344  B2 EE     .l1:	lda	[__si]
  699  01:B346  85 FC     	sta	<__cl
  700  01:B348  A0 01     	ldy	#1
  701  01:B34A  B1 EE     	lda	[__si],Y
  702  01:B34C  85 FD     	sta	<__ch
  703  01:B34E  05 FC     	ora	<__cl
  704  01:B350  F0 56     	beq	.x1
  705                     	addw	<__cx,<__si,<__dx
                0001      .if	(3 = 3)
                          	; 3-arg mode
                          	;
       01:B352  18        	clc
       01:B353  A5 EE     	lda	LOW_BYTE <__si
       01:B355  65 FC     	adc	LOW_BYTE <__cx
       01:B357  85 FE     	sta	LOW_BYTE <__dx
       01:B359  A5 EF     	lda	HIGH_BYTE <__si
       01:B35B  65 FD     	adc	HIGH_BYTE <__cx
       01:B35D  85 FF     	sta	HIGH_BYTE <__dx
                          .else
                          .endif
  706                     	cmpw	<__dx,$8004
       01:B35F  AD 05 80  	lda	HIGH_BYTE $8004
       01:B362  C5 FF     	cmp	HIGH_BYTE <__dx
       01:B364  D0 05     	bne	.x_00491
       01:B366  AD 04 80  	lda	LOW_BYTE $8004
       01:B369  C5 FE     	cmp	LOW_BYTE <__dx
       01:B36B            .x_00491:
  707                     	blo	.x3
       01:B36B  90 45     	bcc	.x3
  708                     	cmpw	#16,<__cx
       01:B36D  A5 FD     	lda	HIGH_BYTE <__cx
       01:B36F  C9 00     	cmp	HIGH_BYTE #16
       01:B371  D0 04     	bne	.x_00493
       01:B373  A5 FC     	lda	LOW_BYTE <__cx
       01:B375  C9 10     	cmp	LOW_BYTE #16
       01:B377            .x_00493:
  709                     	blo	.x3
       01:B377  90 39     	bcc	.x3
  710                     	; -- compare names
  711  01:B379  C2        	cly
  712  01:B37A  A2 04     	ldx	#4
  713  01:B37C  B1 FA     .l2:	lda	[__bx],Y
  714  01:B37E  02        	sxy
  715  01:B37F  D1 EE     	cmp	[__si],Y
  716  01:B381  D0 16     	bne	.next
  717  01:B383  02        	sxy
  718  01:B384  E8        	inx
  719  01:B385  C8        	iny
  720  01:B386  C0 0C     	cpy	#12
  721                     	blo	.l2
       01:B388  90 F2     	bcc	.l2
  722                     	; -- check file size
  723  01:B38A  A5 FD     	lda	<__ch
  724  01:B38C  D0 06     	bne	.ok
  725  01:B38E  A5 FC     	lda	<__cl
  726  01:B390  C9 10     	cmp	#16
  727  01:B392  F0 22     	beq	.x4
  728                     	; -- ok
  729  01:B394  9C C3 29  .ok:	stz	bm_error
  730  01:B397  18        	clc
  731  01:B398  60        	rts
  732                     	; -- next entry
  733                     .next:	addw	<__cx,<__si
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:B399  18        	clc
       01:B39A  A5 EE     	lda	LOW_BYTE <__si
       01:B39C  65 FC     	adc	LOW_BYTE <__cx
       01:B39E  85 EE     	sta	LOW_BYTE <__si
       01:B3A0  A5 EF     	lda	HIGH_BYTE <__si
       01:B3A2  65 FD     	adc	HIGH_BYTE <__cx
       01:B3A4  85 EF     	sta	HIGH_BYTE <__si
                          .endif
  734  01:B3A6  80 9C     	bra	.l1
  735                     	; -- error, file not found
  736  01:B3A8  A9 01     .x1:	lda	#1
  737                     	; -- error, bram not formatted
  738  01:B3AA  8D C3 29  .x2:	sta	bm_error
  739  01:B3AD  20 EC B3  	jsr	lib2_bm_disable
  740  01:B3B0  38        	sec
  741  01:B3B1  60        	rts
  742                     	; -- error, directory corrupted
  743  01:B3B2  A9 03     .x3:	lda	#3
  744  01:B3B4  80 F4     	bra	.x2
  745                     	; -- error, empty file
  746  01:B3B6  A9 04     .x4:	lda	#4
  747  01:B3B8  80 F0     	bra	.x2
  748                     
  749                     
  750                     ; bm_enable()
  751                     ; ---
  752                     ; Internal function to enable the BRAM area and do a quick check
  753                     
  754  01:B3BA            lib2_bm_enable:
  755  01:B3BA  20 D1 B3  	jsr	lib2_bm_unlock
  756                     	; -- check if formatted
  757  01:B3BD  A2 03     	ldx	#3
  758  01:B3BF  BD 00 80  .l1:	lda	$8000,X
  759  01:B3C2  DD DD D8  	cmp	_bm_id,X
  760  01:B3C5  D0 06     	bne	.x1
  761  01:B3C7  CA        	dex
  762  01:B3C8  10 F5     	bpl	.l1
  763                     	; -- ok
  764  01:B3CA  62        	cla
  765  01:B3CB  18        	clc
  766  01:B3CC  60        	rts
  767                     	; -- error, not formatted!
  768  01:B3CD  A9 FF     .x1:	lda	#$FF
  769  01:B3CF  38        	sec
  770  01:B3D0  60        	rts
  771                     
  772                     
  773                     ; bm_unlock()
  774                     ; ---
  775                     ; This internal function handles only the map/unlock of the BRAM area
  776                     
  777  01:B3D1            lib2_bm_unlock:
  778  01:B3D1  78        	sei
  779  01:B3D2  43 10     	tma	#4
  780  01:B3D4  8D C2 29  	sta	bm_mpr4
  781  01:B3D7  A9 F7     	lda	#$F7
  782  01:B3D9  53 10     	tam	#4
  783  01:B3DB  54        	csl
  784  01:B3DC  A9 48     	lda	#$48
  785  01:B3DE  8D 07 18  	sta	bram_unlock
  786  01:B3E1  A9 75     	lda	#$75
  787  01:B3E3  8D 07 18  	sta	bram_unlock
  788  01:B3E6  A9 80     	lda	#$80
  789  01:B3E8  8D 07 18  	sta	bram_unlock
  790  01:B3EB  60        	rts
  791                     
  792                     
  793                     ; bm_disable()
  794                     ; ---
  795                     ; This internal function handles the fixup of BRAM segment/locking
  796                     
  797  01:B3EC            lib2_bm_disable:
  798  01:B3EC  AD C2 29  	lda	bm_mpr4
  799  01:B3EF  53 10     	tam	#4
  800  01:B3F1  AD 03 18  	lda	bram_lock
  801  01:B3F4  D4        	csh
  802  01:B3F5  58        	cli
  803  01:B3F6  60        	rts
  804                     
  805                     
  806                     ; bm_checksum(char *fcb [__si])
  807                     ; ---
  808                     ; Internal function to generate checksum
  809                     ;
  810                     
  811  01:B3F7            lib2_bm_checksum:
  812                     	stwz	<__dx
       01:B3F7  64 FE     	stz	LOW_BYTE <__dx
       01:B3F9  64 FF     	stz	HIGH_BYTE <__dx
  813                     	; -- get file size
  814  01:B3FB  B2 EE     	lda	[__si]
  815                     	sub	#4
                0000      .if (1 = 2)			; from register A (handle
                          .else
       01:B3FD  38        	sec
       01:B3FE  E9 04     	sbc	#4
                          .endif
  816  01:B400  85 FC     	sta	<__cl
  817  01:B402  A0 01     	ldy	#1
  818  01:B404  B1 EE     	lda	[__si],Y
  819  01:B406  E9 00     	sbc	#0
  820  01:B408  85 FD     	sta	<__ch
  821                     	stw	<__si,<__bx
       01:B40A  A5 EE     	lda	LOW_BYTE <__si
       01:B40C  85 FA     	sta	LOW_BYTE <__bx
       01:B40E  A5 EF     	lda	HIGH_BYTE <__si
       01:B410  85 FB     	sta	HIGH_BYTE <__bx
  822                     	; -- calc checksum
  823  01:B412  A0 04     	ldy	#4
  824  01:B414  B1 FA     .l1:	lda	[__bx],Y
  825                     	add	<__dl
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       01:B416  18        	clc
       01:B417  65 FE     	adc	<__dl
                          .endif
  826  01:B419  85 FE     	sta	<__dl
  827  01:B41B  90 02     	bcc	.l2
  828  01:B41D  E6 FF     	inc	<__dh
  829  01:B41F  C8        .l2:	iny
  830  01:B420  D0 02     	bne	.l3
  831  01:B422  E6 FB     	inc	<__bh
  832  01:B424  C6 FC     .l3:	dec	<__cl
  833  01:B426  D0 EC     	bne	.l1
  834  01:B428  C6 FD     	dec	<__ch
  835  01:B42A  10 E8     	bpl	.l1
  836  01:B42C  60        	rts
  837                     
  838                     
  839                     ; bm_setup_ptr(char *fcb [__si], char *buf [__di], int offset [__bp], int nb [__ax])
  840                     ; ---
  841                     
  842  01:B42D            lib2_bm_setup_ptr:
  843                     	; -- check length
  844                     	tstw	<__ax
       01:B42D  A5 F8     	lda	<__ax		; value at stated memory
       01:B42F  05 F9     	ora	<__ax+1		; location is zero
  845  01:B431  F0 21     	beq	.x1
  846                     	; -- check ptr
  847                     	tstw	<__di
       01:B433  A5 F0     	lda	<__di		; value at stated memory
       01:B435  05 F1     	ora	<__di+1		; location is zero
  848  01:B437  F0 1B     	beq	.x1
  849                     	; -- check offset
  850                     	addw	#16,<__bp,<__bx
                0001      .if	(3 = 3)
                          	; 3-arg mode
                          	;
       01:B439  18        	clc
       01:B43A  A5 EC     	lda	LOW_BYTE <__bp
       01:B43C  69 10     	adc	LOW_BYTE #16
       01:B43E  85 FA     	sta	LOW_BYTE <__bx
       01:B440  A5 ED     	lda	HIGH_BYTE <__bp
       01:B442  69 00     	adc	HIGH_BYTE #16
       01:B444  85 FB     	sta	HIGH_BYTE <__bx
                          .else
                          .endif
  851  01:B446  A0 01     	ldy	#1
  852  01:B448  A5 FB     	lda	<__bh
  853  01:B44A  D1 EE     	cmp	[__si],Y
  854  01:B44C  D0 04     	bne	.l1
  855  01:B44E  A5 FA     	lda	<__bl
  856  01:B450  D2 EE     	cmp	[__si]
  857                     .l1:	blo	.l2
       01:B452  90 06     	bcc	.l2
  858                     	; -- eof
  859                     .x1:	stwz	<__ax
       01:B454  64 F8     	stz	LOW_BYTE <__ax
       01:B456  64 F9     	stz	HIGH_BYTE <__ax
  860  01:B458  38        	sec
  861  01:B459  60        	rts
  862                     	; -- set base ptr
  863                     .l2:	addw	<__bx,<__si,<__dx
                0001      .if	(3 = 3)
                          	; 3-arg mode
                          	;
       01:B45A  18        	clc
       01:B45B  A5 EE     	lda	LOW_BYTE <__si
       01:B45D  65 FA     	adc	LOW_BYTE <__bx
       01:B45F  85 FE     	sta	LOW_BYTE <__dx
       01:B461  A5 EF     	lda	HIGH_BYTE <__si
       01:B463  65 FB     	adc	HIGH_BYTE <__bx
       01:B465  85 FF     	sta	HIGH_BYTE <__dx
                          .else
                          .endif
  864                     	; -- check length
  865                     	addw	<__ax,<__bx
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:B467  18        	clc
       01:B468  A5 FA     	lda	LOW_BYTE <__bx
       01:B46A  65 F8     	adc	LOW_BYTE <__ax
       01:B46C  85 FA     	sta	LOW_BYTE <__bx
       01:B46E  A5 FB     	lda	HIGH_BYTE <__bx
       01:B470  65 F9     	adc	HIGH_BYTE <__ax
       01:B472  85 FB     	sta	HIGH_BYTE <__bx
                          .endif
  866  01:B474  B2 EE     	lda	[__si]
  867                     	sub	<__bl
                0000      .if (1 = 2)			; from register A (handle
                          .else
       01:B476  38        	sec
       01:B477  E5 FA     	sbc	<__bl
                          .endif
  868  01:B479  85 FA     	sta	<__bl
  869  01:B47B  B1 EE     	lda	[__si],Y
  870  01:B47D  E5 FB     	sbc	<__bh
  871  01:B47F  85 FB     	sta	<__bh
  872  01:B481  10 0D     	bpl	.ok
  873                     	; -- adjust size
  874                     	addw	<__bx,<__ax
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       01:B483  18        	clc
       01:B484  A5 F8     	lda	LOW_BYTE <__ax
       01:B486  65 FA     	adc	LOW_BYTE <__bx
       01:B488  85 F8     	sta	LOW_BYTE <__ax
       01:B48A  A5 F9     	lda	HIGH_BYTE <__ax
       01:B48C  65 FB     	adc	HIGH_BYTE <__bx
       01:B48E  85 F9     	sta	HIGH_BYTE <__ax
                          .endif
  875                     .ok:	stw	<__ax,<__cx
       01:B490  A5 F8     	lda	LOW_BYTE <__ax
       01:B492  85 FC     	sta	LOW_BYTE <__cx
       01:B494  A5 F9     	lda	HIGH_BYTE <__ax
       01:B496  85 FD     	sta	HIGH_BYTE <__cx
  876  01:B498  18        	clc
  877  01:B499  60        	rts
  878                     
  879                     ;
  880                     ; restore the context of the library routines
  881                     ; in LIB1_BANK
  882                     ;
  883           0000      	.bank	LIB1_BANK
#[2]   startup.asm
#[3]   huc_misc.asm
 1282                     .include "huc_misc.asm"
    1                     ;
    2                     ; HUC_MISC.ASM  -  HuC Misc Library
    3                     ;
    4                     
    5                     
    6                     ; joy(char number)
    7                     ; ----
    8                     
    9  00:D987            _joy:
   10  00:D987  02        	sxy
   11  00:D988  BE 28 22  	ldx	joy,Y
   12  00:D98B  B9 93 26  	lda	joy6,Y
   13  00:D98E  60        	rts
   14                     
   15                     ; joytrg(char number)
   16                     ; ----
   17                     
   18  00:D98F            _joytrg:
   19  00:D98F  02        	sxy
   20  00:D990  BE 2D 22  	ldx	joytrg,Y
   21  00:D993  B9 98 26  	lda	joytrg6,Y
   22  00:D996  60        	rts
   23                     
   24                     ; joyold(char number)
   25                     ; ----
   26                     
   27  00:D997            _joyold:
   28  00:D997  02        	sxy
   29  00:D998  BE 32 22  	ldx	joyold,Y
   30  00:D99B  B9 9D 26  	lda	joyold6,Y
   31  00:D99E  60        	rts
   32                     
   33                     ; joybuf(char number)
   34                     ; ----
   35                     
   36  00:D99F            _joybuf:
   37  00:D99F  02        	sxy
   38  00:D9A0  BE 81 26  	ldx	joybuf,Y
   39  00:D9A3  B9 A2 26  	lda	joybuf6,Y
   40  00:D9A6  60        	rts
   41                     
   42                     
   43                     ; mouse functions
   44                     ; available if SUPPORT_MOUSE is defined (default)
   45                     ; ----
   46                     
   47           0001      .ifdef SUPPORT_MOUSE
   48                     
   49                     ; mouse_exists() - returns true/false (true = 1)
   50                     ; ----
   51                     
   52  00:D9A7            _mouse_exists:
   53  00:D9A7  AE C4 29  	ldx	msflag
   54  00:D9AA  62        	cla
   55  00:D9AB  60        	rts
   56                     
   57                     ; mouse_disable() - turns off mouse support
   58                     ; ----
   59                     
   60  00:D9AC            _mouse_disable:
   61                     	; XXX: This doesn't really need a return value, does it?
   62  00:D9AC  62        	cla
   63  00:D9AD  82        	clx
   64  00:D9AE  8D C4 29  	sta	msflag
   65  00:D9B1  60        	rts
   66                     
   67                     ; mouse_enable() - turns on mouse support, if mouse detected
   68                     ;	- return true/false (true=1) if mouse exists
   69                     ; ----
   70                     
   71  00:D9B2            _mouse_enable:
   72  00:D9B2  20 D1 DA  	jsr	mousinit
   73  00:D9B5  22        	sax
   74  00:D9B6  62        	cla
   75  00:D9B7  60        	rts
   76                     
   77                     ; mouse_x() - returns x/y delta (int)
   78                     ; ----
   79                     
   80  00:D9B8            _mouse_x:
   81  00:D9B8  AE C6 29  	ldx	mshorz
   82  00:D9BB  10 08     	bpl	mouspos
   83  00:D9BD            mousneg:
   84  00:D9BD  A9 FF     	lda	#$ff
   85  00:D9BF  60        	rts
   86                     
   87                     ; mouse_y() - returns y delta (int)
   88                     ; ----
   89                     
   90  00:D9C0            _mouse_y:
   91  00:D9C0  AE C5 29  	ldx	msvert
   92  00:D9C3  30 F8     	bmi	mousneg
   93  00:D9C5            mouspos:
   94  00:D9C5  62        	cla
   95  00:D9C6  60        	rts
   96                     
   97                     .endif ; SUPPORT_MOUSE
   98                     
   99                     
  100                     ; set_joy_callback(char num [__dl], char mask [__al], char keys [__ah], int proc [__bl:__si])
  101                     ; ----
  102                     
  103  00:D9C7            _set_joy_callback.4:
  104  00:D9C7  9C 88 26  	stz	joycallback
  105  00:D9CA  A5 FA     	lda	<__bl
  106  00:D9CC  8D 8B 26  	sta	joycallback+3
  107                     	__ldw	<__si
                0000      .if (1 = 2)
                          .else
       00:D9CF  A6 EE     	ldx	<__si
       00:D9D1  A5 EF     	lda	<__si+1
                          .endif
  108                     	__stw	joycallback+4
       00:D9D3  8E 8C 26  	stx	joycallback+4
       00:D9D6  8D 8D 26  	sta	joycallback+4+1
  109  00:D9D9  05 EE     	ora	<__si
  110  00:D9DB  F0 0F     	beq	.l1
  111  00:D9DD  A5 F9     	lda	<__ah
  112  00:D9DF  8D 8A 26  	sta	joycallback+2
  113  00:D9E2  A5 F8     	lda	<__al
  114  00:D9E4  8D 89 26  	sta	joycallback+1
  115  00:D9E7  A9 80     	lda	#$80
  116  00:D9E9  8D 88 26  	sta	joycallback
  117  00:D9EC  60        .l1:	rts
  118                     
  119                     ; get_joy_events(char num, int rst)
  120                     ; ----
  121                     ; return all the collected joypad events
  122                     ; ----
  123                     
  124  00:D9ED            _get_joy_events.2:
  125  00:D9ED  A4 F8     	ldy	<__al
  126  00:D9EF  E0 00     	cpx	#0
  127  00:D9F1  D0 06     	bne	_get_joy_events.sub
  128  00:D9F3  BE 81 26  	ldx	joybuf,Y
  129  00:D9F6  62        	cla
  130  00:D9F7  60        	rts
  131  00:D9F8            _get_joy_events.1:
  132  00:D9F8  02        	sxy
  133  00:D9F9            _get_joy_events.sub:
  134  00:D9F9  BE 81 26  	ldx	joybuf,Y
  135  00:D9FC  62        	cla
  136  00:D9FD  99 81 26  	sta	joybuf,Y
  137  00:DA00  60        	rts
  138                     
  139                     ; clear_joy_events(char mask)
  140                     ; ----
  141                     
  142  00:DA01            _clear_joy_events:
  143  00:DA01  86 F8     	stx	<__al
  144  00:DA03  C2        	cly
  145  00:DA04  78        	sei
  146  00:DA05  46 F8     .l1:	lsr	<__al
  147  00:DA07  90 15     	bcc	.l2
  148  00:DA09  62        	cla
  149  00:DA0A  99 81 26  	sta	joybuf,Y
  150  00:DA0D  99 A2 26  	sta	joybuf6,Y
  151  00:DA10  99 2D 22  	sta	joytrg,Y
  152  00:DA13  99 98 26  	sta	joytrg6,Y
  153  00:DA16  A9 FF     	lda	#$FF
  154  00:DA18  99 32 22  	sta	joyold,Y
  155  00:DA1B  99 9D 26  	sta	joyold6,Y
  156  00:DA1E  C8        .l2:	iny
  157  00:DA1F  C0 05     	cpy	#5
  158                     	blo	.l1
       00:DA21  90 E2     	bcc	.l1
  159  00:DA23  58        	cli
  160  00:DA24  60        	rts
  161                     
  162                     
  163                     ; clock_hh()
  164                     ; ----
  165  00:DA25            _clock_hh:
  166  00:DA25  62        	cla
  167  00:DA26  AE 8F 26  	ldx	clock_hh
  168  00:DA29  60        	rts
  169                     
  170                     ; clock_mm()
  171                     ; ----
  172  00:DA2A            _clock_mm:
  173  00:DA2A  62        	cla
  174  00:DA2B  AE 90 26  	ldx	clock_mm
  175  00:DA2E  60        	rts
  176                     
  177                     ; clock_ss()
  178                     ; ----
  179  00:DA2F            _clock_ss:
  180  00:DA2F  62        	cla
  181  00:DA30  AE 91 26  	ldx	clock_ss
  182  00:DA33  60        	rts
  183                     
  184                     ; clock_tt()
  185                     ; ----
  186  00:DA34            _clock_tt:
  187  00:DA34  62        	cla
  188  00:DA35  AE 92 26  	ldx	clock_tt
  189  00:DA38  60        	rts
  190                     
  191                     ; clock_reset()
  192                     ; ----
  193  00:DA39            _clock_reset:
  194  00:DA39  9C 8F 26  	stz	clock_hh
  195  00:DA3C  9C 90 26  	stz	clock_mm
  196  00:DA3F  9C 91 26  	stz	clock_ss
  197  00:DA42  9C 92 26  	stz	clock_tt
  198  00:DA45  60        	rts
  199                     
  200                     
  201                     ; poke(int offset bx, char val)
  202                     ; ----
  203                     
  204  00:DA46            _poke.2:
  205  00:DA46  8A        	txa
  206  00:DA47  92 FA     	sta	[__bx]
  207  00:DA49  60        	rts
  208                     
  209                     ; poke/pokew(int offset bx, int val)
  210                     ; ----
  211                     
  212  00:DA4A            _pokew.2:
  213  00:DA4A  22        	sax
  214  00:DA4B  92 FA     	sta	[__bx]
  215  00:DA4D  A0 01     	ldy	#1
  216  00:DA4F  22        	sax
  217  00:DA50  91 FA     	sta	[__bx],Y
  218  00:DA52  60        	rts
  219                     
  220                     ; peek(int offset)
  221                     ; ----
  222                     
  223  00:DA53            _peek:
  224                     	__stw	<__ptr
       00:DA53  86 06     	stx	<__ptr
       00:DA55  85 07     	sta	<__ptr+1
  225  00:DA57  B2 06     	lda	[__ptr]
  226  00:DA59  AA        	tax
  227  00:DA5A  62        	cla
  228  00:DA5B  60        	rts
  229                     
  230                     ; peekw(int offset)
  231                     ; ----
  232                     
  233  00:DA5C            _peekw:
  234                     	__stw	<__ptr
       00:DA5C  86 06     	stx	<__ptr
       00:DA5E  85 07     	sta	<__ptr+1
  235  00:DA60  B2 06     	lda	[__ptr]
  236  00:DA62  AA        	tax
  237  00:DA63  A0 01     	ldy	#1
  238  00:DA65  B1 06     	lda	[__ptr],Y
  239  00:DA67  60        	rts
  240                     
  241                     ; farpeekb(far void *base)
  242                     ; ----
  243                     
  244  00:DA68            _farpeekb.1:
  245  00:DA68  A5 08     	lda	<__fbank
  246  00:DA6A  53 08     	tam	#3
  247  00:DA6C  A5 0A     	lda	<__fptr+1
  248  00:DA6E  29 1F     	and	#$1F
  249  00:DA70  09 60     	ora	#$60
  250  00:DA72  85 0A     	sta	<__fptr+1
  251  00:DA74  B2 09     	lda	[__fptr]
  252  00:DA76  AA        	tax
  253  00:DA77  62        	cla
  254  00:DA78  60        	rts
  255                     
  256                     ; farpeekw(far void *base)
  257                     ; ----
  258                     
  259  00:DA79            _farpeekw.1:
  260  00:DA79  A5 08     	lda	<__fbank
  261  00:DA7B  53 08     	tam	#3
  262  00:DA7D  A5 0A     	lda	<__fptr+1
  263  00:DA7F  29 1F     	and	#$1F
  264  00:DA81  09 60     	ora	#$60
  265  00:DA83  85 0A     	sta	<__fptr+1
  266  00:DA85  80 09     	bra	_farpeekw.sub
  267  00:DA87            _farpeekw.fast:
  268  00:DA87  53 08     	tam	#3
  269  00:DA89  8A        	txa
  270  00:DA8A  29 1F     	and	#$1F
  271  00:DA8C  09 60     	ora	#$60
  272  00:DA8E  85 0A     	sta	<__fptr+1
  273  00:DA90            _farpeekw.sub:
  274  00:DA90  B2 09     	lda	[__fptr]
  275  00:DA92  AA        	tax
  276  00:DA93  E6 09     	inc	<__fptr
  277  00:DA95  90 08     	bcc	.l1
  278  00:DA97  E6 0A     	inc	<__fptr+1
  279  00:DA99  10 04     	bpl	.l1
  280  00:DA9B  A9 60     	lda	#$60
  281  00:DA9D  85 0A     	sta	<__fptr+1
  282  00:DA9F            .l1:
  283  00:DA9F  B2 09     	lda	[__fptr]
  284  00:DAA1  60        	rts
  285                     
  286                     ; farmemget(void *dst, far void *base, int len)
  287                     ; ----
  288                     
  289  00:DAA2            _farmemget.3:
  290                     	maplibfunc	lib2_farmemget.3
       00:DAA2  A8        	tay
       00:DAA3  43 20     	tma	#page(lib2_farmemget.3)
       00:DAA5  48        	pha
       00:DAA6  A9 81     	lda	#bank(lib2_farmemget.3)
       00:DAA8  53 20     	tam	#page(lib2_farmemget.3)
       00:DAAA  98        	tya
       00:DAAB  20 9A B4  	jsr	lib2_farmemget.3
       00:DAAE  A8        	tay
       00:DAAF  68        	pla
       00:DAB0  53 20     	tam	#page(lib2_farmemget.3)
       00:DAB2  98        	tya
  291  00:DAB3  60        	rts
  292                     
  293                     ; The following function was too large to stay
  294                     ; in LIB1_BANK, so it is placed in LIB2_BANK
  295                     ; and must be mapped in and out when used.
  296                     
  297                     ; Code after this routine should be back in LIB1_BANK
  298                     
  299           0001      	.bank	LIB2_BANK
  300                     
  301  01:B49A            lib2_farmemget.3:
  302                     
  303                     	__stw	<__cx
       01:B49A  86 FC     	stx	<__cx
       01:B49C  85 FD     	sta	<__cx+1
  304  01:B49E  A5 08     	lda	<__fbank
  305  01:B4A0  53 08     	tam	#3
  306                     
  307                     	; ----
  308                     	; split transfer if needed
  309                     	;
  310                     	; -- clip length (max. 8KB)
  311                     	cmpw	#$2000,<__cx
       01:B4A2  A5 FD     	lda	HIGH_BYTE <__cx
       01:B4A4  C9 20     	cmp	HIGH_BYTE #$2000
       01:B4A6  D0 04     	bne	.x_00518
       01:B4A8  A5 FC     	lda	LOW_BYTE <__cx
       01:B4AA  C9 00     	cmp	LOW_BYTE #$2000
       01:B4AC            .x_00518:
  312                     	blo	.t1
       01:B4AC  90 08     	bcc	.t1
  313                     	stw	#$2000,<__cx
       01:B4AE  A9 00     	lda	LOW_BYTE #$2000
       01:B4B0  85 FC     	sta	LOW_BYTE <__cx
       01:B4B2  A9 20     	lda	HIGH_BYTE #$2000
       01:B4B4  85 FD     	sta	HIGH_BYTE <__cx
  314                     	; -- check length
  315  01:B4B6  A5 09     .t1:	lda	<__fptr
  316                     	add	<__cl
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       01:B4B8  18        	clc
       01:B4B9  65 FC     	adc	<__cl
                          .endif
  317  01:B4BB  85 F8     	sta	<__al
  318  01:B4BD  A5 0A     	lda	<__fptr+1
  319  01:B4BF  29 1F     	and	#$1F
  320  01:B4C1  65 FD     	adc	<__ch
  321  01:B4C3  85 F9     	sta	<__ah
  322  01:B4C5  C9 20     	cmp	#$20
  323                     	blo	.t2
       01:B4C7  90 15     	bcc	.t2
  324                     	; -- calculate second-half size
  325  01:B4C9  29 1F     	and	#$1F
  326  01:B4CB  85 FF     	sta	<__dh
  327  01:B4CD  A5 F8     	lda	<__al
  328  01:B4CF  85 FE     	sta	<__dl
  329                     	subw	<__dx,<__cx
       01:B4D1  38        	sec
       01:B4D2  A5 FC     	lda	LOW_BYTE <__cx
       01:B4D4  E5 FE     	sbc	LOW_BYTE <__dx
       01:B4D6  85 FC     	sta	LOW_BYTE <__cx
       01:B4D8  A5 FD     	lda	HIGH_BYTE <__cx
       01:B4DA  E5 FF     	sbc	HIGH_BYTE <__dx
       01:B4DC  85 FD     	sta	HIGH_BYTE <__cx
  330                     	; -- remap src ptr
  331  01:B4DE  A5 0A     .t2:	lda	<__fptr+1
  332  01:B4E0  29 1F     	and	#$1F
  333  01:B4E2  09 60     	ora	#$60
  334  01:B4E4  85 0A     	sta	<__fptr+1
  335                     
  336                     	; ----
  337                     	; copy a block
  338                     	;
  339  01:B4E6  82        	clx
  340  01:B4E7  C2        	cly
  341  01:B4E8  C6 FD     	dec	<__ch
  342  01:B4EA  30 1C     	bmi	.l4
  343                     	; -- main loop
  344  01:B4EC  B1 09     .l1:	lda	[__fptr],Y
  345  01:B4EE  91 FA     	sta	[__bx],Y
  346  01:B4F0  C8        	iny
  347  01:B4F1  CA        	dex
  348  01:B4F2  D0 F8     	bne	.l1
  349                     	; -- inc dst ptr
  350  01:B4F4  C0 00     	cpy	#0
  351  01:B4F6  F0 08     	beq	.l2
  352  01:B4F8  98        	tya
  353                     	add	<__bl
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       01:B4F9  18        	clc
       01:B4FA  65 FA     	adc	<__bl
                          .endif
  354  01:B4FC  85 FA     	sta	<__bl
  355  01:B4FE  90 02     	bcc	.l3
  356  01:B500  E6 FB     .l2:	inc	<__bh
  357                     	; -- inc src ptr
  358  01:B502  E6 0A     .l3:	inc	<__fptr+1
  359                     	; -- next chunk
  360  01:B504  C6 FD     	dec	<__ch
  361  01:B506  10 E4     	bpl	.l1
  362  01:B508  A6 FC     .l4:	ldx	<__cl
  363  01:B50A  64 FC     	stz	<__cl
  364  01:B50C  D0 DE     	bne	.l1
  365                     
  366                     	; ----
  367                     	; second half
  368                     	;
  369                     	tstw	<__dx
       01:B50E  A5 FE     	lda	<__dx		; value at stated memory
       01:B510  05 FF     	ora	<__dx+1		; location is zero
  370  01:B512  F0 17     	beq	.l5
  371                     	; -- reload dst and cnt
  372                     	stw	<__dx,<__cx
       01:B514  A5 FE     	lda	LOW_BYTE <__dx
       01:B516  85 FC     	sta	LOW_BYTE <__cx
       01:B518  A5 FF     	lda	HIGH_BYTE <__dx
       01:B51A  85 FD     	sta	HIGH_BYTE <__cx
  373                     	stw	#$6000,<__fptr
       01:B51C  A9 00     	lda	LOW_BYTE #$6000
       01:B51E  85 09     	sta	LOW_BYTE <__fptr
       01:B520  A9 60     	lda	HIGH_BYTE #$6000
       01:B522  85 0A     	sta	HIGH_BYTE <__fptr
  374                     	; -- inc bank
  375  01:B524  43 08     	tma	#3
  376  01:B526  1A        	inc	A
  377  01:B527  53 08     	tam	#3
  378  01:B529  80 C1     	bra	.l1
  379                     
  380                     	; ----
  381                     	; exit
  382                     	;
  383  01:B52B  60        .l5:	rts
  384                     
  385                     ; The preceding function was too large to stay
  386                     ; in LIB1_BANK, so it is placed in LIB2_BANK
  387                     ; and must be mapped in and out when used.
  388                     
  389                     ; Code after this routine should be back in LIB1_BANK
  390                     
  391           0000      	.bank	LIB1_BANK
  392                     
  393                     
  394                     ; srand(int seed)
  395                     ; srand32.2(int seed1 [__dx], int seed2 [__cx])
  396                     ; ---------------
  397                     ; set the seed number for the pseudo-random number generator
  398                     
  399  00:DAB4            _srand:
  400                     	__stw	<__dx
       00:DAB4  86 FE     	stx	<__dx
       00:DAB6  85 FF     	sta	<__dx+1
  401                     	__stw	<__cx
       00:DAB8  86 FC     	stx	<__cx
       00:DABA  85 FD     	sta	<__cx+1
  402                     
  403  00:DABC            _srand32.2:
  404  00:DABC  20 F2 C6  	jsr	srand
  405  00:DABF  60        	rts
  406                     
  407                     ; rand()
  408                     ; ----
  409                     ; get a 16-bit random number
  410                     
  411  00:DAC0            _rand:
  412  00:DAC0  20 18 C7  	jsr	rand
  413                     	__ldw	<__dx
                0000      .if (1 = 2)
                          .else
       00:DAC3  A6 FE     	ldx	<__dx
       00:DAC5  A5 FF     	lda	<__dx+1
                          .endif
  414  00:DAC7  60        	rts
  415                     
  416                     
  417                     ; random(char limit)
  418                     ; --- 
  419                     ; get a random number where 0 <= n < limit
  420                     ; (and limit < 128)
  421                     
  422  00:DAC8            _random:
  423  00:DAC8  22        	sax
  424  00:DAC9  29 7F     	and	#$7f
  425  00:DACB  20 91 C7  	jsr	random
  426  00:DACE  22        	sax
  427  00:DACF  62        	cla
  428  00:DAD0  60        	rts
  429                     
#[2]   startup.asm
 1283                     
 1284                     .endif	; HUC
 1285                     
 1286           0001      .ifdef SUPPORT_MOUSE
#[3]   mouse.asm
 1287                      .include "mouse.asm"
    1                     ;- The mouse is read 4 successive times, in order to assemble the mouse data
    2                     ;  (horiz most-significant-nybble/horiz LSN/vert MSN/vert LSN).
    3                     ;- values are deltas, and reading the mouse every VSYNC is normal
    4                     ;- For vertical movement, up is positive, down is negative
    5                     ;- For horizontal movement, left is positive, right is negative
    6                     ;- I was not able to yield a delta value greater than 0x25 (hexadecimal)
    7                     ;  during a 1-VSYNC interval  (I didn't try all *that* hard though).  This
    8                     ;  should give you an idea of the sensitivity.
    9                     
   10                     ;
   11                     ;  PCE mouse driver source
   12                     ;
   13                     
   14           29C4      	.bss
   15  --:29C4            msflag:	.ds 1
   16  --:29C5            msvert:	.ds 1
   17  --:29C6            mshorz:	.ds 1
   18                     
   19           DAD1      	.code
   20                     
   21                     ;
   22                     ; These stub interfaces are available from LIB1_BANK
   23                     ; But the real guts are in LIB2_BANK
   24                     ;
   25  00:DAD1            mousinit:
   26                     	maplibfunc	lib2_mousinit
       00:DAD1  A8        	tay
       00:DAD2  43 20     	tma	#page(lib2_mousinit)
       00:DAD4  48        	pha
       00:DAD5  A9 81     	lda	#bank(lib2_mousinit)
       00:DAD7  53 20     	tam	#page(lib2_mousinit)
       00:DAD9  98        	tya
       00:DADA  20 2C B5  	jsr	lib2_mousinit
       00:DADD  A8        	tay
       00:DADE  68        	pla
       00:DADF  53 20     	tam	#page(lib2_mousinit)
       00:DAE1  98        	tya
   27  00:DAE2  60        	rts
   28                     
   29  00:DAE3            mousread:
   30                     	maplibfunc	lib2_mousread
       00:DAE3  A8        	tay
       00:DAE4  43 20     	tma	#page(lib2_mousread)
       00:DAE6  48        	pha
       00:DAE7  A9 81     	lda	#bank(lib2_mousread)
       00:DAE9  53 20     	tam	#page(lib2_mousread)
       00:DAEB  98        	tya
       00:DAEC  20 BB B5  	jsr	lib2_mousread
       00:DAEF  A8        	tay
       00:DAF0  68        	pla
       00:DAF1  53 20     	tam	#page(lib2_mousread)
       00:DAF3  98        	tya
   31  00:DAF4  60        	rts
   32                     
   33                     
   34                     ;
   35                     ; These functions are available in bank 2 of the
   36                     ; library:
   37                     ;
   38           0001      	.bank	LIB2_BANK
   39                     
   40                     ;
   41                     ; detect and initialize the mouse
   42                     ;
   43  01:B52C            lib2_mousinit:
   44  01:B52C  A9 20     	lda	#$20	; reset resource-usage flag
   45  01:B52E  04 F5     	tsb	<irq_m	; to skip joystick read portion of vsync
   46                     
   47  01:B530  9C 28 22  	stz	joy	; clear joypad memory area
   48  01:B533  73 28 22  	tii	joy, joy+1, $4
       01:B536  29 22 04  
       01:B539  00        
   49                     
   50  01:B53A  9C 2D 22  	stz	joytrg	; clear joypad memory area
   51  01:B53D  73 2D 22  	tii	joytrg, joytrg+1, $4
       01:B540  2E 22 04  
       01:B543  00        
   52                     
   53  01:B544  9C 32 22  	stz	joyold	; clear joypad memory area
   54  01:B547  73 32 22  	tii	joyold, joyold+1, $4
       01:B54A  33 22 04  
       01:B54D  00        
   55                     
   56  01:B54E  9C 81 26  	stz	joybuf	; clear joypad memory area
   57  01:B551  73 81 26  	tii	joybuf, joybuf+1, $4
       01:B554  82 26 04  
       01:B557  00        
   58                     
   59  01:B558  9C 93 26  	stz	joy6	; clear joypad memory area
   60  01:B55B  73 93 26  	tii	joy6, joy6+1, $4
       01:B55E  94 26 04  
       01:B561  00        
   61                     
   62  01:B562  9C 98 26  	stz	joytrg6	; clear joypad memory area
   63  01:B565  73 98 26  	tii	joytrg6, joytrg6+1, $4
       01:B568  99 26 04  
       01:B56B  00        
   64                     
   65  01:B56C  9C 9D 26  	stz	joyold6	; clear joypad memory area
   66  01:B56F  73 9D 26  	tii	joyold6, joyold6+1, $4
       01:B572  9E 26 04  
       01:B575  00        
   67                     
   68  01:B576  9C A2 26  	stz	joybuf6	; clear joypad memory area
   69  01:B579  73 A2 26  	tii	joybuf6, joybuf6+1, $4
       01:B57C  A3 26 04  
       01:B57F  00        
   70                     
   71  01:B580  9C C5 29  	stz	msvert
   72  01:B583  9C C6 29  	stz	mshorz
   73  01:B586  9C C4 29  	stz	msflag
   74                     
   75  01:B589  62        	cla		; counter of 'good' reads (where vertical == 0)
   76  01:B58A  A2 0A     	ldx	#$0A	; try 10 iterations
   77  01:B58C  48        .loop1:	pha
   78  01:B58D  DA        	phx
   79  01:B58E  A9 01     	lda	#1
   80                     ;	jsr	wait_vsync	; wait for 1 vsync frame
   81  01:B590  20 BB B5  	jsr	lib2_mousread	; read mouse
   82  01:B593  FA        	plx
   83  01:B594  68        	pla
   84  01:B595  AC C5 29  	ldy	msvert	; read mouse vertical axis movement
   85  01:B598  D0 01     	bne	.l1	; if (val == 0), inc counter
   86  01:B59A  1A        	inc a
   87  01:B59B  CA        .l1:	dex
   88  01:B59C  D0 EE     	bne	.loop1	; next iteration
   89                     
   90  01:B59E  C9 00     	cmp	#$00	; if #$00 value found even once (out of 10 times)
   91  01:B5A0  D0 0F     	bne	.mous	; then return(1)
   92                     
   93  01:B5A2  A9 20     	lda	#$20	; reset #$20 bit of $F5
   94  01:B5A4  14 F5     	trb	<irq_m
   95  01:B5A6  62        	cla		; bad return code
   96  01:B5A7  8D C4 29  	sta	msflag
   97  01:B5AA  9C C5 29  	stz	msvert
   98  01:B5AD  9C C6 29  	stz	mshorz
   99  01:B5B0  60        	rts
  100                     
  101  01:B5B1            .mous:
  102  01:B5B1  A9 20     	lda	#$20	; reset #$20 bit of $F5
  103  01:B5B3  14 F5     	trb	<irq_m
  104  01:B5B5  A9 01     	lda	#$01	; good return code
  105  01:B5B7  8D C4 29  	sta	msflag
  106  01:B5BA  60        	rts
  107                     
  108                     ;
  109                     ; actual mechanics of reading mouse
  110                     ;
  111  01:B5BB            lib2_mousread:
  112  01:B5BB  A2 04     	ldx	#$04	; # iterations (actually 5)
  113  01:B5BD  BD 28 22  .loop1:	lda	joy,X	; copy 'current' value to 'previous' value
  114  01:B5C0  9D 32 22  	sta	joyold,X
  115  01:B5C3  CA        	dex
  116  01:B5C4  10 F7     	bpl	.loop1
  117                     
  118  01:B5C6  9C 28 22  	stz	joy	; initialize joypad #1's value
  119                     
  120  01:B5C9  A9 01     	lda	#$01	; reset joypad port# to joystick #1
  121  01:B5CB  8D 00 10  	sta	joyport
  122  01:B5CE  A9 03     	lda	#$03
  123  01:B5D0  8D 00 10  	sta	joyport
  124  01:B5D3  A9 01     	lda	#$01
  125  01:B5D5  8D 00 10  	sta	joyport
  126                     
  127  01:B5D8  20 50 B6  	jsr	delay240	; delay 240 CPU cycles
  128                     
  129  01:B5DB  AD 00 10  	lda	joyport	; read joystick port
  130  01:B5DE  0A        	asl a	; upper nybble of 8-bit value - shift it
  131  01:B5DF  0A        	asl a
  132  01:B5E0  0A        	asl a
  133  01:B5E1  0A        	asl a
  134  01:B5E2  8D C6 29  	sta	mshorz	; store it
  135  01:B5E5  20 5D B6  	jsr	msbutt	; read buttons (toggle port/read other nybble)
  136                     
  137  01:B5E8  A9 01     	lda	#$01	; reset joystick port again (to stick #1)
  138  01:B5EA  8D 00 10  	sta	joyport
  139  01:B5ED  A9 03     	lda	#$03
  140  01:B5EF  8D 00 10  	sta	joyport
  141  01:B5F2  A9 01     	lda	#$01
  142  01:B5F4  8D 00 10  	sta	joyport
  143                     
  144  01:B5F7  20 5C B6  	jsr	delay14	; wait 14 cycles to settle (reference code says 9)
  145                     
  146  01:B5FA  AD 00 10  	lda	joyport	; read port
  147  01:B5FD  29 0F     	and	#$0F	; lower nybble of 8-bit value
  148  01:B5FF  0C C6 29  	tsb	mshorz	; 'or' it into memory
  149  01:B602  44 59     	bsr	msbutt	; read buttons (toggle port/read other nybble)
  150                     
  151  01:B604  A9 01     	lda	#$01	; reset joystick port again
  152  01:B606  8D 00 10  	sta	joyport
  153  01:B609  A9 03     	lda	#$03
  154  01:B60B  8D 00 10  	sta	joyport
  155  01:B60E  A9 01     	lda	#$01
  156  01:B610  8D 00 10  	sta	joyport
  157                     
  158  01:B613  20 5C B6  	jsr	delay14	; wait 14 cycles to settle (reference code says 9)
  159                     
  160  01:B616  AD 00 10  	lda	joyport	; read port
  161  01:B619  0A        	asl a	; upper nybble of 8-bit value - shift it
  162  01:B61A  0A        	asl a
  163  01:B61B  0A        	asl a
  164  01:B61C  0A        	asl a
  165  01:B61D  8D C5 29  	sta	msvert
  166  01:B620  44 3B     	bsr	msbutt	; read buttons (toggle port/read other nybble)
  167                     
  168  01:B622  A9 01     	lda	#$01	; reset joystick port again
  169  01:B624  8D 00 10  	sta	joyport
  170  01:B627  A9 03     	lda	#$03
  171  01:B629  8D 00 10  	sta	joyport
  172  01:B62C  A9 01     	lda	#$01
  173  01:B62E  8D 00 10  	sta	joyport
  174                     
  175  01:B631  20 5C B6  	jsr	delay14	; wait 14 cycles to settle (reference code says 9)
  176                     
  177  01:B634  AD 00 10  	lda	joyport	; read port
  178  01:B637  29 0F     	and	#$0F	; lower nybble of 8-bit value
  179  01:B639  0C C5 29  	tsb	msvert	; 'or' it into value
  180  01:B63C  44 1F     	bsr	msbutt	; read buttons (toggle port/read other nybble)
  181                     
  182  01:B63E  AD 2D 22  	lda	joytrg	; check joystick buttons
  183  01:B641  C9 04     	cmp	#$04	; is 'select' newly-pressed ?
  184  01:B643  D0 0A     	bne	.exit
  185  01:B645  AD 28 22  	lda	joy	; if so, are both run & select pressed ?
  186  01:B648  C9 0C     	cmp	#$0C
  187  01:B64A  D0 03     	bne	.exit
  188  01:B64C  6C 84 22  	jmp	[soft_reset]	; if yes, reboot
  189  01:B64F  60        .exit:	rts		; else return
  190                     
  191  01:B650            delay240:
  192  01:B650  48        	pha		; delay loop for 240 processor cycles
  193  01:B651  DA        	phx		; (including call/return overhead)
  194  01:B652  62        	cla
  195  01:B653  EA        	nop
  196  01:B654  EA        .lp:	nop
  197  01:B655  1A        	inc	a
  198  01:B656  C9 15     	cmp	#21
  199  01:B658  90 FA     	bcc	.lp
  200  01:B65A  FA        	plx
  201  01:B65B  68        	pla
  202  01:B65C            delay14:
  203  01:B65C  60        	rts
  204                     
  205  01:B65D            msbutt:
  206  01:B65D  9C 00 10  	stz	joyport	; toggle joystick port to read buttons
  207                     
  208  01:B660  20 5C B6  	jsr	delay14	; wait 14 cycles to settle (reference code says 9)
  209                     
  210  01:B663  AD 00 10  	lda	joyport	; read value
  211  01:B666  49 FF     	eor	#$FF	; change low-active to high-active
  212  01:B668  29 0F     	and	#$0F	; only 4 bits
  213  01:B66A  0C 28 22  	tsb	joy	; 'or' it into value
  214                     
  215  01:B66D  0D 32 22  	ora	joyold	; determine 'newly-pressed' buttons
  216  01:B670  4D 32 22  	eor	joyold
  217  01:B673  8D 2D 22  	sta	joytrg	; put them into 'delta'
  218  01:B676  60        	rts
  219                     
  220           0000      	.bank	LIB1_BANK	; restore bank-context
#[2]   startup.asm
 1288                     .endif	; SUPPORT_MOUSE
 1289                     
 1290           0001      .if (CDROM)
#[3]   cdrom.asm
 1291                      .include "cdrom.asm"
    1                     ;
    2                     ; PCE CDROM access routines' sources
    3                     ;
    4                     
#[4]   cdrom.inc
    5                     .include "cdrom.inc"
    1                     ;
    2                     ; CDROM.INC  -  MagicKit CD-ROM Equates
    3                     ;
    4                     
    5                     ;
    6                     ; Standard parameters for CD-ROM system functions
    7                     ;
    8                     
    9                     ; These attributes are used for CD_PLAY:
   10                     
   11           0000      CD_SECTOR	= %00000000
   12           0040      CD_MSF		= %01000000
   13           0080      CD_TRACK	= %10000000
   14           00C0      CD_CURRPOS	= %11000000
   15           00C0      CD_LEADOUT	= %11000000
   16           003F      CD_PLAYMODE	= %00111111
   17                     
   18           0000      CDPLAY_MUTE		= 0
   19           0001      CDPLAY_REPEAT		= 1
   20           0002      CDPLAY_NORMAL		= 2
   21           0000      CDPLAY_ENDOFDISC	= 0	; XXX: really?
   22                     
   23           0000      CDFADE_CANCEL	= 0
   24           0008      CDFADE_PCM6	= 8
   25           000A      CDFADE_ADPCM6	= 10
   26           000C      CDFADE_PCM2	= 12
   27           000E      CDFADE_ADPCM2	= 14
   28                     
   29           0000      CDTRK_AUDIO	= 0
   30           0004      CDTRK_DATA	= 4
   31                     
   32           0001      GRP_FILL	= 1
   33           0000      GRP_NOFILL	= 0
#[3]   cdrom.asm
    6                     
    7           29C7      	.bss
    8                     
    9  --:29C7            cdplay_end_ctl	.ds  1 ; saved 'cd_play end' information - type
   10  --:29C8            cdplay_end_h	.ds  1 ; high byte of address
   11  --:29C9            cdplay_end_m	.ds  1 ; mid byte
   12  --:29CA            cdplay_end_l	.ds  1 ; low byte
   13  --:29CB            cd_buf          .ds  4 ; Return buffer from some BIOS commands
   14                     
   15           DAF5      	.code
   16                     
   17                     ;
   18                     ; cd_reset(void)
   19                     ; ----
   20                     ; Reset CDROM
   21                     ; ----
   22                     ;
   23  00:DAF5            _cd_reset:
   24  00:DAF5  20 03 E0  	jsr	cd_reset
   25  00:DAF8  60        	rts
   26                     
   27                     ;
   28                     ; cd_pause(void)
   29                     ; ----
   30                     ; Pause CDROM drive
   31                     ; ----
   32                     ;
   33  00:DAF9            _cd_pause:
   34  00:DAF9  20 18 E0  	jsr	cd_pause
   35  00:DAFC  AA        	tax
   36  00:DAFD  62        	cla
   37  00:DAFE  60        	rts
   38                     
   39                     
   40                     ;
   41                     ; cd_unpause(void)
   42                     ; ----
   43                     ; Continue playing CDROM audio after pause
   44                     ; ----
   45                     ;
   46  00:DAFF            _cd_unpause:
   47           0000      .ifdef HAVE_LIB3
   53                     .endif ; HAVE_LIB3
   54  00:DAFF  AD C7 29  	lda	cdplay_end_ctl
   55  00:DB02  85 FF     	sta	<__dh
   56  00:DB04  AD C8 29  	lda	cdplay_end_h
   57  00:DB07  85 FC     	sta	<__cl
   58  00:DB09  AD C9 29  	lda	cdplay_end_m
   59  00:DB0C  85 FD     	sta	<__ch
   60  00:DB0E  AD CA 29  	lda	cdplay_end_l
   61  00:DB11  85 FE     	sta	<__dl
   62  00:DB13  A9 C0     	lda	#CD_CURRPOS
   63  00:DB15  85 FB     	sta	<__bh
   64  00:DB17  20 12 E0  	jsr	cd_play
   65  00:DB1A  AA        	tax
   66  00:DB1B  62        	cla
   67  00:DB1C  60        	rts
   68                     
   69           0000      .ifdef HAVE_LIB3
   71                     .endif ; HAVE_LIB3
   72                     
   73                     ;
   74                     ; cd_fade(char type)
   75                     ;
   76                     ;   type = $00 -> cancel fade
   77                     ;          $08 -> PCM fadeout 6 seconds
   78                     ;          $0A -> ADPCM fadeout 6 seconds
   79                     ;          $0C -> PCM fadeout 2.5 seconds
   80                     ;          $0E -> ADPCM fadeout 2.5 seconds
   81                     ; ----
   82                     ; Fade-out PCM/ADPCM audio
   83                     ; ----
   84                     ;
   85  00:DB1D            _cd_fade:
   86  00:DB1D  8A        	txa
   87  00:DB1E  20 2D E0  	jsr	cd_fade
   88  00:DB21  AA        	tax
   89  00:DB22  62        	cla
   90  00:DB23  60        	rts
   91                     
   92                     
   93                     ;
   94                     ; cd_playtrk(int start_track [__bx], int end_track [__cx], int mode [acc])
   95                     ;   mode = CDPLAY_MUTE / CDPLAY_REPEAT / CDPLAY_NORMAL
   96                     ; ----
   97                     ; Play CDROM audio track
   98                     ; ----
   99                     ;
  100  00:DB24            _cd_playtrk.3:
  101           0000      .ifdef HAVE_LIB3
  107                     .endif ; HAVE_LIB3
  108  00:DB24  8A        	txa
  109  00:DB25  29 3F     	and	#CD_PLAYMODE
  110  00:DB27  09 80     	ora	#CD_TRACK
  111  00:DB29  85 FF     	sta	<__dh		; end type + play mode
  112  00:DB2B  8D C7 29  	sta	cdplay_end_ctl
  113  00:DB2E  A9 80     	lda	#CD_TRACK
  114  00:DB30  85 FB     	sta	<__bh		; start type
  115                     
  116  00:DB32  A5 FC     	lda	<__cl
  117  00:DB34  D0 0B     	bne	.endtrk
  118                     
  119  00:DB36            .endofdisc:
  120  00:DB36  A5 FF     	lda	<__dh		; repeat to end of disc
  121  00:DB38  09 C0     	ora	#CD_LEADOUT
  122  00:DB3A  85 FF     	sta	<__dh
  123  00:DB3C  8D C7 29  	sta	cdplay_end_ctl
  124  00:DB3F  80 12     	bra	.starttrk
  125                     
  126  00:DB41            .endtrk:
  127  00:DB41  20 B4 E0  	jsr	ex_binbcd
  128  00:DB44  85 FC     	sta	<__cl		; end track
  129  00:DB46  8D C8 29  	sta	cdplay_end_h
  130  00:DB49  64 FD     	stz	<__ch
  131  00:DB4B  9C C9 29  	stz	cdplay_end_m
  132  00:DB4E  64 FE     	stz	<__dl
  133  00:DB50  9C CA 29  	stz	cdplay_end_l
  134                     
  135  00:DB53            .starttrk:
  136  00:DB53  A5 FA     	lda	<__bl		; track #
  137  00:DB55  20 B4 E0  	jsr	ex_binbcd
  138  00:DB58  85 F8     	sta	<__al		; from track
  139  00:DB5A  64 F9     	stz	<__ah
  140  00:DB5C  64 FA     	stz	<__bl
  141  00:DB5E  20 12 E0  	jsr	cd_play
  142  00:DB61  AA        	tax
  143  00:DB62  62        	cla
  144  00:DB63  60        	rts
  145                     
  146           0000      .ifdef HAVE_LIB3
  148                     .endif ; HAVE_LIB3
  149                     
  150                     ;
  151                     ; cd_playmsf(int start_minute [__al], int start_second [__ah], int start_frame [__bl],
  152                     ;            int end_minute [__cl], int end_second [__ch], int end_frame [__dl], int mode [acc])
  153                     ;   mode = CDPLAY_MUTE / CDPLAY_REPEAT / CDPLAY_NORMAL
  154                     ; ----
  155                     ; Play CDROM from/to 'minute/second/frame'
  156                     ; ----
  157                     ;
  158  00:DB64            _cd_playmsf.7:
  159           0000      .ifdef HAVE_LIB3
  165                     .endif ; HAVE_LIB3
  166  00:DB64  8A        	txa
  167  00:DB65  29 3F     	and	#CD_PLAYMODE
  168  00:DB67  09 40     	ora	#CD_MSF
  169  00:DB69  85 FF     	sta	<__dh		; end type + play mode
  170  00:DB6B  8D C7 29  	sta	cdplay_end_ctl
  171  00:DB6E  A9 40     	lda	#CD_MSF
  172  00:DB70  85 FB     	sta	<__bh		; start type
  173                     
  174  00:DB72            .endmsf:
  175  00:DB72  A5 FE     	lda	<__dl		; end frame
  176  00:DB74  20 B4 E0  	jsr	ex_binbcd
  177  00:DB77  85 FE     	sta	<__dl
  178  00:DB79  8D CA 29  	sta	cdplay_end_l
  179                     
  180  00:DB7C  A5 FD     	lda	<__ch		; end second
  181  00:DB7E  20 B4 E0  	jsr	ex_binbcd
  182  00:DB81  85 FD     	sta	<__ch
  183  00:DB83  8D C9 29  	sta	cdplay_end_m
  184                     
  185  00:DB86  A5 FC     	lda	<__cl		; end minute
  186  00:DB88  20 B4 E0  	jsr	ex_binbcd
  187  00:DB8B  85 FC     	sta	<__cl
  188  00:DB8D  8D C8 29  	sta	cdplay_end_h
  189                     
  190  00:DB90            .startmsf:
  191  00:DB90  A5 FA     	lda	<__bl		; start frame
  192  00:DB92  20 B4 E0  	jsr	ex_binbcd
  193  00:DB95  85 FA     	sta	<__bl
  194                     
  195  00:DB97  A5 F9     	lda	<__ah		; start second
  196  00:DB99  20 B4 E0  	jsr	ex_binbcd
  197  00:DB9C  85 F9     	sta	<__ah
  198                     
  199  00:DB9E  A5 F8     	lda	<__al		; start minute
  200  00:DBA0  20 B4 E0  	jsr	ex_binbcd
  201  00:DBA3  85 F8     	sta	<__al
  202                     
  203  00:DBA5  20 12 E0  	jsr	cd_play
  204  00:DBA8  AA        	tax
  205  00:DBA9  62        	cla
  206  00:DBAA  60        	rts
  207                     
  208           0000      .ifdef HAVE_LIB3
  210                     .endif ; HAVE_LIB3
  211                     
  212                     ;
  213                     ; char cd_numtrk(void)
  214                     ; ----
  215                     ; return number of tracks on CDROM
  216                     ; ----
  217                     ;
  218                     _cd_numtrk:	stw	#cd_buf,<__bx
       00:DBAB  A9 CB     	lda	LOW_BYTE #cd_buf
       00:DBAD  85 FA     	sta	LOW_BYTE <__bx
       00:DBAF  A9 29     	lda	HIGH_BYTE #cd_buf
       00:DBB1  85 FB     	sta	HIGH_BYTE <__bx
  219  00:DBB3  64 F8     	stz	<__al		; request type 0
  220  00:DBB5  20 21 E0  	jsr	cd_dinfo
  221  00:DBB8  C9 00     	cmp	#$00
  222  00:DBBA  D0 09     	bne	.err
  223  00:DBBC  AD CC 29  	lda	cd_buf+1
  224  00:DBBF  20 B7 E0  	jsr	ex_bcdbin
  225  00:DBC2  82        	clx
  226  00:DBC3  22        	sax
  227  00:DBC4  60        	rts
  228  00:DBC5  A9 FF     .err:	lda	#$ff
  229  00:DBC7  AA        	tax
  230  00:DBC8  60        	rts
  231                     
  232                     ;
  233                     ; char cd_trkinfo(char track [__ax], char *min [__cx], char *sec [__dx], char *frm [__bp])
  234                     ; ----
  235                     ; Return information about track
  236                     ; ----
  237                     ;
  238  00:DBC9            _cd_trkinfo.4:
  239           0000      .ifdef HAVE_LIB3
  245                     .endif ; HAVE_LIB3
  246                     	__ldw	<__ax
                0000      .if (1 = 2)
                          .else
       00:DBC9  A6 F8     	ldx	<__ax
       00:DBCB  A5 F9     	lda	<__ax+1
                          .endif
  247  00:DBCD  20 EB DB  	jsr	_cd_trktype
  248  00:DBD0  DA        	phx
  249  00:DBD1  AD CB 29  	lda	cd_buf
  250  00:DBD4  20 B7 E0  	jsr	ex_bcdbin
  251  00:DBD7  92 FC     	sta	[__cx]
  252                     
  253  00:DBD9  AD CC 29  	lda	cd_buf+1
  254  00:DBDC  20 B7 E0  	jsr	ex_bcdbin
  255  00:DBDF  92 FE     	sta	[__dx]
  256                     
  257  00:DBE1  AD CD 29  	lda	cd_buf+2
  258  00:DBE4  20 B7 E0  	jsr	ex_bcdbin
  259  00:DBE7  92 EC     	sta	[__bp]
  260                     
  261  00:DBE9  FA        	plx
  262  00:DBEA  60        	rts
  263           0000      .ifdef HAVE_LIB3
  265                     .endif ; HAVE_LIB3
  266                     
  267                     ;
  268                     ; char cd_trktype(char track)
  269                     ; ----
  270                     ; Return type of track (data/audio)
  271                     ; ----
  272                     ;
  273  00:DBEB            _cd_trktype:
  274           0000      .ifdef HAVE_LIB3
  280                     .endif ; HAVE_LIB3
  281  00:DBEB  22        	sax
  282  00:DBEC  20 B4 E0  	jsr	ex_binbcd
  283  00:DBEF  85 F9     	sta	<__ah		; track #
  284                     	stw	#cd_buf,<__bx
       00:DBF1  A9 CB     	lda	LOW_BYTE #cd_buf
       00:DBF3  85 FA     	sta	LOW_BYTE <__bx
       00:DBF5  A9 29     	lda	HIGH_BYTE #cd_buf
       00:DBF7  85 FB     	sta	HIGH_BYTE <__bx
  285  00:DBF9  C9 00     	cmp	#0
  286  00:DBFB  F0 04     	beq	.discnottrk
  287  00:DBFD  A9 02     	lda	#2
  288  00:DBFF  80 02     	bra	.go
  289  00:DC01            .discnottrk:
  290  00:DC01  A9 01     	lda	#1
  291  00:DC03  85 F8     .go:	sta	<__al		; request type 2
  292  00:DC05  20 21 E0  	jsr	cd_dinfo
  293  00:DC08  C9 00     	cmp	#$00
  294  00:DC0A  D0 05     	bne	.err
  295  00:DC0C  AE CE 29  	ldx	cd_buf+3	; track type
  296  00:DC0F  62        	cla
  297  00:DC10  60        	rts
  298  00:DC11  A9 FF     .err:	lda	#$ff
  299  00:DC13  AA        	tax
  300  00:DC14  60        	rts
  301                     
  302           0000      .ifdef HAVE_LIB3
  304                     .endif ; HAVE_LIB3
  305                     
  306                     ;
  307                     ; char cd_execoverlay(int ovl_index)
  308                     ; ----
  309                     ; Execute program overlay from disc
  310                     ; ----
  311                     ;
  312  00:DC15            _cd_execoverlay:
  313           0000      .ifdef HAVE_LIB3
  319                     .endif ; HAVE_LIB3
  320  00:DC15  20 29 DC  	jsr	cd_overlay
  321  00:DC18  C9 00     	cmp	#0
  322  00:DC1A  D0 03     	bne	.error
  323  00:DC1C  4C 00 C0  	jmp	$C000		; loaded fine... now run it
  324  00:DC1F  48        .error:	pha
  325  00:DC20  AE E3 26  	ldx	ovl_running	; failed; reload old segment for error recovery
  326  00:DC23  20 29 DC  	jsr	cd_overlay
  327  00:DC26  FA        	plx			; return error
  328  00:DC27  62        	cla
  329  00:DC28  60        	rts
  330                     
  331  00:DC29            cd_overlay:
  332  00:DC29  20 19 DD  	jsr	prep_rdsect
  333  00:DC2C  64 FC     	stz	<__cl	; sector (offset from base of track)
  334  00:DC2E  85 FD     	sta	<__ch
  335  00:DC30  86 FE     	stx	<__dl
  336  00:DC32  8A        	txa
  337  00:DC33  38        	sec
  338  00:DC34  49 FF     	eor	#$FF
  339  00:DC36  79 01 60  	adc	ovlarray + 1,Y
  340  00:DC39  85 F8     	sta	<__al	; # sectors
  341  00:DC3B  43 40     	tma	#6
  342  00:DC3D  85 FA     	sta	<__bl	; Bank #
  343  00:DC3F  A9 03     	lda	#3
  344  00:DC41  85 FF     	sta	<__dh	; MPR #
  345  00:DC43  20 09 E0  	jsr	cd_read
  346  00:DC46  60        	rts
  347           0000      .ifdef HAVE_LIB3
  349                     .endif ; HAVE_LIB3
  350                     
  351                     ;
  352                     ; char cd_loadvram(int ovl_index [__di], int sect_offset [__si], int vramaddr [__bx], int bytes [acc])
  353                     ; ----
  354                     ; Load CDROM data directly into VRAM
  355                     ; ----
  356                     ;
  357  00:DC47            _cd_loadvram.4:
  358           0000      .ifdef HAVE_LIB3
  364                     .endif ; HAVE_LIB3
  365                     	__stw	<__ax
       00:DC47  86 F8     	stx	<__ax
       00:DC49  85 F9     	sta	<__ax+1
  366                     	__ldw	<__di
                0000      .if (1 = 2)
                          .else
       00:DC4B  A6 F0     	ldx	<__di
       00:DC4D  A5 F1     	lda	<__di+1
                          .endif
  367  00:DC4F  20 19 DD  	jsr	prep_rdsect
  368                     	__addw	<__si
       00:DC52  18        	clc
       00:DC53  22        	sax
       00:DC54  65 EE     	adc	<__si
       00:DC56  22        	sax
       00:DC57  65 EF     	adc	<__si+1
  369  00:DC59  64 FC     	stz	<__cl
  370  00:DC5B  85 FD     	sta	<__ch
  371  00:DC5D  86 FE     	stx	<__dl
  372  00:DC5F  A9 FE     	lda	#$FE
  373  00:DC61  85 FF     	sta	<__dh
  374  00:DC63  20 09 E0  	jsr	cd_read
  375  00:DC66  AA        	tax
  376  00:DC67  62        	cla
  377  00:DC68  60        	rts
  378                     
  379           0000      .ifdef HAVE_LIB3
  381                     .endif ; HAVE_LIB3
  382                     
  383                     ;
  384                     ; char cd_loaddata(int ovl_index [__di], int sect_offset [__si], farptr array [__bl:__bp], int bytes [acc])
  385                     ; ----
  386                     ; Load CDROM data directly into data area, replacing predefined data
  387                     ; ----
  388                     ;
  389           29CF      	.bss
  390  --:29CF            cdtemp_l	.ds	1
  391  --:29D0            cdtemp_m	.ds	1
  392  --:29D1            cdtemp_bank	.ds	1
  393  --:29D2            cdtemp_savbnk60	.ds	1
  394  --:29D3            cdtemp_savbnk80	.ds	1
  395  --:29D4            cdtemp_addr	.ds	2
  396  --:29D6            cdtemp_bytes	.ds	2
  397           DC69      	.code
  398                     
  399  00:DC69            _cd_loaddata.4:
  400           0000      .ifdef HAVE_LIB3
  406                     .endif ; HAVE_LIB3
  407                     	__stw	cdtemp_bytes
       00:DC69  8E D6 29  	stx	cdtemp_bytes
       00:DC6C  8D D7 29  	sta	cdtemp_bytes+1
  408                     	__ldw	<__di
                0000      .if (1 = 2)
                          .else
       00:DC6F  A6 F0     	ldx	<__di
       00:DC71  A5 F1     	lda	<__di+1
                          .endif
  409  00:DC73  20 19 DD  	jsr	prep_rdsect
  410                     	__addw	<__si
       00:DC76  18        	clc
       00:DC77  22        	sax
       00:DC78  65 EE     	adc	<__si
       00:DC7A  22        	sax
       00:DC7B  65 EF     	adc	<__si+1
  411  00:DC7D  8E CF 29  	stx	cdtemp_l	; calculate sector adddress
  412  00:DC80  8D D0 29  	sta	cdtemp_m
  413                     
  414  00:DC83  43 08     	tma	#3		; save entry banks
  415  00:DC85  8D D2 29  	sta	cdtemp_savbnk60
  416  00:DC88  43 10     	tma	#4
  417  00:DC8A  8D D3 29  	sta	cdtemp_savbnk80
  418                     
  419  00:DC8D  A5 FA     	lda	<__bl
  420  00:DC8F  8D D1 29  	sta	cdtemp_bank	; load addr (bank/address)
  421                     	__ldw	<__bp
                0000      .if (1 = 2)
                          .else
       00:DC92  A6 EC     	ldx	<__bp
       00:DC94  A5 ED     	lda	<__bp+1
                          .endif
  422  00:DC96  29 1F     	and	#$1f		; correct to a $6000-relative addr.
  423  00:DC98  09 60     	ora	#$60
  424                     	__stw	cdtemp_addr
       00:DC9A  8E D4 29  	stx	cdtemp_addr
       00:DC9D  8D D5 29  	sta	cdtemp_addr+1
  425                     
  426  00:DCA0            .loop:
  427  00:DCA0  AD D1 29  	lda	cdtemp_bank	; get 2 adjacent banks just in case
  428  00:DCA3  53 08     	tam	#3
  429  00:DCA5  1A        	inc	A
  430  00:DCA6  53 10     	tam	#4
  431                     
  432                     	__ldw	cdtemp_addr	; load address
                0000      .if (1 = 2)
                          .else
       00:DCA8  AE D4 29  	ldx	cdtemp_addr	
       00:DCAB  AD D5 29  	lda	cdtemp_addr	+1
                          .endif
  433                     	__stw	<__bx
       00:DCAE  86 FA     	stx	<__bx
       00:DCB0  85 FB     	sta	<__bx+1
  434                     
  435  00:DCB2  64 FC     	stz	<__cl		; sector address
  436  00:DCB4  AD D0 29  	lda	cdtemp_m
  437  00:DCB7  85 FD     	sta	<__ch
  438  00:DCB9  AD CF 29  	lda	cdtemp_l
  439  00:DCBC  85 FE     	sta	<__dl
  440  00:DCBE  64 FF     	stz	<__dh		; address type (local, # bytes)
  441                     
  442                     	__ldw	cdtemp_bytes
                0000      .if (1 = 2)
                          .else
       00:DCC0  AE D6 29  	ldx	cdtemp_bytes
       00:DCC3  AD D7 29  	lda	cdtemp_bytes+1
                          .endif
  443                     	sub	#$20
                0000      .if (1 = 2)			; from register A (handle
                          .else
       00:DCC6  38        	sec
       00:DCC7  E9 20     	sbc	#$20
                          .endif
  444  00:DCC9  30 0C     	bmi	.less2000
  445                     	__stw	cdtemp_bytes
       00:DCCB  8E D6 29  	stx	cdtemp_bytes
       00:DCCE  8D D7 29  	sta	cdtemp_bytes+1
  446                     	__ldwi	$2000
       00:DCD1  A2 00     	ldx	#low($2000)
       00:DCD3  A9 20     	lda	#high($2000)
  447  00:DCD5  80 09     	bra	.read
  448                     
  449                     .less2000:	add	#$20
                0000      .if (1 = 2)			; register A (handle carry
                          .else
       00:DCD7  18        	clc
       00:DCD8  69 20     	adc	#$20
                          .endif
  450                     	stwz	cdtemp_bytes
       00:DCDA  9C D6 29  	stz	LOW_BYTE cdtemp_bytes
       00:DCDD  9C D7 29  	stz	HIGH_BYTE cdtemp_bytes
  451                     .read:	__stw	<__ax
       00:DCE0  86 F8     	stx	<__ax
       00:DCE2  85 F9     	sta	<__ax+1
  452                     
  453  00:DCE4  20 09 E0  	jsr	cd_read
  454  00:DCE7  C9 00     	cmp	#0
  455  00:DCE9  D0 21     	bne	.error
  456                     
  457                     	__tstw	cdtemp_bytes	; if still some bytes to read
                          	; pha
       00:DCEB  86 02     	stx	<__temp
       00:DCED  05 02     	ora	<__temp
       00:DCEF  62        	cla
       00:DCF0  82        	clx
       00:DCF1  F0 01     	beq	.x_00553
       00:DCF3  E8        	inx
       00:DCF4            .x_00553:
                          	; pla
  458  00:DCF4  F0 16     	beq	.error		; but A = 0 so no error
  459                     
  460                     	addw	#4,cdtemp_l	; add 4 sectors (with 16-bit carry)
                0000      .if	(2 = 3)
                          .else
                          	; 2-arg mode
                          	;
       00:DCF6  18        	clc
       00:DCF7  AD CF 29  	lda	LOW_BYTE cdtemp_l	
       00:DCFA  69 04     	adc	LOW_BYTE #4
       00:DCFC  8D CF 29  	sta	LOW_BYTE cdtemp_l	
       00:DCFF  AD D0 29  	lda	HIGH_BYTE cdtemp_l	
       00:DD02  69 00     	adc	HIGH_BYTE #4
       00:DD04  8D D0 29  	sta	HIGH_BYTE cdtemp_l	
                          .endif
  461  00:DD07  EE D1 29  	inc	cdtemp_bank	; go back for next bank
  462  00:DD0A  80 94     	bra	.loop
  463                     
  464  00:DD0C  AA        .error:	tax
  465  00:DD0D  AD D2 29  	lda	cdtemp_savbnk60
  466  00:DD10  53 08     	tam	#3
  467  00:DD12  AD D3 29  	lda	cdtemp_savbnk80
  468  00:DD15  53 10     	tam	#4
  469  00:DD17  62        	cla
  470  00:DD18  60        	rts
  471           0000      .ifdef HAVE_LIB3
  473                     .endif ; HAVE_LIB3
  474                     
  475                     ;
  476                     ; prepare the sector address
  477                     ;
  478  00:DD19  8A        prep_rdsect:	txa
  479  00:DD1A  A8        	tay
  480                     	map	ovlarray	; in DATA_BANK
       00:DD1B  A9 83     	lda	#bank(ovlarray	)	; addressable memory
       00:DD1D  53 08     	tam	#page(ovlarray	)
  481  00:DD1F  BE 00 60  	ldx	ovlarray,Y
  482  00:DD22  B9 64 60  	lda	ovlarray + 100,Y
  483  00:DD25  60        	rts
  484                     
  485                     ;--------------------
  486                     ; NOT IMPLEMENTED YET
  487                     ; XXX: So what is that code below then?
  488                     ;--------------------
  489                     ;
  490                     ;
  491                     ; cd_status()
  492                     ; ----
  493                     ; Get CDROM status
  494                     ;
  495                     ;   input $00     (= busy check)  -> return $00 if not busy, else busy
  496                     ;         (other) (= ready check) -> return $00 if ready, else sub error code
  497                     ; ----
  498                     ;
  499  00:DD26            _cd_status:
  500  00:DD26  8A        	txa
  501  00:DD27  20 1B E0  	jsr	cd_stat
  502  00:DD2A  AA        	tax
  503  00:DD2B  62        	cla
  504  00:DD2C  60        	rts
  505                     
  506                     
  507                     ;--------------------
  508                     
  509                     
  510                     ;
  511                     ; int cd_getver()
  512                     ; ----
  513                     ; get CDROM system card version number
  514                     ; MSB = major number
  515                     ; LSB = minor number
  516                     ; ----
  517                     ;
  518  00:DD2D            _cd_getver:
  519  00:DD2D  20 5A E0  	jsr	ex_getver
  520  00:DD30  98        	tya
  521  00:DD31  22        	sax
  522  00:DD32  60        	rts
  523                     
  524                     
  525                     ;
  526                     ; int ac_exists(void)
  527                     ; ----
  528                     ; Detect Arcade Card (return 1 if true)
  529                     ; ----
  530                     ;
  531  00:DD33            _ac_exists:
  532  00:DD33  AD FF 1A  	lda	ac_identflag
  533  00:DD36  A2 01     	ldx	#1
  534  00:DD38  C9 51     	cmp	#AC_IDENT
  535  00:DD3A  F0 01     	beq	.true
  536  00:DD3C  82        	clx
  537  00:DD3D  62        .true:	cla
  538  00:DD3E  60        	rts
  539                     
  540                     ;
  541                     ; ad_reset(void)
  542                     ; ----
  543                     ; Reset ADPCM device
  544                     ; ----
  545                     ;
  546  00:DD3F            _ad_reset:
  547  00:DD3F  20 30 E0  	jsr	ad_reset
  548  00:DD42  60        	rts
  549                     
  550                     ;
  551                     ; ad_stop(void)
  552                     ; ----
  553                     ; stop ADPCM playing
  554                     ; ----
  555                     ;
  556  00:DD43            _ad_stop:
  557  00:DD43  20 42 E0  	jsr	ad_stop
  558  00:DD46  60        	rts
  559                     
  560                     ;
  561                     ; char ad_stat(void)
  562                     ; ----
  563                     ; Get ADPCM status
  564                     ; ----
  565                     ;
  566  00:DD47            _ad_stat:
  567  00:DD47  20 45 E0  	jsr	ad_stat
  568  00:DD4A  AA        	tax
  569  00:DD4B  62        	cla
  570  00:DD4C  60        	rts
  571                     
  572                     ;
  573                     ; char ad_trans(int ovl_index [__di], int sect_offset [__si], char nb_sectors [__al], int ad_addr [__bx])
  574                     ; ----
  575                     ; Load CDROM data directly into ADPCM RAM
  576                     ; ----
  577                     ;
  578  00:DD4D            _ad_trans.4:
  579                     	__ldw	<__di
                0000      .if (1 = 2)
                          .else
       00:DD4D  A6 F0     	ldx	<__di
       00:DD4F  A5 F1     	lda	<__di+1
                          .endif
  580  00:DD51  20 19 DD  	jsr	prep_rdsect
  581                     	__addw	<__si
       00:DD54  18        	clc
       00:DD55  22        	sax
       00:DD56  65 EE     	adc	<__si
       00:DD58  22        	sax
       00:DD59  65 EF     	adc	<__si+1
  582  00:DD5B  64 FC     	stz	<__cl
  583  00:DD5D  85 FD     	sta	<__ch
  584  00:DD5F  86 FE     	stx	<__dl
  585  00:DD61  64 FF     	stz	<__dh
  586  00:DD63  20 33 E0  	jsr	ad_trans
  587  00:DD66  AA        	tax
  588  00:DD67  62        	cla
  589  00:DD68  60        	rts
  590                     
  591                     ;
  592                     ; char ad_read(int ad_addr [__cx], char mode [__dh], int buf [__bx], int bytes [__ax])
  593                     ; ----
  594                     ; copy data from ADPCM RAM directly to RAM or VRAM
  595                     ; ----
  596                     ;
  597  00:DD69            _ad_read.4:
  598  00:DD69  20 36 E0  	jsr	ad_read
  599  00:DD6C  AA        	tax
  600  00:DD6D  62        	cla
  601  00:DD6E  60        	rts
  602                     
  603                     ;
  604                     ; char ad_write(int ad_addr [__cx], char mode [__dh], int buf [__bx], int bytes [__ax])
  605                     ; ----
  606                     ; copy data from RAM or VRAM directly to ADPCM VRAM
  607                     ; ----
  608                     ;
  609  00:DD6F            _ad_write.4:
  610  00:DD6F  20 39 E0  	jsr	ad_write
  611  00:DD72  AA        	tax
  612  00:DD73  62        	cla
  613  00:DD74  60        	rts
  614                     
  615                     ;
  616                     ; char ad_play(int ad_addr [__bx], int bytes [__ax], char freq [__dh], char mode [__dl])
  617                     ; ----
  618                     ; play ADPCM sample
  619                     ; ----
  620                     ;
  621  00:DD75            _ad_play.4:
  622  00:DD75  20 3C E0  	jsr	ad_play
  623  00:DD78  AA        	tax
  624  00:DD79  62        	cla
  625  00:DD7A  60        	rts
#[2]   startup.asm
 1292                     .endif	; CDROM
 1293                     
 1294           0000      .if (NEED_SOUND_CODE)
 1296                     .endif ; defined in sound.inc if needed
 1297                     
 1298                     ;
 1299                     ;
 1300                     ;
 1301                     
 1302                     ; ----
 1303                     ; disp_on
 1304                     ; ----
 1305                     ; enable display
 1306                     ; ----
 1307                     
 1308           0001      .ifdef HUC
 1309                     
 1310  00:DD7B            _disp_on:
 1311  00:DD7B  AE 8E 26  	ldx   disp_cr
 1312           0001      .if (CDROM)
 1313  00:DD7E  A9 02     	lda	#2
 1314                     .else
 1316                     .endif
 1317  00:DD80  8D 8E 26  	sta   disp_cr
 1318  00:DD83  62        	cla
 1319  00:DD84  60        	rts
 1320                     
 1321                     .else	; HUC
 1328                     .endif	; HUC
 1329                     
 1330                     
 1331                     ; ----
 1332                     ; disp_off
 1333                     ; ----
 1334                     ; disable display
 1335                     ; ----
 1336                     
 1337           0001      .ifdef HUC
 1338                     
 1339  00:DD85            _disp_off:
 1340  00:DD85  AE 8E 26  	ldx   disp_cr
 1341           0001      .if (CDROM)
 1342  00:DD88  A9 01     	lda	#1
 1343  00:DD8A  8D 8E 26  	sta	disp_cr
 1344                     .else
 1346                     .endif
 1347  00:DD8D  62        	cla
 1348  00:DD8E  60        	rts
 1349                     
 1350                     .else	; HUC
 1356                     .endif	; HUC
 1357                     
 1358                     ; ----
 1359                     ; set_intvec
 1360                     ; ----
 1361                     ; set interrupt vector
 1362                     ; ----
 1363                     ; IN : A = vector number
 1364                     ;           0 IRQ2
 1365                     ;           1 IRQ1 (VDC)
 1366                     ;           2 TIMER
 1367                     ;           3 NMI
 1368                     ;           4 VSYNC
 1369                     ;           5 HSYNC
 1370                     ;           6 SOFT RESET (RUN + SELECT)
 1371                     ;      X = vector address low byte
 1372                     ;      Y =   "      "    high byte
 1373                     ; ----
 1374                     
 1375           0000      .if  !(CDROM)
 1400                     .endif	; !(CDROM)
 1401                     
 1402                     ; ----
 1403                     ; wait_vsync
 1404                     ; ----
 1405                     ; wait the next vsync
 1406                     ; ----
 1407                     ; IN :  A = number of frames to be sync'ed on
 1408                     ; ----
 1409                     ; OUT:  A = number of elapsed frames since last call
 1410                     ; ----
 1411                     
 1412  00:DD8F            wait_vsync:
 1413  00:DD8F  1F F5 03  	bbr1 <irq_m,.l1
 1414  00:DD92  62        	cla			; return immediately if IRQ1 is redirected
 1415           0001      .ifdef HUC
 1416  00:DD93  82        	clx
 1417                     .endif
 1418  00:DD94  60        	rts
 1419                     
 1420  00:DD95  78        .l1:	sei			; disable interrupts
 1421  00:DD96  CD 41 22  	cmp   irq_cnt		; calculate how many frames to wait
 1422  00:DD99  F0 05     	beq  .l2
 1423                     	bhs  .l3
       00:DD9B  B0 04     	bcs	.l3
 1424  00:DD9D  AD 41 22  	lda   irq_cnt
 1425  00:DDA0  1A        .l2:	inc   A
 1426                     .l3:	sub   irq_cnt
                0000      .if (1 = 2)			; from register A (handle
                          .else
       00:DDA1  38        	sec
       00:DDA2  ED 41 22  	sbc	irq_cnt
                          .endif
 1427  00:DDA5  8D 80 26  	sta   vsync_cnt
 1428  00:DDA8  58        	cli			; re-enable interrupts
 1429                     
 1430  00:DDA9  AD 41 22  .l4:	lda   irq_cnt		; wait loop
 1431                     .l5:	incw  rndseed2
       00:DDAC  EE AB 27  	inc	rndseed2		; value at stated memory
       00:DDAF  D0 03     	bne	.x_00560		; location
       00:DDB1  EE AC 27  	inc	rndseed2+1
       00:DDB4            .x_00560:
 1432  00:DDB4  CD 41 22  	cmp   irq_cnt
 1433  00:DDB7  F0 F3     	beq  .l5
 1434  00:DDB9  CE 80 26  	dec   vsync_cnt
 1435  00:DDBC  D0 EB     	bne  .l4
 1436                     
 1437  00:DDBE  9C 41 22  	stz   irq_cnt		; reset system interrupt counter
 1438  00:DDC1  1A        	inc   A			; return number of elapsed frames
 1439                     
 1440           0000      .ifndef HUC
 1444                     .else	; !HUC
 1445                     
 1446                         ; ----
 1447                         ; callback support
 1448                     
 1449  00:DDC2  48        	pha
 1450  00:DDC3  AD 88 26  	lda   joycallback	; callback valid?
 1451  00:DDC6  10 34     	bpl  .t3
 1452  00:DDC8  89 01     	bit   #$01
 1453  00:DDCA  D0 30     	bne  .t3
 1454                     
 1455  00:DDCC  AD 89 26  	lda   joycallback+1	; get events for all the 
 1456  00:DDCF  F0 2B     	beq  .t3		; selected joypads
 1457  00:DDD1  85 F8     	sta  <__al
 1458  00:DDD3  C2        	cly
 1459  00:DDD4  62        	cla
 1460  00:DDD5  46 F8     .t1:    lsr  <__al
 1461  00:DDD7  90 03     	bcc  .t2
 1462  00:DDD9  19 81 26  	ora   joybuf,Y
 1463  00:DDDC  C8        .t2:	iny
 1464  00:DDDD  C0 05     	cpy   #5
 1465                     	blo  .t1
       00:DDDF  90 F4     	bcc	.t1
 1466                     
 1467  00:DDE1  2D 8A 26  	and   joycallback+2	; compare with requested state
 1468  00:DDE4  F0 16     	beq  .t3
 1469                     
 1470  00:DDE6  EE 88 26  	inc   joycallback	; lock callback feature
 1471  00:DDE9  AA        	tax			; call user routine
 1472  00:DDEA  43 20     	tma   #5
 1473  00:DDEC  48        	pha
 1474  00:DDED  AD 8B 26  	lda   joycallback+3
 1475  00:DDF0  53 20     	tam   #5
 1476  00:DDF2  62        	cla
 1477  00:DDF3  20 FF DD  	jsr  .callback
 1478  00:DDF6  68        	pla
 1479  00:DDF7  53 20     	tam   #5
 1480  00:DDF9  CE 88 26  	dec   joycallback	; unlock
 1481                     	; --
 1482  00:DDFC  FA        .t3:	plx
 1483  00:DDFD  62        	cla
 1484  00:DDFE  60        	rts
 1485                     
 1486                         ; ----
 1487                         ; user routine callback
 1488                         ;
 1489  00:DDFF            .callback:
 1490  00:DDFF  6C 8C 26  	jmp   [joycallback+4]
 1491                     
 1492                     .endif	; !HUC
 1493                     
#[3]   joypad.asm
 1494                     .include  "joypad.asm"	; read joypad values
    1                     ; ----
    2                     ; read_joypad
    3                     ; ----
    4                     ; poll joypads
    5                     ;
    6                     ; 'joyport' (location $1000) is a control read/write port which only reads
    7                     ; 4 bits at a time; the program uses joyport to toggle the multiplex line
    8                     ;
    9                     ; real logic values are read into the port - the joypad's keys are default
   10                     ; high, and 'pulled' low when pressed.  Therefore, these values must be
   11                     ; inverted/complemented to yield values where '1' means 'pressed'
   12                     ;
   13                     ; bit values for joypad bytes: (MSB = #7; LSB = #0)
   14                     ; -------------------------------------------------
   15                     ; bit 0 (ie $01) = I
   16                     ; bit 1 (ie $02) = II
   17                     ; bit 2 (ie $04) = 'select'
   18                     ; bit 3 (ie $08) = 'run'
   19                     ; bit 4 (ie $10) = UP
   20                     ; bit 5 (ie $20) = RIGHT
   21                     ; bit 6 (ie $40) = DOWN
   22                     ; bit 7 (ie $80) = LEFT
   23                     ; ----
   24                     ; bit values for joypad 6-button bytes: (MSB = #7; LSB = #0)
   25                     ; ----------------------------------------------------------
   26                     ; bit 0	(ie $01) = III
   27                     ; bit 1	(ie $02) = IV
   28                     ; bit 2	(ie $04) = V
   29                     ; bit 3	(ie $08) = VI
   30                     ; bit 4-7 (ie $F0) = exists (all on or all off)
   31                     ; ----
   32                     
   33                     ; Note: Read twice for 6-button joysticks.
   34                     ; First read should be for 'joy' and second for
   35                     ; 'joy6'; need to hide values temporarily while
   36                     ; scanning twice.
   37                     
   38  00:DE02            read_joypad:
   39           0000      .ifdef _SGX
   41                     .else
   42                     	maplibfunc	lib2_readjoy
       00:DE02  A8        	tay
       00:DE03  43 20     	tma	#page(lib2_readjoy)
       00:DE05  48        	pha
       00:DE06  A9 81     	lda	#bank(lib2_readjoy)
       00:DE08  53 20     	tam	#page(lib2_readjoy)
       00:DE0A  98        	tya
       00:DE0B  20 77 B6  	jsr	lib2_readjoy
       00:DE0E  A8        	tay
       00:DE0F  68        	pla
       00:DE10  53 20     	tam	#page(lib2_readjoy)
       00:DE12  98        	tya
   43                     .endif
   44  00:DE13  60        	rts
   45                     
   46           0000      .ifdef _SGX
   49                     .else
   50           0001      	.bank	LIB2_BANK
   51  01:B677            lib2_readjoy:
   52                     .endif
   53  01:B677  AD 27 22  	lda	joyena		; suppress reset during individual read
   54  01:B67A  48        	pha
   55  01:B67B  9C 27 22  	stz	joyena
   56                     
   57           0001      .if (CDROM)
   58  01:B67E  20 63 E0  	jsr	ex_joysns
   59                     .else
   61                     .endif
   62                     
   63  01:B681  73 28 22  	tii	joy, joy6, 5	; move to 6-button area
       01:B684  93 26 05  
       01:B687  00        
   64                     
   65           0001      .if (CDROM)
   66  01:B688  20 63 E0  	jsr	ex_joysns
   67                     .else
   69                     .endif
   70                     
   71  01:B68B  68        	pla
   72  01:B68C  8D 27 22  	sta	joyena
   73                     
   74  01:B68F  73 A7 26  	tii	joytmp, joyold, 5	; restore past info from stash
       01:B692  32 22 05  
       01:B695  00        
   75  01:B696  73 AC 26  	tii	joytmp6, joyold6, 5
       01:B699  9D 26 05  
       01:B69C  00        
   76                     
   77                     	;
   78                     	; the '.l2' loop determines if first or
   79                     	; second scans imply a 6-button joystick,
   80                     	; and rearrange bytes if out of order,
   81                     	; and zero the joy6 area if necessary
   82                     	;
   83  01:B69D  C2        	cly
   84  01:B69E  B9 28 22  .l2:	lda	joy,Y		; check if 6-button joypad, and
   85  01:B6A1  AA        	tax
   86  01:B6A2  29 50     	and	#JOY_TYPE6	; scans became backwards somehow
   87  01:B6A4  C9 50     	cmp	#JOY_TYPE6
   88  01:B6A6  D0 0A     	bne	.notswap
   89  01:B6A8  B9 93 26  	lda	joy6,Y		; then swap them if they need it
   90  01:B6AB  99 28 22  	sta	joy,Y
   91  01:B6AE  22        	sax
   92  01:B6AF  99 93 26  	sta	joy6,Y
   93                     
   94  01:B6B2            .notswap:
   95  01:B6B2  B9 93 26  	lda	joy6,Y		; verify whether a 6-button exists
   96  01:B6B5  29 50     	and	#JOY_TYPE6
   97  01:B6B7  C9 50     	cmp	#JOY_TYPE6
   98  01:B6B9  F0 04     	beq	.type6
   99  01:B6BB  62        	cla
  100  01:B6BC  99 93 26  	sta	joy6,Y		; not 6-button, so clear extra entry
  101                     
  102  01:B6BF            .type6:
  103  01:B6BF  B9 93 26  	lda	joy6,Y		; strip off unused bits
  104  01:B6C2  29 5F     	and	#(JOY_III | JOY_IV | JOY_V | JOY_VI | JOY_TYPE6)
  105  01:B6C4  99 93 26  	sta	joy6,Y		; clear unnecessary bits
  106                     
  107                     
  108                     	;
  109                     	; The '.l2a' area sets appropriate values
  110                     	; for all of the joytrg and joybuf areas
  111                     	;
  112                     
  113  01:B6C7  B9 28 22  .l2a:	lda	joy,Y
  114  01:B6CA  59 32 22  	eor	joyold,Y		; check against previous value
  115  01:B6CD  39 28 22  	and	joy,Y
  116  01:B6D0  99 2D 22  	sta	joytrg,Y		; 'new key pressed' key values
  117                     
  118                     	; ----
  119                     	; buffered 'new key pressed'
  120                     	; see joy_events();
  121                     	;
  122  01:B6D3  19 81 26  	ora	joybuf,Y		; collect 'new key pressed'
  123  01:B6D6  99 81 26  	sta	joybuf,Y
  124                     
  125                     	; ----
  126                     	; repeat the joyold/joytrg/joybuf stuff
  127                     	; for 6-button values
  128                     	;
  129  01:B6D9  B9 93 26  	lda	joy6,Y
  130  01:B6DC  59 9D 26  	eor	joyold6,Y
  131  01:B6DF  39 93 26  	and	joy6,Y
  132  01:B6E2  99 98 26  	sta	joytrg6,Y
  133  01:B6E5  19 A2 26  	ora	joybuf6,Y
  134  01:B6E8  99 A2 26  	sta	joybuf6,Y
  135                     
  136                     	; ----
  137                     	; next joypad
  138                     	;
  139  01:B6EB  C8        	iny
  140  01:B6EC  C0 05     	cpy	#$05		; cycle for next of 5 joypads
  141  01:B6EE  90 AE     	bcc	.l2
  142                     
  143                     	; ----
  144                     	; soft reset check
  145                     	;
  146  01:B6F0  C2        	cly			; start cycle of 5 joypads
  147  01:B6F1  AD 27 22  .l3:	lda	joyena		; find mask of 'important' joysticks
  148  01:B6F4  39 29 B7  	and	.bitmsk,Y
  149  01:B6F7  F0 11     	beq	.l4		; not important enough to check
  150  01:B6F9  B9 2D 22  	lda	joytrg,Y
  151  01:B6FC  C9 04     	cmp	#$04		; 'select' key newly-pressed ?
  152  01:B6FE  D0 0A     	bne	.l4
  153  01:B700  B9 28 22  	lda	joy,Y
  154  01:B703  C9 0C     	cmp	#$0C		; 'run+select' currently pressed ?
  155  01:B705  D0 03     	bne	.l4
  156                     
  157           0000      .if (DEVELO)
  159                     .else
  160  01:B707  6C 84 22  	jmp	[soft_reset]	; run+select 'soft reset' vector
  161                     .endif ; (DEVELO)
  162                     
  163  01:B70A  C8        .l4:	iny			; try next joypad
  164  01:B70B  C0 05     	cpy	#$05
  165  01:B70D  90 E2     	bcc	.l3
  166                     
  167                     	; ----
  168                     	; joyread hook
  169                     	;
  170           0001      .ifdef HUC
  171                     	tstw	joyhook
       01:B70F  AD 86 26  	lda	joyhook		; value at stated memory
       01:B712  0D 87 26  	ora	joyhook+1		; location is zero
  172  01:B715  F0 03     	beq	.l5
  173  01:B717  20 2E B7  	jsr	.hook
  174  01:B71A            .l5:
  175                     .endif	; HUC
  176                     
  177                     
  178                     	; ----
  179                     	; return
  180                     	;
  181  01:B71A  73 28 22  	tii	joy, joytmp, 5	; stash values for next read because CDROM
       01:B71D  A7 26 05  
       01:B720  00        
  182  01:B721  73 93 26  	tii	joy6, joytmp6, 5	; may force another read between VSYNC's
       01:B724  AC 26 05  
       01:B727  00        
  183                     
  184  01:B728  60        	rts
  185                     
  186                     
  187           0000      .if !(CDROM)
  233                     .endif	; !(CDROM)
  234                     
  235  01:B729            .bitmsk:
  236  01:B729  01 02 04  	.db $01,$02,$04,$08,$10	; bit-masks for check-reset
       01:B72C  08 10     
  237                     
  238                     	; ----
  239                     	; user routine
  240                     	;
  241           0001      .ifdef HUC
  242  01:B72E            .hook:
  243  01:B72E  6C 86 26  	jmp	[joyhook]
  244                     .endif	; HUC
  245                     
  246                     ; At end of all this lib2_bank stuff, we need to return
  247                     ; to the base context of lib1_bank:
  248                     
  249           0000      	.bank	LIB1_BANK
#[2]   startup.asm
#[1]   seekaud.s
   15           60C8      	.data
   16           0003      	.bank DATA_BANK
   17                     
   18           DE14      	.code
   19                     
   20                     ;/*
   21                     ; *
   22                     ; * Seektest2 - attempts 10 seeks for minimum and average delays
   23                     ; * 
   24                     ; */
   25                     ;#include "huc.h"
   26                     ;/*
   27                     ; * backup ram defines
   28                     ; */
   29                     ;#define  BM_OK             0
   30                     ;#define  BM_NOT_FOUND      1
   31                     ;#define  BM_BAD_CHECKSUM   2
   32                     ;#define  BM_DIR_CORRUPTED  3
   33                     ;#define  BM_FILE_EMPTY     4
   34                     ;#define  BM_FULL           5
   35                     ;#define  BM_NOT_FORMATED   0xFF
   36                     ;#define  BRAM_STARTPTR     0x8010
   37                     ;/*
   38                     ; * sprite defines
   39                     ; */
   40                     ;#define  FLIP_X_MASK 0x08
   41                     ;#define  FLIP_Y_MASK 0x80
   42                     ;#define  FLIP_MAS   0x88
   43                     ;#define  SIZE_MAS   0x31
   44                     ;#define  NO_FLIP    0x00
   45                     ;#define  NO_FLIP_X  0x00
   46                     ;#define  NO_FLIP_Y  0x00
   47                     ;#define  FLIP_X     0x08
   48                     ;#define  FLIP_Y     0x80
   49                     ;#define  SZ_16x16   0x00
   50                     ;#define  SZ_16x32   0x10
   51                     ;#define  SZ_16x64   0x30
   52                     ;#define  SZ_32x16   0x01
   53                     ;#define  SZ_32x32   0x11
   54                     ;#define  SZ_32x64   0x31
   55                     ;/*
   56                     ; * joypad defines
   57                     ; */
   58                     ;#define	JOY_A		0x01
   59                     ;#define	JOY_I		0x01
   60                     ;#define	JOY_B		0x02
   61                     ;#define	JOY_II		0x02
   62                     ;#define	JOY_SLCT	0x04
   63                     ;#define	JOY_SEL		0x04
   64                     ;#define	JOY_STRT	0x08
   65                     ;#define	JOY_RUN		0x08
   66                     ;#define	JOY_UP		0x10
   67                     ;#define	JOY_RGHT	0x20
   68                     ;#define	JOY_RIGHT	0x20
   69                     ;#define	JOY_DOWN	0x40
   70                     ;#define	JOY_LEFT	0x80
   71                     ;#define	JOY_C		0x0100
   72                     ;#define	JOY_III		0x0100
   73                     ;#define	JOY_D		0x0200
   74                     ;#define	JOY_IV		0x0200
   75                     ;#define	JOY_E		0x0400
   76                     ;#define	JOY_V		0x0400
   77                     ;#define	JOY_F		0x0800
   78                     ;#define	JOY_VI		0x0800
   79                     ;#define JOY_SIXBUT	0x5000
   80                     ;#define JOY_TYPE6	0x5000
   81                     ;/*
   82                     ; * screen defines
   83                     ; */
   84                     ;#define	SCR_SIZE_32x32	0
   85                     ;#define	SCR_SIZE_64x32	1
   86                     ;#define	SCR_SIZE_128x32	3
   87                     ;#define	SCR_SIZE_32x64	4
   88                     ;#define	SCR_SIZE_64x64	5
   89                     ;#define	SCR_SIZE_128x64	7
   90                     ;#define	XRES_SHARP	0
   91                     ;#define	XRES_SOFT	4
   92                     ;/*
   93                     ; * CD defines
   94                     ; */
   95                     ;#define	CDPLAY_MUTE		0
   96                     ;#define	CDPLAY_REPEAT		1
   97                     ;#define	CDPLAY_NORMAL		2
   98                     ;#define	CDPLAY_ENDOFDISC	0
   99                     ;#define	CDFADE_CANCEL	0
  100                     ;#define	CDFADE_PCM6	8
  101                     ;#define	CDFADE_ADPCM6	10
  102                     ;#define	CDFADE_PCM2	12
  103                     ;#define	CDFADE_ADPCM2	14
  104                     ;#define CDTRK_AUDIO	0
  105                     ;#define CDTRK_DATA	4
  106                     ;/*
  107                     ; * ADPCM defines
  108                     ; */
  109                     ;#define	ADPLAY_AUTOSTOP		0
  110                     ;#define	ADPLAY_REPEAT		0x80
  111                     ;#define ADPLAY_FREQ_16KHZ	0xE
  112                     ;#define ADPLAY_FREQ_10KHZ	0xD
  113                     ;#define ADPLAY_FREQ_8KHZ	0xC
  114                     ;#define ADPLAY_FREQ_6KHZ	0xB
  115                     ;#define ADPLAY_FREQ_5KHZ	0xA
  116                     ;#define ADREAD_RAM	0
  117                     ;#define ADREAD_VRAM	0xFF
  118                     ;#define ADWRITE_RAM	0
  119                     ;#define ADWRITE_VRAM	0xFF
  120                     ;void vsync(void);
  121                     ;void satb_update(void);
  122                     ;void __fastcall vsync(unsigned char num<acc>);
  123                     ;void __fastcall satb_update(unsigned char max<acc>);
  124                     ;void __fastcall vreg(unsigned char reg<acc>);
  125                     ;void __fastcall vreg(unsigned char reg<__al>, unsigned int data<acc>);
  126                     ;void __fastcall spr_hide(unsigned char num<acc>);
  127                     ;void __fastcall spr_show(unsigned char num<acc>);
  128                     ;void __fastcall set_map_pals(char far *pal<__bl:__si>);
  129                     ;void set_map_tile_type(unsigned char);
  130                     ;void set_map_tile_base(unsigned int vaddr);
  131                     ;unsigned char mem_mapdatabank(unsigned char new_bank);
  132                     ;unsigned int mem_mapdatabanks(unsigned int new_banks);
  133                     ;void timer_set(unsigned char cnt);
  134                     ;void timer_start(void);
  135                     ;void timer_stop(void);
  136                     ;unsigned char timer_get(void);
  137                     ;void irq_enable(unsigned char irq);
  138                     ;void irq_disable(unsigned char irq);
  139                     ;#define TITLE_LINE       1
  140                     ;#define DIRECTION_LINE   3
  141                     ;#define START_LINE       5
  142                     ;#define START_UNDER      6
  143                     ;#define OFFSET_LINE      7
  144                     ;#define OFFSET_UNDER     8
  145                     ;#define TARGET_LINE      9
  146                     ;#define STAT_LINE        11
  147                     ;#define READING_LINE     13
  148                     ;#define MIN_LINE         14
  149                     ;#define AVG_LINE         15
  150                     ;#define ADJUST_DIRECTION 0
  151                     ;#define ADJUST_START     1
  152                     ;#define ADJUST_OFFSET    2
  153                     ;#define RUN_TEST         3
  154                     ;#define DIR_FWD          0
  155                     ;#define DIR_BACK         1
  156                     ;#define INSTRUCT_LINE1  24
  157                     ;#define INSTRUCT_LINE2  25
  158                     ;#define INSTRUCT_LINE3  26
  159                     ;#define PREV_LINE  3
  160                     ;#define CURR_LINE  4
  161                     ;#define NEXT_LINE  10
  162                     ;#define UNDER_LINE 11
  163                     ;#define TIME_LINE  6
  164                     ;#asm
  165  00:DE14            _beepsetup:
  166  00:DE14  A9 02         lda #2
  167  00:DE16  8D 00 08      sta psg_ch
  168  00:DE19  A9 FF         lda #$FF
  169  00:DE1B  8D 01 08      sta psg_mainvol
  170  00:DE1E  A9 90         lda #$90    ; 1.5KHz
  171  00:DE20  8D 02 08      sta psg_freqlo
  172  00:DE23  9C 03 08      stz psg_freqhi
  173  00:DE26  A9 00         lda #$0
  174  00:DE28  8D 04 08      sta psg_ctrl
  175  00:DE2B  A9 1F         lda #$1F
  176  00:DE2D  A2 10         ldx #16
  177  00:DE2F            .loop:
  178  00:DE2F  8D 06 08      sta psg_wavebuf
  179  00:DE32  CA            dex
  180  00:DE33  D0 FA         bne .loop
  181  00:DE35  A9 00         lda #$0
  182  00:DE37  A2 10         ldx #16
  183  00:DE39            .loop1:
  184  00:DE39  8D 06 08      sta psg_wavebuf
  185  00:DE3C  CA            dex
  186  00:DE3D  D0 FA         bne .loop1
  187  00:DE3F  A9 FF         lda #$FF
  188  00:DE41  8D 05 08      sta psg_pan
  189  00:DE44  A9 9F         lda #$9f
  190  00:DE46  8D 04 08      sta psg_ctrl
  191  00:DE49  60            rts
  192  00:DE4A            _beepoff:
  193  00:DE4A  A9 00         lda #$0
  194  00:DE4C  8D 04 08      sta psg_ctrl
  195  00:DE4F  60            rts
  196  00:DE50            _beepon:
  197  00:DE50  A9 9F         lda #$9f
  198  00:DE52  8D 04 08      sta psg_ctrl
  199  00:DE55  60            rts
  200  00:DE56            _beeplow:
  201  00:DE56  A9 90         lda #$90
  202  00:DE58  8D 02 08      sta psg_freqlo
  203  00:DE5B  A9 9F         lda #$9f
  204  00:DE5D  8D 04 08      sta psg_ctrl
  205  00:DE60  60            rts
  206  00:DE61            _beephigh:
  207  00:DE61  A9 46         lda #$46
  208  00:DE63  8D 02 08      sta psg_freqlo
  209  00:DE66  A9 9F         lda #$9f
  210  00:DE68  8D 04 08      sta psg_ctrl
  211  00:DE6B  60            rts
  212                     ; cd_read_sector(void) - references char rec_h, char rec_m, char rec_l, char * target_data
  213  00:DE6C            _cd_read_sector:
  214  00:DE6C  A9 02         lda #2    ; logical block, and play
  215  00:DE6E  85 FB         sta <_bh
  216  00:DE70  AD D8 29      lda _rec_h       ; disc sector address (LBA address)
  217  00:DE73  85 F8         sta <_al
  218  00:DE75  AD D9 29      lda _rec_m
  219  00:DE78  85 F9         sta <_ah
  220  00:DE7A  AD DA 29      lda _rec_l
  221  00:DE7D  85 FA         sta <_bl
  222  00:DE7F  20 15 E0      call cd_search
  223  00:DE82  60            rts
  224  00:DE83            _cd_stop:
  225  00:DE83  20 18 E0      call cd_pause
  226  00:DE86  60            rts
  227                     ;char rec_h;
  228                     ;char rec_m;
  229                     ;char rec_l;
  230                     ;char target_data[2048];
  231                     ;char pad;
  232                     ;char padhold;
  233                     ;char hex1;
  234                     ;char hex2;
  235                     ;char start_pos[3];
  236                     ;char offset[3];
  237                     ;char target[3];
  238                     ;char result[3];
  239                     ;/* create array of offsets for adjusting startpos/offset: */
  240                     ;const char add_num[] = {
  241                     ; 0x10, 0x00, 0x00,
  242                     ; 0x01, 0x00, 0x00,
  243                     ; 0x00, 0x10, 0x00,
  244                     ; 0x00, 0x01, 0x00,
  245                     ; 0x00, 0x00, 0x10,
  246                     ; 0x00, 0x00, 0x01
  247                     ;};
  248                     ;char adjust;
  249                     ;char edit_pos;
  250                     ;char direction;
  251                     ;int timing[10];
  252                     ;int min;
  253                     ;int avg;
  254                     ;int tot;
  255                     ;char i;
  256                     ;/* result shown in result[] array: */
  257                     ;add_3digit(base1, base2)
  258                     ;char * base1;
  259                     ;char * base2;
  260  04:4BD0            	.proc _add_3digit
  261                     	__pushw
                0001      .ifndef SMALL
       04:ABD0  A4 00     	ldy	<__stack
       04:ABD2  D0 02     	bne	.x_00564
       04:ABD4  C6 01     	dec	<__stack + 1
                          .endif
       04:ABD6  C6 00     .x_00564:	dec	<__stack
       04:ABD8  92 00     	sta	[__stack]
                0001      .ifndef SMALL
       04:ABDA  D0 02     	bne	.y_00564
       04:ABDC  C6 01     	dec	<__stack + 1
                          .endif
       04:ABDE  C6 00     .y_00564:	dec	<__stack
       04:ABE0  22        	sax
       04:ABE1  92 00     	sta	[__stack]
       04:ABE3  22        	sax
  262                     ;{
  263                     ;   int temp1, temp2;
  264                     	__addmi	-4,__stack
                0000      .if (-4 = 1)
                          .else
                0000      .if (-4 = -1)
                          .else
       04:ABE4  A8        	tay			; 2
       04:ABE5  18        	clc			; 2
       04:ABE6  A5 00     	lda	<__stack		; 4
       04:ABE8  69 FC     	adc	#low(-4)	; 2
       04:ABEA  85 00     	sta	<__stack		; 4
                0000      .if (-4 < 256) & (-4 >= 0)
                          .else
                0001      .if (-4 >= -256) & (-4 < 0)
       04:ABEC  B0 02     	bcs	.y00565		; 4(2)
       04:ABEE  C6 01     	dec	<__stack+1		; 0(6)
       04:ABF0            .y00565:
                          .else
                          .endif
                          .endif
       04:ABF0  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  265                     ;   int temp_sum;
  266                     	__addmi	-2,__stack
                0000      .if (-2 = 1)
                          .else
                0000      .if (-2 = -1)
                          .else
       04:ABF1  A8        	tay			; 2
       04:ABF2  18        	clc			; 2
       04:ABF3  A5 00     	lda	<__stack		; 4
       04:ABF5  69 FE     	adc	#low(-2)	; 2
       04:ABF7  85 00     	sta	<__stack		; 4
                0000      .if (-2 < 256) & (-2 >= 0)
                          .else
                0001      .if (-2 >= -256) & (-2 < 0)
       04:ABF9  B0 02     	bcs	.y00566		; 4(2)
       04:ABFB  C6 01     	dec	<__stack+1		; 0(6)
       04:ABFD            .y00566:
                          .else
                          .endif
                          .endif
       04:ABFD  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  267                     ;   int carry;
  268                     	__addmi	-2,__stack
                0000      .if (-2 = 1)
                          .else
                0000      .if (-2 = -1)
                          .else
       04:ABFE  A8        	tay			; 2
       04:ABFF  18        	clc			; 2
       04:AC00  A5 00     	lda	<__stack		; 4
       04:AC02  69 FE     	adc	#low(-2)	; 2
       04:AC04  85 00     	sta	<__stack		; 4
                0000      .if (-2 < 256) & (-2 >= 0)
                          .else
                0001      .if (-2 >= -256) & (-2 < 0)
       04:AC06  B0 02     	bcs	.y00567		; 4(2)
       04:AC08  C6 01     	dec	<__stack+1		; 0(6)
       04:AC0A            .y00567:
                          .else
                          .endif
                          .endif
       04:AC0A  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  269                     ;   temp1 = (*(base1+2)) & 0xff;
  270                     	__ldw_s	10
                0001      .if (10 < 255)
                          	; short index (bytes :  7/8, cycles : 18/20)
                0000      .if (10 = 0)
                          .else
       04:AC0B  A0 0A     	ldy	#10
       04:AC0D  B1 00     	lda	[__sp],Y
       04:AC0F  AA        	tax
       04:AC10  C8        	iny
       04:AC11  B1 00     	lda	[__sp],Y
                          .endif
                          .else
                          .endif
  271                     	__addwi	2
                0000      .if (2 = 1)
                          .else
                0001      .if (2 = 2)
       04:AC13  E0 FE     	cpx	#$fe
       04:AC15  E8        	inx
       04:AC16  E8        	inx
       04:AC17  69 00     	adc	#0
                          .else
                          .endif
                          .endif
  272                     	__ldub_p
                          	; (bytes : 11, cycles : 19/23)
       04:AC19  86 06     	stx	<__ptr
       04:AC1B  85 07     	sta	<__ptr+1
       04:AC1D  B2 06     	lda	[__ptr]
       04:AC1F  AA        	tax
       04:AC20  62        	cla
  273                     	__andwi	255
       04:AC21  22        	sax
       04:AC22  29 FF     	and	#low(255)
       04:AC24  22        	sax
       04:AC25  29 00     	and	#high(255)
  274                     	__stw_s	6
                0001      .if (6 < 255)
                          	; short index (bytes :  9, cycles : 22)
       04:AC27  22        	sax
       04:AC28  A0 06     	ldy	#6
       04:AC2A  91 00     	sta	[__sp],Y
       04:AC2C  22        	sax
       04:AC2D  C8        	iny
       04:AC2E  91 00     	sta	[__sp],Y
                          .else
                          .endif
  275                     ;   temp2 = (*(base2+2)) & 0xff;
  276                     	__ldw_s	8
                0001      .if (8 < 255)
                          	; short index (bytes :  7/8, cycles : 18/20)
                0000      .if (8 = 0)
                          .else
       04:AC30  A0 08     	ldy	#8
       04:AC32  B1 00     	lda	[__sp],Y
       04:AC34  AA        	tax
       04:AC35  C8        	iny
       04:AC36  B1 00     	lda	[__sp],Y
                          .endif
                          .else
                          .endif
  277                     	__addwi	2
                0000      .if (2 = 1)
                          .else
                0001      .if (2 = 2)
       04:AC38  E0 FE     	cpx	#$fe
       04:AC3A  E8        	inx
       04:AC3B  E8        	inx
       04:AC3C  69 00     	adc	#0
                          .else
                          .endif
                          .endif
  278                     	__ldub_p
                          	; (bytes : 11, cycles : 19/23)
       04:AC3E  86 06     	stx	<__ptr
       04:AC40  85 07     	sta	<__ptr+1
       04:AC42  B2 06     	lda	[__ptr]
       04:AC44  AA        	tax
       04:AC45  62        	cla
  279                     	__andwi	255
       04:AC46  22        	sax
       04:AC47  29 FF     	and	#low(255)
       04:AC49  22        	sax
       04:AC4A  29 00     	and	#high(255)
  280                     	__stw_s	4
                0001      .if (4 < 255)
                          	; short index (bytes :  9, cycles : 22)
       04:AC4C  22        	sax
       04:AC4D  A0 04     	ldy	#4
       04:AC4F  91 00     	sta	[__sp],Y
       04:AC51  22        	sax
       04:AC52  C8        	iny
       04:AC53  91 00     	sta	[__sp],Y
                          .else
                          .endif
  281                     ;   temp_sum = temp1 + temp2;
  282                     	__ldw_s	6
                0001      .if (6 < 255)
                          	; short index (bytes :  7/8, cycles : 18/20)
                0000      .if (6 = 0)
                          .else
       04:AC55  A0 06     	ldy	#6
       04:AC57  B1 00     	lda	[__sp],Y
       04:AC59  AA        	tax
       04:AC5A  C8        	iny
       04:AC5B  B1 00     	lda	[__sp],Y
                          .endif
                          .else
                          .endif
  283                     	__addw_s	4
                0001      .if (4 < 255)
                          	; short index (bytes : 10, cycles : 24)
       04:AC5D  A0 04     	ldy	#4
       04:AC5F  18        	clc
       04:AC60  22        	sax
       04:AC61  71 00     	adc	[__sp],Y
       04:AC63  22        	sax
       04:AC64  C8        	iny
       04:AC65  71 00     	adc	[__sp],Y
                          .else
                          .endif
  284                     	__stw_s	2
                0001      .if (2 < 255)
                          	; short index (bytes :  9, cycles : 22)
       04:AC67  22        	sax
       04:AC68  A0 02     	ldy	#2
       04:AC6A  91 00     	sta	[__sp],Y
       04:AC6C  22        	sax
       04:AC6D  C8        	iny
       04:AC6E  91 00     	sta	[__sp],Y
                          .else
                          .endif
  285                     ;   carry = (temp_sum) >> 8;
  286                     	__ldw_s	2
                0001      .if (2 < 255)
                          	; short index (bytes :  7/8, cycles : 18/20)
                0000      .if (2 = 0)
                          .else
       04:AC70  A0 02     	ldy	#2
       04:AC72  B1 00     	lda	[__sp],Y
       04:AC74  AA        	tax
       04:AC75  C8        	iny
       04:AC76  B1 00     	lda	[__sp],Y
                          .endif
                          .else
                          .endif
  287                     	__asrwi	8
                0000      .if (8 = 1)
                          .else
                0000      .if (8 = 2)
                          .else
                0001      .if (8 = 8)
       04:AC78  AA        	tax
       04:AC79  C9 80     	cmp	#$80
       04:AC7B  62        	cla
       04:AC7C  90 01     	bcc	.x_00582
       04:AC7E  3A        	dec a
       04:AC7F            .x_00582:
                          .else
                          .endif
                          .endif
                          .endif
  288                     	__stw_s	0
                0001      .if (0 < 255)
                          	; short index (bytes :  9, cycles : 22)
       04:AC7F  22        	sax
       04:AC80  A0 00     	ldy	#0
       04:AC82  91 00     	sta	[__sp],Y
       04:AC84  22        	sax
       04:AC85  C8        	iny
       04:AC86  91 00     	sta	[__sp],Y
                          .else
                          .endif
  289                     ;   result[2] = temp_sum & 0xff;
  290                     	__ldw_s	2
                0001      .if (2 < 255)
                          	; short index (bytes :  7/8, cycles : 18/20)
                0000      .if (2 = 0)
                          .else
       04:AC88  A0 02     	ldy	#2
       04:AC8A  B1 00     	lda	[__sp],Y
       04:AC8C  AA        	tax
       04:AC8D  C8        	iny
       04:AC8E  B1 00     	lda	[__sp],Y
                          .endif
                          .else
                          .endif
  291                     	__andwi	255
       04:AC90  22        	sax
       04:AC91  29 FF     	and	#low(255)
       04:AC93  22        	sax
       04:AC94  29 00     	and	#high(255)
  292  04:AC96  8E EA 31  	  stx	_result+2
  293                     ;   temp1 = (*(base1+1)) & 0xff;
  294                     	__ldw_s	10
                0001      .if (10 < 255)
                          	; short index (bytes :  7/8, cycles : 18/20)
                0000      .if (10 = 0)
                          .else
       04:AC99  A0 0A     	ldy	#10
       04:AC9B  B1 00     	lda	[__sp],Y
       04:AC9D  AA        	tax
       04:AC9E  C8        	iny
       04:AC9F  B1 00     	lda	[__sp],Y
                          .endif
                          .else
                          .endif
  295                     	__addwi	1
                0001      .if (1 = 1)
       04:ACA1  E0 FF     	cpx	#$ff
       04:ACA3  E8        	inx
       04:ACA4  69 00     	adc	#0
                          .else
                          .endif
  296                     	__ldub_p
                          	; (bytes : 11, cycles : 19/23)
       04:ACA6  86 06     	stx	<__ptr
       04:ACA8  85 07     	sta	<__ptr+1
       04:ACAA  B2 06     	lda	[__ptr]
       04:ACAC  AA        	tax
       04:ACAD  62        	cla
  297                     	__andwi	255
       04:ACAE  22        	sax
       04:ACAF  29 FF     	and	#low(255)
       04:ACB1  22        	sax
       04:ACB2  29 00     	and	#high(255)
  298                     	__stw_s	6
                0001      .if (6 < 255)
                          	; short index (bytes :  9, cycles : 22)
       04:ACB4  22        	sax
       04:ACB5  A0 06     	ldy	#6
       04:ACB7  91 00     	sta	[__sp],Y
       04:ACB9  22        	sax
       04:ACBA  C8        	iny
       04:ACBB  91 00     	sta	[__sp],Y
                          .else
                          .endif
  299                     ;   temp2 = (*(base2+1)) & 0xff;
  300                     	__ldw_s	8
                0001      .if (8 < 255)
                          	; short index (bytes :  7/8, cycles : 18/20)
                0000      .if (8 = 0)
                          .else
       04:ACBD  A0 08     	ldy	#8
       04:ACBF  B1 00     	lda	[__sp],Y
       04:ACC1  AA        	tax
       04:ACC2  C8        	iny
       04:ACC3  B1 00     	lda	[__sp],Y
                          .endif
                          .else
                          .endif
  301                     	__addwi	1
                0001      .if (1 = 1)
       04:ACC5  E0 FF     	cpx	#$ff
       04:ACC7  E8        	inx
       04:ACC8  69 00     	adc	#0
                          .else
                          .endif
  302                     	__ldub_p
                          	; (bytes : 11, cycles : 19/23)
       04:ACCA  86 06     	stx	<__ptr
       04:ACCC  85 07     	sta	<__ptr+1
       04:ACCE  B2 06     	lda	[__ptr]
       04:ACD0  AA        	tax
       04:ACD1  62        	cla
  303                     	__andwi	255
       04:ACD2  22        	sax
       04:ACD3  29 FF     	and	#low(255)
       04:ACD5  22        	sax
       04:ACD6  29 00     	and	#high(255)
  304                     	__stw_s	4
                0001      .if (4 < 255)
                          	; short index (bytes :  9, cycles : 22)
       04:ACD8  22        	sax
       04:ACD9  A0 04     	ldy	#4
       04:ACDB  91 00     	sta	[__sp],Y
       04:ACDD  22        	sax
       04:ACDE  C8        	iny
       04:ACDF  91 00     	sta	[__sp],Y
                          .else
                          .endif
  305                     ;   temp_sum = temp1 + temp2 + carry;
  306                     	__ldw_s	6
                0001      .if (6 < 255)
                          	; short index (bytes :  7/8, cycles : 18/20)
                0000      .if (6 = 0)
                          .else
       04:ACE1  A0 06     	ldy	#6
       04:ACE3  B1 00     	lda	[__sp],Y
       04:ACE5  AA        	tax
       04:ACE6  C8        	iny
       04:ACE7  B1 00     	lda	[__sp],Y
                          .endif
                          .else
                          .endif
  307                     	__addw_s	4
                0001      .if (4 < 255)
                          	; short index (bytes : 10, cycles : 24)
       04:ACE9  A0 04     	ldy	#4
       04:ACEB  18        	clc
       04:ACEC  22        	sax
       04:ACED  71 00     	adc	[__sp],Y
       04:ACEF  22        	sax
       04:ACF0  C8        	iny
       04:ACF1  71 00     	adc	[__sp],Y
                          .else
                          .endif
  308                     	__addw_s	0
                0001      .if (0 < 255)
                          	; short index (bytes : 10, cycles : 24)
       04:ACF3  A0 00     	ldy	#0
       04:ACF5  18        	clc
       04:ACF6  22        	sax
       04:ACF7  71 00     	adc	[__sp],Y
       04:ACF9  22        	sax
       04:ACFA  C8        	iny
       04:ACFB  71 00     	adc	[__sp],Y
                          .else
                          .endif
  309                     	__stw_s	2
                0001      .if (2 < 255)
                          	; short index (bytes :  9, cycles : 22)
       04:ACFD  22        	sax
       04:ACFE  A0 02     	ldy	#2
       04:AD00  91 00     	sta	[__sp],Y
       04:AD02  22        	sax
       04:AD03  C8        	iny
       04:AD04  91 00     	sta	[__sp],Y
                          .else
                          .endif
  310                     ;   carry = (temp_sum) >> 8;
  311                     	__ldw_s	2
                0001      .if (2 < 255)
                          	; short index (bytes :  7/8, cycles : 18/20)
                0000      .if (2 = 0)
                          .else
       04:AD06  A0 02     	ldy	#2
       04:AD08  B1 00     	lda	[__sp],Y
       04:AD0A  AA        	tax
       04:AD0B  C8        	iny
       04:AD0C  B1 00     	lda	[__sp],Y
                          .endif
                          .else
                          .endif
  312                     	__asrwi	8
                0000      .if (8 = 1)
                          .else
                0000      .if (8 = 2)
                          .else
                0001      .if (8 = 8)
       04:AD0E  AA        	tax
       04:AD0F  C9 80     	cmp	#$80
       04:AD11  62        	cla
       04:AD12  90 01     	bcc	.x_00601
       04:AD14  3A        	dec a
       04:AD15            .x_00601:
                          .else
                          .endif
                          .endif
                          .endif
  313                     	__stw_s	0
                0001      .if (0 < 255)
                          	; short index (bytes :  9, cycles : 22)
       04:AD15  22        	sax
       04:AD16  A0 00     	ldy	#0
       04:AD18  91 00     	sta	[__sp],Y
       04:AD1A  22        	sax
       04:AD1B  C8        	iny
       04:AD1C  91 00     	sta	[__sp],Y
                          .else
                          .endif
  314                     ;   result[1] = temp_sum & 0xff;
  315                     	__ldw_s	2
                0001      .if (2 < 255)
                          	; short index (bytes :  7/8, cycles : 18/20)
                0000      .if (2 = 0)
                          .else
       04:AD1E  A0 02     	ldy	#2
       04:AD20  B1 00     	lda	[__sp],Y
       04:AD22  AA        	tax
       04:AD23  C8        	iny
       04:AD24  B1 00     	lda	[__sp],Y
                          .endif
                          .else
                          .endif
  316                     	__andwi	255
       04:AD26  22        	sax
       04:AD27  29 FF     	and	#low(255)
       04:AD29  22        	sax
       04:AD2A  29 00     	and	#high(255)
  317  04:AD2C  8E E9 31  	  stx	_result+1
  318                     ;   temp1 = (*(base1)) & 0xff;
  319                     	__ldw_s	10
                0001      .if (10 < 255)
                          	; short index (bytes :  7/8, cycles : 18/20)
                0000      .if (10 = 0)
                          .else
       04:AD2F  A0 0A     	ldy	#10
       04:AD31  B1 00     	lda	[__sp],Y
       04:AD33  AA        	tax
       04:AD34  C8        	iny
       04:AD35  B1 00     	lda	[__sp],Y
                          .endif
                          .else
                          .endif
  320                     	__ldub_p
                          	; (bytes : 11, cycles : 19/23)
       04:AD37  86 06     	stx	<__ptr
       04:AD39  85 07     	sta	<__ptr+1
       04:AD3B  B2 06     	lda	[__ptr]
       04:AD3D  AA        	tax
       04:AD3E  62        	cla
  321                     	__andwi	255
       04:AD3F  22        	sax
       04:AD40  29 FF     	and	#low(255)
       04:AD42  22        	sax
       04:AD43  29 00     	and	#high(255)
  322                     	__stw_s	6
                0001      .if (6 < 255)
                          	; short index (bytes :  9, cycles : 22)
       04:AD45  22        	sax
       04:AD46  A0 06     	ldy	#6
       04:AD48  91 00     	sta	[__sp],Y
       04:AD4A  22        	sax
       04:AD4B  C8        	iny
       04:AD4C  91 00     	sta	[__sp],Y
                          .else
                          .endif
  323                     ;   temp2 = (*(base2)) & 0xff;
  324                     	__ldw_s	8
                0001      .if (8 < 255)
                          	; short index (bytes :  7/8, cycles : 18/20)
                0000      .if (8 = 0)
                          .else
       04:AD4E  A0 08     	ldy	#8
       04:AD50  B1 00     	lda	[__sp],Y
       04:AD52  AA        	tax
       04:AD53  C8        	iny
       04:AD54  B1 00     	lda	[__sp],Y
                          .endif
                          .else
                          .endif
  325                     	__ldub_p
                          	; (bytes : 11, cycles : 19/23)
       04:AD56  86 06     	stx	<__ptr
       04:AD58  85 07     	sta	<__ptr+1
       04:AD5A  B2 06     	lda	[__ptr]
       04:AD5C  AA        	tax
       04:AD5D  62        	cla
  326                     	__andwi	255
       04:AD5E  22        	sax
       04:AD5F  29 FF     	and	#low(255)
       04:AD61  22        	sax
       04:AD62  29 00     	and	#high(255)
  327                     	__stw_s	4
                0001      .if (4 < 255)
                          	; short index (bytes :  9, cycles : 22)
       04:AD64  22        	sax
       04:AD65  A0 04     	ldy	#4
       04:AD67  91 00     	sta	[__sp],Y
       04:AD69  22        	sax
       04:AD6A  C8        	iny
       04:AD6B  91 00     	sta	[__sp],Y
                          .else
                          .endif
  328                     ;   temp_sum = temp1 + temp2 + carry;
  329                     	__ldw_s	6
                0001      .if (6 < 255)
                          	; short index (bytes :  7/8, cycles : 18/20)
                0000      .if (6 = 0)
                          .else
       04:AD6D  A0 06     	ldy	#6
       04:AD6F  B1 00     	lda	[__sp],Y
       04:AD71  AA        	tax
       04:AD72  C8        	iny
       04:AD73  B1 00     	lda	[__sp],Y
                          .endif
                          .else
                          .endif
  330                     	__addw_s	4
                0001      .if (4 < 255)
                          	; short index (bytes : 10, cycles : 24)
       04:AD75  A0 04     	ldy	#4
       04:AD77  18        	clc
       04:AD78  22        	sax
       04:AD79  71 00     	adc	[__sp],Y
       04:AD7B  22        	sax
       04:AD7C  C8        	iny
       04:AD7D  71 00     	adc	[__sp],Y
                          .else
                          .endif
  331                     	__addw_s	0
                0001      .if (0 < 255)
                          	; short index (bytes : 10, cycles : 24)
       04:AD7F  A0 00     	ldy	#0
       04:AD81  18        	clc
       04:AD82  22        	sax
       04:AD83  71 00     	adc	[__sp],Y
       04:AD85  22        	sax
       04:AD86  C8        	iny
       04:AD87  71 00     	adc	[__sp],Y
                          .else
                          .endif
  332                     	__stw_s	2
                0001      .if (2 < 255)
                          	; short index (bytes :  9, cycles : 22)
       04:AD89  22        	sax
       04:AD8A  A0 02     	ldy	#2
       04:AD8C  91 00     	sta	[__sp],Y
       04:AD8E  22        	sax
       04:AD8F  C8        	iny
       04:AD90  91 00     	sta	[__sp],Y
                          .else
                          .endif
  333                     ;   result[0] = temp_sum & 0xff;
  334                     	__ldw_s	2
                0001      .if (2 < 255)
                          	; short index (bytes :  7/8, cycles : 18/20)
                0000      .if (2 = 0)
                          .else
       04:AD92  A0 02     	ldy	#2
       04:AD94  B1 00     	lda	[__sp],Y
       04:AD96  AA        	tax
       04:AD97  C8        	iny
       04:AD98  B1 00     	lda	[__sp],Y
                          .endif
                          .else
                          .endif
  335                     	__andwi	255
       04:AD9A  22        	sax
       04:AD9B  29 FF     	and	#low(255)
       04:AD9D  22        	sax
       04:AD9E  29 00     	and	#high(255)
  336  04:ADA0  8E E8 31  	  stx	_result
  337                     ;}
  338  04:ADA3            LL1:
  339                     
  340                     	__addmi	12,__stack
                0000      .if (12 = 1)
                          .else
                0000      .if (12 = -1)
                          .else
       04:ADA3  A8        	tay			; 2
       04:ADA4  18        	clc			; 2
       04:ADA5  A5 00     	lda	<__stack		; 4
       04:ADA7  69 0C     	adc	#low(12)	; 2
       04:ADA9  85 00     	sta	<__stack		; 4
                0001      .if (12 < 256) & (12 >= 0)
       04:ADAB  90 02     	bcc	.x00619		; 4(2)
       04:ADAD  E6 01     	inc	<__stack+1		; 0(6)
       04:ADAF            .x00619:
                          .else
                          .endif
       04:ADAF  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  341  04:ADB0  60        	  rts
  342                     	.endp
  343                     
  344                     ;/* result shown in result[] array: */
  345                     ;sub_3digit(base1, base2)
  346                     ;char * base1;
  347                     ;char * base2;
  348  04:46DB            	.proc _sub_3digit
  349                     	__pushw
                0001      .ifndef SMALL
       04:A6DB  A4 00     	ldy	<__stack
       04:A6DD  D0 02     	bne	.x_00620
       04:A6DF  C6 01     	dec	<__stack + 1
                          .endif
       04:A6E1  C6 00     .x_00620:	dec	<__stack
       04:A6E3  92 00     	sta	[__stack]
                0001      .ifndef SMALL
       04:A6E5  D0 02     	bne	.y_00620
       04:A6E7  C6 01     	dec	<__stack + 1
                          .endif
       04:A6E9  C6 00     .y_00620:	dec	<__stack
       04:A6EB  22        	sax
       04:A6EC  92 00     	sta	[__stack]
       04:A6EE  22        	sax
  350                     ;{
  351                     ;   int temp1, temp2;
  352                     	__addmi	-4,__stack
                0000      .if (-4 = 1)
                          .else
                0000      .if (-4 = -1)
                          .else
       04:A6EF  A8        	tay			; 2
       04:A6F0  18        	clc			; 2
       04:A6F1  A5 00     	lda	<__stack		; 4
       04:A6F3  69 FC     	adc	#low(-4)	; 2
       04:A6F5  85 00     	sta	<__stack		; 4
                0000      .if (-4 < 256) & (-4 >= 0)
                          .else
                0001      .if (-4 >= -256) & (-4 < 0)
       04:A6F7  B0 02     	bcs	.y00621		; 4(2)
       04:A6F9  C6 01     	dec	<__stack+1		; 0(6)
       04:A6FB            .y00621:
                          .else
                          .endif
                          .endif
       04:A6FB  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  353                     ;   int temp_sum;
  354                     	__addmi	-2,__stack
                0000      .if (-2 = 1)
                          .else
                0000      .if (-2 = -1)
                          .else
       04:A6FC  A8        	tay			; 2
       04:A6FD  18        	clc			; 2
       04:A6FE  A5 00     	lda	<__stack		; 4
       04:A700  69 FE     	adc	#low(-2)	; 2
       04:A702  85 00     	sta	<__stack		; 4
                0000      .if (-2 < 256) & (-2 >= 0)
                          .else
                0001      .if (-2 >= -256) & (-2 < 0)
       04:A704  B0 02     	bcs	.y00622		; 4(2)
       04:A706  C6 01     	dec	<__stack+1		; 0(6)
       04:A708            .y00622:
                          .else
                          .endif
                          .endif
       04:A708  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  355                     ;   int carry;
  356                     	__addmi	-2,__stack
                0000      .if (-2 = 1)
                          .else
                0000      .if (-2 = -1)
                          .else
       04:A709  A8        	tay			; 2
       04:A70A  18        	clc			; 2
       04:A70B  A5 00     	lda	<__stack		; 4
       04:A70D  69 FE     	adc	#low(-2)	; 2
       04:A70F  85 00     	sta	<__stack		; 4
                0000      .if (-2 < 256) & (-2 >= 0)
                          .else
                0001      .if (-2 >= -256) & (-2 < 0)
       04:A711  B0 02     	bcs	.y00623		; 4(2)
       04:A713  C6 01     	dec	<__stack+1		; 0(6)
       04:A715            .y00623:
                          .else
                          .endif
                          .endif
       04:A715  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  357                     ;   temp1 = (*(base1+2)) & 0xff;
  358                     	__ldw_s	10
                0001      .if (10 < 255)
                          	; short index (bytes :  7/8, cycles : 18/20)
                0000      .if (10 = 0)
                          .else
       04:A716  A0 0A     	ldy	#10
       04:A718  B1 00     	lda	[__sp],Y
       04:A71A  AA        	tax
       04:A71B  C8        	iny
       04:A71C  B1 00     	lda	[__sp],Y
                          .endif
                          .else
                          .endif
  359                     	__addwi	2
                0000      .if (2 = 1)
                          .else
                0001      .if (2 = 2)
       04:A71E  E0 FE     	cpx	#$fe
       04:A720  E8        	inx
       04:A721  E8        	inx
       04:A722  69 00     	adc	#0
                          .else
                          .endif
                          .endif
  360                     	__ldub_p
                          	; (bytes : 11, cycles : 19/23)
       04:A724  86 06     	stx	<__ptr
       04:A726  85 07     	sta	<__ptr+1
       04:A728  B2 06     	lda	[__ptr]
       04:A72A  AA        	tax
       04:A72B  62        	cla
  361                     	__andwi	255
       04:A72C  22        	sax
       04:A72D  29 FF     	and	#low(255)
       04:A72F  22        	sax
       04:A730  29 00     	and	#high(255)
  362                     	__stw_s	6
                0001      .if (6 < 255)
                          	; short index (bytes :  9, cycles : 22)
       04:A732  22        	sax
       04:A733  A0 06     	ldy	#6
       04:A735  91 00     	sta	[__sp],Y
       04:A737  22        	sax
       04:A738  C8        	iny
       04:A739  91 00     	sta	[__sp],Y
                          .else
                          .endif
  363                     ;   temp2 = (*(base2+2)) & 0xff;
  364                     	__ldw_s	8
                0001      .if (8 < 255)
                          	; short index (bytes :  7/8, cycles : 18/20)
                0000      .if (8 = 0)
                          .else
       04:A73B  A0 08     	ldy	#8
       04:A73D  B1 00     	lda	[__sp],Y
       04:A73F  AA        	tax
       04:A740  C8        	iny
       04:A741  B1 00     	lda	[__sp],Y
                          .endif
                          .else
                          .endif
  365                     	__addwi	2
                0000      .if (2 = 1)
                          .else
                0001      .if (2 = 2)
       04:A743  E0 FE     	cpx	#$fe
       04:A745  E8        	inx
       04:A746  E8        	inx
       04:A747  69 00     	adc	#0
                          .else
                          .endif
                          .endif
  366                     	__ldub_p
                          	; (bytes : 11, cycles : 19/23)
       04:A749  86 06     	stx	<__ptr
       04:A74B  85 07     	sta	<__ptr+1
       04:A74D  B2 06     	lda	[__ptr]
       04:A74F  AA        	tax
       04:A750  62        	cla
  367                     	__andwi	255
       04:A751  22        	sax
       04:A752  29 FF     	and	#low(255)
       04:A754  22        	sax
       04:A755  29 00     	and	#high(255)
  368                     	__stw_s	4
                0001      .if (4 < 255)
                          	; short index (bytes :  9, cycles : 22)
       04:A757  22        	sax
       04:A758  A0 04     	ldy	#4
       04:A75A  91 00     	sta	[__sp],Y
       04:A75C  22        	sax
       04:A75D  C8        	iny
       04:A75E  91 00     	sta	[__sp],Y
                          .else
                          .endif
  369                     ;   temp_sum = temp1 - temp2;
  370                     	__ldw_s	6
                0001      .if (6 < 255)
                          	; short index (bytes :  7/8, cycles : 18/20)
                0000      .if (6 = 0)
                          .else
       04:A760  A0 06     	ldy	#6
       04:A762  B1 00     	lda	[__sp],Y
       04:A764  AA        	tax
       04:A765  C8        	iny
       04:A766  B1 00     	lda	[__sp],Y
                          .endif
                          .else
                          .endif
  371                     	__pushw
                0001      .ifndef SMALL
       04:A768  A4 00     	ldy	<__stack
       04:A76A  D0 02     	bne	.x_00635
       04:A76C  C6 01     	dec	<__stack + 1
                          .endif
       04:A76E  C6 00     .x_00635:	dec	<__stack
       04:A770  92 00     	sta	[__stack]
                0001      .ifndef SMALL
       04:A772  D0 02     	bne	.y_00635
       04:A774  C6 01     	dec	<__stack + 1
                          .endif
       04:A776  C6 00     .y_00635:	dec	<__stack
       04:A778  22        	sax
       04:A779  92 00     	sta	[__stack]
       04:A77B  22        	sax
  372                     	__ldw_s	6
                0001      .if (6 < 255)
                          	; short index (bytes :  7/8, cycles : 18/20)
                0000      .if (6 = 0)
                          .else
       04:A77C  A0 06     	ldy	#6
       04:A77E  B1 00     	lda	[__sp],Y
       04:A780  AA        	tax
       04:A781  C8        	iny
       04:A782  B1 00     	lda	[__sp],Y
                          .endif
                          .else
                          .endif
  373                     	__subws
       04:A784  86 02     	stx	<__temp
       04:A786  85 03     	sta	<__temp+1
       04:A788  38        	sec
       04:A789  B2 00     	lda	[__stack]
       04:A78B  E5 02     	sbc	<__temp
       04:A78D  AA        	tax
       04:A78E  A0 01     	ldy	#1
       04:A790  B1 00     	lda	[__stack],Y
       04:A792  E5 03     	sbc	<__temp+1
                          	__addmi	2, __stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       04:A794  A8        	tay			; 2
       04:A795  18        	clc			; 2
       04:A796  A5 00     	lda	<__stack		; 4
       04:A798  69 02     	adc	#low(2)	; 2
       04:A79A  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       04:A79C  90 02     	bcc	.x00638		; 4(2)
       04:A79E  E6 01     	inc	<__stack+1		; 0(6)
       04:A7A0            .x00638:
                          .else
                          .endif
       04:A7A0  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  374                     	__stw_s	2
                0001      .if (2 < 255)
                          	; short index (bytes :  9, cycles : 22)
       04:A7A1  22        	sax
       04:A7A2  A0 02     	ldy	#2
       04:A7A4  91 00     	sta	[__sp],Y
       04:A7A6  22        	sax
       04:A7A7  C8        	iny
       04:A7A8  91 00     	sta	[__sp],Y
                          .else
                          .endif
  375                     ;   carry = ((temp_sum) >> 8) & 1;
  376                     	__ldw_s	2
                0001      .if (2 < 255)
                          	; short index (bytes :  7/8, cycles : 18/20)
                0000      .if (2 = 0)
                          .else
       04:A7AA  A0 02     	ldy	#2
       04:A7AC  B1 00     	lda	[__sp],Y
       04:A7AE  AA        	tax
       04:A7AF  C8        	iny
       04:A7B0  B1 00     	lda	[__sp],Y
                          .endif
                          .else
                          .endif
  377                     	__asrwi	8
                0000      .if (8 = 1)
                          .else
                0000      .if (8 = 2)
                          .else
                0001      .if (8 = 8)
       04:A7B2  AA        	tax
       04:A7B3  C9 80     	cmp	#$80
       04:A7B5  62        	cla
       04:A7B6  90 01     	bcc	.x_00641
       04:A7B8  3A        	dec a
       04:A7B9            .x_00641:
                          .else
                          .endif
                          .endif
                          .endif
  378                     	__andwi	1
       04:A7B9  22        	sax
       04:A7BA  29 01     	and	#low(1)
       04:A7BC  22        	sax
       04:A7BD  29 00     	and	#high(1)
  379                     	__stw_s	0
                0001      .if (0 < 255)
                          	; short index (bytes :  9, cycles : 22)
       04:A7BF  22        	sax
       04:A7C0  A0 00     	ldy	#0
       04:A7C2  91 00     	sta	[__sp],Y
       04:A7C4  22        	sax
       04:A7C5  C8        	iny
       04:A7C6  91 00     	sta	[__sp],Y
                          .else
                          .endif
  380                     ;   result[2] = temp_sum & 0xff;
  381                     	__ldw_s	2
                0001      .if (2 < 255)
                          	; short index (bytes :  7/8, cycles : 18/20)
                0000      .if (2 = 0)
                          .else
       04:A7C8  A0 02     	ldy	#2
       04:A7CA  B1 00     	lda	[__sp],Y
       04:A7CC  AA        	tax
       04:A7CD  C8        	iny
       04:A7CE  B1 00     	lda	[__sp],Y
                          .endif
                          .else
                          .endif
  382                     	__andwi	255
       04:A7D0  22        	sax
       04:A7D1  29 FF     	and	#low(255)
       04:A7D3  22        	sax
       04:A7D4  29 00     	and	#high(255)
  383  04:A7D6  8E EA 31  	  stx	_result+2
  384                     ;   temp1 = (*(base1+1)) & 0xff;
  385                     	__ldw_s	10
                0001      .if (10 < 255)
                          	; short index (bytes :  7/8, cycles : 18/20)
                0000      .if (10 = 0)
                          .else
       04:A7D9  A0 0A     	ldy	#10
       04:A7DB  B1 00     	lda	[__sp],Y
       04:A7DD  AA        	tax
       04:A7DE  C8        	iny
       04:A7DF  B1 00     	lda	[__sp],Y
                          .endif
                          .else
                          .endif
  386                     	__addwi	1
                0001      .if (1 = 1)
       04:A7E1  E0 FF     	cpx	#$ff
       04:A7E3  E8        	inx
       04:A7E4  69 00     	adc	#0
                          .else
                          .endif
  387                     	__ldub_p
                          	; (bytes : 11, cycles : 19/23)
       04:A7E6  86 06     	stx	<__ptr
       04:A7E8  85 07     	sta	<__ptr+1
       04:A7EA  B2 06     	lda	[__ptr]
       04:A7EC  AA        	tax
       04:A7ED  62        	cla
  388                     	__andwi	255
       04:A7EE  22        	sax
       04:A7EF  29 FF     	and	#low(255)
       04:A7F1  22        	sax
       04:A7F2  29 00     	and	#high(255)
  389                     	__stw_s	6
                0001      .if (6 < 255)
                          	; short index (bytes :  9, cycles : 22)
       04:A7F4  22        	sax
       04:A7F5  A0 06     	ldy	#6
       04:A7F7  91 00     	sta	[__sp],Y
       04:A7F9  22        	sax
       04:A7FA  C8        	iny
       04:A7FB  91 00     	sta	[__sp],Y
                          .else
                          .endif
  390                     ;   temp2 = (*(base2+1)) & 0xff;
  391                     	__ldw_s	8
                0001      .if (8 < 255)
                          	; short index (bytes :  7/8, cycles : 18/20)
                0000      .if (8 = 0)
                          .else
       04:A7FD  A0 08     	ldy	#8
       04:A7FF  B1 00     	lda	[__sp],Y
       04:A801  AA        	tax
       04:A802  C8        	iny
       04:A803  B1 00     	lda	[__sp],Y
                          .endif
                          .else
                          .endif
  392                     	__addwi	1
                0001      .if (1 = 1)
       04:A805  E0 FF     	cpx	#$ff
       04:A807  E8        	inx
       04:A808  69 00     	adc	#0
                          .else
                          .endif
  393                     	__ldub_p
                          	; (bytes : 11, cycles : 19/23)
       04:A80A  86 06     	stx	<__ptr
       04:A80C  85 07     	sta	<__ptr+1
       04:A80E  B2 06     	lda	[__ptr]
       04:A810  AA        	tax
       04:A811  62        	cla
  394                     	__andwi	255
       04:A812  22        	sax
       04:A813  29 FF     	and	#low(255)
       04:A815  22        	sax
       04:A816  29 00     	and	#high(255)
  395                     	__stw_s	4
                0001      .if (4 < 255)
                          	; short index (bytes :  9, cycles : 22)
       04:A818  22        	sax
       04:A819  A0 04     	ldy	#4
       04:A81B  91 00     	sta	[__sp],Y
       04:A81D  22        	sax
       04:A81E  C8        	iny
       04:A81F  91 00     	sta	[__sp],Y
                          .else
                          .endif
  396                     ;   temp_sum = temp1 - temp2 - carry;
  397                     	__ldw_s	6
                0001      .if (6 < 255)
                          	; short index (bytes :  7/8, cycles : 18/20)
                0000      .if (6 = 0)
                          .else
       04:A821  A0 06     	ldy	#6
       04:A823  B1 00     	lda	[__sp],Y
       04:A825  AA        	tax
       04:A826  C8        	iny
       04:A827  B1 00     	lda	[__sp],Y
                          .endif
                          .else
                          .endif
  398                     	__pushw
                0001      .ifndef SMALL
       04:A829  A4 00     	ldy	<__stack
       04:A82B  D0 02     	bne	.x_00657
       04:A82D  C6 01     	dec	<__stack + 1
                          .endif
       04:A82F  C6 00     .x_00657:	dec	<__stack
       04:A831  92 00     	sta	[__stack]
                0001      .ifndef SMALL
       04:A833  D0 02     	bne	.y_00657
       04:A835  C6 01     	dec	<__stack + 1
                          .endif
       04:A837  C6 00     .y_00657:	dec	<__stack
       04:A839  22        	sax
       04:A83A  92 00     	sta	[__stack]
       04:A83C  22        	sax
  399                     	__ldw_s	6
                0001      .if (6 < 255)
                          	; short index (bytes :  7/8, cycles : 18/20)
                0000      .if (6 = 0)
                          .else
       04:A83D  A0 06     	ldy	#6
       04:A83F  B1 00     	lda	[__sp],Y
       04:A841  AA        	tax
       04:A842  C8        	iny
       04:A843  B1 00     	lda	[__sp],Y
                          .endif
                          .else
                          .endif
  400                     	__subws
       04:A845  86 02     	stx	<__temp
       04:A847  85 03     	sta	<__temp+1
       04:A849  38        	sec
       04:A84A  B2 00     	lda	[__stack]
       04:A84C  E5 02     	sbc	<__temp
       04:A84E  AA        	tax
       04:A84F  A0 01     	ldy	#1
       04:A851  B1 00     	lda	[__stack],Y
       04:A853  E5 03     	sbc	<__temp+1
                          	__addmi	2, __stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       04:A855  A8        	tay			; 2
       04:A856  18        	clc			; 2
       04:A857  A5 00     	lda	<__stack		; 4
       04:A859  69 02     	adc	#low(2)	; 2
       04:A85B  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       04:A85D  90 02     	bcc	.x00660		; 4(2)
       04:A85F  E6 01     	inc	<__stack+1		; 0(6)
       04:A861            .x00660:
                          .else
                          .endif
       04:A861  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  401                     	__pushw
                0001      .ifndef SMALL
       04:A862  A4 00     	ldy	<__stack
       04:A864  D0 02     	bne	.x_00661
       04:A866  C6 01     	dec	<__stack + 1
                          .endif
       04:A868  C6 00     .x_00661:	dec	<__stack
       04:A86A  92 00     	sta	[__stack]
                0001      .ifndef SMALL
       04:A86C  D0 02     	bne	.y_00661
       04:A86E  C6 01     	dec	<__stack + 1
                          .endif
       04:A870  C6 00     .y_00661:	dec	<__stack
       04:A872  22        	sax
       04:A873  92 00     	sta	[__stack]
       04:A875  22        	sax
  402                     	__ldw_s	2
                0001      .if (2 < 255)
                          	; short index (bytes :  7/8, cycles : 18/20)
                0000      .if (2 = 0)
                          .else
       04:A876  A0 02     	ldy	#2
       04:A878  B1 00     	lda	[__sp],Y
       04:A87A  AA        	tax
       04:A87B  C8        	iny
       04:A87C  B1 00     	lda	[__sp],Y
                          .endif
                          .else
                          .endif
  403                     	__subws
       04:A87E  86 02     	stx	<__temp
       04:A880  85 03     	sta	<__temp+1
       04:A882  38        	sec
       04:A883  B2 00     	lda	[__stack]
       04:A885  E5 02     	sbc	<__temp
       04:A887  AA        	tax
       04:A888  A0 01     	ldy	#1
       04:A88A  B1 00     	lda	[__stack],Y
       04:A88C  E5 03     	sbc	<__temp+1
                          	__addmi	2, __stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       04:A88E  A8        	tay			; 2
       04:A88F  18        	clc			; 2
       04:A890  A5 00     	lda	<__stack		; 4
       04:A892  69 02     	adc	#low(2)	; 2
       04:A894  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       04:A896  90 02     	bcc	.x00664		; 4(2)
       04:A898  E6 01     	inc	<__stack+1		; 0(6)
       04:A89A            .x00664:
                          .else
                          .endif
       04:A89A  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  404                     	__stw_s	2
                0001      .if (2 < 255)
                          	; short index (bytes :  9, cycles : 22)
       04:A89B  22        	sax
       04:A89C  A0 02     	ldy	#2
       04:A89E  91 00     	sta	[__sp],Y
       04:A8A0  22        	sax
       04:A8A1  C8        	iny
       04:A8A2  91 00     	sta	[__sp],Y
                          .else
                          .endif
  405                     ;   carry = ((temp_sum) >> 8) & 1;
  406                     	__ldw_s	2
                0001      .if (2 < 255)
                          	; short index (bytes :  7/8, cycles : 18/20)
                0000      .if (2 = 0)
                          .else
       04:A8A4  A0 02     	ldy	#2
       04:A8A6  B1 00     	lda	[__sp],Y
       04:A8A8  AA        	tax
       04:A8A9  C8        	iny
       04:A8AA  B1 00     	lda	[__sp],Y
                          .endif
                          .else
                          .endif
  407                     	__asrwi	8
                0000      .if (8 = 1)
                          .else
                0000      .if (8 = 2)
                          .else
                0001      .if (8 = 8)
       04:A8AC  AA        	tax
       04:A8AD  C9 80     	cmp	#$80
       04:A8AF  62        	cla
       04:A8B0  90 01     	bcc	.x_00667
       04:A8B2  3A        	dec a
       04:A8B3            .x_00667:
                          .else
                          .endif
                          .endif
                          .endif
  408                     	__andwi	1
       04:A8B3  22        	sax
       04:A8B4  29 01     	and	#low(1)
       04:A8B6  22        	sax
       04:A8B7  29 00     	and	#high(1)
  409                     	__stw_s	0
                0001      .if (0 < 255)
                          	; short index (bytes :  9, cycles : 22)
       04:A8B9  22        	sax
       04:A8BA  A0 00     	ldy	#0
       04:A8BC  91 00     	sta	[__sp],Y
       04:A8BE  22        	sax
       04:A8BF  C8        	iny
       04:A8C0  91 00     	sta	[__sp],Y
                          .else
                          .endif
  410                     ;   result[1] = temp_sum & 0xff;
  411                     	__ldw_s	2
                0001      .if (2 < 255)
                          	; short index (bytes :  7/8, cycles : 18/20)
                0000      .if (2 = 0)
                          .else
       04:A8C2  A0 02     	ldy	#2
       04:A8C4  B1 00     	lda	[__sp],Y
       04:A8C6  AA        	tax
       04:A8C7  C8        	iny
       04:A8C8  B1 00     	lda	[__sp],Y
                          .endif
                          .else
                          .endif
  412                     	__andwi	255
       04:A8CA  22        	sax
       04:A8CB  29 FF     	and	#low(255)
       04:A8CD  22        	sax
       04:A8CE  29 00     	and	#high(255)
  413  04:A8D0  8E E9 31  	  stx	_result+1
  414                     ;   temp1 = (*(base1)) & 0xff;
  415                     	__ldw_s	10
                0001      .if (10 < 255)
                          	; short index (bytes :  7/8, cycles : 18/20)
                0000      .if (10 = 0)
                          .else
       04:A8D3  A0 0A     	ldy	#10
       04:A8D5  B1 00     	lda	[__sp],Y
       04:A8D7  AA        	tax
       04:A8D8  C8        	iny
       04:A8D9  B1 00     	lda	[__sp],Y
                          .endif
                          .else
                          .endif
  416                     	__ldub_p
                          	; (bytes : 11, cycles : 19/23)
       04:A8DB  86 06     	stx	<__ptr
       04:A8DD  85 07     	sta	<__ptr+1
       04:A8DF  B2 06     	lda	[__ptr]
       04:A8E1  AA        	tax
       04:A8E2  62        	cla
  417                     	__andwi	255
       04:A8E3  22        	sax
       04:A8E4  29 FF     	and	#low(255)
       04:A8E6  22        	sax
       04:A8E7  29 00     	and	#high(255)
  418                     	__stw_s	6
                0001      .if (6 < 255)
                          	; short index (bytes :  9, cycles : 22)
       04:A8E9  22        	sax
       04:A8EA  A0 06     	ldy	#6
       04:A8EC  91 00     	sta	[__sp],Y
       04:A8EE  22        	sax
       04:A8EF  C8        	iny
       04:A8F0  91 00     	sta	[__sp],Y
                          .else
                          .endif
  419                     ;   temp2 = (*(base2)) & 0xff;
  420                     	__ldw_s	8
                0001      .if (8 < 255)
                          	; short index (bytes :  7/8, cycles : 18/20)
                0000      .if (8 = 0)
                          .else
       04:A8F2  A0 08     	ldy	#8
       04:A8F4  B1 00     	lda	[__sp],Y
       04:A8F6  AA        	tax
       04:A8F7  C8        	iny
       04:A8F8  B1 00     	lda	[__sp],Y
                          .endif
                          .else
                          .endif
  421                     	__ldub_p
                          	; (bytes : 11, cycles : 19/23)
       04:A8FA  86 06     	stx	<__ptr
       04:A8FC  85 07     	sta	<__ptr+1
       04:A8FE  B2 06     	lda	[__ptr]
       04:A900  AA        	tax
       04:A901  62        	cla
  422                     	__andwi	255
       04:A902  22        	sax
       04:A903  29 FF     	and	#low(255)
       04:A905  22        	sax
       04:A906  29 00     	and	#high(255)
  423                     	__stw_s	4
                0001      .if (4 < 255)
                          	; short index (bytes :  9, cycles : 22)
       04:A908  22        	sax
       04:A909  A0 04     	ldy	#4
       04:A90B  91 00     	sta	[__sp],Y
       04:A90D  22        	sax
       04:A90E  C8        	iny
       04:A90F  91 00     	sta	[__sp],Y
                          .else
                          .endif
  424                     ;   temp_sum = temp1 - temp2 - carry;
  425                     	__ldw_s	6
                0001      .if (6 < 255)
                          	; short index (bytes :  7/8, cycles : 18/20)
                0000      .if (6 = 0)
                          .else
       04:A911  A0 06     	ldy	#6
       04:A913  B1 00     	lda	[__sp],Y
       04:A915  AA        	tax
       04:A916  C8        	iny
       04:A917  B1 00     	lda	[__sp],Y
                          .endif
                          .else
                          .endif
  426                     	__pushw
                0001      .ifndef SMALL
       04:A919  A4 00     	ldy	<__stack
       04:A91B  D0 02     	bne	.x_00681
       04:A91D  C6 01     	dec	<__stack + 1
                          .endif
       04:A91F  C6 00     .x_00681:	dec	<__stack
       04:A921  92 00     	sta	[__stack]
                0001      .ifndef SMALL
       04:A923  D0 02     	bne	.y_00681
       04:A925  C6 01     	dec	<__stack + 1
                          .endif
       04:A927  C6 00     .y_00681:	dec	<__stack
       04:A929  22        	sax
       04:A92A  92 00     	sta	[__stack]
       04:A92C  22        	sax
  427                     	__ldw_s	6
                0001      .if (6 < 255)
                          	; short index (bytes :  7/8, cycles : 18/20)
                0000      .if (6 = 0)
                          .else
       04:A92D  A0 06     	ldy	#6
       04:A92F  B1 00     	lda	[__sp],Y
       04:A931  AA        	tax
       04:A932  C8        	iny
       04:A933  B1 00     	lda	[__sp],Y
                          .endif
                          .else
                          .endif
  428                     	__subws
       04:A935  86 02     	stx	<__temp
       04:A937  85 03     	sta	<__temp+1
       04:A939  38        	sec
       04:A93A  B2 00     	lda	[__stack]
       04:A93C  E5 02     	sbc	<__temp
       04:A93E  AA        	tax
       04:A93F  A0 01     	ldy	#1
       04:A941  B1 00     	lda	[__stack],Y
       04:A943  E5 03     	sbc	<__temp+1
                          	__addmi	2, __stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       04:A945  A8        	tay			; 2
       04:A946  18        	clc			; 2
       04:A947  A5 00     	lda	<__stack		; 4
       04:A949  69 02     	adc	#low(2)	; 2
       04:A94B  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       04:A94D  90 02     	bcc	.x00684		; 4(2)
       04:A94F  E6 01     	inc	<__stack+1		; 0(6)
       04:A951            .x00684:
                          .else
                          .endif
       04:A951  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  429                     	__pushw
                0001      .ifndef SMALL
       04:A952  A4 00     	ldy	<__stack
       04:A954  D0 02     	bne	.x_00685
       04:A956  C6 01     	dec	<__stack + 1
                          .endif
       04:A958  C6 00     .x_00685:	dec	<__stack
       04:A95A  92 00     	sta	[__stack]
                0001      .ifndef SMALL
       04:A95C  D0 02     	bne	.y_00685
       04:A95E  C6 01     	dec	<__stack + 1
                          .endif
       04:A960  C6 00     .y_00685:	dec	<__stack
       04:A962  22        	sax
       04:A963  92 00     	sta	[__stack]
       04:A965  22        	sax
  430                     	__ldw_s	2
                0001      .if (2 < 255)
                          	; short index (bytes :  7/8, cycles : 18/20)
                0000      .if (2 = 0)
                          .else
       04:A966  A0 02     	ldy	#2
       04:A968  B1 00     	lda	[__sp],Y
       04:A96A  AA        	tax
       04:A96B  C8        	iny
       04:A96C  B1 00     	lda	[__sp],Y
                          .endif
                          .else
                          .endif
  431                     	__subws
       04:A96E  86 02     	stx	<__temp
       04:A970  85 03     	sta	<__temp+1
       04:A972  38        	sec
       04:A973  B2 00     	lda	[__stack]
       04:A975  E5 02     	sbc	<__temp
       04:A977  AA        	tax
       04:A978  A0 01     	ldy	#1
       04:A97A  B1 00     	lda	[__stack],Y
       04:A97C  E5 03     	sbc	<__temp+1
                          	__addmi	2, __stack
                0000      .if (2 = 1)
                          .else
                0000      .if (2 = -1)
                          .else
       04:A97E  A8        	tay			; 2
       04:A97F  18        	clc			; 2
       04:A980  A5 00     	lda	<__stack		; 4
       04:A982  69 02     	adc	#low(2)	; 2
       04:A984  85 00     	sta	<__stack		; 4
                0001      .if (2 < 256) & (2 >= 0)
       04:A986  90 02     	bcc	.x00688		; 4(2)
       04:A988  E6 01     	inc	<__stack+1		; 0(6)
       04:A98A            .x00688:
                          .else
                          .endif
       04:A98A  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  432                     	__stw_s	2
                0001      .if (2 < 255)
                          	; short index (bytes :  9, cycles : 22)
       04:A98B  22        	sax
       04:A98C  A0 02     	ldy	#2
       04:A98E  91 00     	sta	[__sp],Y
       04:A990  22        	sax
       04:A991  C8        	iny
       04:A992  91 00     	sta	[__sp],Y
                          .else
                          .endif
  433                     ;   result[0] = temp_sum & 0xff;
  434                     	__ldw_s	2
                0001      .if (2 < 255)
                          	; short index (bytes :  7/8, cycles : 18/20)
                0000      .if (2 = 0)
                          .else
       04:A994  A0 02     	ldy	#2
       04:A996  B1 00     	lda	[__sp],Y
       04:A998  AA        	tax
       04:A999  C8        	iny
       04:A99A  B1 00     	lda	[__sp],Y
                          .endif
                          .else
                          .endif
  435                     	__andwi	255
       04:A99C  22        	sax
       04:A99D  29 FF     	and	#low(255)
       04:A99F  22        	sax
       04:A9A0  29 00     	and	#high(255)
  436  04:A9A2  8E E8 31  	  stx	_result
  437                     ;}
  438  04:A9A5            LL2:
  439                     
  440                     	__addmi	12,__stack
                0000      .if (12 = 1)
                          .else
                0000      .if (12 = -1)
                          .else
       04:A9A5  A8        	tay			; 2
       04:A9A6  18        	clc			; 2
       04:A9A7  A5 00     	lda	<__stack		; 4
       04:A9A9  69 0C     	adc	#low(12)	; 2
       04:A9AB  85 00     	sta	<__stack		; 4
                0001      .if (12 < 256) & (12 >= 0)
       04:A9AD  90 02     	bcc	.x00692		; 4(2)
       04:A9AF  E6 01     	inc	<__stack+1		; 0(6)
       04:A9B1            .x00692:
                          .else
                          .endif
       04:A9B1  98        	tya			; 2 => 20(24) / 26
                          .endif
                          .endif
  441  04:A9B2  60        	  rts
  442                     	.endp
  443                     
  444                     ;show_startpos()
  445                     ;{
  446  04:4FB5            	.proc _show_startpos
  447                     ;   put_hex(start_pos[0], 2, 14, START_LINE);
  448                     	__ldub	_start_pos
                0000      .if (1 = 2)
                          .else
       04:AFB5  AE DF 31  	ldx	_start_pos
       04:AFB8  62        	cla
                          .endif
  449                     	__stw	__dx
       04:AFB9  8E FE 20  	stx	__dx
       04:AFBC  8D FF 20  	sta	__dx+1
  450                     	__ldwi	2
       04:AFBF  A2 02     	ldx	#low(2)
       04:AFC1  A9 00     	lda	#high(2)
  451  04:AFC3  8E FC 20  	  stx	__cl
  452                     	__ldwi	14
       04:AFC6  A2 0E     	ldx	#low(14)
       04:AFC8  A9 00     	lda	#high(14)
  453  04:AFCA  8E FA 20  	  stx	__bl
  454                     	__ldwi	5
       04:AFCD  A2 05     	ldx	#low(5)
       04:AFCF  A9 00     	lda	#high(5)
  455  04:AFD1  20 0E CF  	  call	_put_hex.4
  456                     ;   put_hex(start_pos[1], 2, 16, START_LINE);
  457                     	__ldub	_start_pos+1
                0000      .if (1 = 2)
                          .else
       04:AFD4  AE E0 31  	ldx	_start_pos+1
       04:AFD7  62        	cla
                          .endif
  458                     	__stw	__dx
       04:AFD8  8E FE 20  	stx	__dx
       04:AFDB  8D FF 20  	sta	__dx+1
  459                     	__ldwi	2
       04:AFDE  A2 02     	ldx	#low(2)
       04:AFE0  A9 00     	lda	#high(2)
  460  04:AFE2  8E FC 20  	  stx	__cl
  461                     	__ldwi	16
       04:AFE5  A2 10     	ldx	#low(16)
       04:AFE7  A9 00     	lda	#high(16)
  462  04:AFE9  8E FA 20  	  stx	__bl
  463                     	__ldwi	5
       04:AFEC  A2 05     	ldx	#low(5)
       04:AFEE  A9 00     	lda	#high(5)
  464  04:AFF0  20 0E CF  	  call	_put_hex.4
  465                     ;   put_hex(start_pos[2], 2, 18, START_LINE);
  466                     	__ldub	_start_pos+2
                0000      .if (1 = 2)
                          .else
       04:AFF3  AE E1 31  	ldx	_start_pos+2
       04:AFF6  62        	cla
                          .endif
  467                     	__stw	__dx
       04:AFF7  8E FE 20  	stx	__dx
       04:AFFA  8D FF 20  	sta	__dx+1
  468                     	__ldwi	2
       04:AFFD  A2 02     	ldx	#low(2)
       04:AFFF  A9 00     	lda	#high(2)
  469  04:B001  8E FC 20  	  stx	__cl
  470                     	__ldwi	18
       04:B004  A2 12     	ldx	#low(18)
       04:B006  A9 00     	lda	#high(18)
  471  04:B008  8E FA 20  	  stx	__bl
  472                     	__ldwi	5
       04:B00B  A2 05     	ldx	#low(5)
       04:B00D  A9 00     	lda	#high(5)
  473  04:B00F  20 0E CF  	  call	_put_hex.4
  474                     ;}
  475  04:B012            LL3:
  476                     
  477  04:B012  60        	  rts
  478                     	.endp
  479                     
  480                     ;show_offset()
  481                     ;{
  482  04:5013            	.proc _show_offset
  483                     ;   put_hex(offset[0], 2, 14, OFFSET_LINE);
  484                     	__ldub	_offset
                0000      .if (1 = 2)
                          .else
       04:B013  AE E2 31  	ldx	_offset
       04:B016  62        	cla
                          .endif
  485                     	__stw	__dx
       04:B017  8E FE 20  	stx	__dx
       04:B01A  8D FF 20  	sta	__dx+1
  486                     	__ldwi	2
       04:B01D  A2 02     	ldx	#low(2)
       04:B01F  A9 00     	lda	#high(2)
  487  04:B021  8E FC 20  	  stx	__cl
  488                     	__ldwi	14
       04:B024  A2 0E     	ldx	#low(14)
       04:B026  A9 00     	lda	#high(14)
  489  04:B028  8E FA 20  	  stx	__bl
  490                     	__ldwi	7
       04:B02B  A2 07     	ldx	#low(7)
       04:B02D  A9 00     	lda	#high(7)
  491  04:B02F  20 0E CF  	  call	_put_hex.4
  492                     ;   put_hex(offset[1], 2, 16, OFFSET_LINE);
  493                     	__ldub	_offset+1
                0000      .if (1 = 2)
                          .else
       04:B032  AE E3 31  	ldx	_offset+1
       04:B035  62        	cla
                          .endif
  494                     	__stw	__dx
       04:B036  8E FE 20  	stx	__dx
       04:B039  8D FF 20  	sta	__dx+1
  495                     	__ldwi	2
       04:B03C  A2 02     	ldx	#low(2)
       04:B03E  A9 00     	lda	#high(2)
  496  04:B040  8E FC 20  	  stx	__cl
  497                     	__ldwi	16
       04:B043  A2 10     	ldx	#low(16)
       04:B045  A9 00     	lda	#high(16)
  498  04:B047  8E FA 20  	  stx	__bl
  499                     	__ldwi	7
       04:B04A  A2 07     	ldx	#low(7)
       04:B04C  A9 00     	lda	#high(7)
  500  04:B04E  20 0E CF  	  call	_put_hex.4
  501                     ;   put_hex(offset[2], 2, 18, OFFSET_LINE);
  502                     	__ldub	_offset+2
                0000      .if (1 = 2)
                          .else
       04:B051  AE E4 31  	ldx	_offset+2
       04:B054  62        	cla
                          .endif
  503                     	__stw	__dx
       04:B055  8E FE 20  	stx	__dx
       04:B058  8D FF 20  	sta	__dx+1
  504                     	__ldwi	2
       04:B05B  A2 02     	ldx	#low(2)
       04:B05D  A9 00     	lda	#high(2)
  505  04:B05F  8E FC 20  	  stx	__cl
  506                     	__ldwi	18
       04:B062  A2 12     	ldx	#low(18)
       04:B064  A9 00     	lda	#high(18)
  507  04:B066  8E FA 20  	  stx	__bl
  508                     	__ldwi	7
       04:B069  A2 07     	ldx	#low(7)
       04:B06B  A9 00     	lda	#high(7)
  509  04:B06D  20 0E CF  	  call	_put_hex.4
  510                     ;}
  511  04:B070            LL4:
  512                     
  513  04:B070  60        	  rts
  514                     	.endp
  515                     
  516                     ;show_target()
  517                     ;{
  518  04:5071            	.proc _show_target
  519                     ;   put_hex(target[0], 2, 14, TARGET_LINE);
  520                     	__ldub	_target
                0000      .if (1 = 2)
                          .else
       04:B071  AE E5 31  	ldx	_target
       04:B074  62        	cla
                          .endif
  521                     	__stw	__dx
       04:B075  8E FE 20  	stx	__dx
       04:B078  8D FF 20  	sta	__dx+1
  522                     	__ldwi	2
       04:B07B  A2 02     	ldx	#low(2)
       04:B07D  A9 00     	lda	#high(2)
  523  04:B07F  8E FC 20  	  stx	__cl
  524                     	__ldwi	14
       04:B082  A2 0E     	ldx	#low(14)
       04:B084  A9 00     	lda	#high(14)
  525  04:B086  8E FA 20  	  stx	__bl
  526                     	__ldwi	9
       04:B089  A2 09     	ldx	#low(9)
       04:B08B  A9 00     	lda	#high(9)
  527  04:B08D  20 0E CF  	  call	_put_hex.4
  528                     ;   put_hex(target[1], 2, 16, TARGET_LINE);
  529                     	__ldub	_target+1
                0000      .if (1 = 2)
                          .else
       04:B090  AE E6 31  	ldx	_target+1
       04:B093  62        	cla
                          .endif
  530                     	__stw	__dx
       04:B094  8E FE 20  	stx	__dx
       04:B097  8D FF 20  	sta	__dx+1
  531                     	__ldwi	2
       04:B09A  A2 02     	ldx	#low(2)
       04:B09C  A9 00     	lda	#high(2)
  532  04:B09E  8E FC 20  	  stx	__cl
  533                     	__ldwi	16
       04:B0A1  A2 10     	ldx	#low(16)
       04:B0A3  A9 00     	lda	#high(16)
  534  04:B0A5  8E FA 20  	  stx	__bl
  535                     	__ldwi	9
       04:B0A8  A2 09     	ldx	#low(9)
       04:B0AA  A9 00     	lda	#high(9)
  536  04:B0AC  20 0E CF  	  call	_put_hex.4
  537                     ;   put_hex(target[2], 2, 18, TARGET_LINE);
  538                     	__ldub	_target+2
                0000      .if (1 = 2)
                          .else
       04:B0AF  AE E7 31  	ldx	_target+2
       04:B0B2  62        	cla
                          .endif
  539                     	__stw	__dx
       04:B0B3  8E FE 20  	stx	__dx
       04:B0B6  8D FF 20  	sta	__dx+1
  540                     	__ldwi	2
       04:B0B9  A2 02     	ldx	#low(2)
       04:B0BB  A9 00     	lda	#high(2)
  541  04:B0BD  8E FC 20  	  stx	__cl
  542                     	__ldwi	18
       04:B0C0  A2 12     	ldx	#low(18)
       04:B0C2  A9 00     	lda	#high(18)
  543  04:B0C4  8E FA 20  	  stx	__bl
  544                     	__ldwi	9
       04:B0C7  A2 09     	ldx	#low(9)
       04:B0C9  A9 00     	lda	#high(9)
  545  04:B0CB  20 0E CF  	  call	_put_hex.4
  546                     ;}
  547  04:B0CE            LL5:
  548                     
  549  04:B0CE  60        	  rts
  550                     	.endp
  551                     
  552                     ;limit_startpos()
  553                     ;{
  554  04:4EE7            	.proc _limit_startpos
  555                     ;   if ((result[0] < 0x00) || (result[0] >= 0x80))
  556                     	__ldub	_result
                0000      .if (1 = 2)
                          .else
       04:AEE7  AE E8 31  	ldx	_result
       04:AEEA  62        	cla
                          .endif
  557                     	__stw	<__temp
       04:AEEB  86 02     	stx	<__temp
       04:AEED  85 03     	sta	<__temp+1
  558                     	__ldwi	0
       04:AEEF  A2 00     	ldx	#low(0)
       04:AEF1  A9 00     	lda	#high(0)
  559  04:AEF3  20 D6 C8  	  jsr	ltzp
  560                     	__lbnen	LL8
       04:AEF6  E0 00     	cpx	#0
       04:AEF8  D0 0F     	bne	LL8
  561                     	__ldub	_result
                0000      .if (1 = 2)
                          .else
       04:AEFA  AE E8 31  	ldx	_result
       04:AEFD  62        	cla
                          .endif
  562                     	__stw	<__temp
       04:AEFE  86 02     	stx	<__temp
       04:AF00  85 03     	sta	<__temp+1
  563                     	__ldwi	128
       04:AF02  A2 80     	ldx	#low(128)
       04:AF04  A9 00     	lda	#high(128)
  564  04:AF06  20 52 C9  	  jsr	gezp
  565  04:AF09            LL8:
  566                     
  567                     	__tstw
                          	; pha
       04:AF09  86 02     	stx	<__temp
       04:AF0B  05 02     	ora	<__temp
       04:AF0D  62        	cla
       04:AF0E  82        	clx
       04:AF0F  F0 01     	beq	.x_00745
       04:AF11  E8        	inx
       04:AF12            .x_00745:
                          	; pla
  568                     	__lbeq	LL7
       04:AF12  E0 00     	cpx	#0
       04:AF14  D0 03     	bne	.x00746
       04:AF16  4C 2B AF  	jmp	LL7
       04:AF19            .x00746
  569                     ;   {
  570                     ;      result[0] = 0x00;
  571                     	__stbi	_result, 0
       04:AF19  A2 00     	ldx	#low(0)
       04:AF1B  8E E8 31  	stx	_result
       04:AF1E  62        	cla
  572                     ;      result[1] = 0x00;
  573                     	__stbi	_result+1, 0
       04:AF1F  A2 00     	ldx	#low(0)
       04:AF21  8E E9 31  	stx	_result+1
       04:AF24  62        	cla
  574                     ;      result[2] = 0x00;
  575                     	__stbi	_result+2, 0
       04:AF25  A2 00     	ldx	#low(0)
       04:AF27  8E EA 31  	stx	_result+2
       04:AF2A  62        	cla
  576                     ;   }
  577                     ;   if (result[0] > 0x04)
  578  04:AF2B            LL7:
  579                     
  580                     	__ldub	_result
                0000      .if (1 = 2)
                          .else
       04:AF2B  AE E8 31  	ldx	_result
       04:AF2E  62        	cla
                          .endif
  581                     	__stw	<__temp
       04:AF2F  86 02     	stx	<__temp
       04:AF31  85 03     	sta	<__temp+1
  582                     	__ldwi	4
       04:AF33  A2 04     	ldx	#low(4)
       04:AF35  A9 00     	lda	#high(4)
  583  04:AF37  20 0A C9  	  jsr	gtzp
  584                     	__lbeq	LL9
       04:AF3A  E0 00     	cpx	#0
       04:AF3C  D0 03     	bne	.x00753
       04:AF3E  4C 53 AF  	jmp	LL9
       04:AF41            .x00753
  585                     ;   {
  586                     ;      result[0] = 0x04;
  587                     	__stbi	_result, 4
       04:AF41  A2 04     	ldx	#low(4)
       04:AF43  8E E8 31  	stx	_result
       04:AF46  62        	cla
  588                     ;      result[1] = 0xff;
  589                     	__stbi	_result+1, 255
       04:AF47  A2 FF     	ldx	#low(255)
       04:AF49  8E E9 31  	stx	_result+1
       04:AF4C  62        	cla
  590                     ;      result[2] = 0xff;
  591                     	__stbi	_result+2, 255
       04:AF4D  A2 FF     	ldx	#low(255)
       04:AF4F  8E EA 31  	stx	_result+2
       04:AF52  62        	cla
  592                     ;   }
  593                     ;}
  594  04:AF53            LL9:
  595                     
  596  04:AF53            LL6:
  597                     
  598  04:AF53  60        	  rts
  599                     	.endp
  600                     
  601                     ;limit_offset()
  602                     ;{
  603  04:50CF            	.proc _limit_offset
  604                     ;   if ((result[0] < 0x00) || (result[0] >= 0x80))
  605                     	__ldub	_result
                0000      .if (1 = 2)
                          .else
       04:B0CF  AE E8 31  	ldx	_result
       04:B0D2  62        	cla
                          .endif
  606                     	__stw	<__temp
       04:B0D3  86 02     	stx	<__temp
       04:B0D5  85 03     	sta	<__temp+1
  607                     	__ldwi	0
       04:B0D7  A2 00     	ldx	#low(0)
       04:B0D9  A9 00     	lda	#high(0)
  608  04:B0DB  20 D6 C8  	  jsr	ltzp
  609                     	__lbnen	LL12
       04:B0DE  E0 00     	cpx	#0
       04:B0E0  D0 0F     	bne	LL12
  610                     	__ldub	_result
                0000      .if (1 = 2)
                          .else
       04:B0E2  AE E8 31  	ldx	_result
       04:B0E5  62        	cla
                          .endif
  611                     	__stw	<__temp
       04:B0E6  86 02     	stx	<__temp
       04:B0E8  85 03     	sta	<__temp+1
  612                     	__ldwi	128
       04:B0EA  A2 80     	ldx	#low(128)
       04:B0EC  A9 00     	lda	#high(128)
  613  04:B0EE  20 52 C9  	  jsr	gezp
  614  04:B0F1            LL12:
  615                     
  616                     	__tstw
                          	; pha
       04:B0F1  86 02     	stx	<__temp
       04:B0F3  05 02     	ora	<__temp
       04:B0F5  62        	cla
       04:B0F6  82        	clx
       04:B0F7  F0 01     	beq	.x_00764
       04:B0F9  E8        	inx
       04:B0FA            .x_00764:
                          	; pla
  617                     	__lbeq	LL11
       04:B0FA  E0 00     	cpx	#0
       04:B0FC  D0 03     	bne	.x00765
       04:B0FE  4C 13 B1  	jmp	LL11
       04:B101            .x00765
  618                     ;   {
  619                     ;      result[0] = 0x00;
  620                     	__stbi	_result, 0
       04:B101  A2 00     	ldx	#low(0)
       04:B103  8E E8 31  	stx	_result
       04:B106  62        	cla
  621                     ;      result[1] = 0x00;
  622                     	__stbi	_result+1, 0
       04:B107  A2 00     	ldx	#low(0)
       04:B109  8E E9 31  	stx	_result+1
       04:B10C  62        	cla
  623                     ;      result[2] = 0x00;
  624                     	__stbi	_result+2, 0
       04:B10D  A2 00     	ldx	#low(0)
       04:B10F  8E EA 31  	stx	_result+2
       04:B112  62        	cla
  625                     ;   }
  626                     ;}
  627  04:B113            LL11:
  628                     
  629  04:B113            LL10:
  630                     
  631  04:B113  60        	  rts
  632                     	.endp
  633                     
  634                     ;fix_offset()
  635                     ;{
  636  04:49B3            	.proc _fix_offset
  637                     ;   if (direction == DIR_FWD)
  638                     	__ldub	_direction
                0000      .if (1 = 2)
                          .else
       04:A9B3  AE ED 31  	ldx	_direction
       04:A9B6  62        	cla
                          .endif
  639                     	__cmpwi_eq	0
       04:A9B7  E0 00     	cpx	#low(0)
       04:A9B9  82        	clx
       04:A9BA  D0 06     	bne	.f00770
       04:A9BC  C9 00     	cmp	#high(0)
       04:A9BE  D0 02     	bne	.f00770
       04:A9C0  A2 01     	ldx	#1
       04:A9C2  62        .f00770:	cla
  640                     	__lbeq	LL14
       04:A9C3  E0 00     	cpx	#0
       04:A9C5  D0 03     	bne	.x00771
       04:A9C7  4C 67 AA  	jmp	LL14
       04:A9CA            .x00771
  641                     ;   {
  642                     ;      /* if (start + offset) > maximum, reset offset to (maximum - start) */
  643                     ;      add_3digit(start_pos, offset);
  644                     	__ldwi	_start_pos
       04:A9CA  A2 DF     	ldx	#low(_start_pos)
       04:A9CC  A9 31     	lda	#high(_start_pos)
  645                     	__pushw
                0001      .ifndef SMALL
       04:A9CE  A4 00     	ldy	<__stack
       04:A9D0  D0 02     	bne	.x_00773
       04:A9D2  C6 01     	dec	<__stack + 1
                          .endif
       04:A9D4  C6 00     .x_00773:	dec	<__stack
       04:A9D6  92 00     	sta	[__stack]
                0001      .ifndef SMALL
       04:A9D8  D0 02     	bne	.y_00773
       04:A9DA  C6 01     	dec	<__stack + 1
                          .endif
       04:A9DC  C6 00     .y_00773:	dec	<__stack
       04:A9DE  22        	sax
       04:A9DF  92 00     	sta	[__stack]
       04:A9E1  22        	sax
  646                     	__ldwi	_offset
       04:A9E2  A2 E2     	ldx	#low(_offset)
       04:A9E4  A9 31     	lda	#high(_offset)
  647  04:A9E6  20 D0 AB  	  call	_add_3digit
  648                     ;      if (result[0] > 0x04)
  649                     	__ldub	_result
                0000      .if (1 = 2)
                          .else
       04:A9E9  AE E8 31  	ldx	_result
       04:A9EC  62        	cla
                          .endif
  650                     	__stw	<__temp
       04:A9ED  86 02     	stx	<__temp
       04:A9EF  85 03     	sta	<__temp+1
  651                     	__ldwi	4
       04:A9F1  A2 04     	ldx	#low(4)
       04:A9F3  A9 00     	lda	#high(4)
  652  04:A9F5  20 0A C9  	  jsr	gtzp
  653                     	__lbeq	LL15
       04:A9F8  E0 00     	cpx	#0
       04:A9FA  D0 03     	bne	.x00778
       04:A9FC  4C 64 AA  	jmp	LL15
       04:A9FF            .x00778
  654                     ;      {
  655                     ;         target[0] = 0x04;
  656                     	__stbi	_target, 4
       04:A9FF  A2 04     	ldx	#low(4)
       04:AA01  8E E5 31  	stx	_target
       04:AA04  62        	cla
  657                     ;         target[1] = 0xff;
  658                     	__stbi	_target+1, 255
       04:AA05  A2 FF     	ldx	#low(255)
       04:AA07  8E E6 31  	stx	_target+1
       04:AA0A  62        	cla
  659                     ;         target[2] = 0xff;
  660                     	__stbi	_target+2, 255
       04:AA0B  A2 FF     	ldx	#low(255)
       04:AA0D  8E E7 31  	stx	_target+2
       04:AA10  62        	cla
  661                     ;         sub_3digit(target, start_pos);
  662                     	__ldwi	_target
       04:AA11  A2 E5     	ldx	#low(_target)
       04:AA13  A9 31     	lda	#high(_target)
  663                     	__pushw
                0001      .ifndef SMALL
       04:AA15  A4 00     	ldy	<__stack
       04:AA17  D0 02     	bne	.x_00783
       04:AA19  C6 01     	dec	<__stack + 1
                          .endif
       04:AA1B  C6 00     .x_00783:	dec	<__stack
       04:AA1D  92 00     	sta	[__stack]
                0001      .ifndef SMALL
       04:AA1F  D0 02     	bne	.y_00783
       04:AA21  C6 01     	dec	<__stack + 1
                          .endif
       04:AA23  C6 00     .y_00783:	dec	<__stack
       04:AA25  22        	sax
       04:AA26  92 00     	sta	[__stack]
       04:AA28  22        	sax
  664                     	__ldwi	_start_pos
       04:AA29  A2 DF     	ldx	#low(_start_pos)
       04:AA2B  A9 31     	lda	#high(_start_pos)
  665  04:AA2D  20 DB A6  	  call	_sub_3digit
  666                     ;         offset[0] = result[0];
  667                     	__ldub	_result
                0000      .if (1 = 2)
                          .else
       04:AA30  AE E8 31  	ldx	_result
       04:AA33  62        	cla
                          .endif
  668  04:AA34  8E E2 31  	  stx	_offset
  669                     ;         offset[1] = result[1];
  670                     	__ldub	_result+1
                0000      .if (1 = 2)
                          .else
       04:AA37  AE E9 31  	ldx	_result+1
       04:AA3A  62        	cla
                          .endif
  671  04:AA3B  8E E3 31  	  stx	_offset+1
  672                     ;         offset[2] = result[2];
  673                     	__ldub	_result+2
                0000      .if (1 = 2)
                          .else
       04:AA3E  AE EA 31  	ldx	_result+2
       04:AA41  62        	cla
                          .endif
  674  04:AA42  8E E4 31  	  stx	_offset+2
  675                     ;         add_3digit(start_pos, offset);
  676                     	__ldwi	_start_pos
       04:AA45  A2 DF     	ldx	#low(_start_pos)
       04:AA47  A9 31     	lda	#high(_start_pos)
  677                     	__pushw
                0001      .ifndef SMALL
       04:AA49  A4 00     	ldy	<__stack
       04:AA4B  D0 02     	bne	.x_00789
       04:AA4D  C6 01     	dec	<__stack + 1
                          .endif
       04:AA4F  C6 00     .x_00789:	dec	<__stack
       04:AA51  92 00     	sta	[__stack]
                0001      .ifndef SMALL
       04:AA53  D0 02     	bne	.y_00789
       04:AA55  C6 01     	dec	<__stack + 1
                          .endif
       04:AA57  C6 00     .y_00789:	dec	<__stack
       04:AA59  22        	sax
       04:AA5A  92 00     	sta	[__stack]
       04:AA5C  22        	sax
  678                     	__ldwi	_offset
       04:AA5D  A2 E2     	ldx	#low(_offset)
       04:AA5F  A9 31     	lda	#high(_offset)
  679  04:AA61  20 D0 AB  	  call	_add_3digit
  680                     ;      }
  681                     ;   }
  682  04:AA64            LL15:
  683                     
  684                     ;   else if (direction == DIR_BACK)
  685                     	__lbra	LL16
       04:AA64  4C BA AB  	jmp	LL16
  686  04:AA67            LL14:
  687                     
  688                     	__ldub	_direction
                0000      .if (1 = 2)
                          .else
       04:AA67  AE ED 31  	ldx	_direction
       04:AA6A  62        	cla
                          .endif
  689                     	__cmpwi_eq	1
       04:AA6B  E0 01     	cpx	#low(1)
       04:AA6D  82        	clx
       04:AA6E  D0 06     	bne	.f00793
       04:AA70  C9 00     	cmp	#high(1)
       04:AA72  D0 02     	bne	.f00793
       04:AA74  A2 01     	ldx	#1
       04:AA76  62        .f00793:	cla
  690                     	__lbeq	LL17
       04:AA77  E0 00     	cpx	#0
       04:AA79  D0 03     	bne	.x00794
       04:AA7B  4C BA AB  	jmp	LL17
       04:AA7E            .x00794
  691                     ;   {
  692                     ;      /* if (start - offset) < 0, reset offset to start */
  693                     ;      if ( (offset[0] > start_pos[0]) || 
  694                     	__ldub	_offset
                0000      .if (1 = 2)
                          .else
       04:AA7E  AE E2 31  	ldx	_offset
       04:AA81  62        	cla
                          .endif
  695                     	__pushw
                0001      .ifndef SMALL
       04:AA82  A4 00     	ldy	<__stack
       04:AA84  D0 02     	bne	.x_00796
       04:AA86  C6 01     	dec	<__stack + 1
                          .endif
       04:AA88  C6 00     .x_00796:	dec	<__stack
       04:AA8A  92 00     	sta	[__stack]
                0001      .ifndef SMALL
       04:AA8C  D0 02     	bne	.y_00796
       04:AA8E  C6 01     	dec	<__stack + 1
                          .endif
       04:AA90  C6 00     .y_00796:	dec	<__stack
       04:AA92  22        	sax
       04:AA93  92 00     	sta	[__stack]
       04:AA95  22        	sax
  696                     	__ldub	_start_pos
                0000      .if (1 = 2)
                          .else
       04:AA96  AE DF 31  	ldx	_start_pos
       04:AA99  62        	cla
                          .endif
  697  04:AA9A  20 61 C8  	  jsr	gt
  698                     	__lbne	LL19
       04:AA9D  E0 00     	cpx	#0
       04:AA9F  F0 03     	beq	.x00798
       04:AAA1  4C EF AA  	jmp	LL19
       04:AAA4            .x00798
  699                     ;          ((offset[0] == start_pos[0]) && (offset[1] > start_pos[1])) ||
  700                     	__ldub	_offset
                0000      .if (1 = 2)
                          .else
       04:AAA4  AE E2 31  	ldx	_offset
       04:AAA7  62        	cla
                          .endif
  701                     	__pushw
                0001      .ifndef SMALL
       04:AAA8  A4 00     	ldy	<__stack
       04:AAAA  D0 02     	bne	.x_00800
       04:AAAC  C6 01     	dec	<__stack + 1
                          .endif
       04:AAAE  C6 00     .x_00800:	dec	<__stack
       04:AAB0  92 00     	sta	[__stack]
                0001      .ifndef SMALL
       04:AAB2  D0 02     	bne	.y_00800
       04:AAB4  C6 01     	dec	<__stack + 1
                          .endif
       04:AAB6  C6 00     .y_00800:	dec	<__stack
       04:AAB8  22        	sax
       04:AAB9  92 00     	sta	[__stack]
       04:AABB  22        	sax
  702                     	__ldub	_start_pos
                0000      .if (1 = 2)
                          .else
       04:AABC  AE DF 31  	ldx	_start_pos
       04:AABF  62        	cla
                          .endif
  703  04:AAC0  20 AB C7  	  jsr	eq
  704                     	__lbeqn	LL20
       04:AAC3  E0 00     	cpx	#0
       04:AAC5  F0 1F     	beq	LL20
  705                     	__ldub	_offset+1
                0000      .if (1 = 2)
                          .else
       04:AAC7  AE E3 31  	ldx	_offset+1
       04:AACA  62        	cla
                          .endif
  706                     	__pushw
                0001      .ifndef SMALL
       04:AACB  A4 00     	ldy	<__stack
       04:AACD  D0 02     	bne	.x_00804
       04:AACF  C6 01     	dec	<__stack + 1
                          .endif
       04:AAD1  C6 00     .x_00804:	dec	<__stack
       04:AAD3  92 00     	sta	[__stack]
                0001      .ifndef SMALL
       04:AAD5  D0 02     	bne	.y_00804
       04:AAD7  C6 01     	dec	<__stack + 1
                          .endif
       04:AAD9  C6 00     .y_00804:	dec	<__stack
       04:AADB  22        	sax
       04:AADC  92 00     	sta	[__stack]
       04:AADE  22        	sax
  707                     	__ldub	_start_pos+1
                0000      .if (1 = 2)
                          .else
       04:AADF  AE E0 31  	ldx	_start_pos+1
       04:AAE2  62        	cla
                          .endif
  708  04:AAE3  20 61 C8  	  jsr	gt
  709  04:AAE6            LL20:
  710                     
  711                     	__boolw
       04:AAE6  86 02     	stx	<__temp
       04:AAE8  05 02     	ora	<__temp
       04:AAEA  82        	clx
       04:AAEB  F0 01     	beq	.x00806
       04:AAED  E8        	inx
       04:AAEE  62        .x00806	cla
  712  04:AAEF            LL19:
  713                     
  714                     	__tstw
                          	; pha
       04:AAEF  86 02     	stx	<__temp
       04:AAF1  05 02     	ora	<__temp
       04:AAF3  62        	cla
       04:AAF4  82        	clx
       04:AAF5  F0 01     	beq	.x_00807
       04:AAF7  E8        	inx
       04:AAF8            .x_00807:
                          	; pla
  715                     	__lbne	LL21
       04:AAF8  E0 00     	cpx	#0
       04:AAFA  F0 03     	beq	.x00808
       04:AAFC  4C 76 AB  	jmp	LL21
       04:AAFF            .x00808
  716                     ;          ((offset[0] == start_pos[0]) && (offset[1] == start_pos[1]) && (offset[2] > start_pos[2])))
  717                     	__ldub	_offset
                0000      .if (1 = 2)
                          .else
       04:AAFF  AE E2 31  	ldx	_offset
       04:AB02  62        	cla
                          .endif
  718                     	__pushw
                0001      .ifndef SMALL
       04:AB03  A4 00     	ldy	<__stack
       04:AB05  D0 02     	bne	.x_00810
       04:AB07  C6 01     	dec	<__stack + 1
                          .endif
       04:AB09  C6 00     .x_00810:	dec	<__stack
       04:AB0B  92 00     	sta	[__stack]
                0001      .ifndef SMALL
       04:AB0D  D0 02     	bne	.y_00810
       04:AB0F  C6 01     	dec	<__stack + 1
                          .endif
       04:AB11  C6 00     .y_00810:	dec	<__stack
       04:AB13  22        	sax
       04:AB14  92 00     	sta	[__stack]
       04:AB16  22        	sax
  719                     	__ldub	_start_pos
                0000      .if (1 = 2)
                          .else
       04:AB17  AE DF 31  	ldx	_start_pos
       04:AB1A  62        	cla
                          .endif
  720  04:AB1B  20 AB C7  	  jsr	eq
  721                     	__lbeqn	LL22
       04:AB1E  E0 00     	cpx	#0
       04:AB20  F0 1F     	beq	LL22
  722                     	__ldub	_offset+1
                0000      .if (1 = 2)
                          .else
       04:AB22  AE E3 31  	ldx	_offset+1
       04:AB25  62        	cla
                          .endif
  723                     	__pushw
                0001      .ifndef SMALL
       04:AB26  A4 00     	ldy	<__stack
       04:AB28  D0 02     	bne	.x_00814
       04:AB2A  C6 01     	dec	<__stack + 1
                          .endif
       04:AB2C  C6 00     .x_00814:	dec	<__stack
       04:AB2E  92 00     	sta	[__stack]
                0001      .ifndef SMALL
       04:AB30  D0 02     	bne	.y_00814
       04:AB32  C6 01     	dec	<__stack + 1
                          .endif
       04:AB34  C6 00     .y_00814:	dec	<__stack
       04:AB36  22        	sax
       04:AB37  92 00     	sta	[__stack]
       04:AB39  22        	sax
  724                     	__ldub	_start_pos+1
                0000      .if (1 = 2)
                          .else
       04:AB3A  AE E0 31  	ldx	_start_pos+1
       04:AB3D  62        	cla
                          .endif
  725  04:AB3E  20 AB C7  	  jsr	eq
  726  04:AB41            LL22:
  727                     
  728                     	__tstw
                          	; pha
       04:AB41  86 02     	stx	<__temp
       04:AB43  05 02     	ora	<__temp
       04:AB45  62        	cla
       04:AB46  82        	clx
       04:AB47  F0 01     	beq	.x_00816
       04:AB49  E8        	inx
       04:AB4A            .x_00816:
                          	; pla
  729                     	__lbeqn	LL23
       04:AB4A  E0 00     	cpx	#0
       04:AB4C  F0 1F     	beq	LL23
  730                     	__ldub	_offset+2
                0000      .if (1 = 2)
                          .else
       04:AB4E  AE E4 31  	ldx	_offset+2
       04:AB51  62        	cla
                          .endif
  731                     	__pushw
                0001      .ifndef SMALL
       04:AB52  A4 00     	ldy	<__stack
       04:AB54  D0 02     	bne	.x_00819
       04:AB56  C6 01     	dec	<__stack + 1
                          .endif
       04:AB58  C6 00     .x_00819:	dec	<__stack
       04:AB5A  92 00     	sta	[__stack]
                0001      .ifndef SMALL
       04:AB5C  D0 02     	bne	.y_00819
       04:AB5E  C6 01     	dec	<__stack + 1
                          .endif
       04:AB60  C6 00     .y_00819:	dec	<__stack
       04:AB62  22        	sax
       04:AB63  92 00     	sta	[__stack]
       04:AB65  22        	sax
  732                     	__ldub	_start_pos+2
                0000      .if (1 = 2)
                          .else
       04:AB66  AE E1 31  	ldx	_start_pos+2
       04:AB69  62        	cla
                          .endif
  733  04:AB6A  20 61 C8  	  jsr	gt
  734  04:AB6D            LL23:
  735                     
  736                     	__boolw
       04:AB6D  86 02     	stx	<__temp
       04:AB6F  05 02     	ora	<__temp
       04:AB71  82        	clx
       04:AB72  F0 01     	beq	.x00821
       04:AB74  E8        	inx
       04:AB75  62        .x00821	cla
  737  04:AB76            LL21:
  738                     
  739                     	__tstw
                          	; pha
       04:AB76  86 02     	stx	<__temp
       04:AB78  05 02     	ora	<__temp
       04:AB7A  62        	cla
       04:AB7B  82        	clx
       04:AB7C  F0 01     	beq	.x_00822
       04:AB7E  E8        	inx
       04:AB7F            .x_00822:
                          	; pla
  740                     	__lbeq	LL18
       04:AB7F  E0 00     	cpx	#0
       04:AB81  D0 03     	bne	.x00823
       04:AB83  4C 9B AB  	jmp	LL18
       04:AB86            .x00823
  741                     ;      {
  742                     ;         offset[0] = start_pos[0];
  743                     	__ldub	_start_pos
                0000      .if (1 = 2)
                          .else
       04:AB86  AE DF 31  	ldx	_start_pos
       04:AB89  62        	cla
                          .endif
  744  04:AB8A  8E E2 31  	  stx	_offset
  745                     ;         offset[1] = start_pos[1];
  746                     	__ldub	_start_pos+1
                0000      .if (1 = 2)
                          .else
       04:AB8D  AE E0 31  	ldx	_start_pos+1
       04:AB90  62        	cla
                          .endif
  747  04:AB91  8E E3 31  	  stx	_offset+1
  748                     ;         offset[2] = start_pos[2];
  749                     	__ldub	_start_pos+2
                0000      .if (1 = 2)
                          .else
       04:AB94  AE E1 31  	ldx	_start_pos+2
       04:AB97  62        	cla
                          .endif
  750  04:AB98  8E E4 31  	  stx	_offset+2
  751                     ;      }
  752                     ;      sub_3digit(start_pos, offset);
  753  04:AB9B            LL18:
  754                     
  755                     	__ldwi	_start_pos
       04:AB9B  A2 DF     	ldx	#low(_start_pos)
       04:AB9D  A9 31     	lda	#high(_start_pos)
  756                     	__pushw
                0001      .ifndef SMALL
       04:AB9F  A4 00     	ldy	<__stack
       04:ABA1  D0 02     	bne	.x_00828
       04:ABA3  C6 01     	dec	<__stack + 1
                          .endif
       04:ABA5  C6 00     .x_00828:	dec	<__stack
       04:ABA7  92 00     	sta	[__stack]
                0001      .ifndef SMALL
       04:ABA9  D0 02     	bne	.y_00828
       04:ABAB  C6 01     	dec	<__stack + 1
                          .endif
       04:ABAD  C6 00     .y_00828:	dec	<__stack
       04:ABAF  22        	sax
       04:ABB0  92 00     	sta	[__stack]
       04:ABB2  22        	sax
  757                     	__ldwi	_offset
       04:ABB3  A2 E2     	ldx	#low(_offset)
       04:ABB5  A9 31     	lda	#high(_offset)
  758  04:ABB7  20 DB A6  	  call	_sub_3digit
  759                     ;   }
  760                     ;   /* in either case, target needs to be set as final (start +- offset) */
  761                     ;   target[0] = result[0];
  762  04:ABBA            LL17:
  763                     
  764  04:ABBA            LL16:
  765                     
  766                     	__ldub	_result
                0000      .if (1 = 2)
                          .else
       04:ABBA  AE E8 31  	ldx	_result
       04:ABBD  62        	cla
                          .endif
  767  04:ABBE  8E E5 31  	  stx	_target
  768                     ;   target[1] = result[1];
  769                     	__ldub	_result+1
                0000      .if (1 = 2)
                          .else
       04:ABC1  AE E9 31  	ldx	_result+1
       04:ABC4  62        	cla
                          .endif
  770  04:ABC5  8E E6 31  	  stx	_target+1
  771                     ;   target[2] = result[2];
  772                     	__ldub	_result+2
                0000      .if (1 = 2)
                          .else
       04:ABC8  AE EA 31  	ldx	_result+2
       04:ABCB  62        	cla
                          .endif
  773  04:ABCC  8E E7 31  	  stx	_target+2
  774                     ;}
  775  04:ABCF            LL13:
  776                     
  777  04:ABCF  60        	  rts
  778                     	.endp
  779                     
  780                     ;clear_index()
  781                     ;{
  782  04:4F54            	.proc _clear_index
  783                     ;   put_string("      ", 14, START_UNDER);
  784                     	__ldwi	LL0+0
       04:AF54  A2 00     	ldx	#low(LL0+0)
       04:AF56  A9 40     	lda	#high(LL0+0)
  785                     	__stw	__si
       04:AF58  8E EE 20  	stx	__si
       04:AF5B  8D EF 20  	sta	__si+1
  786                     	__ldwi	14
       04:AF5E  A2 0E     	ldx	#low(14)
       04:AF60  A9 00     	lda	#high(14)
  787  04:AF62  8E FA 20  	  stx	__bl
  788                     	__ldwi	6
       04:AF65  A2 06     	ldx	#low(6)
       04:AF67  A9 00     	lda	#high(6)
  789  04:AF69  20 57 CF  	  call	_put_string.3
  790                     ;   put_string("      ", 14, OFFSET_UNDER);
  791                     	__ldwi	LL0+7
       04:AF6C  A2 07     	ldx	#low(LL0+7)
       04:AF6E  A9 40     	lda	#high(LL0+7)
  792                     	__stw	__si
       04:AF70  8E EE 20  	stx	__si
       04:AF73  8D EF 20  	sta	__si+1
  793                     	__ldwi	14
       04:AF76  A2 0E     	ldx	#low(14)
       04:AF78  A9 00     	lda	#high(14)
  794  04:AF7A  8E FA 20  	  stx	__bl
  795                     	__ldwi	8
       04:AF7D  A2 08     	ldx	#low(8)
       04:AF7F  A9 00     	lda	#high(8)
  796  04:AF81  20 57 CF  	  call	_put_string.3
  797                     ;   put_string("   ", 2, DIRECTION_LINE);
  798                     	__ldwi	LL0+14
       04:AF84  A2 0E     	ldx	#low(LL0+14)
       04:AF86  A9 40     	lda	#high(LL0+14)
  799                     	__stw	__si
       04:AF88  8E EE 20  	stx	__si
       04:AF8B  8D EF 20  	sta	__si+1
  800                     	__ldwi	2
       04:AF8E  A2 02     	ldx	#low(2)
       04:AF90  A9 00     	lda	#high(2)
  801  04:AF92  8E FA 20  	  stx	__bl
  802                     	__ldwi	3
       04:AF95  A2 03     	ldx	#low(3)
       04:AF97  A9 00     	lda	#high(3)
  803  04:AF99  20 57 CF  	  call	_put_string.3
  804                     ;   put_string("   ", 26, DIRECTION_LINE);
  805                     	__ldwi	LL0+18
       04:AF9C  A2 12     	ldx	#low(LL0+18)
       04:AF9E  A9 40     	lda	#high(LL0+18)
  806                     	__stw	__si
       04:AFA0  8E EE 20  	stx	__si
       04:AFA3  8D EF 20  	sta	__si+1
  807                     	__ldwi	26
       04:AFA6  A2 1A     	ldx	#low(26)
       04:AFA8  A9 00     	lda	#high(26)
  808  04:AFAA  8E FA 20  	  stx	__bl
  809                     	__ldwi	3
       04:AFAD  A2 03     	ldx	#low(3)
       04:AFAF  A9 00     	lda	#high(3)
  810  04:AFB1  20 57 CF  	  call	_put_string.3
  811                     ;}
  812  04:AFB4            LL24:
  813                     
  814  04:AFB4  60        	  rts
  815                     	.endp
  816                     
  817                     ;put_index()
  818                     ;{
  819  04:4DB1            	.proc _put_index
  820                     ;   if (direction == DIR_FWD)
  821                     	__ldub	_direction
                0000      .if (1 = 2)
                          .else
       04:ADB1  AE ED 31  	ldx	_direction
       04:ADB4  62        	cla
                          .endif
  822                     	__cmpwi_eq	0
       04:ADB5  E0 00     	cpx	#low(0)
       04:ADB7  82        	clx
       04:ADB8  D0 06     	bne	.f00850
       04:ADBA  C9 00     	cmp	#high(0)
       04:ADBC  D0 02     	bne	.f00850
       04:ADBE  A2 01     	ldx	#1
       04:ADC0  62        .f00850:	cla
  823                     	__lbeq	LL26
       04:ADC1  E0 00     	cpx	#0
       04:ADC3  D0 03     	bne	.x00851
       04:ADC5  4C E3 AD  	jmp	LL26
       04:ADC8            .x00851
  824                     ;   {
  825                     ;       put_string("FORWARD ", 14, DIRECTION_LINE);
  826                     	__ldwi	LL0+22
       04:ADC8  A2 16     	ldx	#low(LL0+22)
       04:ADCA  A9 40     	lda	#high(LL0+22)
  827                     	__stw	__si
       04:ADCC  8E EE 20  	stx	__si
       04:ADCF  8D EF 20  	sta	__si+1
  828                     	__ldwi	14
       04:ADD2  A2 0E     	ldx	#low(14)
       04:ADD4  A9 00     	lda	#high(14)
  829  04:ADD6  8E FA 20  	  stx	__bl
  830                     	__ldwi	3
       04:ADD9  A2 03     	ldx	#low(3)
       04:ADDB  A9 00     	lda	#high(3)
  831  04:ADDD  20 57 CF  	  call	_put_string.3
  832                     ;   }
  833                     ;   else
  834                     	__lbra	LL27
       04:ADE0  4C FB AD  	jmp	LL27
  835  04:ADE3            LL26:
  836                     
  837                     ;   {
  838                     ;       put_string("BACKWARD", 14, DIRECTION_LINE);
  839                     	__ldwi	LL0+31
       04:ADE3  A2 1F     	ldx	#low(LL0+31)
       04:ADE5  A9 40     	lda	#high(LL0+31)
  840                     	__stw	__si
       04:ADE7  8E EE 20  	stx	__si
       04:ADEA  8D EF 20  	sta	__si+1
  841                     	__ldwi	14
       04:ADED  A2 0E     	ldx	#low(14)
       04:ADEF  A9 00     	lda	#high(14)
  842  04:ADF1  8E FA 20  	  stx	__bl
  843                     	__ldwi	3
       04:ADF4  A2 03     	ldx	#low(3)
       04:ADF6  A9 00     	lda	#high(3)
  844  04:ADF8  20 57 CF  	  call	_put_string.3
  845                     ;   }
  846  04:ADFB            LL27:
  847                     
  848                     ;   if (adjust == ADJUST_DIRECTION)
  849                     	__ldub	_adjust
                0000      .if (1 = 2)
                          .else
       04:ADFB  AE EB 31  	ldx	_adjust
       04:ADFE  62        	cla
                          .endif
  850                     	__cmpwi_eq	0
       04:ADFF  E0 00     	cpx	#low(0)
       04:AE01  82        	clx
       04:AE02  D0 06     	bne	.f00862
       04:AE04  C9 00     	cmp	#high(0)
       04:AE06  D0 02     	bne	.f00862
       04:AE08  A2 01     	ldx	#1
       04:AE0A  62        .f00862:	cla
  851                     	__lbeq	LL28
       04:AE0B  E0 00     	cpx	#0
       04:AE0D  D0 03     	bne	.x00863
       04:AE0F  4C 45 AE  	jmp	LL28
       04:AE12            .x00863
  852                     ;   {
  853                     ;       put_string(">>>", 2, DIRECTION_LINE);
  854                     	__ldwi	LL0+40
       04:AE12  A2 28     	ldx	#low(LL0+40)
       04:AE14  A9 40     	lda	#high(LL0+40)
  855                     	__stw	__si
       04:AE16  8E EE 20  	stx	__si
       04:AE19  8D EF 20  	sta	__si+1
  856                     	__ldwi	2
       04:AE1C  A2 02     	ldx	#low(2)
       04:AE1E  A9 00     	lda	#high(2)
  857  04:AE20  8E FA 20  	  stx	__bl
  858                     	__ldwi	3
       04:AE23  A2 03     	ldx	#low(3)
       04:AE25  A9 00     	lda	#high(3)
  859  04:AE27  20 57 CF  	  call	_put_string.3
  860                     ;       put_string("<<<", 26, DIRECTION_LINE);
  861                     	__ldwi	LL0+44
       04:AE2A  A2 2C     	ldx	#low(LL0+44)
       04:AE2C  A9 40     	lda	#high(LL0+44)
  862                     	__stw	__si
       04:AE2E  8E EE 20  	stx	__si
       04:AE31  8D EF 20  	sta	__si+1
  863                     	__ldwi	26
       04:AE34  A2 1A     	ldx	#low(26)
       04:AE36  A9 00     	lda	#high(26)
  864  04:AE38  8E FA 20  	  stx	__bl
  865                     	__ldwi	3
       04:AE3B  A2 03     	ldx	#low(3)
       04:AE3D  A9 00     	lda	#high(3)
  866  04:AE3F  20 57 CF  	  call	_put_string.3
  867                     ;   }
  868                     ;   else if (adjust == ADJUST_START)
  869                     	__lbra	LL29
       04:AE42  4C E6 AE  	jmp	LL29
  870  04:AE45            LL28:
  871                     
  872                     	__ldub	_adjust
                0000      .if (1 = 2)
                          .else
       04:AE45  AE EB 31  	ldx	_adjust
       04:AE48  62        	cla
                          .endif
  873                     	__cmpwi_eq	1
       04:AE49  E0 01     	cpx	#low(1)
       04:AE4B  82        	clx
       04:AE4C  D0 06     	bne	.f00874
       04:AE4E  C9 00     	cmp	#high(1)
       04:AE50  D0 02     	bne	.f00874
       04:AE52  A2 01     	ldx	#1
       04:AE54  62        .f00874:	cla
  874                     	__lbeq	LL30
       04:AE55  E0 00     	cpx	#0
       04:AE57  D0 03     	bne	.x00875
       04:AE59  4C 97 AE  	jmp	LL30
       04:AE5C            .x00875
  875                     ;   {
  876                     ;       put_string("      ", 14, START_UNDER);
  877                     	__ldwi	LL0+48
       04:AE5C  A2 30     	ldx	#low(LL0+48)
       04:AE5E  A9 40     	lda	#high(LL0+48)
  878                     	__stw	__si
       04:AE60  8E EE 20  	stx	__si
       04:AE63  8D EF 20  	sta	__si+1
  879                     	__ldwi	14
       04:AE66  A2 0E     	ldx	#low(14)
       04:AE68  A9 00     	lda	#high(14)
  880  04:AE6A  8E FA 20  	  stx	__bl
  881                     	__ldwi	6
       04:AE6D  A2 06     	ldx	#low(6)
       04:AE6F  A9 00     	lda	#high(6)
  882  04:AE71  20 57 CF  	  call	_put_string.3
  883                     ;       put_string("^", 14+edit_pos, START_UNDER);
  884                     	__ldwi	LL0+55
       04:AE74  A2 37     	ldx	#low(LL0+55)
       04:AE76  A9 40     	lda	#high(LL0+55)
  885                     	__stw	__si
       04:AE78  8E EE 20  	stx	__si
       04:AE7B  8D EF 20  	sta	__si+1
  886                     	__ldwi	14
       04:AE7E  A2 0E     	ldx	#low(14)
       04:AE80  A9 00     	lda	#high(14)
  887                     	__addub	_edit_pos
       04:AE82  18        	clc
       04:AE83  22        	sax
       04:AE84  6D EC 31  	adc	_edit_pos
       04:AE87  22        	sax
       04:AE88  69 00     	adc	#0
  888  04:AE8A  8E FA 20  	  stx	__bl
  889                     	__ldwi	6
       04:AE8D  A2 06     	ldx	#low(6)
       04:AE8F  A9 00     	lda	#high(6)
  890  04:AE91  20 57 CF  	  call	_put_string.3
  891                     ;   }
  892                     ;   else if (adjust == ADJUST_OFFSET)
  893                     	__lbra	LL31
       04:AE94  4C E6 AE  	jmp	LL31
  894  04:AE97            LL30:
  895                     
  896                     	__ldub	_adjust
                0000      .if (1 = 2)
                          .else
       04:AE97  AE EB 31  	ldx	_adjust
       04:AE9A  62        	cla
                          .endif
  897                     	__cmpwi_eq	2
       04:AE9B  E0 02     	cpx	#low(2)
       04:AE9D  82        	clx
       04:AE9E  D0 06     	bne	.f00887
       04:AEA0  C9 00     	cmp	#high(2)
       04:AEA2  D0 02     	bne	.f00887
       04:AEA4  A2 01     	ldx	#1
       04:AEA6  62        .f00887:	cla
  898                     	__lbeq	LL32
       04:AEA7  E0 00     	cpx	#0
       04:AEA9  D0 03     	bne	.x00888
       04:AEAB  4C E6 AE  	jmp	LL32
       04:AEAE            .x00888
  899                     ;   {
  900                     ;       put_string("      ", 14, OFFSET_UNDER);
  901                     	__ldwi	LL0+57
       04:AEAE  A2 39     	ldx	#low(LL0+57)
       04:AEB0  A9 40     	lda	#high(LL0+57)
  902                     	__stw	__si
       04:AEB2  8E EE 20  	stx	__si
       04:AEB5  8D EF 20  	sta	__si+1
  903                     	__ldwi	14
       04:AEB8  A2 0E     	ldx	#low(14)
       04:AEBA  A9 00     	lda	#high(14)
  904  04:AEBC  8E FA 20  	  stx	__bl
  905                     	__ldwi	8
       04:AEBF  A2 08     	ldx	#low(8)
       04:AEC1  A9 00     	lda	#high(8)
  906  04:AEC3  20 57 CF  	  call	_put_string.3
  907                     ;       put_string("^", 14+edit_pos, OFFSET_UNDER);
  908                     	__ldwi	LL0+64
       04:AEC6  A2 40     	ldx	#low(LL0+64)
       04:AEC8  A9 40     	lda	#high(LL0+64)
  909                     	__stw	__si
       04:AECA  8E EE 20  	stx	__si
       04:AECD  8D EF 20  	sta	__si+1
  910                     	__ldwi	14
       04:AED0  A2 0E     	ldx	#low(14)
       04:AED2  A9 00     	lda	#high(14)
  911                     	__addub	_edit_pos
       04:AED4  18        	clc
       04:AED5  22        	sax
       04:AED6  6D EC 31  	adc	_edit_pos
       04:AED9  22        	sax
       04:AEDA  69 00     	adc	#0
  912  04:AEDC  8E FA 20  	  stx	__bl
  913                     	__ldwi	8
       04:AEDF  A2 08     	ldx	#low(8)
       04:AEE1  A9 00     	lda	#high(8)
  914  04:AEE3  20 57 CF  	  call	_put_string.3
  915                     ;   }   
  916                     ;}
  917  04:AEE6            LL32:
  918                     
  919  04:AEE6            LL31:
  920                     
  921  04:AEE6            LL29:
  922                     
  923  04:AEE6            LL25:
  924                     
  925  04:AEE6  60        	  rts
  926                     	.endp
  927                     
  928                     ;main()
  929                     ;{
  930  04:4000            	.proc _main
  931                     ;   set_color(0,0);
  932                     	__ldwi	0
       04:A000  A2 00     	ldx	#low(0)
       04:A002  A9 00     	lda	#high(0)
  933                     	__stw	color_reg
       04:A004  8E 02 04  	stx	color_reg
       04:A007  8D 03 04  	sta	color_reg+1
  934                     	__ldwi	0
       04:A00A  A2 00     	ldx	#low(0)
       04:A00C  A9 00     	lda	#high(0)
  935                     	__stw	color_data
       04:A00E  8E 04 04  	stx	color_data
       04:A011  8D 05 04  	sta	color_data+1
  936                     ;   set_color(1,511);
  937                     	__ldwi	1
       04:A014  A2 01     	ldx	#low(1)
       04:A016  A9 00     	lda	#high(1)
  938                     	__stw	color_reg
       04:A018  8E 02 04  	stx	color_reg
       04:A01B  8D 03 04  	sta	color_reg+1
  939                     	__ldwi	511
       04:A01E  A2 FF     	ldx	#low(511)
       04:A020  A9 01     	lda	#high(511)
  940                     	__stw	color_data
       04:A022  8E 04 04  	stx	color_data
       04:A025  8D 05 04  	sta	color_data+1
  941                     ;   for (i = 0; i < 3; i++) {
  942                     	__ldwi	0
       04:A028  A2 00     	ldx	#low(0)
       04:A02A  A9 00     	lda	#high(0)
  943  04:A02C  8E 08 32  	  stx	_i
  944  04:A02F            LL34:
  945                     
  946                     	__ldub	_i
                0000      .if (1 = 2)
                          .else
       04:A02F  AE 08 32  	ldx	_i
       04:A032  62        	cla
                          .endif
  947                     	__stw	<__temp
       04:A033  86 02     	stx	<__temp
       04:A035  85 03     	sta	<__temp+1
  948                     	__ldwi	3
       04:A037  A2 03     	ldx	#low(3)
       04:A039  A9 00     	lda	#high(3)
  949  04:A03B  20 D6 C8  	  jsr	ltzp
  950                     	__lbnen	LL36
       04:A03E  E0 00     	cpx	#0
       04:A040  D0 0D     	bne	LL36
  951                     	__lbra	LL37
       04:A042  4C 9A A0  	jmp	LL37
  952  04:A045            LL35:
  953                     
  954                     	__ldub	_i
                0000      .if (1 = 2)
                          .else
       04:A045  AE 08 32  	ldx	_i
       04:A048  62        	cla
                          .endif
  955  04:A049  EE 08 32  	inc	_i
  956                     	__lbra	LL34
       04:A04C  4C 2F A0  	jmp	LL34
  957  04:A04F            LL36:
  958                     
  959                     ;      start_pos[i] = 0;
  960                     	__ldwi	_start_pos
       04:A04F  A2 DF     	ldx	#low(_start_pos)
       04:A051  A9 31     	lda	#high(_start_pos)
  961                     	__addub	_i
       04:A053  18        	clc
       04:A054  22        	sax
       04:A055  6D 08 32  	adc	_i
       04:A058  22        	sax
       04:A059  69 00     	adc	#0
  962                     	__stbip	0
                          	__stw	__ptr
       04:A05B  8E 06 20  	stx	__ptr
       04:A05E  8D 07 20  	sta	__ptr+1
       04:A061  A9 00     	lda	#low(0)
       04:A063  92 06     	sta	[__ptr]
       04:A065  AA        	tax
       04:A066  62        	cla
  963                     ;      offset[i] = 0;
  964                     	__ldwi	_offset
       04:A067  A2 E2     	ldx	#low(_offset)
       04:A069  A9 31     	lda	#high(_offset)
  965                     	__addub	_i
       04:A06B  18        	clc
       04:A06C  22        	sax
       04:A06D  6D 08 32  	adc	_i
       04:A070  22        	sax
       04:A071  69 00     	adc	#0
  966                     	__stbip	0
                          	__stw	__ptr
       04:A073  8E 06 20  	stx	__ptr
       04:A076  8D 07 20  	sta	__ptr+1
       04:A079  A9 00     	lda	#low(0)
       04:A07B  92 06     	sta	[__ptr]
       04:A07D  AA        	tax
       04:A07E  62        	cla
  967                     ;      target[i] = 0;
  968                     	__ldwi	_target
       04:A07F  A2 E5     	ldx	#low(_target)
       04:A081  A9 31     	lda	#high(_target)
  969                     	__addub	_i
       04:A083  18        	clc
       04:A084  22        	sax
       04:A085  6D 08 32  	adc	_i
       04:A088  22        	sax
       04:A089  69 00     	adc	#0
  970                     	__stbip	0
                          	__stw	__ptr
       04:A08B  8E 06 20  	stx	__ptr
       04:A08E  8D 07 20  	sta	__ptr+1
       04:A091  A9 00     	lda	#low(0)
       04:A093  92 06     	sta	[__ptr]
       04:A095  AA        	tax
       04:A096  62        	cla
  971                     ;   }
  972                     	__lbra	LL35
       04:A097  4C 45 A0  	jmp	LL35
  973  04:A09A            LL37:
  974                     
  975                     ;   edit_pos = 0;
  976                     	__ldwi	0
       04:A09A  A2 00     	ldx	#low(0)
       04:A09C  A9 00     	lda	#high(0)
  977  04:A09E  8E EC 31  	  stx	_edit_pos
  978                     ;   adjust = ADJUST_START;
  979                     	__ldwi	1
       04:A0A1  A2 01     	ldx	#low(1)
       04:A0A3  A9 00     	lda	#high(1)
  980  04:A0A5  8E EB 31  	  stx	_adjust
  981                     ;   direction = DIR_FWD;
  982                     	__ldwi	0
       04:A0A8  A2 00     	ldx	#low(0)
       04:A0AA  A9 00     	lda	#high(0)
  983  04:A0AC  8E ED 31  	  stx	_direction
  984                     ;   put_string("Head Seek Test", 10, TITLE_LINE);
  985                     	__ldwi	LL0+66
       04:A0AF  A2 42     	ldx	#low(LL0+66)
       04:A0B1  A9 40     	lda	#high(LL0+66)
  986                     	__stw	__si
       04:A0B3  8E EE 20  	stx	__si
       04:A0B6  8D EF 20  	sta	__si+1
  987                     	__ldwi	10
       04:A0B9  A2 0A     	ldx	#low(10)
       04:A0BB  A9 00     	lda	#high(10)
  988  04:A0BD  8E FA 20  	  stx	__bl
  989                     	__ldwi	1
       04:A0C0  A2 01     	ldx	#low(1)
       04:A0C2  A9 00     	lda	#high(1)
  990  04:A0C4  20 57 CF  	  call	_put_string.3
  991                     ;   put_string("       Dir: ", 2, DIRECTION_LINE);
  992                     	__ldwi	LL0+81
       04:A0C7  A2 51     	ldx	#low(LL0+81)
       04:A0C9  A9 40     	lda	#high(LL0+81)
  993                     	__stw	__si
       04:A0CB  8E EE 20  	stx	__si
       04:A0CE  8D EF 20  	sta	__si+1
  994                     	__ldwi	2
       04:A0D1  A2 02     	ldx	#low(2)
       04:A0D3  A9 00     	lda	#high(2)
  995  04:A0D5  8E FA 20  	  stx	__bl
  996                     	__ldwi	3
       04:A0D8  A2 03     	ldx	#low(3)
       04:A0DA  A9 00     	lda	#high(3)
  997  04:A0DC  20 57 CF  	  call	_put_string.3
  998                     ;   put_string("Start  LBA: ", 2, START_LINE);
  999                     	__ldwi	LL0+94
       04:A0DF  A2 5E     	ldx	#low(LL0+94)
       04:A0E1  A9 40     	lda	#high(LL0+94)
 1000                     	__stw	__si
       04:A0E3  8E EE 20  	stx	__si
       04:A0E6  8D EF 20  	sta	__si+1
 1001                     	__ldwi	2
       04:A0E9  A2 02     	ldx	#low(2)
       04:A0EB  A9 00     	lda	#high(2)
 1002  04:A0ED  8E FA 20  	  stx	__bl
 1003                     	__ldwi	5
       04:A0F0  A2 05     	ldx	#low(5)
       04:A0F2  A9 00     	lda	#high(5)
 1004  04:A0F4  20 57 CF  	  call	_put_string.3
 1005                     ;   put_string("Offset LBA: ", 2, OFFSET_LINE);
 1006                     	__ldwi	LL0+107
       04:A0F7  A2 6B     	ldx	#low(LL0+107)
       04:A0F9  A9 40     	lda	#high(LL0+107)
 1007                     	__stw	__si
       04:A0FB  8E EE 20  	stx	__si
       04:A0FE  8D EF 20  	sta	__si+1
 1008                     	__ldwi	2
       04:A101  A2 02     	ldx	#low(2)
       04:A103  A9 00     	lda	#high(2)
 1009  04:A105  8E FA 20  	  stx	__bl
 1010                     	__ldwi	7
       04:A108  A2 07     	ldx	#low(7)
       04:A10A  A9 00     	lda	#high(7)
 1011  04:A10C  20 57 CF  	  call	_put_string.3
 1012                     ;   put_string("Target LBA: ", 2, TARGET_LINE);
 1013                     	__ldwi	LL0+120
       04:A10F  A2 78     	ldx	#low(LL0+120)
       04:A111  A9 40     	lda	#high(LL0+120)
 1014                     	__stw	__si
       04:A113  8E EE 20  	stx	__si
       04:A116  8D EF 20  	sta	__si+1
 1015                     	__ldwi	2
       04:A119  A2 02     	ldx	#low(2)
       04:A11B  A9 00     	lda	#high(2)
 1016  04:A11D  8E FA 20  	  stx	__bl
 1017                     	__ldwi	9
       04:A120  A2 09     	ldx	#low(9)
       04:A122  A9 00     	lda	#high(9)
 1018  04:A124  20 57 CF  	  call	_put_string.3
 1019                     ;   show_startpos();
 1020  04:A127  20 B5 AF  	  call	_show_startpos
 1021                     ;   show_offset();
 1022  04:A12A  20 13 B0  	  call	_show_offset
 1023                     ;   show_target();
 1024  04:A12D  20 71 B0  	  call	_show_target
 1025                     ;   put_string("Change Values: direction pad", 2, INSTRUCT_LINE1);
 1026                     	__ldwi	LL0+133
       04:A130  A2 85     	ldx	#low(LL0+133)
       04:A132  A9 40     	lda	#high(LL0+133)
 1027                     	__stw	__si
       04:A134  8E EE 20  	stx	__si
       04:A137  8D EF 20  	sta	__si+1
 1028                     	__ldwi	2
       04:A13A  A2 02     	ldx	#low(2)
       04:A13C  A9 00     	lda	#high(2)
 1029  04:A13E  8E FA 20  	  stx	__bl
 1030                     	__ldwi	24
       04:A141  A2 18     	ldx	#low(24)
       04:A143  A9 00     	lda	#high(24)
 1031  04:A145  20 57 CF  	  call	_put_string.3
 1032                     ;   put_string("Button II = fwd; I = back", 2, INSTRUCT_LINE3);
 1033                     	__ldwi	LL0+162
       04:A148  A2 A2     	ldx	#low(LL0+162)
       04:A14A  A9 40     	lda	#high(LL0+162)
 1034                     	__stw	__si
       04:A14C  8E EE 20  	stx	__si
       04:A14F  8D EF 20  	sta	__si+1
 1035                     	__ldwi	2
       04:A152  A2 02     	ldx	#low(2)
       04:A154  A9 00     	lda	#high(2)
 1036  04:A156  8E FA 20  	  stx	__bl
 1037                     	__ldwi	26
       04:A159  A2 1A     	ldx	#low(26)
       04:A15B  A9 00     	lda	#high(26)
 1038  04:A15D  20 57 CF  	  call	_put_string.3
 1039                     ;   while(1)
 1040  04:A160            LL38:
 1041                     
 1042                     	__ldwi	1
       04:A160  A2 01     	ldx	#low(1)
       04:A162  A9 00     	lda	#high(1)
 1043                     	__tstw
                          	; pha
       04:A164  86 02     	stx	<__temp
       04:A166  05 02     	ora	<__temp
       04:A168  62        	cla
       04:A169  82        	clx
       04:A16A  F0 01     	beq	.x_00959
       04:A16C  E8        	inx
       04:A16D            .x_00959:
                          	; pla
 1044                     	__lbeq	LL39
       04:A16D  E0 00     	cpx	#0
       04:A16F  D0 03     	bne	.x00960
       04:A171  4C D7 A6  	jmp	LL39
       04:A174            .x00960
 1045                     ;   {
 1046                     ;      put_index();
 1047  04:A174  20 B1 AD  	  call	_put_index
 1048                     ;      pad = joytrg(0);
 1049                     	__ldwi	0
       04:A177  A2 00     	ldx	#low(0)
       04:A179  A9 00     	lda	#high(0)
 1050  04:A17B  20 8F D9  	  call	_joytrg
 1051  04:A17E  8E DB 31  	  stx	_pad
 1052                     ;      if (adjust == ADJUST_DIRECTION)
 1053                     	__ldub	_adjust
                0000      .if (1 = 2)
                          .else
       04:A181  AE EB 31  	ldx	_adjust
       04:A184  62        	cla
                          .endif
 1054                     	__cmpwi_eq	0
       04:A185  E0 00     	cpx	#low(0)
       04:A187  82        	clx
       04:A188  D0 06     	bne	.f00963
       04:A18A  C9 00     	cmp	#high(0)
       04:A18C  D0 02     	bne	.f00963
       04:A18E  A2 01     	ldx	#1
       04:A190  62        .f00963:	cla
 1055                     	__lbeq	LL40
       04:A191  E0 00     	cpx	#0
       04:A193  D0 03     	bne	.x00964
       04:A195  4C 1C A2  	jmp	LL40
       04:A198            .x00964
 1056                     ;      {
 1057                     ;         if (pad & (JOY_LEFT | JOY_RGHT | JOY_UP | JOY_DOWN))
 1058                     	__ldub	_pad
                0000      .if (1 = 2)
                          .else
       04:A198  AE DB 31  	ldx	_pad
       04:A19B  62        	cla
                          .endif
 1059                     	__andwi	240
       04:A19C  22        	sax
       04:A19D  29 F0     	and	#low(240)
       04:A19F  22        	sax
       04:A1A0  29 00     	and	#high(240)
 1060                     	__tstw
                          	; pha
       04:A1A2  86 02     	stx	<__temp
       04:A1A4  05 02     	ora	<__temp
       04:A1A6  62        	cla
       04:A1A7  82        	clx
       04:A1A8  F0 01     	beq	.x_00967
       04:A1AA  E8        	inx
       04:A1AB            .x_00967:
                          	; pla
 1061                     	__lbeq	LL41
       04:A1AB  E0 00     	cpx	#0
       04:A1AD  D0 03     	bne	.x00968
       04:A1AF  4C F2 A1  	jmp	LL41
       04:A1B2            .x00968
 1062                     ;         {
 1063                     ;            if (direction == DIR_FWD)
 1064                     	__ldub	_direction
                0000      .if (1 = 2)
                          .else
       04:A1B2  AE ED 31  	ldx	_direction
       04:A1B5  62        	cla
                          .endif
 1065                     	__cmpwi_eq	0
       04:A1B6  E0 00     	cpx	#low(0)
       04:A1B8  82        	clx
       04:A1B9  D0 06     	bne	.f00970
       04:A1BB  C9 00     	cmp	#high(0)
       04:A1BD  D0 02     	bne	.f00970
       04:A1BF  A2 01     	ldx	#1
       04:A1C1  62        .f00970:	cla
 1066                     	__lbeq	LL42
       04:A1C2  E0 00     	cpx	#0
       04:A1C4  D0 03     	bne	.x00971
       04:A1C6  4C DF A1  	jmp	LL42
       04:A1C9            .x00971
 1067                     ;            {
 1068                     ;               direction = DIR_BACK;
 1069                     	__ldwi	1
       04:A1C9  A2 01     	ldx	#low(1)
       04:A1CB  A9 00     	lda	#high(1)
 1070  04:A1CD  8E ED 31  	  stx	_direction
 1071                     ;               put_index();
 1072  04:A1D0  20 B1 AD  	  call	_put_index
 1073                     ;               /* if startpos + offset is outside limits, adjust offset */
 1074                     ;               fix_offset();
 1075  04:A1D3  20 B3 A9  	  call	_fix_offset
 1076                     ;               show_offset();
 1077  04:A1D6  20 13 B0  	  call	_show_offset
 1078                     ;               show_target();
 1079  04:A1D9  20 71 B0  	  call	_show_target
 1080                     ;            }
 1081                     ;            else
 1082                     	__lbra	LL43
       04:A1DC  4C F2 A1  	jmp	LL43
 1083  04:A1DF            LL42:
 1084                     
 1085                     ;            {
 1086                     ;               direction = DIR_FWD;
 1087                     	__ldwi	0
       04:A1DF  A2 00     	ldx	#low(0)
       04:A1E1  A9 00     	lda	#high(0)
 1088  04:A1E3  8E ED 31  	  stx	_direction
 1089                     ;               put_index();
 1090  04:A1E6  20 B1 AD  	  call	_put_index
 1091                     ;               /* if startpos + offset is outside limits, adjust offset */
 1092                     ;               fix_offset();
 1093  04:A1E9  20 B3 A9  	  call	_fix_offset
 1094                     ;               show_offset();
 1095  04:A1EC  20 13 B0  	  call	_show_offset
 1096                     ;               show_target();
 1097  04:A1EF  20 71 B0  	  call	_show_target
 1098                     ;            }
 1099  04:A1F2            LL43:
 1100                     
 1101                     ;         }
 1102                     ;         if (pad & JOY_B)
 1103  04:A1F2            LL41:
 1104                     
 1105                     	__ldub	_pad
                0000      .if (1 = 2)
                          .else
       04:A1F2  AE DB 31  	ldx	_pad
       04:A1F5  62        	cla
                          .endif
 1106                     	__andwi	2
       04:A1F6  22        	sax
       04:A1F7  29 02     	and	#low(2)
       04:A1F9  22        	sax
       04:A1FA  29 00     	and	#high(2)
 1107                     	__tstw
                          	; pha
       04:A1FC  86 02     	stx	<__temp
       04:A1FE  05 02     	ora	<__temp
       04:A200  62        	cla
       04:A201  82        	clx
       04:A202  F0 01     	beq	.x_00977
       04:A204  E8        	inx
       04:A205            .x_00977:
                          	; pla
 1108                     	__lbeq	LL44
       04:A205  E0 00     	cpx	#0
       04:A207  D0 03     	bne	.x00978
       04:A209  4C 19 A2  	jmp	LL44
       04:A20C            .x00978
 1109                     ;         {
 1110                     ;            adjust = ADJUST_START;
 1111                     	__ldwi	1
       04:A20C  A2 01     	ldx	#low(1)
       04:A20E  A9 00     	lda	#high(1)
 1112  04:A210  8E EB 31  	  stx	_adjust
 1113                     ;            clear_index();
 1114  04:A213  20 54 AF  	  call	_clear_index
 1115                     ;            put_index();
 1116  04:A216  20 B1 AD  	  call	_put_index
 1117                     ;         }
 1118                     ;      }
 1119  04:A219            LL44:
 1120                     
 1121                     ;      else if ((adjust == ADJUST_START) || (adjust == ADJUST_OFFSET))
 1122                     	__lbra	LL45
       04:A219  4C CD A6  	jmp	LL45
 1123  04:A21C            LL40:
 1124                     
 1125                     	__ldub	_adjust
                0000      .if (1 = 2)
                          .else
       04:A21C  AE EB 31  	ldx	_adjust
       04:A21F  62        	cla
                          .endif
 1126                     	__cmpwi_eq	1
       04:A220  E0 01     	cpx	#low(1)
       04:A222  82        	clx
       04:A223  D0 06     	bne	.f00982
       04:A225  C9 00     	cmp	#high(1)
       04:A227  D0 02     	bne	.f00982
       04:A229  A2 01     	ldx	#1
       04:A22B  62        .f00982:	cla
 1127                     	__lbnen	LL47
       04:A22C  E0 00     	cpx	#0
       04:A22E  D0 10     	bne	LL47
 1128                     	__ldub	_adjust
                0000      .if (1 = 2)
                          .else
       04:A230  AE EB 31  	ldx	_adjust
       04:A233  62        	cla
                          .endif
 1129                     	__cmpwi_eq	2
       04:A234  E0 02     	cpx	#low(2)
       04:A236  82        	clx
       04:A237  D0 06     	bne	.f00985
       04:A239  C9 00     	cmp	#high(2)
       04:A23B  D0 02     	bne	.f00985
       04:A23D  A2 01     	ldx	#1
       04:A23F  62        .f00985:	cla
 1130  04:A240            LL47:
 1131                     
 1132                     	__tstw
                          	; pha
       04:A240  86 02     	stx	<__temp
       04:A242  05 02     	ora	<__temp
       04:A244  62        	cla
       04:A245  82        	clx
       04:A246  F0 01     	beq	.x_00986
       04:A248  E8        	inx
       04:A249            .x_00986:
                          	; pla
 1133                     	__lbeq	LL46
       04:A249  E0 00     	cpx	#0
       04:A24B  D0 03     	bne	.x00987
       04:A24D  4C CD A6  	jmp	LL46
       04:A250            .x00987
 1134                     ;      {
 1135                     ;         if (pad & JOY_LEFT)
 1136                     	__ldub	_pad
                0000      .if (1 = 2)
                          .else
       04:A250  AE DB 31  	ldx	_pad
       04:A253  62        	cla
                          .endif
 1137                     	__andwi	128
       04:A254  22        	sax
       04:A255  29 80     	and	#low(128)
       04:A257  22        	sax
       04:A258  29 00     	and	#high(128)
 1138                     	__tstw
                          	; pha
       04:A25A  86 02     	stx	<__temp
       04:A25C  05 02     	ora	<__temp
       04:A25E  62        	cla
       04:A25F  82        	clx
       04:A260  F0 01     	beq	.x_00990
       04:A262  E8        	inx
       04:A263            .x_00990:
                          	; pla
 1139                     	__lbeq	LL48
       04:A263  E0 00     	cpx	#0
       04:A265  D0 03     	bne	.x00991
       04:A267  4C 8F A2  	jmp	LL48
       04:A26A            .x00991
 1140                     ;         {
 1141                     ;            if (edit_pos > 0)
 1142                     	__ldub	_edit_pos
                0000      .if (1 = 2)
                          .else
       04:A26A  AE EC 31  	ldx	_edit_pos
       04:A26D  62        	cla
                          .endif
 1143                     	__stw	<__temp
       04:A26E  86 02     	stx	<__temp
       04:A270  85 03     	sta	<__temp+1
 1144                     	__ldwi	0
       04:A272  A2 00     	ldx	#low(0)
       04:A274  A9 00     	lda	#high(0)
 1145  04:A276  20 0A C9  	  jsr	gtzp
 1146                     	__lbeq	LL49
       04:A279  E0 00     	cpx	#0
       04:A27B  D0 03     	bne	.x00995
       04:A27D  4C 8F A2  	jmp	LL49
       04:A280            .x00995
 1147                     ;            {
 1148                     ;               edit_pos -= 1;
 1149                     	__ldub	_edit_pos
                0000      .if (1 = 2)
                          .else
       04:A280  AE EC 31  	ldx	_edit_pos
       04:A283  62        	cla
                          .endif
 1150                     	__subwi	1
                0001      .if (1 = 1)
       04:A284  E0 01     	cpx	#1
       04:A286  CA        	dex
       04:A287  E9 00     	sbc	#0
                          .else
                          .endif
 1151  04:A289  8E EC 31  	  stx	_edit_pos
 1152                     ;               put_index();
 1153  04:A28C  20 B1 AD  	  call	_put_index
 1154                     ;            }
 1155                     ;         }
 1156  04:A28F            LL49:
 1157                     
 1158                     ;         if (pad & JOY_RGHT)
 1159  04:A28F            LL48:
 1160                     
 1161                     	__ldub	_pad
                0000      .if (1 = 2)
                          .else
       04:A28F  AE DB 31  	ldx	_pad
       04:A292  62        	cla
                          .endif
 1162                     	__andwi	32
       04:A293  22        	sax
       04:A294  29 20     	and	#low(32)
       04:A296  22        	sax
       04:A297  29 00     	and	#high(32)
 1163                     	__tstw
                          	; pha
       04:A299  86 02     	stx	<__temp
       04:A29B  05 02     	ora	<__temp
       04:A29D  62        	cla
       04:A29E  82        	clx
       04:A29F  F0 01     	beq	.x_01000
       04:A2A1  E8        	inx
       04:A2A2            .x_01000:
                          	; pla
 1164                     	__lbeq	LL50
       04:A2A2  E0 00     	cpx	#0
       04:A2A4  D0 03     	bne	.x01001
       04:A2A6  4C C9 A2  	jmp	LL50
       04:A2A9            .x01001
 1165                     ;         {
 1166                     ;            if (edit_pos < 5)
 1167                     	__ldub	_edit_pos
                0000      .if (1 = 2)
                          .else
       04:A2A9  AE EC 31  	ldx	_edit_pos
       04:A2AC  62        	cla
                          .endif
 1168                     	__stw	<__temp
       04:A2AD  86 02     	stx	<__temp
       04:A2AF  85 03     	sta	<__temp+1
 1169                     	__ldwi	5
       04:A2B1  A2 05     	ldx	#low(5)
       04:A2B3  A9 00     	lda	#high(5)
 1170  04:A2B5  20 D6 C8  	  jsr	ltzp
 1171                     	__lbeq	LL51
       04:A2B8  E0 00     	cpx	#0
       04:A2BA  D0 03     	bne	.x01005
       04:A2BC  4C C9 A2  	jmp	LL51
       04:A2BF            .x01005
 1172                     ;            {
 1173                     ;               edit_pos += 1;
 1174  04:A2BF  EE EC 31  	inc	_edit_pos
 1175                     	__ldub	_edit_pos
                0000      .if (1 = 2)
                          .else
       04:A2C2  AE EC 31  	ldx	_edit_pos
       04:A2C5  62        	cla
                          .endif
 1176                     ;               put_index();
 1177  04:A2C6  20 B1 AD  	  call	_put_index
 1178                     ;            }
 1179                     ;         }
 1180  04:A2C9            LL51:
 1181                     
 1182                     ;         if (pad & JOY_UP)
 1183  04:A2C9            LL50:
 1184                     
 1185                     	__ldub	_pad
                0000      .if (1 = 2)
                          .else
       04:A2C9  AE DB 31  	ldx	_pad
       04:A2CC  62        	cla
                          .endif
 1186                     	__andwi	16
       04:A2CD  22        	sax
       04:A2CE  29 10     	and	#low(16)
       04:A2D0  22        	sax
       04:A2D1  29 00     	and	#high(16)
 1187                     	__tstw
                          	; pha
       04:A2D3  86 02     	stx	<__temp
       04:A2D5  05 02     	ora	<__temp
       04:A2D7  62        	cla
       04:A2D8  82        	clx
       04:A2D9  F0 01     	beq	.x_01009
       04:A2DB  E8        	inx
       04:A2DC            .x_01009:
                          	; pla
 1188                     	__lbeq	LL52
       04:A2DC  E0 00     	cpx	#0
       04:A2DE  D0 03     	bne	.x01010
       04:A2E0  4C C3 A3  	jmp	LL52
       04:A2E3            .x01010
 1189                     ;         {
 1190                     ;            if (adjust == ADJUST_START)
 1191                     	__ldub	_adjust
                0000      .if (1 = 2)
                          .else
       04:A2E3  AE EB 31  	ldx	_adjust
       04:A2E6  62        	cla
                          .endif
 1192                     	__cmpwi_eq	1
       04:A2E7  E0 01     	cpx	#low(1)
       04:A2E9  82        	clx
       04:A2EA  D0 06     	bne	.f01012
       04:A2EC  C9 00     	cmp	#high(1)
       04:A2EE  D0 02     	bne	.f01012
       04:A2F0  A2 01     	ldx	#1
       04:A2F2  62        .f01012:	cla
 1193                     	__lbeq	LL53
       04:A2F3  E0 00     	cpx	#0
       04:A2F5  D0 03     	bne	.x01013
       04:A2F7  4C 56 A3  	jmp	LL53
       04:A2FA            .x01013
 1194                     ;            {
 1195                     ;               add_3digit(&start_pos[0], &add_num[(edit_pos*3)]);
 1196                     	__ldwi	_start_pos
       04:A2FA  A2 DF     	ldx	#low(_start_pos)
       04:A2FC  A9 31     	lda	#high(_start_pos)
 1197                     	__pushw
                0001      .ifndef SMALL
       04:A2FE  A4 00     	ldy	<__stack
       04:A300  D0 02     	bne	.x_01015
       04:A302  C6 01     	dec	<__stack + 1
                          .endif
       04:A304  C6 00     .x_01015:	dec	<__stack
       04:A306  92 00     	sta	[__stack]
                0001      .ifndef SMALL
       04:A308  D0 02     	bne	.y_01015
       04:A30A  C6 01     	dec	<__stack + 1
                          .endif
       04:A30C  C6 00     .y_01015:	dec	<__stack
       04:A30E  22        	sax
       04:A30F  92 00     	sta	[__stack]
       04:A311  22        	sax
 1198                     	__ldub	_edit_pos
                0000      .if (1 = 2)
                          .else
       04:A312  AE EC 31  	ldx	_edit_pos
       04:A315  62        	cla
                          .endif
 1199                     	__mulwi	3
                0000      .if (3 = 2)
                          .else
                0001      .if (3 = 3)
                          	__stw	<__temp
       04:A316  86 02     	stx	<__temp
       04:A318  85 03     	sta	<__temp+1
                          	__aslw
       04:A31A  22        	sax
       04:A31B  0A        	asl	A
       04:A31C  22        	sax
       04:A31D  2A        	rol	A
                          	__addw	<__temp
       04:A31E  18        	clc
       04:A31F  22        	sax
       04:A320  65 02     	adc	<__temp
       04:A322  22        	sax
       04:A323  65 03     	adc	<__temp+1
                          .else
                          .endif
                          .endif
 1200                     	__addwi_sym	_add_num
       04:A325  18        	clc
       04:A326  22        	sax
       04:A327  69 0A     	adc	#low(_add_num)
       04:A329  22        	sax
       04:A32A  69 41     	adc	#high(_add_num)
 1201  04:A32C  20 D0 AB  	  call	_add_3digit
 1202                     ;               limit_startpos();  /* check if outside bounds */
 1203  04:A32F  20 E7 AE  	  call	_limit_startpos
 1204                     ;               start_pos[0] = result[0];
 1205                     	__ldub	_result
                0000      .if (1 = 2)
                          .else
       04:A332  AE E8 31  	ldx	_result
       04:A335  62        	cla
                          .endif
 1206  04:A336  8E DF 31  	  stx	_start_pos
 1207                     ;               start_pos[1] = result[1];
 1208                     	__ldub	_result+1
                0000      .if (1 = 2)
                          .else
       04:A339  AE E9 31  	ldx	_result+1
       04:A33C  62        	cla
                          .endif
 1209  04:A33D  8E E0 31  	  stx	_start_pos+1
 1210                     ;               start_pos[2] = result[2];
 1211                     	__ldub	_result+2
                0000      .if (1 = 2)
                          .else
       04:A340  AE EA 31  	ldx	_result+2
       04:A343  62        	cla
                          .endif
 1212  04:A344  8E E1 31  	  stx	_start_pos+2
 1213                     ;               show_startpos();
 1214  04:A347  20 B5 AF  	  call	_show_startpos
 1215                     ;               /* if startpos + offset is outside limits, adjust offset */
 1216                     ;               fix_offset();
 1217  04:A34A  20 B3 A9  	  call	_fix_offset
 1218                     ;               show_offset();
 1219  04:A34D  20 13 B0  	  call	_show_offset
 1220                     ;               show_target();
 1221  04:A350  20 71 B0  	  call	_show_target
 1222                     ;            }
 1223                     ;            else if (adjust == ADJUST_OFFSET)
 1224                     	__lbra	LL54
       04:A353  4C C3 A3  	jmp	LL54
 1225  04:A356            LL53:
 1226                     
 1227                     	__ldub	_adjust
                0000      .if (1 = 2)
                          .else
       04:A356  AE EB 31  	ldx	_adjust
       04:A359  62        	cla
                          .endif
 1228                     	__cmpwi_eq	2
       04:A35A  E0 02     	cpx	#low(2)
       04:A35C  82        	clx
       04:A35D  D0 06     	bne	.f01027
       04:A35F  C9 00     	cmp	#high(2)
       04:A361  D0 02     	bne	.f01027
       04:A363  A2 01     	ldx	#1
       04:A365  62        .f01027:	cla
 1229                     	__lbeq	LL55
       04:A366  E0 00     	cpx	#0
       04:A368  D0 03     	bne	.x01028
       04:A36A  4C C3 A3  	jmp	LL55
       04:A36D            .x01028
 1230                     ;            {
 1231                     ;               add_3digit(&offset[0], &add_num[(edit_pos*3)]);
 1232                     	__ldwi	_offset
       04:A36D  A2 E2     	ldx	#low(_offset)
       04:A36F  A9 31     	lda	#high(_offset)
 1233                     	__pushw
                0001      .ifndef SMALL
       04:A371  A4 00     	ldy	<__stack
       04:A373  D0 02     	bne	.x_01030
       04:A375  C6 01     	dec	<__stack + 1
                          .endif
       04:A377  C6 00     .x_01030:	dec	<__stack
       04:A379  92 00     	sta	[__stack]
                0001      .ifndef SMALL
       04:A37B  D0 02     	bne	.y_01030
       04:A37D  C6 01     	dec	<__stack + 1
                          .endif
       04:A37F  C6 00     .y_01030:	dec	<__stack
       04:A381  22        	sax
       04:A382  92 00     	sta	[__stack]
       04:A384  22        	sax
 1234                     	__ldub	_edit_pos
                0000      .if (1 = 2)
                          .else
       04:A385  AE EC 31  	ldx	_edit_pos
       04:A388  62        	cla
                          .endif
 1235                     	__mulwi	3
                0000      .if (3 = 2)
                          .else
                0001      .if (3 = 3)
                          	__stw	<__temp
       04:A389  86 02     	stx	<__temp
       04:A38B  85 03     	sta	<__temp+1
                          	__aslw
       04:A38D  22        	sax
       04:A38E  0A        	asl	A
       04:A38F  22        	sax
       04:A390  2A        	rol	A
                          	__addw	<__temp
       04:A391  18        	clc
       04:A392  22        	sax
       04:A393  65 02     	adc	<__temp
       04:A395  22        	sax
       04:A396  65 03     	adc	<__temp+1
                          .else
                          .endif
                          .endif
 1236                     	__addwi_sym	_add_num
       04:A398  18        	clc
       04:A399  22        	sax
       04:A39A  69 0A     	adc	#low(_add_num)
       04:A39C  22        	sax
       04:A39D  69 41     	adc	#high(_add_num)
 1237  04:A39F  20 D0 AB  	  call	_add_3digit
 1238                     ;               limit_offset();
 1239  04:A3A2  20 CF B0  	  call	_limit_offset
 1240                     ;               offset[0] = result[0];
 1241                     	__ldub	_result
                0000      .if (1 = 2)
                          .else
       04:A3A5  AE E8 31  	ldx	_result
       04:A3A8  62        	cla
                          .endif
 1242  04:A3A9  8E E2 31  	  stx	_offset
 1243                     ;               offset[1] = result[1];
 1244                     	__ldub	_result+1
                0000      .if (1 = 2)
                          .else
       04:A3AC  AE E9 31  	ldx	_result+1
       04:A3AF  62        	cla
                          .endif
 1245  04:A3B0  8E E3 31  	  stx	_offset+1
 1246                     ;               offset[2] = result[2];
 1247                     	__ldub	_result+2
                0000      .if (1 = 2)
                          .else
       04:A3B3  AE EA 31  	ldx	_result+2
       04:A3B6  62        	cla
                          .endif
 1248  04:A3B7  8E E4 31  	  stx	_offset+2
 1249                     ;               /* if startpos + offset is outside limits, adjust offset */
 1250                     ;               fix_offset();
 1251  04:A3BA  20 B3 A9  	  call	_fix_offset
 1252                     ;               show_offset();
 1253  04:A3BD  20 13 B0  	  call	_show_offset
 1254                     ;               show_target();
 1255  04:A3C0  20 71 B0  	  call	_show_target
 1256                     ;            }
 1257                     ;         }
 1258  04:A3C3            LL55:
 1259                     
 1260  04:A3C3            LL54:
 1261                     
 1262                     ;         if (pad & JOY_DOWN)
 1263  04:A3C3            LL52:
 1264                     
 1265                     	__ldub	_pad
                0000      .if (1 = 2)
                          .else
       04:A3C3  AE DB 31  	ldx	_pad
       04:A3C6  62        	cla
                          .endif
 1266                     	__andwi	64
       04:A3C7  22        	sax
       04:A3C8  29 40     	and	#low(64)
       04:A3CA  22        	sax
       04:A3CB  29 00     	and	#high(64)
 1267                     	__tstw
                          	; pha
       04:A3CD  86 02     	stx	<__temp
       04:A3CF  05 02     	ora	<__temp
       04:A3D1  62        	cla
       04:A3D2  82        	clx
       04:A3D3  F0 01     	beq	.x_01042
       04:A3D5  E8        	inx
       04:A3D6            .x_01042:
                          	; pla
 1268                     	__lbeq	LL56
       04:A3D6  E0 00     	cpx	#0
       04:A3D8  D0 03     	bne	.x01043
       04:A3DA  4C BD A4  	jmp	LL56
       04:A3DD            .x01043
 1269                     ;         {
 1270                     ;            if (adjust == ADJUST_START)
 1271                     	__ldub	_adjust
                0000      .if (1 = 2)
                          .else
       04:A3DD  AE EB 31  	ldx	_adjust
       04:A3E0  62        	cla
                          .endif
 1272                     	__cmpwi_eq	1
       04:A3E1  E0 01     	cpx	#low(1)
       04:A3E3  82        	clx
       04:A3E4  D0 06     	bne	.f01045
       04:A3E6  C9 00     	cmp	#high(1)
       04:A3E8  D0 02     	bne	.f01045
       04:A3EA  A2 01     	ldx	#1
       04:A3EC  62        .f01045:	cla
 1273                     	__lbeq	LL57
       04:A3ED  E0 00     	cpx	#0
       04:A3EF  D0 03     	bne	.x01046
       04:A3F1  4C 50 A4  	jmp	LL57
       04:A3F4            .x01046
 1274                     ;            {
 1275                     ;               sub_3digit(&start_pos[0], &add_num[(edit_pos*3)]);
 1276                     	__ldwi	_start_pos
       04:A3F4  A2 DF     	ldx	#low(_start_pos)
       04:A3F6  A9 31     	lda	#high(_start_pos)
 1277                     	__pushw
                0001      .ifndef SMALL
       04:A3F8  A4 00     	ldy	<__stack
       04:A3FA  D0 02     	bne	.x_01048
       04:A3FC  C6 01     	dec	<__stack + 1
                          .endif
       04:A3FE  C6 00     .x_01048:	dec	<__stack
       04:A400  92 00     	sta	[__stack]
                0001      .ifndef SMALL
       04:A402  D0 02     	bne	.y_01048
       04:A404  C6 01     	dec	<__stack + 1
                          .endif
       04:A406  C6 00     .y_01048:	dec	<__stack
       04:A408  22        	sax
       04:A409  92 00     	sta	[__stack]
       04:A40B  22        	sax
 1278                     	__ldub	_edit_pos
                0000      .if (1 = 2)
                          .else
       04:A40C  AE EC 31  	ldx	_edit_pos
       04:A40F  62        	cla
                          .endif
 1279                     	__mulwi	3
                0000      .if (3 = 2)
                          .else
                0001      .if (3 = 3)
                          	__stw	<__temp
       04:A410  86 02     	stx	<__temp
       04:A412  85 03     	sta	<__temp+1
                          	__aslw
       04:A414  22        	sax
       04:A415  0A        	asl	A
       04:A416  22        	sax
       04:A417  2A        	rol	A
                          	__addw	<__temp
       04:A418  18        	clc
       04:A419  22        	sax
       04:A41A  65 02     	adc	<__temp
       04:A41C  22        	sax
       04:A41D  65 03     	adc	<__temp+1
                          .else
                          .endif
                          .endif
 1280                     	__addwi_sym	_add_num
       04:A41F  18        	clc
       04:A420  22        	sax
       04:A421  69 0A     	adc	#low(_add_num)
       04:A423  22        	sax
       04:A424  69 41     	adc	#high(_add_num)
 1281  04:A426  20 DB A6  	  call	_sub_3digit
 1282                     ;               limit_startpos();  /* check if outside bounds */
 1283  04:A429  20 E7 AE  	  call	_limit_startpos
 1284                     ;               start_pos[0] = result[0];
 1285                     	__ldub	_result
                0000      .if (1 = 2)
                          .else
       04:A42C  AE E8 31  	ldx	_result
       04:A42F  62        	cla
                          .endif
 1286  04:A430  8E DF 31  	  stx	_start_pos
 1287                     ;               start_pos[1] = result[1];
 1288                     	__ldub	_result+1
                0000      .if (1 = 2)
                          .else
       04:A433  AE E9 31  	ldx	_result+1
       04:A436  62        	cla
                          .endif
 1289  04:A437  8E E0 31  	  stx	_start_pos+1
 1290                     ;               start_pos[2] = result[2];
 1291                     	__ldub	_result+2
                0000      .if (1 = 2)
                          .else
       04:A43A  AE EA 31  	ldx	_result+2
       04:A43D  62        	cla
                          .endif
 1292  04:A43E  8E E1 31  	  stx	_start_pos+2
 1293                     ;               show_startpos();
 1294  04:A441  20 B5 AF  	  call	_show_startpos
 1295                     ;               /* if startpos + offset is outside limits, adjust offset */
 1296                     ;               fix_offset();
 1297  04:A444  20 B3 A9  	  call	_fix_offset
 1298                     ;               show_offset();
 1299  04:A447  20 13 B0  	  call	_show_offset
 1300                     ;               show_target();
 1301  04:A44A  20 71 B0  	  call	_show_target
 1302                     ;            }
 1303                     ;            else if (adjust == ADJUST_OFFSET)
 1304                     	__lbra	LL58
       04:A44D  4C BD A4  	jmp	LL58
 1305  04:A450            LL57:
 1306                     
 1307                     	__ldub	_adjust
                0000      .if (1 = 2)
                          .else
       04:A450  AE EB 31  	ldx	_adjust
       04:A453  62        	cla
                          .endif
 1308                     	__cmpwi_eq	2
       04:A454  E0 02     	cpx	#low(2)
       04:A456  82        	clx
       04:A457  D0 06     	bne	.f01060
       04:A459  C9 00     	cmp	#high(2)
       04:A45B  D0 02     	bne	.f01060
       04:A45D  A2 01     	ldx	#1
       04:A45F  62        .f01060:	cla
 1309                     	__lbeq	LL59
       04:A460  E0 00     	cpx	#0
       04:A462  D0 03     	bne	.x01061
       04:A464  4C BD A4  	jmp	LL59
       04:A467            .x01061
 1310                     ;            {
 1311                     ;               sub_3digit(&offset[0], &add_num[(edit_pos*3)]);
 1312                     	__ldwi	_offset
       04:A467  A2 E2     	ldx	#low(_offset)
       04:A469  A9 31     	lda	#high(_offset)
 1313                     	__pushw
                0001      .ifndef SMALL
       04:A46B  A4 00     	ldy	<__stack
       04:A46D  D0 02     	bne	.x_01063
       04:A46F  C6 01     	dec	<__stack + 1
                          .endif
       04:A471  C6 00     .x_01063:	dec	<__stack
       04:A473  92 00     	sta	[__stack]
                0001      .ifndef SMALL
       04:A475  D0 02     	bne	.y_01063
       04:A477  C6 01     	dec	<__stack + 1
                          .endif
       04:A479  C6 00     .y_01063:	dec	<__stack
       04:A47B  22        	sax
       04:A47C  92 00     	sta	[__stack]
       04:A47E  22        	sax
 1314                     	__ldub	_edit_pos
                0000      .if (1 = 2)
                          .else
       04:A47F  AE EC 31  	ldx	_edit_pos
       04:A482  62        	cla
                          .endif
 1315                     	__mulwi	3
                0000      .if (3 = 2)
                          .else
                0001      .if (3 = 3)
                          	__stw	<__temp
       04:A483  86 02     	stx	<__temp
       04:A485  85 03     	sta	<__temp+1
                          	__aslw
       04:A487  22        	sax
       04:A488  0A        	asl	A
       04:A489  22        	sax
       04:A48A  2A        	rol	A
                          	__addw	<__temp
       04:A48B  18        	clc
       04:A48C  22        	sax
       04:A48D  65 02     	adc	<__temp
       04:A48F  22        	sax
       04:A490  65 03     	adc	<__temp+1
                          .else
                          .endif
                          .endif
 1316                     	__addwi_sym	_add_num
       04:A492  18        	clc
       04:A493  22        	sax
       04:A494  69 0A     	adc	#low(_add_num)
       04:A496  22        	sax
       04:A497  69 41     	adc	#high(_add_num)
 1317  04:A499  20 DB A6  	  call	_sub_3digit
 1318                     ;               limit_offset();
 1319  04:A49C  20 CF B0  	  call	_limit_offset
 1320                     ;               offset[0] = result[0];
 1321                     	__ldub	_result
                0000      .if (1 = 2)
                          .else
       04:A49F  AE E8 31  	ldx	_result
       04:A4A2  62        	cla
                          .endif
 1322  04:A4A3  8E E2 31  	  stx	_offset
 1323                     ;               offset[1] = result[1];
 1324                     	__ldub	_result+1
                0000      .if (1 = 2)
                          .else
       04:A4A6  AE E9 31  	ldx	_result+1
       04:A4A9  62        	cla
                          .endif
 1325  04:A4AA  8E E3 31  	  stx	_offset+1
 1326                     ;               offset[2] = result[2];
 1327                     	__ldub	_result+2
                0000      .if (1 = 2)
                          .else
       04:A4AD  AE EA 31  	ldx	_result+2
       04:A4B0  62        	cla
                          .endif
 1328  04:A4B1  8E E4 31  	  stx	_offset+2
 1329                     ;               /* if startpos + offset is outside limits, adjust offset */
 1330                     ;               fix_offset();
 1331  04:A4B4  20 B3 A9  	  call	_fix_offset
 1332                     ;               show_offset();
 1333  04:A4B7  20 13 B0  	  call	_show_offset
 1334                     ;               show_target();
 1335  04:A4BA  20 71 B0  	  call	_show_target
 1336                     ;            }
 1337                     ;         }
 1338  04:A4BD            LL59:
 1339                     
 1340  04:A4BD            LL58:
 1341                     
 1342                     ;         if (pad & JOY_B)  /* this is button II */
 1343  04:A4BD            LL56:
 1344                     
 1345                     	__ldub	_pad
                0000      .if (1 = 2)
                          .else
       04:A4BD  AE DB 31  	ldx	_pad
       04:A4C0  62        	cla
                          .endif
 1346                     	__andwi	2
       04:A4C1  22        	sax
       04:A4C2  29 02     	and	#low(2)
       04:A4C4  22        	sax
       04:A4C5  29 00     	and	#high(2)
 1347                     	__tstw
                          	; pha
       04:A4C7  86 02     	stx	<__temp
       04:A4C9  05 02     	ora	<__temp
       04:A4CB  62        	cla
       04:A4CC  82        	clx
       04:A4CD  F0 01     	beq	.x_01075
       04:A4CF  E8        	inx
       04:A4D0            .x_01075:
                          	; pla
 1348                     	__lbeq	LL60
       04:A4D0  E0 00     	cpx	#0
       04:A4D2  D0 03     	bne	.x01076
       04:A4D4  4C 68 A6  	jmp	LL60
       04:A4D7            .x01076
 1349                     ;         {
 1350                     ;            if (adjust == ADJUST_START)
 1351                     	__ldub	_adjust
                0000      .if (1 = 2)
                          .else
       04:A4D7  AE EB 31  	ldx	_adjust
       04:A4DA  62        	cla
                          .endif
 1352                     	__cmpwi_eq	1
       04:A4DB  E0 01     	cpx	#low(1)
       04:A4DD  82        	clx
       04:A4DE  D0 06     	bne	.f01078
       04:A4E0  C9 00     	cmp	#high(1)
       04:A4E2  D0 02     	bne	.f01078
       04:A4E4  A2 01     	ldx	#1
       04:A4E6  62        .f01078:	cla
 1353                     	__lbeq	LL61
       04:A4E7  E0 00     	cpx	#0
       04:A4E9  D0 03     	bne	.x01079
       04:A4EB  4C FE A4  	jmp	LL61
       04:A4EE            .x01079
 1354                     ;            {
 1355                     ;               adjust = ADJUST_OFFSET;
 1356                     	__ldwi	2
       04:A4EE  A2 02     	ldx	#low(2)
       04:A4F0  A9 00     	lda	#high(2)
 1357  04:A4F2  8E EB 31  	  stx	_adjust
 1358                     ;               clear_index();
 1359  04:A4F5  20 54 AF  	  call	_clear_index
 1360                     ;               put_index();
 1361  04:A4F8  20 B1 AD  	  call	_put_index
 1362                     ;            }
 1363                     ;            else if (adjust == ADJUST_OFFSET)
 1364                     	__lbra	LL62
       04:A4FB  4C 68 A6  	jmp	LL62
 1365  04:A4FE            LL61:
 1366                     
 1367                     	__ldub	_adjust
                0000      .if (1 = 2)
                          .else
       04:A4FE  AE EB 31  	ldx	_adjust
       04:A501  62        	cla
                          .endif
 1368                     	__cmpwi_eq	2
       04:A502  E0 02     	cpx	#low(2)
       04:A504  82        	clx
       04:A505  D0 06     	bne	.f01083
       04:A507  C9 00     	cmp	#high(2)
       04:A509  D0 02     	bne	.f01083
       04:A50B  A2 01     	ldx	#1
       04:A50D  62        .f01083:	cla
 1369                     	__lbeq	LL63
       04:A50E  E0 00     	cpx	#0
       04:A510  D0 03     	bne	.x01084
       04:A512  4C 68 A6  	jmp	LL63
       04:A515            .x01084
 1370                     ;            {
 1371                     ;               clear_index();
 1372  04:A515  20 54 AF  	  call	_clear_index
 1373                     ;               adjust = ADJUST_OFFSET;
 1374                     	__ldwi	2
       04:A518  A2 02     	ldx	#low(2)
       04:A51A  A9 00     	lda	#high(2)
 1375  04:A51C  8E EB 31  	  stx	_adjust
 1376                     ;               for (i = 0; i < 10; i++)
 1377                     	__ldwi	0
       04:A51F  A2 00     	ldx	#low(0)
       04:A521  A9 00     	lda	#high(0)
 1378  04:A523  8E 08 32  	  stx	_i
 1379  04:A526            LL64:
 1380                     
 1381                     	__ldub	_i
                0000      .if (1 = 2)
                          .else
       04:A526  AE 08 32  	ldx	_i
       04:A529  62        	cla
                          .endif
 1382                     	__stw	<__temp
       04:A52A  86 02     	stx	<__temp
       04:A52C  85 03     	sta	<__temp+1
 1383                     	__ldwi	10
       04:A52E  A2 0A     	ldx	#low(10)
       04:A530  A9 00     	lda	#high(10)
 1384  04:A532  20 D6 C8  	  jsr	ltzp
 1385                     	__lbnen	LL66
       04:A535  E0 00     	cpx	#0
       04:A537  D0 0D     	bne	LL66
 1386                     	__lbra	LL67
       04:A539  4C 69 A5  	jmp	LL67
 1387  04:A53C            LL65:
 1388                     
 1389                     	__ldub	_i
                0000      .if (1 = 2)
                          .else
       04:A53C  AE 08 32  	ldx	_i
       04:A53F  62        	cla
                          .endif
 1390  04:A540  EE 08 32  	inc	_i
 1391                     	__lbra	LL64
       04:A543  4C 26 A5  	jmp	LL64
 1392  04:A546            LL66:
 1393                     
 1394                     ;               {
 1395                     ;                  put_string("     ", 5, READING_LINE+i);
 1396                     	__ldwi	LL0+188
       04:A546  A2 BC     	ldx	#low(LL0+188)
       04:A548  A9 40     	lda	#high(LL0+188)
 1397                     	__stw	__si
       04:A54A  8E EE 20  	stx	__si
       04:A54D  8D EF 20  	sta	__si+1
 1398                     	__ldwi	5
       04:A550  A2 05     	ldx	#low(5)
       04:A552  A9 00     	lda	#high(5)
 1399  04:A554  8E FA 20  	  stx	__bl
 1400                     	__ldwi	13
       04:A557  A2 0D     	ldx	#low(13)
       04:A559  A9 00     	lda	#high(13)
 1401                     	__addub	_i
       04:A55B  18        	clc
       04:A55C  22        	sax
       04:A55D  6D 08 32  	adc	_i
       04:A560  22        	sax
       04:A561  69 00     	adc	#0
 1402  04:A563  20 57 CF  	  call	_put_string.3
 1403                     ;               }
 1404                     	__lbra	LL65
       04:A566  4C 3C A5  	jmp	LL65
 1405  04:A569            LL67:
 1406                     
 1407                     ;               put_string("          ", 18, MIN_LINE);
 1408                     	__ldwi	LL0+194
       04:A569  A2 C2     	ldx	#low(LL0+194)
       04:A56B  A9 40     	lda	#high(LL0+194)
 1409                     	__stw	__si
       04:A56D  8E EE 20  	stx	__si
       04:A570  8D EF 20  	sta	__si+1
 1410                     	__ldwi	18
       04:A573  A2 12     	ldx	#low(18)
       04:A575  A9 00     	lda	#high(18)
 1411  04:A577  8E FA 20  	  stx	__bl
 1412                     	__ldwi	14
       04:A57A  A2 0E     	ldx	#low(14)
       04:A57C  A9 00     	lda	#high(14)
 1413  04:A57E  20 57 CF  	  call	_put_string.3
 1414                     ;               put_string("          ", 18, AVG_LINE);
 1415                     	__ldwi	LL0+205
       04:A581  A2 CD     	ldx	#low(LL0+205)
       04:A583  A9 40     	lda	#high(LL0+205)
 1416                     	__stw	__si
       04:A585  8E EE 20  	stx	__si
       04:A588  8D EF 20  	sta	__si+1
 1417                     	__ldwi	18
       04:A58B  A2 12     	ldx	#low(18)
       04:A58D  A9 00     	lda	#high(18)
 1418  04:A58F  8E FA 20  	  stx	__bl
 1419                     	__ldwi	15
       04:A592  A2 0F     	ldx	#low(15)
       04:A594  A9 00     	lda	#high(15)
 1420  04:A596  20 57 CF  	  call	_put_string.3
 1421                     ;               /* run test */
 1422                     ;               min = 32767;
 1423                     	__ldwi	32767
       04:A599  A2 FF     	ldx	#low(32767)
       04:A59B  A9 7F     	lda	#high(32767)
 1424                     	__stw	_min
       04:A59D  8E 02 32  	stx	_min
       04:A5A0  8D 03 32  	sta	_min+1
 1425                     ;               tot = 0;
 1426                     	__ldwi	0
       04:A5A3  A2 00     	ldx	#low(0)
       04:A5A5  A9 00     	lda	#high(0)
 1427                     	__stw	_tot
       04:A5A7  8E 06 32  	stx	_tot
       04:A5AA  8D 07 32  	sta	_tot+1
 1428                     ;            
 1429                     ;/*               for (i = 0; i < 10; i++)
 1430                     ;               {
 1431                     ;                  put_string("Move to initial position", 2, STAT_LINE);
 1432                     ;*/
 1433                     ;                  /*initial head position seek */
 1434                     ;/*
 1435                     ;                  rec_h = start_pos[0];
 1436                     ;                  rec_m = start_pos[1];
 1437                     ;                  rec_l = start_pos[2];
 1438                     ;                  cd_read_sector();
 1439                     ;                  put_string("Random delay            ", 2, STAT_LINE);
 1440                     ;                  vsync(random(55)+5);               
 1441                     ;*/
 1442                     ;                  put_string("Seeking...              ", 2, STAT_LINE);
 1443                     	__ldwi	LL0+216
       04:A5AD  A2 D8     	ldx	#low(LL0+216)
       04:A5AF  A9 40     	lda	#high(LL0+216)
 1444                     	__stw	__si
       04:A5B1  8E EE 20  	stx	__si
       04:A5B4  8D EF 20  	sta	__si+1
 1445                     	__ldwi	2
       04:A5B7  A2 02     	ldx	#low(2)
       04:A5B9  A9 00     	lda	#high(2)
 1446  04:A5BB  8E FA 20  	  stx	__bl
 1447                     	__ldwi	11
       04:A5BE  A2 0B     	ldx	#low(11)
       04:A5C0  A9 00     	lda	#high(11)
 1448  04:A5C2  20 57 CF  	  call	_put_string.3
 1449                     ;                  rec_h = target[0];
 1450                     	__ldub	_target
                0000      .if (1 = 2)
                          .else
       04:A5C5  AE E5 31  	ldx	_target
       04:A5C8  62        	cla
                          .endif
 1451  04:A5C9  8E D8 29  	  stx	_rec_h
 1452                     ;                  rec_m = target[1];
 1453                     	__ldub	_target+1
                0000      .if (1 = 2)
                          .else
       04:A5CC  AE E6 31  	ldx	_target+1
       04:A5CF  62        	cla
                          .endif
 1454  04:A5D0  8E D9 29  	  stx	_rec_m
 1455                     ;                  rec_l = target[2];
 1456                     	__ldub	_target+2
                0000      .if (1 = 2)
                          .else
       04:A5D3  AE E7 31  	ldx	_target+2
       04:A5D6  62        	cla
                          .endif
 1457  04:A5D7  8E DA 29  	  stx	_rec_l
 1458                     ;/*
 1459                     ;                  vsync(0);
 1460                     ;                  clock_reset();
 1461                     ;*/
 1462                     ;                  /* Seek */
 1463                     ;                  beepsetup();
 1464  04:A5DA  20 14 DE  	  call	_beepsetup
 1465                     ;                  beepon();
 1466  04:A5DD  20 50 DE  	  call	_beepon
 1467                     ;                  beeplow();
 1468  04:A5E0  20 56 DE  	  call	_beeplow
 1469                     ;                  cd_read_sector();
 1470  04:A5E3  20 6C DE  	  call	_cd_read_sector
 1471                     ;                  beephigh();
 1472  04:A5E6  20 61 DE  	  call	_beephigh
 1473                     ;		  for (i = 0; i < 60; i++) {
 1474                     	__ldwi	0
       04:A5E9  A2 00     	ldx	#low(0)
       04:A5EB  A9 00     	lda	#high(0)
 1475  04:A5ED  8E 08 32  	  stx	_i
 1476  04:A5F0            LL68:
 1477                     
 1478                     	__ldub	_i
                0000      .if (1 = 2)
                          .else
       04:A5F0  AE 08 32  	ldx	_i
       04:A5F3  62        	cla
                          .endif
 1479                     	__stw	<__temp
       04:A5F4  86 02     	stx	<__temp
       04:A5F6  85 03     	sta	<__temp+1
 1480                     	__ldwi	60
       04:A5F8  A2 3C     	ldx	#low(60)
       04:A5FA  A9 00     	lda	#high(60)
 1481  04:A5FC  20 D6 C8  	  jsr	ltzp
 1482                     	__lbnen	LL70
       04:A5FF  E0 00     	cpx	#0
       04:A601  D0 0D     	bne	LL70
 1483                     	__lbra	LL71
       04:A603  4C 1A A6  	jmp	LL71
 1484  04:A606            LL69:
 1485                     
 1486                     	__ldub	_i
                0000      .if (1 = 2)
                          .else
       04:A606  AE 08 32  	ldx	_i
       04:A609  62        	cla
                          .endif
 1487  04:A60A  EE 08 32  	inc	_i
 1488                     	__lbra	LL68
       04:A60D  4C F0 A5  	jmp	LL68
 1489  04:A610            LL70:
 1490                     
 1491                     ;                     vsync(0);
 1492                     	__ldwi	0
       04:A610  A2 00     	ldx	#low(0)
       04:A612  A9 00     	lda	#high(0)
 1493  04:A614  20 89 CF  	  call	_vsync.1
 1494                     ;		  }
 1495                     	__lbra	LL69
       04:A617  4C 06 A6  	jmp	LL69
 1496  04:A61A            LL71:
 1497                     
 1498                     ;                  beepoff();
 1499  04:A61A  20 4A DE  	  call	_beepoff
 1500                     ;                  cd_stop();
 1501  04:A61D  20 83 DE  	  call	_cd_stop
 1502                     ;		  /* cd_stop_play(); */  /* call cd_pause and stop tone */
 1503                     ;		  start_pos[0] = target[0];
 1504                     	__ldub	_target
                0000      .if (1 = 2)
                          .else
       04:A620  AE E5 31  	ldx	_target
       04:A623  62        	cla
                          .endif
 1505  04:A624  8E DF 31  	  stx	_start_pos
 1506                     ;		  start_pos[1] = target[1];
 1507                     	__ldub	_target+1
                0000      .if (1 = 2)
                          .else
       04:A627  AE E6 31  	ldx	_target+1
       04:A62A  62        	cla
                          .endif
 1508  04:A62B  8E E0 31  	  stx	_start_pos+1
 1509                     ;		  start_pos[2] = target[2];
 1510                     	__ldub	_target+2
                0000      .if (1 = 2)
                          .else
       04:A62E  AE E7 31  	ldx	_target+2
       04:A631  62        	cla
                          .endif
 1511  04:A632  8E E1 31  	  stx	_start_pos+2
 1512                     ;		  offset[0] = 0;
 1513                     	__stbi	_offset, 0
       04:A635  A2 00     	ldx	#low(0)
       04:A637  8E E2 31  	stx	_offset
       04:A63A  62        	cla
 1514                     ;		  offset[1] = 0;
 1515                     	__stbi	_offset+1, 0
       04:A63B  A2 00     	ldx	#low(0)
       04:A63D  8E E3 31  	stx	_offset+1
       04:A640  62        	cla
 1516                     ;		  offset[2] = 0;
 1517                     	__stbi	_offset+2, 0
       04:A641  A2 00     	ldx	#low(0)
       04:A643  8E E4 31  	stx	_offset+2
       04:A646  62        	cla
 1518                     ;		  show_startpos();
 1519  04:A647  20 B5 AF  	  call	_show_startpos
 1520                     ;		  show_offset();
 1521  04:A64A  20 13 B0  	  call	_show_offset
 1522                     ;		  show_target();
 1523  04:A64D  20 71 B0  	  call	_show_target
 1524                     ;/*
 1525                     ;                  timing[i] = (clock_mm() * 3600) + (clock_ss() * 60) + clock_tt();
 1526                     ;                  if (timing[i] < min)
 1527                     ;                  {
 1528                     ;                     min = timing[i];
 1529                     ;                  }
 1530                     ;                  tot = tot + timing[i];
 1531                     ;                  put_number(timing[i], 5, 5, READING_LINE+i);
 1532                     ;*/
 1533                     ;		  /* re-establish starting point */
 1534                     ;/*               } */
 1535                     ;/*
 1536                     ;               avg = tot / 10;
 1537                     ;*/
 1538                     ;               put_string("                        ", 2, STAT_LINE);
 1539                     	__ldwi	LL0+241
       04:A650  A2 F1     	ldx	#low(LL0+241)
       04:A652  A9 40     	lda	#high(LL0+241)
 1540                     	__stw	__si
       04:A654  8E EE 20  	stx	__si
       04:A657  8D EF 20  	sta	__si+1
 1541                     	__ldwi	2
       04:A65A  A2 02     	ldx	#low(2)
       04:A65C  A9 00     	lda	#high(2)
 1542  04:A65E  8E FA 20  	  stx	__bl
 1543                     	__ldwi	11
       04:A661  A2 0B     	ldx	#low(11)
       04:A663  A9 00     	lda	#high(11)
 1544  04:A665  20 57 CF  	  call	_put_string.3
 1545                     ;/*
 1546                     ;               put_string("Min: ", 18, MIN_LINE);
 1547                     ;               put_number(min, 5, 23, MIN_LINE);
 1548                     ;               put_string("Avg: ", 18, AVG_LINE);
 1549                     ;               put_number(avg, 5, 23, AVG_LINE);
 1550                     ;*/
 1551                     ;            }
 1552                     ;         }
 1553  04:A668            LL63:
 1554                     
 1555  04:A668            LL62:
 1556                     
 1557                     ;         if (pad & JOY_A)
 1558  04:A668            LL60:
 1559                     
 1560                     	__ldub	_pad
                0000      .if (1 = 2)
                          .else
       04:A668  AE DB 31  	ldx	_pad
       04:A66B  62        	cla
                          .endif
 1561                     	__andwi	1
       04:A66C  22        	sax
       04:A66D  29 01     	and	#low(1)
       04:A66F  22        	sax
       04:A670  29 00     	and	#high(1)
 1562                     	__tstw
                          	; pha
       04:A672  86 02     	stx	<__temp
       04:A674  05 02     	ora	<__temp
       04:A676  62        	cla
       04:A677  82        	clx
       04:A678  F0 01     	beq	.x_01141
       04:A67A  E8        	inx
       04:A67B            .x_01141:
                          	; pla
 1563                     	__lbeq	LL72
       04:A67B  E0 00     	cpx	#0
       04:A67D  D0 03     	bne	.x01142
       04:A67F  4C CD A6  	jmp	LL72
       04:A682            .x01142
 1564                     ;         {
 1565                     ;            if (adjust == ADJUST_OFFSET)
 1566                     	__ldub	_adjust
                0000      .if (1 = 2)
                          .else
       04:A682  AE EB 31  	ldx	_adjust
       04:A685  62        	cla
                          .endif
 1567                     	__cmpwi_eq	2
       04:A686  E0 02     	cpx	#low(2)
       04:A688  82        	clx
       04:A689  D0 06     	bne	.f01144
       04:A68B  C9 00     	cmp	#high(2)
       04:A68D  D0 02     	bne	.f01144
       04:A68F  A2 01     	ldx	#1
       04:A691  62        .f01144:	cla
 1568                     	__lbeq	LL73
       04:A692  E0 00     	cpx	#0
       04:A694  D0 03     	bne	.x01145
       04:A696  4C A9 A6  	jmp	LL73
       04:A699            .x01145
 1569                     ;            {
 1570                     ;               adjust = ADJUST_START;
 1571                     	__ldwi	1
       04:A699  A2 01     	ldx	#low(1)
       04:A69B  A9 00     	lda	#high(1)
 1572  04:A69D  8E EB 31  	  stx	_adjust
 1573                     ;               clear_index();
 1574  04:A6A0  20 54 AF  	  call	_clear_index
 1575                     ;               put_index();
 1576  04:A6A3  20 B1 AD  	  call	_put_index
 1577                     ;            }
 1578                     ;            else if (adjust == ADJUST_START)
 1579                     	__lbra	LL74
       04:A6A6  4C CD A6  	jmp	LL74
 1580  04:A6A9            LL73:
 1581                     
 1582                     	__ldub	_adjust
                0000      .if (1 = 2)
                          .else
       04:A6A9  AE EB 31  	ldx	_adjust
       04:A6AC  62        	cla
                          .endif
 1583                     	__cmpwi_eq	1
       04:A6AD  E0 01     	cpx	#low(1)
       04:A6AF  82        	clx
       04:A6B0  D0 06     	bne	.f01149
       04:A6B2  C9 00     	cmp	#high(1)
       04:A6B4  D0 02     	bne	.f01149
       04:A6B6  A2 01     	ldx	#1
       04:A6B8  62        .f01149:	cla
 1584                     	__lbeq	LL75
       04:A6B9  E0 00     	cpx	#0
       04:A6BB  D0 03     	bne	.x01150
       04:A6BD  4C CD A6  	jmp	LL75
       04:A6C0            .x01150
 1585                     ;            {
 1586                     ;               adjust = ADJUST_DIRECTION;
 1587                     	__ldwi	0
       04:A6C0  A2 00     	ldx	#low(0)
       04:A6C2  A9 00     	lda	#high(0)
 1588  04:A6C4  8E EB 31  	  stx	_adjust
 1589                     ;               clear_index();
 1590  04:A6C7  20 54 AF  	  call	_clear_index
 1591                     ;               put_index();
 1592  04:A6CA  20 B1 AD  	  call	_put_index
 1593                     ;            }
 1594                     ;         }
 1595  04:A6CD            LL75:
 1596                     
 1597  04:A6CD            LL74:
 1598                     
 1599                     ;      }
 1600  04:A6CD            LL72:
 1601                     
 1602                     ;      vsync(0);
 1603  04:A6CD            LL46:
 1604                     
 1605  04:A6CD            LL45:
 1606                     
 1607                     	__ldwi	0
       04:A6CD  A2 00     	ldx	#low(0)
       04:A6CF  A9 00     	lda	#high(0)
 1608  04:A6D1  20 89 CF  	  call	_vsync.1
 1609                     ;   }
 1610                     	__lbra	LL38
       04:A6D4  4C 60 A1  	jmp	LL38
 1611  04:A6D7            LL39:
 1612                     
 1613                     ;   return;
 1614                     	__lbra	LL33
       04:A6D7  4C DA A6  	jmp	LL33
 1615                     ;}
 1616  04:A6DA            LL33:
 1617                     
 1618  04:A6DA  60        	  rts
 1619                     	.endp
 1620                     
 1621           60C8      	.data
 1622           0002      	.bank CONST_BANK
 1623  02:4000            LL0:
 1624  02:4000  20 20 20  	.db	32,32,32,32,32,32,0,32
       02:4003  20 20 20  
       02:4006  00 20     
 1625  02:4008  20 20 20  	.db	32,32,32,32,32,0,32,32
       02:400B  20 20 00  
       02:400E  20 20     
 1626  02:4010  20 00 20  	.db	32,0,32,32,32,0,70,79
       02:4013  20 20 00  
       02:4016  46 4F     
 1627  02:4018  52 57 41  	.db	82,87,65,82,68,32,0,66
       02:401B  52 44 20  
       02:401E  00 42     
 1628  02:4020  41 43 4B  	.db	65,67,75,87,65,82,68,0
       02:4023  57 41 52  
       02:4026  44 00     
 1629  02:4028  3E 3E 3E  	.db	62,62,62,0,60,60,60,0
       02:402B  00 3C 3C  
       02:402E  3C 00     
 1630  02:4030  20 20 20  	.db	32,32,32,32,32,32,0,94
       02:4033  20 20 20  
       02:4036  00 5E     
 1631  02:4038  00 20 20  	.db	0,32,32,32,32,32,32,0
       02:403B  20 20 20  
       02:403E  20 00     
 1632  02:4040  5E 00 48  	.db	94,0,72,101,97,100,32,83
       02:4043  65 61 64  
       02:4046  20 53     
 1633  02:4048  65 65 6B  	.db	101,101,107,32,84,101,115,116
       02:404B  20 54 65  
       02:404E  73 74     
 1634  02:4050  00 20 20  	.db	0,32,32,32,32,32,32,32
       02:4053  20 20 20  
       02:4056  20 20     
 1635  02:4058  44 69 72  	.db	68,105,114,58,32,0,83,116
       02:405B  3A 20 00  
       02:405E  53 74     
 1636  02:4060  61 72 74  	.db	97,114,116,32,32,76,66,65
       02:4063  20 20 4C  
       02:4066  42 41     
 1637  02:4068  3A 20 00  	.db	58,32,0,79,102,102,115,101
       02:406B  4F 66 66  
       02:406E  73 65     
 1638  02:4070  74 20 4C  	.db	116,32,76,66,65,58,32,0
       02:4073  42 41 3A  
       02:4076  20 00     
 1639  02:4078  54 61 72  	.db	84,97,114,103,101,116,32,76
       02:407B  67 65 74  
       02:407E  20 4C     
 1640  02:4080  42 41 3A  	.db	66,65,58,32,0,67,104,97
       02:4083  20 00 43  
       02:4086  68 61     
 1641  02:4088  6E 67 65  	.db	110,103,101,32,86,97,108,117
       02:408B  20 56 61  
       02:408E  6C 75     
 1642  02:4090  65 73 3A  	.db	101,115,58,32,100,105,114,101
       02:4093  20 64 69  
       02:4096  72 65     
 1643  02:4098  63 74 69  	.db	99,116,105,111,110,32,112,97
       02:409B  6F 6E 20  
       02:409E  70 61     
 1644  02:40A0  64 00 42  	.db	100,0,66,117,116,116,111,110
       02:40A3  75 74 74  
       02:40A6  6F 6E     
 1645  02:40A8  20 49 49  	.db	32,73,73,32,61,32,102,119
       02:40AB  20 3D 20  
       02:40AE  66 77     
 1646  02:40B0  64 3B 20  	.db	100,59,32,73,32,61,32,98
       02:40B3  49 20 3D  
       02:40B6  20 62     
 1647  02:40B8  61 63 6B  	.db	97,99,107,0,32,32,32,32
       02:40BB  00 20 20  
       02:40BE  20 20     
 1648  02:40C0  20 00 20  	.db	32,0,32,32,32,32,32,32
       02:40C3  20 20 20  
       02:40C6  20 20     
 1649  02:40C8  20 20 20  	.db	32,32,32,32,0,32,32,32
       02:40CB  20 00 20  
       02:40CE  20 20     
 1650  02:40D0  20 20 20  	.db	32,32,32,32,32,32,32,0
       02:40D3  20 20 20  
       02:40D6  20 00     
 1651  02:40D8  53 65 65  	.db	83,101,101,107,105,110,103,46
       02:40DB  6B 69 6E  
       02:40DE  67 2E     
 1652  02:40E0  2E 2E 20  	.db	46,46,32,32,32,32,32,32
       02:40E3  20 20 20  
       02:40E6  20 20     
 1653  02:40E8  20 20 20  	.db	32,32,32,32,32,32,32,32
       02:40EB  20 20 20  
       02:40EE  20 20     
 1654  02:40F0  00 20 20  	.db	0,32,32,32,32,32,32,32
       02:40F3  20 20 20  
       02:40F6  20 20     
 1655  02:40F8  20 20 20  	.db	32,32,32,32,32,32,32,32
       02:40FB  20 20 20  
       02:40FE  20 20     
 1656  02:4100  20 20 20  	.db	32,32,32,32,32,32,32,32
       02:4103  20 20 20  
       02:4106  20 20     
 1657  02:4108  20 00     	.db	32,0
 1658  02:410A            _add_num:
 1659  02:410A  10        	.db	0x10
 1660  02:410B  00        	.db	0x00
 1661  02:410C  00        	.db	0x00
 1662  02:410D  01        	.db	0x01
 1663  02:410E  00        	.db	0x00
 1664  02:410F  00        	.db	0x00
 1665  02:4110  00        	.db	0x00
 1666  02:4111  10        	.db	0x10
 1667  02:4112  00        	.db	0x00
 1668  02:4113  00        	.db	0x00
 1669  02:4114  01        	.db	0x01
 1670  02:4115  00        	.db	0x00
 1671  02:4116  00        	.db	0x00
 1672  02:4117  00        	.db	0x00
 1673  02:4118  10        	.db	0x10
 1674  02:4119  00        	.db	0x00
 1675  02:411A  00        	.db	0x00
 1676  02:411B  01        	.db	0x01
 1677                     
 1678           29D8      	.bss
 1679  --:29D8            _rec_h:		.ds	1
 1680  --:29D9            _rec_m:		.ds	1
 1681  --:29DA            _rec_l:		.ds	1
 1682  --:29DB            _target_data:		.ds	2048
 1683  --:31DB            _pad:		.ds	1
 1684  --:31DC            _padhold:		.ds	1
 1685  --:31DD            _hex1:		.ds	1
 1686  --:31DE            _hex2:		.ds	1
 1687  --:31DF            _start_pos:		.ds	3
 1688  --:31E2            _offset:		.ds	3
 1689  --:31E5            _target:		.ds	3
 1690  --:31E8            _result:		.ds	3
 1691  --:31EB            _adjust:		.ds	1
 1692  --:31EC            _edit_pos:		.ds	1
 1693  --:31ED            _direction:		.ds	1
 1694  --:31EE            _timing:		.ds	20
 1695  --:3202            _min:		.ds	2
 1696  --:3204            _avg:		.ds	2
 1697  --:3206            _tot:		.ds	2
 1698  --:3208            _i:		.ds	1
 1699                     
 1700                     
 1701                     ;0 error(s) in compilation
 1702                     ;	literal pool:266
 1703                     ;	constant pool:18
 1704                     ;	global pool:64
 1705                     ;	Macro pool:105
 1706  --:3209            huc_rodata:
 1707  --:3209            __huc_rodata:
 1708  --:3209            huc_rodata_end:
 1709  --:3209            __huc_rodata_end:
 1710  --:3209            huc_data:
 1711  --:3209            __huc_data:
 1712  --:3209            huc_data_end:
 1713  --:3209            __huc_data_end:
 1714  --:3209            __heap_start:
