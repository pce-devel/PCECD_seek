; Small C HuC6280 (v0.2, 08/Nov/97)
;
; Taken to HuC (22/Feb/00)
;
;
; This file generated by HuC (v3.99-d245a7c9-dirty, 2021-02-06)
; on Sun Jul 18 22:48:46 2021
;

HUC	= 1
                                                                           
DEPRECATED	= 1

	.include "startup.asm"
	.data
	.bank DATA_BANK

	.code

;/*
; *
; * Seektest2 - attempts 10 seeks for minimum and average delays
; * 
; */
;#include "huc.h"
;/*
; * backup ram defines
; */
;#define  BM_OK             0
;#define  BM_NOT_FOUND      1
;#define  BM_BAD_CHECKSUM   2
;#define  BM_DIR_CORRUPTED  3
;#define  BM_FILE_EMPTY     4
;#define  BM_FULL           5
;#define  BM_NOT_FORMATED   0xFF
;#define  BRAM_STARTPTR     0x8010
;/*
; * sprite defines
; */
;#define  FLIP_X_MASK 0x08
;#define  FLIP_Y_MASK 0x80
;#define  FLIP_MAS   0x88
;#define  SIZE_MAS   0x31
;#define  NO_FLIP    0x00
;#define  NO_FLIP_X  0x00
;#define  NO_FLIP_Y  0x00
;#define  FLIP_X     0x08
;#define  FLIP_Y     0x80
;#define  SZ_16x16   0x00
;#define  SZ_16x32   0x10
;#define  SZ_16x64   0x30
;#define  SZ_32x16   0x01
;#define  SZ_32x32   0x11
;#define  SZ_32x64   0x31
;/*
; * joypad defines
; */
;#define	JOY_A		0x01
;#define	JOY_I		0x01
;#define	JOY_B		0x02
;#define	JOY_II		0x02
;#define	JOY_SLCT	0x04
;#define	JOY_SEL		0x04
;#define	JOY_STRT	0x08
;#define	JOY_RUN		0x08
;#define	JOY_UP		0x10
;#define	JOY_RGHT	0x20
;#define	JOY_RIGHT	0x20
;#define	JOY_DOWN	0x40
;#define	JOY_LEFT	0x80
;#define	JOY_C		0x0100
;#define	JOY_III		0x0100
;#define	JOY_D		0x0200
;#define	JOY_IV		0x0200
;#define	JOY_E		0x0400
;#define	JOY_V		0x0400
;#define	JOY_F		0x0800
;#define	JOY_VI		0x0800
;#define JOY_SIXBUT	0x5000
;#define JOY_TYPE6	0x5000
;/*
; * screen defines
; */
;#define	SCR_SIZE_32x32	0
;#define	SCR_SIZE_64x32	1
;#define	SCR_SIZE_128x32	3
;#define	SCR_SIZE_32x64	4
;#define	SCR_SIZE_64x64	5
;#define	SCR_SIZE_128x64	7
;#define	XRES_SHARP	0
;#define	XRES_SOFT	4
;/*
; * CD defines
; */
;#define	CDPLAY_MUTE		0
;#define	CDPLAY_REPEAT		1
;#define	CDPLAY_NORMAL		2
;#define	CDPLAY_ENDOFDISC	0
;#define	CDFADE_CANCEL	0
;#define	CDFADE_PCM6	8
;#define	CDFADE_ADPCM6	10
;#define	CDFADE_PCM2	12
;#define	CDFADE_ADPCM2	14
;#define CDTRK_AUDIO	0
;#define CDTRK_DATA	4
;/*
; * ADPCM defines
; */
;#define	ADPLAY_AUTOSTOP		0
;#define	ADPLAY_REPEAT		0x80
;#define ADPLAY_FREQ_16KHZ	0xE
;#define ADPLAY_FREQ_10KHZ	0xD
;#define ADPLAY_FREQ_8KHZ	0xC
;#define ADPLAY_FREQ_6KHZ	0xB
;#define ADPLAY_FREQ_5KHZ	0xA
;#define ADREAD_RAM	0
;#define ADREAD_VRAM	0xFF
;#define ADWRITE_RAM	0
;#define ADWRITE_VRAM	0xFF
;void vsync(void);
;void satb_update(void);
;void __fastcall vsync(unsigned char num<acc>);
;void __fastcall satb_update(unsigned char max<acc>);
;void __fastcall vreg(unsigned char reg<acc>);
;void __fastcall vreg(unsigned char reg<__al>, unsigned int data<acc>);
;void __fastcall spr_hide(unsigned char num<acc>);
;void __fastcall spr_show(unsigned char num<acc>);
;void __fastcall set_map_pals(char far *pal<__bl:__si>);
;void set_map_tile_type(unsigned char);
;void set_map_tile_base(unsigned int vaddr);
;unsigned char mem_mapdatabank(unsigned char new_bank);
;unsigned int mem_mapdatabanks(unsigned int new_banks);
;void timer_set(unsigned char cnt);
;void timer_start(void);
;void timer_stop(void);
;unsigned char timer_get(void);
;void irq_enable(unsigned char irq);
;void irq_disable(unsigned char irq);
;#define TITLE_LINE       1
;#define DIRECTION_LINE   3
;#define START_LINE       5
;#define START_UNDER      6
;#define OFFSET_LINE      7
;#define OFFSET_UNDER     8
;#define TARGET_LINE      9
;#define STAT_LINE        11
;#define READING_LINE     13
;#define MIN_LINE         14
;#define AVG_LINE         15
;#define ADJUST_DIRECTION 0
;#define ADJUST_START     1
;#define ADJUST_OFFSET    2
;#define RUN_TEST         3
;#define DIR_FWD          0
;#define DIR_BACK         1
;#define INSTRUCT_LINE1  24
;#define INSTRUCT_LINE2  25
;#define INSTRUCT_LINE3  26
;#define PREV_LINE  3
;#define CURR_LINE  4
;#define NEXT_LINE  10
;#define UNDER_LINE 11
;#define TIME_LINE  6
;#asm
_beepsetup:
    lda #2
    sta psg_ch
    lda #$FF
    sta psg_mainvol
    lda #$90    ; 1.5KHz
    sta psg_freqlo
    stz psg_freqhi
    lda #$0
    sta psg_ctrl
    lda #$1F
    ldx #16
.loop:
    sta psg_wavebuf
    dex
    bne .loop
    lda #$0
    ldx #16
.loop1:
    sta psg_wavebuf
    dex
    bne .loop1
    lda #$FF
    sta psg_pan
    lda #$9f
    sta psg_ctrl
    rts
_beepoff:
    lda #$0
    sta psg_ctrl
    rts
_beepon:
    lda #$9f
    sta psg_ctrl
    rts
_beeplow:
    lda #$90
    sta psg_freqlo
    lda #$9f
    sta psg_ctrl
    rts
_beephigh:
    lda #$46
    sta psg_freqlo
    lda #$9f
    sta psg_ctrl
    rts
; cd_read_sector(void) - references char rec_h, char rec_m, char rec_l, char * target_data
_cd_read_sector:
    lda #2    ; logical block, and play
    sta <_bh
    lda _rec_h       ; disc sector address (LBA address)
    sta <_al
    lda _rec_m
    sta <_ah
    lda _rec_l
    sta <_bl
    call cd_search
    rts
_cd_stop:
    call cd_pause
    rts
;char rec_h;
;char rec_m;
;char rec_l;
;char target_data[2048];
;char pad;
;char padhold;
;char hex1;
;char hex2;
;char start_pos[3];
;char offset[3];
;char target[3];
;char result[3];
;/* create array of offsets for adjusting startpos/offset: */
;const char add_num[] = {
; 0x10, 0x00, 0x00,
; 0x01, 0x00, 0x00,
; 0x00, 0x10, 0x00,
; 0x00, 0x01, 0x00,
; 0x00, 0x00, 0x10,
; 0x00, 0x00, 0x01
;};
;char adjust;
;char edit_pos;
;char direction;
;int timing[10];
;int min;
;int avg;
;int tot;
;char i;
;/* result shown in result[] array: */
;add_3digit(base1, base2)
;char * base1;
;char * base2;
	.proc _add_3digit
	__pushw
;{
;   int temp1, temp2;
	__addmi	-4,__stack
;   int temp_sum;
	__addmi	-2,__stack
;   int carry;
	__addmi	-2,__stack
;   temp1 = (*(base1+2)) & 0xff;
	__ldw_s	10
	__addwi	2
	__ldub_p
	__andwi	255
	__stw_s	6
;   temp2 = (*(base2+2)) & 0xff;
	__ldw_s	8
	__addwi	2
	__ldub_p
	__andwi	255
	__stw_s	4
;   temp_sum = temp1 + temp2;
	__ldw_s	6
	__addw_s	4
	__stw_s	2
;   carry = (temp_sum) >> 8;
	__ldw_s	2
	__asrwi	8
	__stw_s	0
;   result[2] = temp_sum & 0xff;
	__ldw_s	2
	__andwi	255
	  stx	_result+2
;   temp1 = (*(base1+1)) & 0xff;
	__ldw_s	10
	__addwi	1
	__ldub_p
	__andwi	255
	__stw_s	6
;   temp2 = (*(base2+1)) & 0xff;
	__ldw_s	8
	__addwi	1
	__ldub_p
	__andwi	255
	__stw_s	4
;   temp_sum = temp1 + temp2 + carry;
	__ldw_s	6
	__addw_s	4
	__addw_s	0
	__stw_s	2
;   carry = (temp_sum) >> 8;
	__ldw_s	2
	__asrwi	8
	__stw_s	0
;   result[1] = temp_sum & 0xff;
	__ldw_s	2
	__andwi	255
	  stx	_result+1
;   temp1 = (*(base1)) & 0xff;
	__ldw_s	10
	__ldub_p
	__andwi	255
	__stw_s	6
;   temp2 = (*(base2)) & 0xff;
	__ldw_s	8
	__ldub_p
	__andwi	255
	__stw_s	4
;   temp_sum = temp1 + temp2 + carry;
	__ldw_s	6
	__addw_s	4
	__addw_s	0
	__stw_s	2
;   result[0] = temp_sum & 0xff;
	__ldw_s	2
	__andwi	255
	  stx	_result
;}
LL1:

	__addmi	12,__stack
	  rts
	.endp

;/* result shown in result[] array: */
;sub_3digit(base1, base2)
;char * base1;
;char * base2;
	.proc _sub_3digit
	__pushw
;{
;   int temp1, temp2;
	__addmi	-4,__stack
;   int temp_sum;
	__addmi	-2,__stack
;   int carry;
	__addmi	-2,__stack
;   temp1 = (*(base1+2)) & 0xff;
	__ldw_s	10
	__addwi	2
	__ldub_p
	__andwi	255
	__stw_s	6
;   temp2 = (*(base2+2)) & 0xff;
	__ldw_s	8
	__addwi	2
	__ldub_p
	__andwi	255
	__stw_s	4
;   temp_sum = temp1 - temp2;
	__ldw_s	6
	__pushw
	__ldw_s	6
	__subws
	__stw_s	2
;   carry = ((temp_sum) >> 8) & 1;
	__ldw_s	2
	__asrwi	8
	__andwi	1
	__stw_s	0
;   result[2] = temp_sum & 0xff;
	__ldw_s	2
	__andwi	255
	  stx	_result+2
;   temp1 = (*(base1+1)) & 0xff;
	__ldw_s	10
	__addwi	1
	__ldub_p
	__andwi	255
	__stw_s	6
;   temp2 = (*(base2+1)) & 0xff;
	__ldw_s	8
	__addwi	1
	__ldub_p
	__andwi	255
	__stw_s	4
;   temp_sum = temp1 - temp2 - carry;
	__ldw_s	6
	__pushw
	__ldw_s	6
	__subws
	__pushw
	__ldw_s	2
	__subws
	__stw_s	2
;   carry = ((temp_sum) >> 8) & 1;
	__ldw_s	2
	__asrwi	8
	__andwi	1
	__stw_s	0
;   result[1] = temp_sum & 0xff;
	__ldw_s	2
	__andwi	255
	  stx	_result+1
;   temp1 = (*(base1)) & 0xff;
	__ldw_s	10
	__ldub_p
	__andwi	255
	__stw_s	6
;   temp2 = (*(base2)) & 0xff;
	__ldw_s	8
	__ldub_p
	__andwi	255
	__stw_s	4
;   temp_sum = temp1 - temp2 - carry;
	__ldw_s	6
	__pushw
	__ldw_s	6
	__subws
	__pushw
	__ldw_s	2
	__subws
	__stw_s	2
;   result[0] = temp_sum & 0xff;
	__ldw_s	2
	__andwi	255
	  stx	_result
;}
LL2:

	__addmi	12,__stack
	  rts
	.endp

;show_startpos()
;{
	.proc _show_startpos
;   put_hex(start_pos[0], 2, 14, START_LINE);
	__ldub	_start_pos
	__stw	__dx
	__ldwi	2
	  stx	__cl
	__ldwi	14
	  stx	__bl
	__ldwi	5
	  call	_put_hex.4
;   put_hex(start_pos[1], 2, 16, START_LINE);
	__ldub	_start_pos+1
	__stw	__dx
	__ldwi	2
	  stx	__cl
	__ldwi	16
	  stx	__bl
	__ldwi	5
	  call	_put_hex.4
;   put_hex(start_pos[2], 2, 18, START_LINE);
	__ldub	_start_pos+2
	__stw	__dx
	__ldwi	2
	  stx	__cl
	__ldwi	18
	  stx	__bl
	__ldwi	5
	  call	_put_hex.4
;}
LL3:

	  rts
	.endp

;show_offset()
;{
	.proc _show_offset
;   put_hex(offset[0], 2, 14, OFFSET_LINE);
	__ldub	_offset
	__stw	__dx
	__ldwi	2
	  stx	__cl
	__ldwi	14
	  stx	__bl
	__ldwi	7
	  call	_put_hex.4
;   put_hex(offset[1], 2, 16, OFFSET_LINE);
	__ldub	_offset+1
	__stw	__dx
	__ldwi	2
	  stx	__cl
	__ldwi	16
	  stx	__bl
	__ldwi	7
	  call	_put_hex.4
;   put_hex(offset[2], 2, 18, OFFSET_LINE);
	__ldub	_offset+2
	__stw	__dx
	__ldwi	2
	  stx	__cl
	__ldwi	18
	  stx	__bl
	__ldwi	7
	  call	_put_hex.4
;}
LL4:

	  rts
	.endp

;show_target()
;{
	.proc _show_target
;   put_hex(target[0], 2, 14, TARGET_LINE);
	__ldub	_target
	__stw	__dx
	__ldwi	2
	  stx	__cl
	__ldwi	14
	  stx	__bl
	__ldwi	9
	  call	_put_hex.4
;   put_hex(target[1], 2, 16, TARGET_LINE);
	__ldub	_target+1
	__stw	__dx
	__ldwi	2
	  stx	__cl
	__ldwi	16
	  stx	__bl
	__ldwi	9
	  call	_put_hex.4
;   put_hex(target[2], 2, 18, TARGET_LINE);
	__ldub	_target+2
	__stw	__dx
	__ldwi	2
	  stx	__cl
	__ldwi	18
	  stx	__bl
	__ldwi	9
	  call	_put_hex.4
;}
LL5:

	  rts
	.endp

;limit_startpos()
;{
	.proc _limit_startpos
;   if ((result[0] < 0x00) || (result[0] >= 0x80))
	__ldub	_result
	__stw	<__temp
	__ldwi	0
	  jsr	ltzp
	__lbnen	LL8
	__ldub	_result
	__stw	<__temp
	__ldwi	128
	  jsr	gezp
LL8:

	__tstw
	__lbeq	LL7
;   {
;      result[0] = 0x00;
	__stbi	_result, 0
;      result[1] = 0x00;
	__stbi	_result+1, 0
;      result[2] = 0x00;
	__stbi	_result+2, 0
;   }
;   if (result[0] > 0x04)
LL7:

	__ldub	_result
	__stw	<__temp
	__ldwi	4
	  jsr	gtzp
	__lbeq	LL9
;   {
;      result[0] = 0x04;
	__stbi	_result, 4
;      result[1] = 0xff;
	__stbi	_result+1, 255
;      result[2] = 0xff;
	__stbi	_result+2, 255
;   }
;}
LL9:

LL6:

	  rts
	.endp

;limit_offset()
;{
	.proc _limit_offset
;   if ((result[0] < 0x00) || (result[0] >= 0x80))
	__ldub	_result
	__stw	<__temp
	__ldwi	0
	  jsr	ltzp
	__lbnen	LL12
	__ldub	_result
	__stw	<__temp
	__ldwi	128
	  jsr	gezp
LL12:

	__tstw
	__lbeq	LL11
;   {
;      result[0] = 0x00;
	__stbi	_result, 0
;      result[1] = 0x00;
	__stbi	_result+1, 0
;      result[2] = 0x00;
	__stbi	_result+2, 0
;   }
;}
LL11:

LL10:

	  rts
	.endp

;fix_offset()
;{
	.proc _fix_offset
;   if (direction == DIR_FWD)
	__ldub	_direction
	__cmpwi_eq	0
	__lbeq	LL14
;   {
;      /* if (start + offset) > maximum, reset offset to (maximum - start) */
;      add_3digit(start_pos, offset);
	__ldwi	_start_pos
	__pushw
	__ldwi	_offset
	  call	_add_3digit
;      if (result[0] > 0x04)
	__ldub	_result
	__stw	<__temp
	__ldwi	4
	  jsr	gtzp
	__lbeq	LL15
;      {
;         target[0] = 0x04;
	__stbi	_target, 4
;         target[1] = 0xff;
	__stbi	_target+1, 255
;         target[2] = 0xff;
	__stbi	_target+2, 255
;         sub_3digit(target, start_pos);
	__ldwi	_target
	__pushw
	__ldwi	_start_pos
	  call	_sub_3digit
;         offset[0] = result[0];
	__ldub	_result
	  stx	_offset
;         offset[1] = result[1];
	__ldub	_result+1
	  stx	_offset+1
;         offset[2] = result[2];
	__ldub	_result+2
	  stx	_offset+2
;         add_3digit(start_pos, offset);
	__ldwi	_start_pos
	__pushw
	__ldwi	_offset
	  call	_add_3digit
;      }
;   }
LL15:

;   else if (direction == DIR_BACK)
	__lbra	LL16
LL14:

	__ldub	_direction
	__cmpwi_eq	1
	__lbeq	LL17
;   {
;      /* if (start - offset) < 0, reset offset to start */
;      if ( (offset[0] > start_pos[0]) || 
	__ldub	_offset
	__pushw
	__ldub	_start_pos
	  jsr	gt
	__lbne	LL19
;          ((offset[0] == start_pos[0]) && (offset[1] > start_pos[1])) ||
	__ldub	_offset
	__pushw
	__ldub	_start_pos
	  jsr	eq
	__lbeqn	LL20
	__ldub	_offset+1
	__pushw
	__ldub	_start_pos+1
	  jsr	gt
LL20:

	__boolw
LL19:

	__tstw
	__lbne	LL21
;          ((offset[0] == start_pos[0]) && (offset[1] == start_pos[1]) && (offset[2] > start_pos[2])))
	__ldub	_offset
	__pushw
	__ldub	_start_pos
	  jsr	eq
	__lbeqn	LL22
	__ldub	_offset+1
	__pushw
	__ldub	_start_pos+1
	  jsr	eq
LL22:

	__tstw
	__lbeqn	LL23
	__ldub	_offset+2
	__pushw
	__ldub	_start_pos+2
	  jsr	gt
LL23:

	__boolw
LL21:

	__tstw
	__lbeq	LL18
;      {
;         offset[0] = start_pos[0];
	__ldub	_start_pos
	  stx	_offset
;         offset[1] = start_pos[1];
	__ldub	_start_pos+1
	  stx	_offset+1
;         offset[2] = start_pos[2];
	__ldub	_start_pos+2
	  stx	_offset+2
;      }
;      sub_3digit(start_pos, offset);
LL18:

	__ldwi	_start_pos
	__pushw
	__ldwi	_offset
	  call	_sub_3digit
;   }
;   /* in either case, target needs to be set as final (start +- offset) */
;   target[0] = result[0];
LL17:

LL16:

	__ldub	_result
	  stx	_target
;   target[1] = result[1];
	__ldub	_result+1
	  stx	_target+1
;   target[2] = result[2];
	__ldub	_result+2
	  stx	_target+2
;}
LL13:

	  rts
	.endp

;clear_index()
;{
	.proc _clear_index
;   put_string("      ", 14, START_UNDER);
	__ldwi	LL0+0
	__stw	__si
	__ldwi	14
	  stx	__bl
	__ldwi	6
	  call	_put_string.3
;   put_string("      ", 14, OFFSET_UNDER);
	__ldwi	LL0+7
	__stw	__si
	__ldwi	14
	  stx	__bl
	__ldwi	8
	  call	_put_string.3
;   put_string("   ", 2, DIRECTION_LINE);
	__ldwi	LL0+14
	__stw	__si
	__ldwi	2
	  stx	__bl
	__ldwi	3
	  call	_put_string.3
;   put_string("   ", 26, DIRECTION_LINE);
	__ldwi	LL0+18
	__stw	__si
	__ldwi	26
	  stx	__bl
	__ldwi	3
	  call	_put_string.3
;}
LL24:

	  rts
	.endp

;put_index()
;{
	.proc _put_index
;   if (direction == DIR_FWD)
	__ldub	_direction
	__cmpwi_eq	0
	__lbeq	LL26
;   {
;       put_string("FORWARD ", 14, DIRECTION_LINE);
	__ldwi	LL0+22
	__stw	__si
	__ldwi	14
	  stx	__bl
	__ldwi	3
	  call	_put_string.3
;   }
;   else
	__lbra	LL27
LL26:

;   {
;       put_string("BACKWARD", 14, DIRECTION_LINE);
	__ldwi	LL0+31
	__stw	__si
	__ldwi	14
	  stx	__bl
	__ldwi	3
	  call	_put_string.3
;   }
LL27:

;   if (adjust == ADJUST_DIRECTION)
	__ldub	_adjust
	__cmpwi_eq	0
	__lbeq	LL28
;   {
;       put_string(">>>", 2, DIRECTION_LINE);
	__ldwi	LL0+40
	__stw	__si
	__ldwi	2
	  stx	__bl
	__ldwi	3
	  call	_put_string.3
;       put_string("<<<", 26, DIRECTION_LINE);
	__ldwi	LL0+44
	__stw	__si
	__ldwi	26
	  stx	__bl
	__ldwi	3
	  call	_put_string.3
;   }
;   else if (adjust == ADJUST_START)
	__lbra	LL29
LL28:

	__ldub	_adjust
	__cmpwi_eq	1
	__lbeq	LL30
;   {
;       put_string("      ", 14, START_UNDER);
	__ldwi	LL0+48
	__stw	__si
	__ldwi	14
	  stx	__bl
	__ldwi	6
	  call	_put_string.3
;       put_string("^", 14+edit_pos, START_UNDER);
	__ldwi	LL0+55
	__stw	__si
	__ldwi	14
	__addub	_edit_pos
	  stx	__bl
	__ldwi	6
	  call	_put_string.3
;   }
;   else if (adjust == ADJUST_OFFSET)
	__lbra	LL31
LL30:

	__ldub	_adjust
	__cmpwi_eq	2
	__lbeq	LL32
;   {
;       put_string("      ", 14, OFFSET_UNDER);
	__ldwi	LL0+57
	__stw	__si
	__ldwi	14
	  stx	__bl
	__ldwi	8
	  call	_put_string.3
;       put_string("^", 14+edit_pos, OFFSET_UNDER);
	__ldwi	LL0+64
	__stw	__si
	__ldwi	14
	__addub	_edit_pos
	  stx	__bl
	__ldwi	8
	  call	_put_string.3
;   }   
;}
LL32:

LL31:

LL29:

LL25:

	  rts
	.endp

;main()
;{
	.proc _main
;   set_color(0,0);
	__ldwi	0
	__stw	color_reg
	__ldwi	0
	__stw	color_data
;   set_color(1,511);
	__ldwi	1
	__stw	color_reg
	__ldwi	511
	__stw	color_data
;   for (i = 0; i < 3; i++) {
	__ldwi	0
	  stx	_i
LL34:

	__ldub	_i
	__stw	<__temp
	__ldwi	3
	  jsr	ltzp
	__lbnen	LL36
	__lbra	LL37
LL35:

	__ldub	_i
	inc	_i
	__lbra	LL34
LL36:

;      start_pos[i] = 0;
	__ldwi	_start_pos
	__addub	_i
	__stbip	0
;      offset[i] = 0;
	__ldwi	_offset
	__addub	_i
	__stbip	0
;      target[i] = 0;
	__ldwi	_target
	__addub	_i
	__stbip	0
;   }
	__lbra	LL35
LL37:

;   edit_pos = 0;
	__ldwi	0
	  stx	_edit_pos
;   adjust = ADJUST_START;
	__ldwi	1
	  stx	_adjust
;   direction = DIR_FWD;
	__ldwi	0
	  stx	_direction
;   put_string("Head Seek Test", 10, TITLE_LINE);
	__ldwi	LL0+66
	__stw	__si
	__ldwi	10
	  stx	__bl
	__ldwi	1
	  call	_put_string.3
;   put_string("       Dir: ", 2, DIRECTION_LINE);
	__ldwi	LL0+81
	__stw	__si
	__ldwi	2
	  stx	__bl
	__ldwi	3
	  call	_put_string.3
;   put_string("Start  LBA: ", 2, START_LINE);
	__ldwi	LL0+94
	__stw	__si
	__ldwi	2
	  stx	__bl
	__ldwi	5
	  call	_put_string.3
;   put_string("Offset LBA: ", 2, OFFSET_LINE);
	__ldwi	LL0+107
	__stw	__si
	__ldwi	2
	  stx	__bl
	__ldwi	7
	  call	_put_string.3
;   put_string("Target LBA: ", 2, TARGET_LINE);
	__ldwi	LL0+120
	__stw	__si
	__ldwi	2
	  stx	__bl
	__ldwi	9
	  call	_put_string.3
;   show_startpos();
	  call	_show_startpos
;   show_offset();
	  call	_show_offset
;   show_target();
	  call	_show_target
;   put_string("Change Values: direction pad", 2, INSTRUCT_LINE1);
	__ldwi	LL0+133
	__stw	__si
	__ldwi	2
	  stx	__bl
	__ldwi	24
	  call	_put_string.3
;   put_string("Button II = fwd; I = back", 2, INSTRUCT_LINE3);
	__ldwi	LL0+162
	__stw	__si
	__ldwi	2
	  stx	__bl
	__ldwi	26
	  call	_put_string.3
;   while(1)
LL38:

	__ldwi	1
	__tstw
	__lbeq	LL39
;   {
;      put_index();
	  call	_put_index
;      pad = joytrg(0);
	__ldwi	0
	  call	_joytrg
	  stx	_pad
;      if (adjust == ADJUST_DIRECTION)
	__ldub	_adjust
	__cmpwi_eq	0
	__lbeq	LL40
;      {
;         if (pad & (JOY_LEFT | JOY_RGHT | JOY_UP | JOY_DOWN))
	__ldub	_pad
	__andwi	240
	__tstw
	__lbeq	LL41
;         {
;            if (direction == DIR_FWD)
	__ldub	_direction
	__cmpwi_eq	0
	__lbeq	LL42
;            {
;               direction = DIR_BACK;
	__ldwi	1
	  stx	_direction
;               put_index();
	  call	_put_index
;               /* if startpos + offset is outside limits, adjust offset */
;               fix_offset();
	  call	_fix_offset
;               show_offset();
	  call	_show_offset
;               show_target();
	  call	_show_target
;            }
;            else
	__lbra	LL43
LL42:

;            {
;               direction = DIR_FWD;
	__ldwi	0
	  stx	_direction
;               put_index();
	  call	_put_index
;               /* if startpos + offset is outside limits, adjust offset */
;               fix_offset();
	  call	_fix_offset
;               show_offset();
	  call	_show_offset
;               show_target();
	  call	_show_target
;            }
LL43:

;         }
;         if (pad & JOY_B)
LL41:

	__ldub	_pad
	__andwi	2
	__tstw
	__lbeq	LL44
;         {
;            adjust = ADJUST_START;
	__ldwi	1
	  stx	_adjust
;            clear_index();
	  call	_clear_index
;            put_index();
	  call	_put_index
;         }
;      }
LL44:

;      else if ((adjust == ADJUST_START) || (adjust == ADJUST_OFFSET))
	__lbra	LL45
LL40:

	__ldub	_adjust
	__cmpwi_eq	1
	__lbnen	LL47
	__ldub	_adjust
	__cmpwi_eq	2
LL47:

	__tstw
	__lbeq	LL46
;      {
;         if (pad & JOY_LEFT)
	__ldub	_pad
	__andwi	128
	__tstw
	__lbeq	LL48
;         {
;            if (edit_pos > 0)
	__ldub	_edit_pos
	__stw	<__temp
	__ldwi	0
	  jsr	gtzp
	__lbeq	LL49
;            {
;               edit_pos -= 1;
	__ldub	_edit_pos
	__subwi	1
	  stx	_edit_pos
;               put_index();
	  call	_put_index
;            }
;         }
LL49:

;         if (pad & JOY_RGHT)
LL48:

	__ldub	_pad
	__andwi	32
	__tstw
	__lbeq	LL50
;         {
;            if (edit_pos < 5)
	__ldub	_edit_pos
	__stw	<__temp
	__ldwi	5
	  jsr	ltzp
	__lbeq	LL51
;            {
;               edit_pos += 1;
	inc	_edit_pos
	__ldub	_edit_pos
;               put_index();
	  call	_put_index
;            }
;         }
LL51:

;         if (pad & JOY_UP)
LL50:

	__ldub	_pad
	__andwi	16
	__tstw
	__lbeq	LL52
;         {
;            if (adjust == ADJUST_START)
	__ldub	_adjust
	__cmpwi_eq	1
	__lbeq	LL53
;            {
;               add_3digit(&start_pos[0], &add_num[(edit_pos*3)]);
	__ldwi	_start_pos
	__pushw
	__ldub	_edit_pos
	__mulwi	3
	__addwi_sym	_add_num
	  call	_add_3digit
;               limit_startpos();  /* check if outside bounds */
	  call	_limit_startpos
;               start_pos[0] = result[0];
	__ldub	_result
	  stx	_start_pos
;               start_pos[1] = result[1];
	__ldub	_result+1
	  stx	_start_pos+1
;               start_pos[2] = result[2];
	__ldub	_result+2
	  stx	_start_pos+2
;               show_startpos();
	  call	_show_startpos
;               /* if startpos + offset is outside limits, adjust offset */
;               fix_offset();
	  call	_fix_offset
;               show_offset();
	  call	_show_offset
;               show_target();
	  call	_show_target
;            }
;            else if (adjust == ADJUST_OFFSET)
	__lbra	LL54
LL53:

	__ldub	_adjust
	__cmpwi_eq	2
	__lbeq	LL55
;            {
;               add_3digit(&offset[0], &add_num[(edit_pos*3)]);
	__ldwi	_offset
	__pushw
	__ldub	_edit_pos
	__mulwi	3
	__addwi_sym	_add_num
	  call	_add_3digit
;               limit_offset();
	  call	_limit_offset
;               offset[0] = result[0];
	__ldub	_result
	  stx	_offset
;               offset[1] = result[1];
	__ldub	_result+1
	  stx	_offset+1
;               offset[2] = result[2];
	__ldub	_result+2
	  stx	_offset+2
;               /* if startpos + offset is outside limits, adjust offset */
;               fix_offset();
	  call	_fix_offset
;               show_offset();
	  call	_show_offset
;               show_target();
	  call	_show_target
;            }
;         }
LL55:

LL54:

;         if (pad & JOY_DOWN)
LL52:

	__ldub	_pad
	__andwi	64
	__tstw
	__lbeq	LL56
;         {
;            if (adjust == ADJUST_START)
	__ldub	_adjust
	__cmpwi_eq	1
	__lbeq	LL57
;            {
;               sub_3digit(&start_pos[0], &add_num[(edit_pos*3)]);
	__ldwi	_start_pos
	__pushw
	__ldub	_edit_pos
	__mulwi	3
	__addwi_sym	_add_num
	  call	_sub_3digit
;               limit_startpos();  /* check if outside bounds */
	  call	_limit_startpos
;               start_pos[0] = result[0];
	__ldub	_result
	  stx	_start_pos
;               start_pos[1] = result[1];
	__ldub	_result+1
	  stx	_start_pos+1
;               start_pos[2] = result[2];
	__ldub	_result+2
	  stx	_start_pos+2
;               show_startpos();
	  call	_show_startpos
;               /* if startpos + offset is outside limits, adjust offset */
;               fix_offset();
	  call	_fix_offset
;               show_offset();
	  call	_show_offset
;               show_target();
	  call	_show_target
;            }
;            else if (adjust == ADJUST_OFFSET)
	__lbra	LL58
LL57:

	__ldub	_adjust
	__cmpwi_eq	2
	__lbeq	LL59
;            {
;               sub_3digit(&offset[0], &add_num[(edit_pos*3)]);
	__ldwi	_offset
	__pushw
	__ldub	_edit_pos
	__mulwi	3
	__addwi_sym	_add_num
	  call	_sub_3digit
;               limit_offset();
	  call	_limit_offset
;               offset[0] = result[0];
	__ldub	_result
	  stx	_offset
;               offset[1] = result[1];
	__ldub	_result+1
	  stx	_offset+1
;               offset[2] = result[2];
	__ldub	_result+2
	  stx	_offset+2
;               /* if startpos + offset is outside limits, adjust offset */
;               fix_offset();
	  call	_fix_offset
;               show_offset();
	  call	_show_offset
;               show_target();
	  call	_show_target
;            }
;         }
LL59:

LL58:

;         if (pad & JOY_B)  /* this is button II */
LL56:

	__ldub	_pad
	__andwi	2
	__tstw
	__lbeq	LL60
;         {
;            if (adjust == ADJUST_START)
	__ldub	_adjust
	__cmpwi_eq	1
	__lbeq	LL61
;            {
;               adjust = ADJUST_OFFSET;
	__ldwi	2
	  stx	_adjust
;               clear_index();
	  call	_clear_index
;               put_index();
	  call	_put_index
;            }
;            else if (adjust == ADJUST_OFFSET)
	__lbra	LL62
LL61:

	__ldub	_adjust
	__cmpwi_eq	2
	__lbeq	LL63
;            {
;               clear_index();
	  call	_clear_index
;               adjust = ADJUST_OFFSET;
	__ldwi	2
	  stx	_adjust
;               for (i = 0; i < 10; i++)
	__ldwi	0
	  stx	_i
LL64:

	__ldub	_i
	__stw	<__temp
	__ldwi	10
	  jsr	ltzp
	__lbnen	LL66
	__lbra	LL67
LL65:

	__ldub	_i
	inc	_i
	__lbra	LL64
LL66:

;               {
;                  put_string("     ", 5, READING_LINE+i);
	__ldwi	LL0+188
	__stw	__si
	__ldwi	5
	  stx	__bl
	__ldwi	13
	__addub	_i
	  call	_put_string.3
;               }
	__lbra	LL65
LL67:

;               put_string("          ", 18, MIN_LINE);
	__ldwi	LL0+194
	__stw	__si
	__ldwi	18
	  stx	__bl
	__ldwi	14
	  call	_put_string.3
;               put_string("          ", 18, AVG_LINE);
	__ldwi	LL0+205
	__stw	__si
	__ldwi	18
	  stx	__bl
	__ldwi	15
	  call	_put_string.3
;               /* run test */
;               min = 32767;
	__ldwi	32767
	__stw	_min
;               tot = 0;
	__ldwi	0
	__stw	_tot
;            
;/*               for (i = 0; i < 10; i++)
;               {
;                  put_string("Move to initial position", 2, STAT_LINE);
;*/
;                  /*initial head position seek */
;/*
;                  rec_h = start_pos[0];
;                  rec_m = start_pos[1];
;                  rec_l = start_pos[2];
;                  cd_read_sector();
;                  put_string("Random delay            ", 2, STAT_LINE);
;                  vsync(random(55)+5);               
;*/
;                  put_string("Seeking...              ", 2, STAT_LINE);
	__ldwi	LL0+216
	__stw	__si
	__ldwi	2
	  stx	__bl
	__ldwi	11
	  call	_put_string.3
;                  rec_h = target[0];
	__ldub	_target
	  stx	_rec_h
;                  rec_m = target[1];
	__ldub	_target+1
	  stx	_rec_m
;                  rec_l = target[2];
	__ldub	_target+2
	  stx	_rec_l
;/*
;                  vsync(0);
;                  clock_reset();
;*/
;                  /* Seek */
;                  beepsetup();
	  call	_beepsetup
;                  beepon();
	  call	_beepon
;                  beeplow();
	  call	_beeplow
;                  cd_read_sector();
	  call	_cd_read_sector
;                  beephigh();
	  call	_beephigh
;		  for (i = 0; i < 60; i++) {
	__ldwi	0
	  stx	_i
LL68:

	__ldub	_i
	__stw	<__temp
	__ldwi	60
	  jsr	ltzp
	__lbnen	LL70
	__lbra	LL71
LL69:

	__ldub	_i
	inc	_i
	__lbra	LL68
LL70:

;                     vsync(0);
	__ldwi	0
	  call	_vsync.1
;		  }
	__lbra	LL69
LL71:

;                  beepoff();
	  call	_beepoff
;                  cd_stop();
	  call	_cd_stop
;		  /* cd_stop_play(); */  /* call cd_pause and stop tone */
;		  start_pos[0] = target[0];
	__ldub	_target
	  stx	_start_pos
;		  start_pos[1] = target[1];
	__ldub	_target+1
	  stx	_start_pos+1
;		  start_pos[2] = target[2];
	__ldub	_target+2
	  stx	_start_pos+2
;		  offset[0] = 0;
	__stbi	_offset, 0
;		  offset[1] = 0;
	__stbi	_offset+1, 0
;		  offset[2] = 0;
	__stbi	_offset+2, 0
;		  show_startpos();
	  call	_show_startpos
;		  show_offset();
	  call	_show_offset
;		  show_target();
	  call	_show_target
;/*
;                  timing[i] = (clock_mm() * 3600) + (clock_ss() * 60) + clock_tt();
;                  if (timing[i] < min)
;                  {
;                     min = timing[i];
;                  }
;                  tot = tot + timing[i];
;                  put_number(timing[i], 5, 5, READING_LINE+i);
;*/
;		  /* re-establish starting point */
;/*               } */
;/*
;               avg = tot / 10;
;*/
;               put_string("                        ", 2, STAT_LINE);
	__ldwi	LL0+241
	__stw	__si
	__ldwi	2
	  stx	__bl
	__ldwi	11
	  call	_put_string.3
;/*
;               put_string("Min: ", 18, MIN_LINE);
;               put_number(min, 5, 23, MIN_LINE);
;               put_string("Avg: ", 18, AVG_LINE);
;               put_number(avg, 5, 23, AVG_LINE);
;*/
;            }
;         }
LL63:

LL62:

;         if (pad & JOY_A)
LL60:

	__ldub	_pad
	__andwi	1
	__tstw
	__lbeq	LL72
;         {
;            if (adjust == ADJUST_OFFSET)
	__ldub	_adjust
	__cmpwi_eq	2
	__lbeq	LL73
;            {
;               adjust = ADJUST_START;
	__ldwi	1
	  stx	_adjust
;               clear_index();
	  call	_clear_index
;               put_index();
	  call	_put_index
;            }
;            else if (adjust == ADJUST_START)
	__lbra	LL74
LL73:

	__ldub	_adjust
	__cmpwi_eq	1
	__lbeq	LL75
;            {
;               adjust = ADJUST_DIRECTION;
	__ldwi	0
	  stx	_adjust
;               clear_index();
	  call	_clear_index
;               put_index();
	  call	_put_index
;            }
;         }
LL75:

LL74:

;      }
LL72:

;      vsync(0);
LL46:

LL45:

	__ldwi	0
	  call	_vsync.1
;   }
	__lbra	LL38
LL39:

;   return;
	__lbra	LL33
;}
LL33:

	  rts
	.endp

	.data
	.bank CONST_BANK
LL0:
	.db	32,32,32,32,32,32,0,32
	.db	32,32,32,32,32,0,32,32
	.db	32,0,32,32,32,0,70,79
	.db	82,87,65,82,68,32,0,66
	.db	65,67,75,87,65,82,68,0
	.db	62,62,62,0,60,60,60,0
	.db	32,32,32,32,32,32,0,94
	.db	0,32,32,32,32,32,32,0
	.db	94,0,72,101,97,100,32,83
	.db	101,101,107,32,84,101,115,116
	.db	0,32,32,32,32,32,32,32
	.db	68,105,114,58,32,0,83,116
	.db	97,114,116,32,32,76,66,65
	.db	58,32,0,79,102,102,115,101
	.db	116,32,76,66,65,58,32,0
	.db	84,97,114,103,101,116,32,76
	.db	66,65,58,32,0,67,104,97
	.db	110,103,101,32,86,97,108,117
	.db	101,115,58,32,100,105,114,101
	.db	99,116,105,111,110,32,112,97
	.db	100,0,66,117,116,116,111,110
	.db	32,73,73,32,61,32,102,119
	.db	100,59,32,73,32,61,32,98
	.db	97,99,107,0,32,32,32,32
	.db	32,0,32,32,32,32,32,32
	.db	32,32,32,32,0,32,32,32
	.db	32,32,32,32,32,32,32,0
	.db	83,101,101,107,105,110,103,46
	.db	46,46,32,32,32,32,32,32
	.db	32,32,32,32,32,32,32,32
	.db	0,32,32,32,32,32,32,32
	.db	32,32,32,32,32,32,32,32
	.db	32,32,32,32,32,32,32,32
	.db	32,0
_add_num:
	.db	0x10
	.db	0x00
	.db	0x00
	.db	0x01
	.db	0x00
	.db	0x00
	.db	0x00
	.db	0x10
	.db	0x00
	.db	0x00
	.db	0x01
	.db	0x00
	.db	0x00
	.db	0x00
	.db	0x10
	.db	0x00
	.db	0x00
	.db	0x01

	.bss
_rec_h:		.ds	1
_rec_m:		.ds	1
_rec_l:		.ds	1
_target_data:		.ds	2048
_pad:		.ds	1
_padhold:		.ds	1
_hex1:		.ds	1
_hex2:		.ds	1
_start_pos:		.ds	3
_offset:		.ds	3
_target:		.ds	3
_result:		.ds	3
_adjust:		.ds	1
_edit_pos:		.ds	1
_direction:		.ds	1
_timing:		.ds	20
_min:		.ds	2
_avg:		.ds	2
_tot:		.ds	2
_i:		.ds	1


;0 error(s) in compilation
;	literal pool:266
;	constant pool:18
;	global pool:64
;	Macro pool:105
huc_rodata:
__huc_rodata:
huc_rodata_end:
__huc_rodata_end:
huc_data:
__huc_data:
huc_data_end:
__huc_data_end:
__heap_start:
